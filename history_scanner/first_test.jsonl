{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit\n    ~~~~~~~~\n\n    A microblogging application written with Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nfrom __future__ import with_statement\nimport re\nimport time\nimport sqlite3\nfrom hashlib import md5\nfrom datetime import datetime\nfrom contextlib import closing\nfrom flask import Flask, request, session, url_for, redirect, \\\n     render_template, abort, g, flash\nfrom werkzeug import check_password_hash, generate_password_hash\n\n\n# configuration\nDATABASE = '\/tmp\/minitwit.db'\nPER_PAGE = 30\nDEBUG = True\nSECRET_KEY = 'development key'\n\n# create our little application :)\napp = Flask(__name__)\n\n\ndef connect_db():\n    \"\"\"Returns a new database connection to the database.\"\"\"\n    return sqlite3.connect(DATABASE)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with closing(connect_db()) as db:\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef query_db(query, args=(), one=False):\n    \"\"\"Queries the database and returns a list of dictionaries.\"\"\"\n    cur = g.db.execute(query, args)\n    rv = [dict((cur.description[idx][0], value)\n               for idx, value in enumerate(row)) for row in cur.fetchall()]\n    return (rv[0] if rv else None) if one else rv\n\n\ndef get_user_id(username):\n    \"\"\"Convenience method to look up the id for a username\"\"\"\n    rv = g.db.execute('select user_id from user where username = ?',\n                       [username]).fetchone()\n    return rv[0] if rv else None\n\n\ndef format_datetime(timestamp):\n    \"\"\"Format a timestamp for display\"\"\"\n    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')\n\n\ndef gravatar_url(email, size=80):\n    \"\"\"Return the gravatar image for the given email address\"\"\"\n    return 'http:\/\/www.gravatar.com\/avatar\/%s?d=identicon&s=%d' % \\\n        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)\n\n\n@app.request_init\ndef before_request():\n    \"\"\"Make sure we are connected to the database each request and look\n    up the current user so that we know he's there.\n    \"\"\"\n    g.db = connect_db()\n    g.user = None\n    if 'user_id' in session:\n        g.user = query_db('select * from user where user_id = ?',\n                          [session['user_id']], one=True)\n\n\n@app.request_shutdown\ndef after_request(response):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    g.db.close()\n    return response\n\n\n@app.route('\/')\ndef timeline():\n    \"\"\"Shows a users timeline or if no user is logged in it will\n    redirect to the public timeline.  This timeline shows the user's\n    messages as well as all the messages of followed users.\n    \"\"\"\n    if not g.user:\n        return redirect(url_for('public_timeline'))\n    offset = request.args.get('offset', type=int)\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id and (\n            user.user_id = ? or\n            user.user_id in (select whom_id from follower\n                                    where who_id = ?))\n        order by message.pub_date desc limit ?''',\n        [session['user_id'], session['user_id'], PER_PAGE]))\n\n\n@app.route('\/public')\ndef public_timeline():\n    \"\"\"Displays the latest messages of all users.\"\"\"\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id\n        order by message.pub_date desc limit ?''', [PER_PAGE]))\n\n\n@app.route('\/<username>')\ndef user_timeline(username):\n    \"\"\"Display's a users tweets.\"\"\"\n    profile_user = query_db('select * from user where username = ?',\n                            [username], one=True)\n    if profile_user is None:\n        abort(404)\n    followd = False\n    if g.user:\n        followed = query_db('''select 1 from follower where\n            follower.who_id = ? and follower.whom_id = ?''',\n            [session['user_id'], profile_user['user_id']], one=True) is not None\n    return render_template('timeline.html', messages=query_db('''\n            select message.*, user.* from message, user where\n            user.user_id = message.author_id and user.user_id = ?\n            order by message.pub_date desc limit ?''',\n            [profile_user['user_id'], PER_PAGE]), followed=followed,\n            profile_user=profile_user)\n\n\n@app.route('\/<username>\/follow')\ndef follow_user(username):\n    \"\"\"Adds the current user as follower of the given user\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    g.db.execute('insert into follower (who_id, whom_id) values (?, ?)',\n                [session['user_id'], whom_id])\n    g.db.commit()\n    flash('You are now following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/<username>\/unfollow')\ndef unfollow_user(username):\n    \"\"\"Removes the current user as follower of the given user\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    g.db.execute('delete from follower where who_id=? and whom_id=?',\n                [session['user_id'], whom_id])\n    g.db.commit()\n    flash('You are no longer following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/add_message', methods=['POST'])\ndef add_message():\n    \"\"\"Registers a new message for the user\"\"\"\n    if 'user_id' not in session:\n        abort(401)\n    if request.form['text']:\n        g.db.execute('''insert into message (author_id, text, pub_date)\n            values (?, ?, ?)''', (session['user_id'], request.form['text'],\n                                  int(time.time())))\n        g.db.commit()\n        flash('Your message was recorded')\n    return redirect(url_for('timeline'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    \"\"\"Logs the user in\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        user = query_db('''select * from user where\n            username = ?''', [request.form['username']], one=True)\n        if user is None:\n            error = 'Invalid username'\n        elif not check_password_hash(user['pw_hash'],\n                                     request.form['password']):\n            error = 'Invalid password'\n        else:\n            flash('You were logged in')\n            session['user_id'] = user['user_id']\n            return redirect(url_for('timeline'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/register', methods=['GET', 'POST'])\ndef register():\n    \"\"\"Registers the user\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        if not request.form['username']:\n            error = 'You have to enter a username'\n        elif not request.form['email'] or \\\n                 '@' not in request.form['email']:\n            error = 'You have to enter a valid email address'\n        elif not request.form['password']:\n            error = 'You have to enter a password'\n        elif request.form['password'] != request.form['password2']:\n            error = 'The two passwords do not match'\n        elif get_user_id(request.form['username']) is not None:\n            error = 'The username is already taken'\n        else:\n            g.db.execute('''insert into user (\n                username, email, pw_hash) values (?, ?, ?)''',\n                [request.form['username'], request.form['email'],\n                 generate_password_hash(request.form['password'])])\n            g.db.commit()\n            flash('You were successfully registered and can login now')\n            return redirect(url_for('login'))\n    return render_template('register.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    \"\"\"Logs the user out\"\"\"\n    flash('You were logged out')\n    session.pop('user_id', None)\n    return redirect(url_for('public_timeline'))\n\n\n# add some filters to jinja and set the secret key and debug mode\n# from the configuration.\napp.jinja_env.filters['datetimeformat'] = format_datetime\napp.jinja_env.filters['gravatar'] = gravatar_url\napp.secret_key = SECRET_KEY\napp.debug = DEBUG\n\n\nif __name__ == '__main__':\n    app.run()\n\n\"\"\"\nGenerate tests which test: Added tests for minitwit.  Testing with Flask is awesome\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit Tests\n    ~~~~~~~~~~~~~~\n\n    Tests the MiniTwit application.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport minitwit\nimport unittest\nimport tempfile\nfrom contextlib import closing\n\n\nclass MiniTwitTestCase(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Before each test, set up a blank database\"\"\"\n        self.db = tempfile.NamedTemporaryFile()\n        self.app = minitwit.app.test_client()\n        minitwit.DATABASE = self.db.name\n        minitwit.init_db()\n\n    # helper functions\n\n    def register(self, username, password, password2=None, email=None):\n        \"\"\"Helper function to register a user\"\"\"\n        if password2 is None:\n            password2 = password\n        if email is None:\n            email = username + '@example.com'\n        return self.app.post('\/register', data={\n            'username':     username,\n            'password':     password,\n            'password2':    password2,\n            'email':        email,\n        }, follow_redirects=True)\n\n    def login(self, username, password):\n        \"\"\"Helper function to login\"\"\"\n        return self.app.post('\/login', data={\n            'username': username,\n            'password': password\n        }, follow_redirects=True)\n\n    def register_and_login(self, username, password):\n        \"\"\"Registers and logs in in one go\"\"\"\n        self.register(username, password)\n        return self.login(username, password)\n\n    def logout(self):\n        \"\"\"Helper function to logout\"\"\"\n        return self.app.get('\/logout', follow_redirects=True)\n\n    def add_message(self, text):\n        \"\"\"Records a message\"\"\"\n        rv = self.app.post('\/add_message', data={'text': text},\n                                    follow_redirects=True)\n        if text:\n            assert 'Your message was recorded' in rv.data\n        return rv\n\n    # testing functions\n\n    def test_register(self):\n        \"\"\"Make sure registering works\"\"\"\n        rv = self.register('user1', 'default')\n        assert 'You were successfully registered ' \\\n               'and can login now' in rv.data\n        rv = self.register('user1', 'default')\n        assert 'The username is already taken' in rv.data\n        rv = self.register('', 'default')\n        assert 'You have to enter a username' in rv.data\n        rv = self.register('meh', '')\n        assert 'You have to enter a password' in rv.data\n        rv = self.register('meh', 'x', 'y')\n        assert 'The two passwords do not match' in rv.data\n        rv = self.register('meh', 'foo', email='broken')\n        assert 'You have to enter a valid email address' in rv.data\n\n    def test_login_logout(self):\n        \"\"\"Make sure logging in and logging out works\"\"\"\n        rv = self.register_and_login('user1', 'default')\n        assert 'You were logged in' in rv.data\n        rv = self.logout()\n        assert 'You were logged out' in rv.data\n        rv = self.login('user1', 'wrongpassword')\n        assert 'Invalid password' in rv.data\n        rv = self.login('user2', 'wrongpassword')\n        assert 'Invalid username' in rv.data\n\n    def test_message_recording(self):\n        \"\"\"Check if adding messages works\"\"\"\n        self.register_and_login('foo', 'default')\n        self.add_message('test message 1')\n        self.add_message('<test message 2>')\n        rv = self.app.get('\/')\n        assert 'test message 1' in rv.data\n        assert '&lt;test message 2&gt;' in rv.data\n\n    def test_timelines(self):\n        \"\"\"Make sure that timelines work\"\"\"\n        self.register_and_login('foo', 'default')\n        self.add_message('the message by foo')\n        self.logout()\n        self.register_and_login('bar', 'default')\n        self.add_message('the message by bar')\n        rv = self.app.get('\/public')\n        assert 'the message by foo' in rv.data\n        assert 'the message by bar' in rv.data\n\n        # bar's timeline should just show bar's message\n        rv = self.app.get('\/')\n        assert 'the message by foo' not in rv.data\n        assert 'the message by bar' in rv.data\n\n        # now let's follow foo\n        rv = self.app.get('\/foo\/follow', follow_redirects=True)\n        assert 'You are now following &#34;foo&#34;' in rv.data\n\n        # we should now see foo's message\n        rv = self.app.get('\/')\n        assert 'the message by foo' in rv.data\n        assert 'the message by bar' in rv.data\n\n        # but on the user's page we only want the user's message\n        rv = self.app.get('\/bar')\n        assert 'the message by foo' not in rv.data\n        assert 'the message by bar' in rv.data\n        rv = self.app.get('\/foo')\n        assert 'the message by foo' in rv.data\n        assert 'the message by bar' not in rv.data\n\n        # now unfollow and check if that worked\n        rv = self.app.get('\/foo\/unfollow', follow_redirects=True)\n        assert 'You are no longer following &#34;foo&#34;' in rv.data\n        rv = self.app.get('\/')\n        assert 'the message by foo' not in rv.data\n        assert 'the message by bar' in rv.data\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nfrom __future__ import with_statement\nimport time\nimport sqlite3\nfrom contextlib import closing\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\nfrom werkzeug import secure_filename\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.secret_key = SECRET_KEY\napp.debug = DEBUG\n\n\ndef connect_db():\n    \"\"\"Returns a new connection to the database.\"\"\"\n    return sqlite3.connect(DATABASE)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with closing(connect_db()) as db:\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\n@app.request_init\ndef before_request():\n    \"\"\"Make sure we are connected to the database each request.  Also\n    set `g.logged_in` to `True` if we are logged in.\n    \"\"\"\n    g.db = connect_db()\n    g.logged_in = session.get('logged_in', False)\n\n\n@app.request_shutdown\ndef after_request(response):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    g.db.close()\n    return response\n\n\n@app.route('\/')\ndef show_entries():\n    cur = g.db.execute('select title, text from entries order by id desc')\n    entries = [dict(title=row[0], text=row[1]) for row in cur.fetchall()]\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not g.logged_in:\n        abort(401)\n    g.db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    g.db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != USERNAME:\n            error = 'Invalid username'\n        elif request.form['password'] != PASSWORD:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    app.run()\n\n\"\"\"\nGenerate tests which test: Added mini blogging application as Flask example.\n\nThis should become the tutorial.\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr Tests\n    ~~~~~~~~~~~~\n\n    Tests the Flaskr application.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport flaskr\nimport unittest\nimport tempfile\n\n\nclass FlaskrTestCase(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Before each test, set up a blank database\"\"\"\n        self.db = tempfile.NamedTemporaryFile()\n        self.app = flaskr.app.test_client()\n        flaskr.DATABASE = self.db.name\n        flaskr.init_db()\n\n    def login(self, username, password):\n        return self.app.post('\/login', data=dict(\n            username=username,\n            password=password\n        ), follow_redirects=True)\n\n    def logout(self):\n        return self.app.get('\/logout', follow_redirects=True)\n\n    # testing functions\n\n    def test_login_logout(self):\n        \"\"\"Make sure login and logout works\"\"\"\n        rv = self.login(flaskr.USERNAME, flaskr.PASSWORD)\n        assert 'You were logged in' in rv.data\n        rv = self.logout()\n        assert 'You were logged out' in rv.data\n        rv = self.login(flaskr.USERNAME + 'x', flaskr.PASSWORD)\n        assert 'Invalid username' in rv.data\n        rv = self.login(flaskr.USERNAME, flaskr.PASSWORD + 'x')\n        assert 'Invalid password' in rv.data\n\n    def test_messages(self):\n        \"\"\"Test that messages work\"\"\"\n        # start with a blank state\n        rv = self.app.get('\/')\n        assert 'No entries here so far' in rv.data\n        self.login(flaskr.USERNAME, flaskr.PASSWORD)\n        rv = self.app.post('\/add', data=dict(\n            title='<Hello>',\n            text='<strong>HTML<\/strong> allowed here'\n        ), follow_redirects=True)\n        assert 'No entries here so far' not in rv.data\n        self.login(flaskr.USERNAME, flaskr.PASSWORD)\n        assert '&lt;Hello&gt' in rv.data\n        assert '<strong>HTML<\/strong> allowed here' in rv.data\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nfrom __future__ import with_statement\nimport sqlite3\nfrom contextlib import closing\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.secret_key = SECRET_KEY\napp.debug = DEBUG\n\n\ndef connect_db():\n    \"\"\"Returns a new connection to the database.\"\"\"\n    return sqlite3.connect(DATABASE)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with closing(connect_db()) as db:\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\n@app.before_request\ndef before_request():\n    \"\"\"Make sure we are connected to the database each request.\"\"\"\n    g.db = connect_db()\n\n\n@app.after_request\ndef after_request(response):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    g.db.close()\n    return response\n\n\n@app.route('\/')\ndef show_entries():\n    cur = g.db.execute('select title, text from entries order by id desc')\n    entries = [dict(title=row[0], text=row[1]) for row in cur.fetchall()]\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    g.db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    g.db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != USERNAME:\n            error = 'Invalid username'\n        elif request.form['password'] != PASSWORD:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    app.run()\n\n\"\"\"\nGenerate tests which test: request_init -> before_request and request_shutdown -> after_request\n\nThis fixes #9.\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    Flask Tests\n    ~~~~~~~~~~~\n\n    Tests Flask itself.  The majority of Flask is already tested\n    as part of Werkzeug.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nfrom __future__ import with_statement\nimport flask\nimport unittest\nimport tempfile\n\n\nclass ContextTestCase(unittest.TestCase):\n\n    def test_context_binding(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return 'Hello %s!' % flask.request.args['name']\n        @app.route('\/meh')\n        def meh():\n            return flask.request.url\n\n        with app.test_request_context('\/?name=World'):\n            assert index() == 'Hello World!'\n        with app.test_request_context('\/meh'):\n            assert meh() == 'http:\/\/localhost\/meh'\n\n\nclass BasicFunctionality(unittest.TestCase):\n\n    def test_request_dispatching(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.request.method\n        @app.route('\/more', methods=['GET', 'POST'])\n        def more():\n            return flask.request.method\n\n        c = app.test_client()\n        assert c.get('\/').data == 'GET'\n        rv = c.post('\/')\n        assert rv.status_code == 405\n        assert sorted(rv.allow) == ['GET', 'HEAD']\n        rv = c.head('\/')\n        assert rv.status_code == 200\n        assert not rv.data # head truncates\n        assert c.post('\/more').data == 'POST'\n        assert c.get('\/more').data == 'GET'\n        rv = c.delete('\/more')\n        assert rv.status_code == 405\n        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']\n\n    def test_session(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n        @app.route('\/set', methods=['POST'])\n        def set():\n            flask.session['value'] = flask.request.form['value']\n            return 'value set'\n        @app.route('\/get')\n        def get():\n            return flask.session['value']\n\n        c = app.test_client()\n        assert c.post('\/set', data={'value': '42'}).data == 'value set'\n        assert c.get('\/get').data == '42'\n\n    def test_request_processing(self):\n        app = flask.Flask(__name__)\n        evts = []\n        @app.before_request\n        def before_request():\n            evts.append('before')\n        @app.after_request\n        def after_request(response):\n            response.data += '|after'\n            evts.append('after')\n            return response\n        @app.route('\/')\n        def index():\n            assert 'before' in evts\n            assert 'after' not in evts\n            return 'request'\n        assert 'after' not in evts\n        rv = app.test_client().get('\/').data\n        assert 'after' in evts\n        assert rv == 'request|after'\n\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        @app.errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @app.errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @app.route('\/')\n        def index():\n            flask.abort(404)\n        @app.route('\/error')\n        def error():\n            1\/0\n        c = app.test_client()\n        rv = c.get('\/')\n        assert rv.status_code == 404\n        assert rv.data == 'not found'\n        rv = c.get('\/error')\n        assert rv.status_code == 500\n        assert 'internal server error' in rv.data\n\n    def test_response_creation(self):\n        app = flask.Flask(__name__)\n        @app.route('\/unicode')\n        def from_unicode():\n            return u'H\u00e4llo W\u00f6rld'\n        @app.route('\/string')\n        def from_string():\n            return u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n        @app.route('\/args')\n        def from_tuple():\n            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text\/plain'\n        c = app.test_client()\n        assert c.get('\/unicode').data == u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n        assert c.get('\/string').data == u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n        rv = c.get('\/args')\n        assert rv.data == 'Meh'\n        assert rv.headers['X-Foo'] == 'Testing'\n        assert rv.status_code == 400\n        assert rv.mimetype == 'text\/plain'\n\n    def test_url_generation(self):\n        app = flask.Flask(__name__)\n        @app.route('\/hello\/<name>', methods=['POST'])\n        def hello():\n            pass\n        with app.test_request_context():\n            assert flask.url_for('hello', name='test x') == '\/hello\/test%20x'\n\n    def test_static_files(self):\n        app = flask.Flask(__name__)\n        rv = app.test_client().get('\/static\/index.html')\n        assert rv.status_code == 200\n        assert rv.data.strip() == '<h1>Hello World!<\/h1>'\n        with app.test_request_context():\n            assert flask.url_for('static', filename='index.html') \\\n                == '\/static\/index.html'\n\n\nclass Templating(unittest.TestCase):\n\n    def test_context_processing(self):\n        app = flask.Flask(__name__)\n        @app.context_processor\n        def context_processor():\n            return {'injected_value': 42}\n        @app.route('\/')\n        def index():\n            return flask.render_template('context_template.html', value=23)\n        rv = app.test_client().get('\/')\n        assert rv.data == '<p>23|42'\n\n    def test_escaping(self):\n        text = '<p>Hello World!'\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('escaping_template.html', text=text,\n                                         html=flask.Markup(text))\n        lines = app.test_client().get('\/').data.splitlines()\n        assert lines == [\n            '&lt;p&gt;Hello World!',\n            '<p>Hello World!',\n            '<p>Hello World!',\n            '<p>Hello World!',\n            '&lt;p&gt;Hello World!',\n            '<p>Hello World!'\n        ]\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nfrom __future__ import with_statement\nimport sqlite3\nfrom contextlib import closing\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Returns a new connection to the database.\"\"\"\n    return sqlite3.connect(app.config['DATABASE'])\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with closing(connect_db()) as db:\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\n@app.before_request\ndef before_request():\n    \"\"\"Make sure we are connected to the database each request.\"\"\"\n    g.db = connect_db()\n\n\n@app.after_request\ndef after_request(response):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    g.db.close()\n    return response\n\n\n@app.route('\/')\ndef show_entries():\n    cur = g.db.execute('select title, text from entries order by id desc')\n    entries = [dict(title=row[0], text=row[1]) for row in cur.fetchall()]\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    g.db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    g.db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    app.run()\n\n\"\"\"\nGenerate tests which test: Ported examples over to new config. documented upgrading\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr Tests\n    ~~~~~~~~~~~~\n\n    Tests the Flaskr application.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport os\nimport flaskr\nimport unittest\nimport tempfile\n\n\nclass FlaskrTestCase(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Before each test, set up a blank database\"\"\"\n        self.db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()\n        self.app = flaskr.app.test_client()\n        flaskr.init_db()\n\n    def tearDown(self):\n        \"\"\"Get rid of the database again after each test.\"\"\"\n        os.close(self.db_fd)\n        os.unlink(flaskr.app.config['DATABASE'])\n\n    def login(self, username, password):\n        return self.app.post('\/login', data=dict(\n            username=username,\n            password=password\n        ), follow_redirects=True)\n\n    def logout(self):\n        return self.app.get('\/logout', follow_redirects=True)\n\n    # testing functions\n\n    def test_empty_db(self):\n        \"\"\"Start with a blank database.\"\"\"\n        rv = self.app.get('\/')\n        assert 'No entries here so far' in rv.data\n\n    def test_login_logout(self):\n        \"\"\"Make sure login and logout works\"\"\"\n        rv = self.login(flaskr.app.config['USERNAME'],\n                        flaskr.app.config['PASSWORD'])\n        assert 'You were logged in' in rv.data\n        rv = self.logout()\n        assert 'You were logged out' in rv.data\n        rv = self.login(flaskr.app.config['USERNAME'] + 'x',\n                        flaskr.app.config['PASSWORD'])\n        assert 'Invalid username' in rv.data\n        rv = self.login(flaskr.app.config['USERNAME'],\n                        flaskr.app.config['PASSWORD'] + 'x')\n        assert 'Invalid password' in rv.data\n\n    def test_messages(self):\n        \"\"\"Test that messages work\"\"\"\n        self.login(flaskr.app.config['USERNAME'],\n                   flaskr.app.config['PASSWORD'])\n        rv = self.app.post('\/add', data=dict(\n            title='<Hello>',\n            text='<strong>HTML<\/strong> allowed here'\n        ), follow_redirects=True)\n        assert 'No entries here so far' not in rv.data\n        assert '&lt;Hello&gt' in rv.data\n        assert '<strong>HTML<\/strong> allowed here' in rv.data\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit\n    ~~~~~~~~\n\n    A microblogging application written with Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nfrom __future__ import with_statement\nimport time\nimport sqlite3\nfrom hashlib import md5\nfrom datetime import datetime\nfrom contextlib import closing\nfrom flask import Flask, request, session, url_for, redirect, \\\n     render_template, abort, g, flash\nfrom werkzeug import check_password_hash, generate_password_hash\n\n\n# configuration\nDATABASE = '\/tmp\/minitwit.db'\nPER_PAGE = 30\nDEBUG = True\nSECRET_KEY = 'development key'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('MINITWIT_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Returns a new connection to the database.\"\"\"\n    return sqlite3.connect(app.config['DATABASE'])\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with closing(connect_db()) as db:\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef query_db(query, args=(), one=False):\n    \"\"\"Queries the database and returns a list of dictionaries.\"\"\"\n    cur = g.db.execute(query, args)\n    rv = [dict((cur.description[idx][0], value)\n               for idx, value in enumerate(row)) for row in cur.fetchall()]\n    return (rv[0] if rv else None) if one else rv\n\n\ndef get_user_id(username):\n    \"\"\"Convenience method to look up the id for a username.\"\"\"\n    rv = g.db.execute('select user_id from user where username = ?',\n                       [username]).fetchone()\n    return rv[0] if rv else None\n\n\ndef format_datetime(timestamp):\n    \"\"\"Format a timestamp for display.\"\"\"\n    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')\n\n\ndef gravatar_url(email, size=80):\n    \"\"\"Return the gravatar image for the given email address.\"\"\"\n    return 'http:\/\/www.gravatar.com\/avatar\/%s?d=identicon&s=%d' % \\\n        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)\n\n\n@app.before_request\ndef before_request():\n    \"\"\"Make sure we are connected to the database each request and look\n    up the current user so that we know he's there.\n    \"\"\"\n    g.db = connect_db()\n    g.user = None\n    if 'user_id' in session:\n        g.user = query_db('select * from user where user_id = ?',\n                          [session['user_id']], one=True)\n\n\n@app.after_request\ndef after_request(response):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    g.db.close()\n    return response\n\n\n@app.route('\/')\ndef timeline():\n    \"\"\"Shows a users timeline or if no user is logged in it will\n    redirect to the public timeline.  This timeline shows the user's\n    messages as well as all the messages of followed users.\n    \"\"\"\n    if not g.user:\n        return redirect(url_for('public_timeline'))\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id and (\n            user.user_id = ? or\n            user.user_id in (select whom_id from follower\n                                    where who_id = ?))\n        order by message.pub_date desc limit ?''',\n        [session['user_id'], session['user_id'], PER_PAGE]))\n\n\n@app.route('\/public')\ndef public_timeline():\n    \"\"\"Displays the latest messages of all users.\"\"\"\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id\n        order by message.pub_date desc limit ?''', [PER_PAGE]))\n\n\n@app.route('\/<username>')\ndef user_timeline(username):\n    \"\"\"Display's a users tweets.\"\"\"\n    profile_user = query_db('select * from user where username = ?',\n                            [username], one=True)\n    if profile_user is None:\n        abort(404)\n    followed = False\n    if g.user:\n        followed = query_db('''select 1 from follower where\n            follower.who_id = ? and follower.whom_id = ?''',\n            [session['user_id'], profile_user['user_id']],\n            one=True) is not None\n    return render_template('timeline.html', messages=query_db('''\n            select message.*, user.* from message, user where\n            user.user_id = message.author_id and user.user_id = ?\n            order by message.pub_date desc limit ?''',\n            [profile_user['user_id'], PER_PAGE]), followed=followed,\n            profile_user=profile_user)\n\n\n@app.route('\/<username>\/follow')\ndef follow_user(username):\n    \"\"\"Adds the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    g.db.execute('insert into follower (who_id, whom_id) values (?, ?)',\n                [session['user_id'], whom_id])\n    g.db.commit()\n    flash('You are now following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/<username>\/unfollow')\ndef unfollow_user(username):\n    \"\"\"Removes the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    g.db.execute('delete from follower where who_id=? and whom_id=?',\n                [session['user_id'], whom_id])\n    g.db.commit()\n    flash('You are no longer following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/add_message', methods=['POST'])\ndef add_message():\n    \"\"\"Registers a new message for the user.\"\"\"\n    if 'user_id' not in session:\n        abort(401)\n    if request.form['text']:\n        g.db.execute('''insert into message (author_id, text, pub_date)\n            values (?, ?, ?)''', (session['user_id'], request.form['text'],\n                                  int(time.time())))\n        g.db.commit()\n        flash('Your message was recorded')\n    return redirect(url_for('timeline'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    \"\"\"Logs the user in.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        user = query_db('''select * from user where\n            username = ?''', [request.form['username']], one=True)\n        if user is None:\n            error = 'Invalid username'\n        elif not check_password_hash(user['pw_hash'],\n                                     request.form['password']):\n            error = 'Invalid password'\n        else:\n            flash('You were logged in')\n            session['user_id'] = user['user_id']\n            return redirect(url_for('timeline'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/register', methods=['GET', 'POST'])\ndef register():\n    \"\"\"Registers the user.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        if not request.form['username']:\n            error = 'You have to enter a username'\n        elif not request.form['email'] or \\\n                 '@' not in request.form['email']:\n            error = 'You have to enter a valid email address'\n        elif not request.form['password']:\n            error = 'You have to enter a password'\n        elif request.form['password'] != request.form['password2']:\n            error = 'The two passwords do not match'\n        elif get_user_id(request.form['username']) is not None:\n            error = 'The username is already taken'\n        else:\n            g.db.execute('''insert into user (\n                username, email, pw_hash) values (?, ?, ?)''',\n                [request.form['username'], request.form['email'],\n                 generate_password_hash(request.form['password'])])\n            g.db.commit()\n            flash('You were successfully registered and can login now')\n            return redirect(url_for('login'))\n    return render_template('register.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    \"\"\"Logs the user out.\"\"\"\n    flash('You were logged out')\n    session.pop('user_id', None)\n    return redirect(url_for('public_timeline'))\n\n\n# add some filters to jinja\napp.jinja_env.filters['datetimeformat'] = format_datetime\napp.jinja_env.filters['gravatar'] = gravatar_url\n\n\nif __name__ == '__main__':\n    app.run()\n\n\"\"\"\nGenerate tests which test: Ported examples over to new config. documented upgrading\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit Tests\n    ~~~~~~~~~~~~~~\n\n    Tests the MiniTwit application.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport os\nimport minitwit\nimport unittest\nimport tempfile\n\n\nclass MiniTwitTestCase(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Before each test, set up a blank database\"\"\"\n        self.db_fd, minitwit.app.config['DATABASE'] = tempfile.mkstemp()\n        self.app = minitwit.app.test_client()\n        minitwit.init_db()\n\n    def tearDown(self):\n        \"\"\"Get rid of the database again after each test.\"\"\"\n        os.close(self.db_fd)\n        os.unlink(minitwit.app.config['DATABASE'])\n\n    # helper functions\n\n    def register(self, username, password, password2=None, email=None):\n        \"\"\"Helper function to register a user\"\"\"\n        if password2 is None:\n            password2 = password\n        if email is None:\n            email = username + '@example.com'\n        return self.app.post('\/register', data={\n            'username':     username,\n            'password':     password,\n            'password2':    password2,\n            'email':        email,\n        }, follow_redirects=True)\n\n    def login(self, username, password):\n        \"\"\"Helper function to login\"\"\"\n        return self.app.post('\/login', data={\n            'username': username,\n            'password': password\n        }, follow_redirects=True)\n\n    def register_and_login(self, username, password):\n        \"\"\"Registers and logs in in one go\"\"\"\n        self.register(username, password)\n        return self.login(username, password)\n\n    def logout(self):\n        \"\"\"Helper function to logout\"\"\"\n        return self.app.get('\/logout', follow_redirects=True)\n\n    def add_message(self, text):\n        \"\"\"Records a message\"\"\"\n        rv = self.app.post('\/add_message', data={'text': text},\n                                    follow_redirects=True)\n        if text:\n            assert 'Your message was recorded' in rv.data\n        return rv\n\n    # testing functions\n\n    def test_register(self):\n        \"\"\"Make sure registering works\"\"\"\n        rv = self.register('user1', 'default')\n        assert 'You were successfully registered ' \\\n               'and can login now' in rv.data\n        rv = self.register('user1', 'default')\n        assert 'The username is already taken' in rv.data\n        rv = self.register('', 'default')\n        assert 'You have to enter a username' in rv.data\n        rv = self.register('meh', '')\n        assert 'You have to enter a password' in rv.data\n        rv = self.register('meh', 'x', 'y')\n        assert 'The two passwords do not match' in rv.data\n        rv = self.register('meh', 'foo', email='broken')\n        assert 'You have to enter a valid email address' in rv.data\n\n    def test_login_logout(self):\n        \"\"\"Make sure logging in and logging out works\"\"\"\n        rv = self.register_and_login('user1', 'default')\n        assert 'You were logged in' in rv.data\n        rv = self.logout()\n        assert 'You were logged out' in rv.data\n        rv = self.login('user1', 'wrongpassword')\n        assert 'Invalid password' in rv.data\n        rv = self.login('user2', 'wrongpassword')\n        assert 'Invalid username' in rv.data\n\n    def test_message_recording(self):\n        \"\"\"Check if adding messages works\"\"\"\n        self.register_and_login('foo', 'default')\n        self.add_message('test message 1')\n        self.add_message('<test message 2>')\n        rv = self.app.get('\/')\n        assert 'test message 1' in rv.data\n        assert '&lt;test message 2&gt;' in rv.data\n\n    def test_timelines(self):\n        \"\"\"Make sure that timelines work\"\"\"\n        self.register_and_login('foo', 'default')\n        self.add_message('the message by foo')\n        self.logout()\n        self.register_and_login('bar', 'default')\n        self.add_message('the message by bar')\n        rv = self.app.get('\/public')\n        assert 'the message by foo' in rv.data\n        assert 'the message by bar' in rv.data\n\n        # bar's timeline should just show bar's message\n        rv = self.app.get('\/')\n        assert 'the message by foo' not in rv.data\n        assert 'the message by bar' in rv.data\n\n        # now let's follow foo\n        rv = self.app.get('\/foo\/follow', follow_redirects=True)\n        assert 'You are now following &#34;foo&#34;' in rv.data\n\n        # we should now see foo's message\n        rv = self.app.get('\/')\n        assert 'the message by foo' in rv.data\n        assert 'the message by bar' in rv.data\n\n        # but on the user's page we only want the user's message\n        rv = self.app.get('\/bar')\n        assert 'the message by foo' not in rv.data\n        assert 'the message by bar' in rv.data\n        rv = self.app.get('\/foo')\n        assert 'the message by foo' in rv.data\n        assert 'the message by bar' not in rv.data\n\n        # now unfollow and check if that worked\n        rv = self.app.get('\/foo\/unfollow', follow_redirects=True)\n        assert 'You are no longer following &#34;foo&#34;' in rv.data\n        rv = self.app.get('\/')\n        assert 'the message by foo' not in rv.data\n        assert 'the message by bar' in rv.data\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.wrappers\n    ~~~~~~~~~~~~~~\n\n    Implements the WSGI wrappers (request and response).\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom werkzeug.wrappers import Request as RequestBase, Response as ResponseBase\nfrom werkzeug.utils import cached_property\n\nfrom .exceptions import JSONBadRequest\nfrom .debughelpers import attach_enctype_error_multidict\nfrom . import json\nfrom .globals import _request_ctx_stack\n\n\nclass Request(RequestBase):\n    \"\"\"The request object used by default in Flask.  Remembers the\n    matched endpoint and view arguments.\n\n    It is what ends up as :class:`~flask.request`.  If you want to replace\n    the request object used you can subclass this and set\n    :attr:`~flask.Flask.request_class` to your subclass.\n\n    The request object is a :class:`~werkzeug.wrappers.Request` subclass and\n    provides all of the attributes Werkzeug defines plus a few Flask\n    specific ones.\n    \"\"\"\n\n    #: the internal URL rule that matched the request.  This can be\n    #: useful to inspect which methods are allowed for the URL from\n    #: a before\/after handler (``request.url_rule.methods``) etc.\n    #:\n    #: .. versionadded:: 0.6\n    url_rule = None\n\n    #: a dict of view arguments that matched the request.  If an exception\n    #: happened when matching, this will be `None`.\n    view_args = None\n\n    #: if matching the URL failed, this is the exception that will be\n    #: raised \/ was raised as part of the request handling.  This is\n    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n    #: something similar.\n    routing_exception = None\n\n    # switched by the request context until 1.0 to opt in deprecated\n    # module functionality\n    _is_old_module = False\n\n    @property\n    def max_content_length(self):\n        \"\"\"Read-only view of the `MAX_CONTENT_LENGTH` config key.\"\"\"\n        ctx = _request_ctx_stack.top\n        if ctx is not None:\n            return ctx.app.config['MAX_CONTENT_LENGTH']\n\n    @property\n    def endpoint(self):\n        \"\"\"The endpoint that matched the request.  This in combination with\n        :attr:`view_args` can be used to reconstruct the same or a\n        modified URL.  If an exception happened when matching, this will\n        be `None`.\n        \"\"\"\n        if self.url_rule is not None:\n            return self.url_rule.endpoint\n\n    @property\n    def module(self):\n        \"\"\"The name of the current module if the request was dispatched\n        to an actual module.  This is deprecated functionality, use blueprints\n        instead.\n        \"\"\"\n        from warnings import warn\n        warn(DeprecationWarning('modules were deprecated in favor of '\n                                'blueprints.  Use request.blueprint '\n                                'instead.'), stacklevel=2)\n        if self._is_old_module:\n            return self.blueprint\n\n    @property\n    def blueprint(self):\n        \"\"\"The name of the current blueprint\"\"\"\n        if self.url_rule and '.' in self.url_rule.endpoint:\n            return self.url_rule.endpoint.rsplit('.', 1)[0]\n\n    @cached_property\n    def json(self):\n        \"\"\"If the mimetype is `application\/json` this will contain the\n        parsed JSON data.  Otherwise this will be `None`.\n\n        This requires Python 2.6 or an installed version of simplejson.\n        \"\"\"\n        if self.mimetype == 'application\/json':\n            request_charset = self.mimetype_params.get('charset')\n            try:\n                if request_charset is not None:\n                    return json.loads(self.data, encoding=request_charset)\n                return json.loads(self.data)\n            except ValueError as e:\n                return self.on_json_loading_failed(e)\n\n    def on_json_loading_failed(self, e):\n        \"\"\"Called if decoding of the JSON data failed.  The return value of\n        this method is used by :attr:`json` when an error occurred.  The default\n        implementation raises a :class:`JSONBadRequest`, which is a subclass of\n        :class:`~werkzeug.exceptions.BadRequest` which sets the\n        ``Content-Type`` to ``application\/json`` and provides a JSON-formatted\n        error description::\n\n            {\"description\": \"The browser (or proxy) sent a request that \\\n                             this server could not understand.\"}\n\n        .. versionchanged:: 0.9\n           Return a :class:`JSONBadRequest` instead of a\n           :class:`~werkzeug.exceptions.BadRequest` by default.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        raise JSONBadRequest()\n\n    def _load_form_data(self):\n        RequestBase._load_form_data(self)\n\n        # in debug mode we're replacing the files multidict with an ad-hoc\n        # subclass that raises a different error for key errors.\n        ctx = _request_ctx_stack.top\n        if ctx is not None and ctx.app.debug and \\\n           self.mimetype != 'multipart\/form-data' and not self.files:\n            attach_enctype_error_multidict(self)\n\n\nclass Response(ResponseBase):\n    \"\"\"The response object that is used by default in Flask.  Works like the\n    response object from Werkzeug but is set to have an HTML mimetype by\n    default.  Quite often you don't have to create this object yourself because\n    :meth:`~flask.Flask.make_response` will take care of that for you.\n\n    If you want to replace the response object used you can subclass this and\n    set :attr:`~flask.Flask.response_class` to your subclass.\n    \"\"\"\n    default_mimetype = 'text\/html'\n\n\"\"\"\nGenerate tests which test: automated change using python-modernize: use 'as' in except\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.blueprints\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Blueprints (and currently modules)\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom __future__ import with_statement\n\nimport flask\nimport unittest\nimport warnings\nfrom flask.testsuite import FlaskTestCase, emits_module_deprecation_warning\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_cache_control_header\nfrom jinja2 import TemplateNotFound\n\n\n# import moduleapp here because it uses deprecated features and we don't\n# want to see the warnings\nwarnings.simplefilter('ignore', DeprecationWarning)\nfrom moduleapp import app as moduleapp\nwarnings.simplefilter('default', DeprecationWarning)\n\n\nclass ModuleTestCase(FlaskTestCase):\n\n    @emits_module_deprecation_warning\n    def test_basic_module(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.route('\/')\n        def admin_index():\n            return 'admin index'\n        @admin.route('\/login')\n        def admin_login():\n            return 'admin login'\n        @admin.route('\/logout')\n        def admin_logout():\n            return 'admin logout'\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, 'the index')\n        self.assert_equal(c.get('\/admin\/').data, 'admin index')\n        self.assert_equal(c.get('\/admin\/login').data, 'admin login')\n        self.assert_equal(c.get('\/admin\/logout').data, 'admin logout')\n\n    @emits_module_deprecation_warning\n    def test_default_endpoint_name(self):\n        app = flask.Flask(__name__)\n        mod = flask.Module(__name__, 'frontend')\n        def index():\n            return 'Awesome'\n        mod.add_url_rule('\/', view_func=index)\n        app.register_module(mod)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'Awesome')\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('frontend.index'), '\/')\n\n    @emits_module_deprecation_warning\n    def test_request_processing(self):\n        catched = []\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.before_request\n        def before_admin_request():\n            catched.append('before-admin')\n        @admin.after_request\n        def after_admin_request(response):\n            catched.append('after-admin')\n            return response\n        @admin.route('\/')\n        def admin_index():\n            return 'the admin'\n        @app.before_request\n        def before_request():\n            catched.append('before-app')\n        @app.after_request\n        def after_request(response):\n            catched.append('after-app')\n            return response\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/').data, 'the index')\n        self.assert_equal(catched, ['before-app', 'after-app'])\n        del catched[:]\n\n        self.assert_equal(c.get('\/admin\/').data, 'the admin')\n        self.assert_equal(catched, ['before-app', 'before-admin',\n                           'after-admin', 'after-app'])\n\n    @emits_module_deprecation_warning\n    def test_context_processors(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @app.context_processor\n        def inject_all_regualr():\n            return {'a': 1}\n        @admin.context_processor\n        def inject_admin():\n            return {'b': 2}\n        @admin.app_context_processor\n        def inject_all_module():\n            return {'c': 3}\n        @app.route('\/')\n        def index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        @admin.route('\/')\n        def admin_index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, '13')\n        self.assert_equal(c.get('\/admin\/').data, '123')\n\n    @emits_module_deprecation_warning\n    def test_late_binding(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.route('\/')\n        def index():\n            return '42'\n        app.register_module(admin, url_prefix='\/admin')\n        self.assert_equal(app.test_client().get('\/admin\/').data, '42')\n\n    @emits_module_deprecation_warning\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.app_errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @admin.app_errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @admin.route('\/')\n        def index():\n            flask.abort(404)\n        @admin.route('\/error')\n        def error():\n            1 \/\/ 0\n        app.register_module(admin)\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, 'not found')\n        rv = c.get('\/error')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_equal('internal server error', rv.data)\n\n    def test_templates_and_static(self):\n        app = moduleapp\n        app.testing = True\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, 'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), 'Admin File')\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), '\/* nested file *\/')\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_safe_access(self):\n        app = moduleapp\n\n        with app.test_request_context():\n            f = app.view_functions['admin.static']\n\n            try:\n                f('\/etc\/passwd')\n            except NotFound:\n                pass\n            else:\n                self.assert_(0, 'expected exception')\n            try:\n                f('..\/__init__.py')\n            except NotFound:\n                pass\n            else:\n                self.assert_(0, 'expected exception')\n\n            # testcase for a security issue that may exist on windows systems\n            import os\n            import ntpath\n            old_path = os.path\n            os.path = ntpath\n            try:\n                try:\n                    f('..\\\\__init__.py')\n                except NotFound:\n                    pass\n                else:\n                    self.assert_(0, 'expected exception')\n            finally:\n                os.path = old_path\n\n    @emits_module_deprecation_warning\n    def test_endpoint_decorator(self):\n        from werkzeug.routing import Submount, Rule\n        from flask import Module\n\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n        module = Module(__name__, __name__)\n\n        @module.endpoint('bar')\n        def bar():\n            return 'bar'\n\n        @module.endpoint('index')\n        def index():\n            return 'index'\n\n        app.register_module(module)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, 'index')\n        self.assert_equal(c.get('\/foo\/bar').data, 'bar')\n\n\nclass BlueprintTestCase(FlaskTestCase):\n\n    def test_blueprint_specific_error_handling(self):\n        frontend = flask.Blueprint('frontend', __name__)\n        backend = flask.Blueprint('backend', __name__)\n        sideend = flask.Blueprint('sideend', __name__)\n\n        @frontend.errorhandler(403)\n        def frontend_forbidden(e):\n            return 'frontend says no', 403\n\n        @frontend.route('\/frontend-no')\n        def frontend_no():\n            flask.abort(403)\n\n        @backend.errorhandler(403)\n        def backend_forbidden(e):\n            return 'backend says no', 403\n\n        @backend.route('\/backend-no')\n        def backend_no():\n            flask.abort(403)\n\n        @sideend.route('\/what-is-a-sideend')\n        def sideend_no():\n            flask.abort(403)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n        app.register_blueprint(sideend)\n\n        @app.errorhandler(403)\n        def app_forbidden(e):\n            return 'application itself says no', 403\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/frontend-no').data, 'frontend says no')\n        self.assert_equal(c.get('\/backend-no').data, 'backend says no')\n        self.assert_equal(c.get('\/what-is-a-sideend').data, 'application itself says no')\n\n    def test_blueprint_url_definitions(self):\n        bp = flask.Blueprint('test', __name__)\n\n        @bp.route('\/foo', defaults={'baz': 42})\n        def foo(bar, baz):\n            return '%s\/%d' % (bar, baz)\n\n        @bp.route('\/bar')\n        def bar(bar):\n            return unicode(bar)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/1', url_defaults={'bar': 23})\n        app.register_blueprint(bp, url_prefix='\/2', url_defaults={'bar': 19})\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/1\/foo').data, u'23\/42')\n        self.assert_equal(c.get('\/2\/foo').data, u'19\/42')\n        self.assert_equal(c.get('\/1\/bar').data, u'23')\n        self.assert_equal(c.get('\/2\/bar').data, u'19')\n\n    def test_blueprint_url_processors(self):\n        bp = flask.Blueprint('frontend', __name__, url_prefix='\/<lang_code>')\n\n        @bp.url_defaults\n        def add_language_code(endpoint, values):\n            values.setdefault('lang_code', flask.g.lang_code)\n\n        @bp.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop('lang_code')\n\n        @bp.route('\/')\n        def index():\n            return flask.url_for('.about')\n\n        @bp.route('\/about')\n        def about():\n            return flask.url_for('.index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/de\/').data, '\/de\/about')\n        self.assert_equal(c.get('\/de\/about').data, '\/de\/')\n\n    def test_templates_and_static(self):\n        from blueprintapp import app\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, 'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), 'Admin File')\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), '\/* nested file *\/')\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            expected_max_age = 3600\n            if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == expected_max_age:\n                expected_max_age = 7200\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = expected_max_age\n            rv = c.get('\/admin\/static\/css\/test.css')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, expected_max_age)\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_default_static_cache_timeout(self):\n        app = flask.Flask(__name__)\n        class MyBlueprint(flask.Blueprint):\n            def get_send_file_max_age(self, filename):\n                return 100\n\n        blueprint = MyBlueprint('blueprint', __name__, static_folder='static')\n        app.register_blueprint(blueprint)\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            with app.test_request_context():\n                unexpected_max_age = 3600\n                if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == unexpected_max_age:\n                    unexpected_max_age = 7200\n                app.config['SEND_FILE_MAX_AGE_DEFAULT'] = unexpected_max_age\n                rv = blueprint.send_static_file('index.html')\n                cc = parse_cache_control_header(rv.headers['Cache-Control'])\n                self.assert_equal(cc.max_age, 100)\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n    def test_templates_list(self):\n        from blueprintapp import app\n        templates = sorted(app.jinja_env.list_templates())\n        self.assert_equal(templates, ['admin\/index.html',\n                                     'frontend\/index.html'])\n\n    def test_dotted_names(self):\n        frontend = flask.Blueprint('myapp.frontend', __name__)\n        backend = flask.Blueprint('myapp.backend', __name__)\n\n        @frontend.route('\/fe')\n        def frontend_index():\n            return flask.url_for('myapp.backend.backend_index')\n\n        @frontend.route('\/fe2')\n        def frontend_page2():\n            return flask.url_for('.frontend_index')\n\n        @backend.route('\/be')\n        def backend_index():\n            return flask.url_for('myapp.frontend.frontend_index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/fe').data.strip(), '\/be')\n        self.assert_equal(c.get('\/fe2').data.strip(), '\/fe')\n        self.assert_equal(c.get('\/be').data.strip(), '\/fe')\n\n    def test_empty_url_defaults(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/', defaults={'page': 1})\n        @bp.route('\/page\/<int:page>')\n        def something(page):\n            return str(page)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, '1')\n        self.assert_equal(c.get('\/page\/2').data, '2')\n\n    def test_route_decorator_custom_endpoint(self):\n\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar', endpoint='bar')\n        def foo_bar():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/123', endpoint='123')\n        def foo_bar_foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/foo')\n        def bar_foo():\n            return flask.request.endpoint\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        @app.route('\/')\n        def index():\n            return flask.request.endpoint\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/').data, 'index')\n        self.assertEqual(c.get('\/py\/foo').data, 'bp.foo')\n        self.assertEqual(c.get('\/py\/bar').data, 'bp.bar')\n        self.assertEqual(c.get('\/py\/bar\/123').data, 'bp.123')\n        self.assertEqual(c.get('\/py\/bar\/foo').data, 'bp.bar_foo')\n\n    def test_route_decorator_custom_endpoint_with_dots(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        try:\n            @bp.route('\/bar', endpoint='bar.bar')\n            def foo_bar():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        try:\n            @bp.route('\/bar\/123', endpoint='bar.123')\n            def foo_bar_foo():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        def foo_foo_foo():\n            pass\n\n        self.assertRaises(\n            AssertionError,\n            lambda: bp.add_url_rule(\n                '\/bar\/123', endpoint='bar.123', view_func=foo_foo_foo\n            )\n        )\n\n        self.assertRaises(\n            AssertionError,\n            bp.route('\/bar\/123', endpoint='bar.123'),\n            lambda: None\n        )\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/py\/foo').data, 'bp.foo')\n        # The rule's din't actually made it through\n        rv = c.get('\/py\/bar')\n        assert rv.status_code == 404\n        rv = c.get('\/py\/bar\/123')\n        assert rv.status_code == 404\n\n    def test_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('my_reverse' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_add_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('my_reverse' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('strrev')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('strrev' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_add_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'strrev')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('strrev' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_template_filter_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_add_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def super_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(super_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('super_reverse')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_add_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'super_reverse')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('is_boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['is_boolean'](False))\n\n    def test_add_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('is_boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['is_boolean'](False))\n\n    def test_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_template_test_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_add_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_add_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(BlueprintTestCase))\n    suite.addTest(unittest.makeSuite(ModuleTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.appctx\n    ~~~~~~~~~~~~~~~~~~~~~~\n\n    Tests the application context.\n\n    :copyright: (c) 2012 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nfrom flask.testsuite import FlaskTestCase\n\n\nclass AppContextTestCase(FlaskTestCase):\n\n    def test_basic_url_generation(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'localhost'\n        app.config['PREFERRED_URL_SCHEME'] = 'https'\n\n        @app.route('\/')\n        def index():\n            pass\n\n        with app.app_context():\n            rv = flask.url_for('index')\n            self.assert_equal(rv, 'https:\/\/localhost\/')\n\n    def test_url_generation_requires_server_name(self):\n        app = flask.Flask(__name__)\n        with app.app_context():\n            with self.assert_raises(RuntimeError):\n                flask.url_for('index')\n\n    def test_url_generation_without_context_fails(self):\n        with self.assert_raises(RuntimeError):\n            flask.url_for('index')\n\n    def test_request_context_means_app_context(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            self.assert_equal(flask.current_app._get_current_object(), app)\n        self.assert_equal(flask._app_ctx_stack.top, None)\n\n    def test_app_context_provides_current_app(self):\n        app = flask.Flask(__name__)\n        with app.app_context():\n            self.assert_equal(flask.current_app._get_current_object(), app)\n        self.assert_equal(flask._app_ctx_stack.top, None)\n\n    def test_app_tearing_down(self):\n        cleanup_stuff = []\n        app = flask.Flask(__name__)\n        @app.teardown_appcontext\n        def cleanup(exception):\n            cleanup_stuff.append(exception)\n\n        with app.app_context():\n            pass\n\n        self.assert_equal(cleanup_stuff, [None])\n\n    def test_custom_app_ctx_globals_class(self):\n        class CustomRequestGlobals(object):\n            def __init__(self):\n                self.spam = 'eggs'\n        app = flask.Flask(__name__)\n        app.app_ctx_globals_class = CustomRequestGlobals\n        with app.app_context():\n            self.assert_equal(\n                flask.render_template_string('{{ g.spam }}'), 'eggs')\n\n    def test_context_refcounts(self):\n        called = []\n        app = flask.Flask(__name__)\n        @app.teardown_request\n        def teardown_req(error=None):\n            called.append('request')\n        @app.teardown_appcontext\n        def teardown_app(error=None):\n            called.append('app')\n        @app.route('\/')\n        def index():\n            with flask._app_ctx_stack.top:\n                with flask._request_ctx_stack.top:\n                    pass\n            self.assert_(flask._request_ctx_stack.request.environ\n                ['werkzeug.request'] is not None)\n        c = app.test_client()\n        c.get('\/')\n        self.assertEqual(called, ['request', 'app'])\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(AppContextTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.basic\n    ~~~~~~~~~~~~~~~~~~~~~\n\n    The basic functionality.\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport re\nimport uuid\nimport flask\nimport pickle\nimport unittest\nfrom datetime import datetime\nfrom threading import Thread\nfrom flask.testsuite import FlaskTestCase, emits_module_deprecation_warning\nfrom werkzeug.exceptions import BadRequest, NotFound\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\nimport six\n\n\nclass BasicFunctionalityTestCase(FlaskTestCase):\n\n    def test_options_work(self):\n        app = flask.Flask(__name__)\n        @app.route('\/', methods=['GET', 'POST'])\n        def index():\n            return 'Hello World'\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])\n        self.assert_equal(rv.data, '')\n\n    def test_options_on_multiple_rules(self):\n        app = flask.Flask(__name__)\n        @app.route('\/', methods=['GET', 'POST'])\n        def index():\n            return 'Hello World'\n        @app.route('\/', methods=['PUT'])\n        def index_put():\n            return 'Aha!'\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'])\n\n    def test_options_handling_disabled(self):\n        app = flask.Flask(__name__)\n        def index():\n            return 'Hello World!'\n        index.provide_automatic_options = False\n        app.route('\/')(index)\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(rv.status_code, 405)\n\n        app = flask.Flask(__name__)\n        def index2():\n            return 'Hello World!'\n        index2.provide_automatic_options = True\n        app.route('\/', methods=['OPTIONS'])(index2)\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(sorted(rv.allow), ['OPTIONS'])\n\n    def test_request_dispatching(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.request.method\n        @app.route('\/more', methods=['GET', 'POST'])\n        def more():\n            return flask.request.method\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, 'GET')\n        rv = c.post('\/')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS'])\n        rv = c.head('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_(not rv.data) # head truncates\n        self.assert_equal(c.post('\/more').data, 'POST')\n        self.assert_equal(c.get('\/more').data, 'GET')\n        rv = c.delete('\/more')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])\n\n    def test_url_mapping(self):\n        app = flask.Flask(__name__)\n        def index():\n            return flask.request.method\n        def more():\n            return flask.request.method\n\n        app.add_url_rule('\/', 'index', index)\n        app.add_url_rule('\/more', 'more', more, methods=['GET', 'POST'])\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, 'GET')\n        rv = c.post('\/')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS'])\n        rv = c.head('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_(not rv.data) # head truncates\n        self.assert_equal(c.post('\/more').data, 'POST')\n        self.assert_equal(c.get('\/more').data, 'GET')\n        rv = c.delete('\/more')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])\n\n    def test_werkzeug_routing(self):\n        from werkzeug.routing import Submount, Rule\n        app = flask.Flask(__name__)\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n        def bar():\n            return 'bar'\n        def index():\n            return 'index'\n        app.view_functions['bar'] = bar\n        app.view_functions['index'] = index\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, 'index')\n        self.assert_equal(c.get('\/foo\/bar').data, 'bar')\n\n    def test_endpoint_decorator(self):\n        from werkzeug.routing import Submount, Rule\n        app = flask.Flask(__name__)\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n\n        @app.endpoint('bar')\n        def bar():\n            return 'bar'\n\n        @app.endpoint('index')\n        def index():\n            return 'index'\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, 'index')\n        self.assert_equal(c.get('\/foo\/bar').data, 'bar')\n\n    def test_session(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n        @app.route('\/set', methods=['POST'])\n        def set():\n            flask.session['value'] = flask.request.form['value']\n            return 'value set'\n        @app.route('\/get')\n        def get():\n            return flask.session['value']\n\n        c = app.test_client()\n        self.assert_equal(c.post('\/set', data={'value': '42'}).data, 'value set')\n        self.assert_equal(c.get('\/get').data, '42')\n\n    def test_session_using_server_name(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='example.com'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com\/')\n        self.assert_('domain=.example.com' in rv.headers['set-cookie'].lower())\n        self.assert_('httponly' in rv.headers['set-cookie'].lower())\n\n    def test_session_using_server_name_and_port(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='example.com:8080'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/')\n        self.assert_('domain=.example.com' in rv.headers['set-cookie'].lower())\n        self.assert_('httponly' in rv.headers['set-cookie'].lower())\n\n    def test_session_using_server_name_port_and_path(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='example.com:8080',\n            APPLICATION_ROOT='\/foo'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/foo')\n        self.assert_('domain=example.com' in rv.headers['set-cookie'].lower())\n        self.assert_('path=\/foo' in rv.headers['set-cookie'].lower())\n        self.assert_('httponly' in rv.headers['set-cookie'].lower())\n\n    def test_session_using_application_root(self):\n        class PrefixPathMiddleware(object):\n            def __init__(self, app, prefix):\n                self.app = app\n                self.prefix = prefix\n            def __call__(self, environ, start_response):\n                environ['SCRIPT_NAME'] = self.prefix\n                return self.app(environ, start_response)\n\n        app = flask.Flask(__name__)\n        app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, '\/bar')\n        app.config.update(\n            SECRET_KEY='foo',\n            APPLICATION_ROOT='\/bar'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/')\n        self.assert_('path=\/bar' in rv.headers['set-cookie'].lower())\n\n    def test_session_using_session_settings(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='www.example.com:8080',\n            APPLICATION_ROOT='\/test',\n            SESSION_COOKIE_DOMAIN='.example.com',\n            SESSION_COOKIE_HTTPONLY=False,\n            SESSION_COOKIE_SECURE=True,\n            SESSION_COOKIE_PATH='\/'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/www.example.com:8080\/test\/')\n        cookie = rv.headers['set-cookie'].lower()\n        self.assert_('domain=.example.com' in cookie)\n        self.assert_('path=\/;' in cookie)\n        self.assert_('secure' in cookie)\n        self.assert_('httponly' not in cookie)\n\n    def test_missing_session(self):\n        app = flask.Flask(__name__)\n        def expect_exception(f, *args, **kwargs):\n            try:\n                f(*args, **kwargs)\n            except RuntimeError as e:\n                self.assert_(e.args and 'session is unavailable' in e.args[0])\n            else:\n                self.assert_(False, 'expected exception')\n        with app.test_request_context():\n            self.assert_(flask.session.get('missing_key') is None)\n            expect_exception(flask.session.__setitem__, 'foo', 42)\n            expect_exception(flask.session.pop, 'foo')\n\n    def test_session_expiration(self):\n        permanent = True\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n        @app.route('\/')\n        def index():\n            flask.session['test'] = 42\n            flask.session.permanent = permanent\n            return ''\n\n        @app.route('\/test')\n        def test():\n            return six.text_type(flask.session.permanent)\n\n        client = app.test_client()\n        rv = client.get('\/')\n        self.assert_('set-cookie' in rv.headers)\n        match = re.search(r'\\bexpires=([^;]+)', rv.headers['set-cookie'])\n        expires = parse_date(match.group())\n        expected = datetime.utcnow() + app.permanent_session_lifetime\n        self.assert_equal(expires.year, expected.year)\n        self.assert_equal(expires.month, expected.month)\n        self.assert_equal(expires.day, expected.day)\n\n        rv = client.get('\/test')\n        self.assert_equal(rv.data, 'True')\n\n        permanent = False\n        rv = app.test_client().get('\/')\n        self.assert_('set-cookie' in rv.headers)\n        match = re.search(r'\\bexpires=([^;]+)', rv.headers['set-cookie'])\n        self.assert_(match is None)\n\n    def test_session_stored_last(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'development-key'\n        app.testing = True\n\n        @app.after_request\n        def modify_session(response):\n            flask.session['foo'] = 42\n            return response\n        @app.route('\/')\n        def dump_session_contents():\n            return repr(flask.session.get('foo'))\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, 'None')\n        self.assert_equal(c.get('\/').data, '42')\n\n    def test_session_special_types(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'development-key'\n        app.testing = True\n        now = datetime.utcnow().replace(microsecond=0)\n        the_uuid = uuid.uuid4()\n\n        @app.after_request\n        def modify_session(response):\n            flask.session['m'] = flask.Markup('Hello!')\n            flask.session['u'] = the_uuid\n            flask.session['dt'] = now\n            flask.session['t'] = (1, 2, 3)\n            return response\n\n        @app.route('\/')\n        def dump_session_contents():\n            return pickle.dumps(dict(flask.session))\n\n        c = app.test_client()\n        c.get('\/')\n        rv = pickle.loads(c.get('\/').data)\n        self.assert_equal(rv['m'], flask.Markup('Hello!'))\n        self.assert_equal(type(rv['m']), flask.Markup)\n        self.assert_equal(rv['dt'], now)\n        self.assert_equal(rv['u'], the_uuid)\n        self.assert_equal(rv['t'], (1, 2, 3))\n\n    def test_flashes(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n\n        with app.test_request_context():\n            self.assert_(not flask.session.modified)\n            flask.flash('Zap')\n            flask.session.modified = False\n            flask.flash('Zip')\n            self.assert_(flask.session.modified)\n            self.assert_equal(list(flask.get_flashed_messages()), ['Zap', 'Zip'])\n\n    def test_extended_flashing(self):\n        # Be sure app.testing=True below, else tests can fail silently.\n        #\n        # Specifically, if app.testing is not set to True, the AssertionErrors\n        # in the view functions will cause a 500 response to the test client\n        # instead of propagating exceptions.\n\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n        app.testing = True\n\n        @app.route('\/')\n        def index():\n            flask.flash(u'Hello World')\n            flask.flash(u'Hello World', 'error')\n            flask.flash(flask.Markup(u'<em>Testing<\/em>'), 'warning')\n            return ''\n\n        @app.route('\/test\/')\n        def test():\n            messages = flask.get_flashed_messages()\n            self.assert_equal(len(messages), 3)\n            self.assert_equal(messages[0], u'Hello World')\n            self.assert_equal(messages[1], u'Hello World')\n            self.assert_equal(messages[2], flask.Markup(u'<em>Testing<\/em>'))\n            return ''\n\n        @app.route('\/test_with_categories\/')\n        def test_with_categories():\n            messages = flask.get_flashed_messages(with_categories=True)\n            self.assert_equal(len(messages), 3)\n            self.assert_equal(messages[0], ('message', u'Hello World'))\n            self.assert_equal(messages[1], ('error', u'Hello World'))\n            self.assert_equal(messages[2], ('warning', flask.Markup(u'<em>Testing<\/em>')))\n            return ''\n\n        @app.route('\/test_filter\/')\n        def test_filter():\n            messages = flask.get_flashed_messages(category_filter=['message'], with_categories=True)\n            self.assert_equal(len(messages), 1)\n            self.assert_equal(messages[0], ('message', u'Hello World'))\n            return ''\n\n        @app.route('\/test_filters\/')\n        def test_filters():\n            messages = flask.get_flashed_messages(category_filter=['message', 'warning'], with_categories=True)\n            self.assert_equal(len(messages), 2)\n            self.assert_equal(messages[0], ('message', u'Hello World'))\n            self.assert_equal(messages[1], ('warning', flask.Markup(u'<em>Testing<\/em>')))\n            return ''\n\n        @app.route('\/test_filters_without_returning_categories\/')\n        def test_filters2():\n            messages = flask.get_flashed_messages(category_filter=['message', 'warning'])\n            self.assert_equal(len(messages), 2)\n            self.assert_equal(messages[0], u'Hello World')\n            self.assert_equal(messages[1], flask.Markup(u'<em>Testing<\/em>'))\n            return ''\n\n        # Create new test client on each test to clean flashed messages.\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_with_categories\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_filter\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_filters\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_filters_without_returning_categories\/')\n\n    def test_request_processing(self):\n        app = flask.Flask(__name__)\n        evts = []\n        @app.before_request\n        def before_request():\n            evts.append('before')\n        @app.after_request\n        def after_request(response):\n            response.data += '|after'\n            evts.append('after')\n            return response\n        @app.route('\/')\n        def index():\n            self.assert_('before' in evts)\n            self.assert_('after' not in evts)\n            return 'request'\n        self.assert_('after' not in evts)\n        rv = app.test_client().get('\/').data\n        self.assert_('after' in evts)\n        self.assert_equal(rv, 'request|after')\n\n    def test_after_request_processing(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            @flask.after_this_request\n            def foo(response):\n                response.headers['X-Foo'] = 'a header'\n                return response\n            return 'Test'\n        c = app.test_client()\n        resp = c.get('\/')\n        self.assertEqual(resp.status_code, 200)\n        self.assertEqual(resp.headers['X-Foo'], 'a header')\n\n    def test_teardown_request_handler(self):\n        called = []\n        app = flask.Flask(__name__)\n        @app.teardown_request\n        def teardown_request(exc):\n            called.append(True)\n            return \"Ignored\"\n        @app.route('\/')\n        def root():\n            return \"Response\"\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_('Response' in rv.data)\n        self.assert_equal(len(called), 1)\n\n    def test_teardown_request_handler_debug_mode(self):\n        called = []\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.teardown_request\n        def teardown_request(exc):\n            called.append(True)\n            return \"Ignored\"\n        @app.route('\/')\n        def root():\n            return \"Response\"\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_('Response' in rv.data)\n        self.assert_equal(len(called), 1)\n\n    def test_teardown_request_handler_error(self):\n        called = []\n        app = flask.Flask(__name__)\n        @app.teardown_request\n        def teardown_request1(exc):\n            self.assert_equal(type(exc), ZeroDivisionError)\n            called.append(True)\n            # This raises a new error and blows away sys.exc_info(), so we can\n            # test that all teardown_requests get passed the same original\n            # exception.\n            try:\n                raise TypeError\n            except:\n                pass\n        @app.teardown_request\n        def teardown_request2(exc):\n            self.assert_equal(type(exc), ZeroDivisionError)\n            called.append(True)\n            # This raises a new error and blows away sys.exc_info(), so we can\n            # test that all teardown_requests get passed the same original\n            # exception.\n            try:\n                raise TypeError\n            except:\n                pass\n        @app.route('\/')\n        def fails():\n            1\/0\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_('Internal Server Error' in rv.data)\n        self.assert_equal(len(called), 2)\n\n    def test_before_after_request_order(self):\n        called = []\n        app = flask.Flask(__name__)\n        @app.before_request\n        def before1():\n            called.append(1)\n        @app.before_request\n        def before2():\n            called.append(2)\n        @app.after_request\n        def after1(response):\n            called.append(4)\n            return response\n        @app.after_request\n        def after2(response):\n            called.append(3)\n            return response\n        @app.teardown_request\n        def finish1(exc):\n            called.append(6)\n        @app.teardown_request\n        def finish2(exc):\n            called.append(5)\n        @app.route('\/')\n        def index():\n            return '42'\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, '42')\n        self.assert_equal(called, [1, 2, 3, 4, 5, 6])\n\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        @app.errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @app.errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @app.route('\/')\n        def index():\n            flask.abort(404)\n        @app.route('\/error')\n        def error():\n            1 \/\/ 0\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, 'not found')\n        rv = c.get('\/error')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_equal('internal server error', rv.data)\n\n    def test_before_request_and_routing_errors(self):\n        app = flask.Flask(__name__)\n        @app.before_request\n        def attach_something():\n            flask.g.something = 'value'\n        @app.errorhandler(404)\n        def return_something(error):\n            return flask.g.something, 404\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, 'value')\n\n    def test_user_error_handling(self):\n        class MyException(Exception):\n            pass\n\n        app = flask.Flask(__name__)\n        @app.errorhandler(MyException)\n        def handle_my_exception(e):\n            self.assert_(isinstance(e, MyException))\n            return '42'\n        @app.route('\/')\n        def index():\n            raise MyException()\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, '42')\n\n    def test_trapping_of_bad_request_key_errors(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/fail')\n        def fail():\n            flask.request.form['missing_key']\n        c = app.test_client()\n        self.assert_equal(c.get('\/fail').status_code, 400)\n\n        app.config['TRAP_BAD_REQUEST_ERRORS'] = True\n        c = app.test_client()\n        try:\n            c.get('\/fail')\n        except KeyError as e:\n            self.assert_(isinstance(e, BadRequest))\n        else:\n            self.fail('Expected exception')\n\n    def test_trapping_of_all_http_exceptions(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.config['TRAP_HTTP_EXCEPTIONS'] = True\n        @app.route('\/fail')\n        def fail():\n            flask.abort(404)\n\n        c = app.test_client()\n        try:\n            c.get('\/fail')\n        except NotFound as e:\n            pass\n        else:\n            self.fail('Expected exception')\n\n    def test_enctype_debug_helper(self):\n        from flask.debughelpers import DebugFilesKeyError\n        app = flask.Flask(__name__)\n        app.debug = True\n        @app.route('\/fail', methods=['POST'])\n        def index():\n            return flask.request.files['foo'].filename\n\n        # with statement is important because we leave an exception on the\n        # stack otherwise and we want to ensure that this is not the case\n        # to not negatively affect other tests.\n        with app.test_client() as c:\n            try:\n                c.post('\/fail', data={'foo': 'index.txt'})\n            except DebugFilesKeyError as e:\n                self.assert_('no file contents were transmitted' in str(e))\n                self.assert_('This was submitted: \"index.txt\"' in str(e))\n            else:\n                self.fail('Expected exception')\n\n    def test_response_creation(self):\n        app = flask.Flask(__name__)\n        @app.route('\/unicode')\n        def from_unicode():\n            return u'H\u00e4llo W\u00f6rld'\n        @app.route('\/string')\n        def from_string():\n            return u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n        @app.route('\/args')\n        def from_tuple():\n            return 'Meh', 400, {\n                'X-Foo': 'Testing',\n                'Content-Type': 'text\/plain; charset=utf-8'\n            }\n        c = app.test_client()\n        self.assert_equal(c.get('\/unicode').data, u'H\u00e4llo W\u00f6rld'.encode('utf-8'))\n        self.assert_equal(c.get('\/string').data, u'H\u00e4llo W\u00f6rld'.encode('utf-8'))\n        rv = c.get('\/args')\n        self.assert_equal(rv.data, 'Meh')\n        self.assert_equal(rv.headers['X-Foo'], 'Testing')\n        self.assert_equal(rv.status_code, 400)\n        self.assert_equal(rv.mimetype, 'text\/plain')\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.make_response()\n            self.assert_equal(rv.status_code, 200)\n            self.assert_equal(rv.data, '')\n            self.assert_equal(rv.mimetype, 'text\/html')\n\n            rv = flask.make_response('Awesome')\n            self.assert_equal(rv.status_code, 200)\n            self.assert_equal(rv.data, 'Awesome')\n            self.assert_equal(rv.mimetype, 'text\/html')\n\n            rv = flask.make_response('W00t', 404)\n            self.assert_equal(rv.status_code, 404)\n            self.assert_equal(rv.data, 'W00t')\n            self.assert_equal(rv.mimetype, 'text\/html')\n\n    def test_make_response_with_response_instance(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.make_response(\n                flask.jsonify({'msg': 'W00t'}), 400)\n            self.assertEqual(rv.status_code, 400)\n            self.assertEqual(rv.data,\n                             '{\\n  \"msg\": \"W00t\"\\n}')\n            self.assertEqual(rv.mimetype, 'application\/json')\n\n            rv = flask.make_response(\n                flask.Response(''), 400)\n            self.assertEqual(rv.status_code, 400)\n            self.assertEqual(rv.data, '')\n            self.assertEqual(rv.mimetype, 'text\/html')\n\n            rv = flask.make_response(\n                flask.Response('', headers={'Content-Type': 'text\/html'}),\n                400, [('X-Foo', 'bar')])\n            self.assertEqual(rv.status_code, 400)\n            self.assertEqual(rv.headers['Content-Type'], 'text\/html')\n            self.assertEqual(rv.headers['X-Foo'], 'bar')\n\n    def test_url_generation(self):\n        app = flask.Flask(__name__)\n        @app.route('\/hello\/<name>', methods=['POST'])\n        def hello():\n            pass\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('hello', name='test x'), '\/hello\/test%20x')\n            self.assert_equal(flask.url_for('hello', name='test x', _external=True),\n                              'http:\/\/localhost\/hello\/test%20x')\n\n    def test_build_error_handler(self):\n        app = flask.Flask(__name__)\n\n        # Test base case, a URL which results in a BuildError.\n        with app.test_request_context():\n            self.assertRaises(BuildError, flask.url_for, 'spam')\n\n        # Verify the error is re-raised if not the current exception.\n        try:\n            with app.test_request_context():\n                flask.url_for('spam')\n        except BuildError as error:\n            pass\n        try:\n            raise RuntimeError('Test case where BuildError is not current.')\n        except RuntimeError:\n            self.assertRaises(BuildError, app.handle_url_build_error, error, 'spam', {})\n\n        # Test a custom handler.\n        def handler(error, endpoint, values):\n            # Just a test.\n            return '\/test_handler\/'\n        app.url_build_error_handlers.append(handler)\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('spam'), '\/test_handler\/')\n\n    def test_custom_converters(self):\n        from werkzeug.routing import BaseConverter\n        class ListConverter(BaseConverter):\n            def to_python(self, value):\n                return value.split(',')\n            def to_url(self, value):\n                base_to_url = super(ListConverter, self).to_url\n                return ','.join(base_to_url(x) for x in value)\n        app = flask.Flask(__name__)\n        app.url_map.converters['list'] = ListConverter\n        @app.route('\/<list:args>')\n        def index(args):\n            return '|'.join(args)\n        c = app.test_client()\n        self.assert_equal(c.get('\/1,2,3').data, '1|2|3')\n\n    def test_static_files(self):\n        app = flask.Flask(__name__)\n        rv = app.test_client().get('\/static\/index.html')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_equal(rv.data.strip(), '<h1>Hello World!<\/h1>')\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('static', filename='index.html'),\n                              '\/static\/index.html')\n\n    def test_none_response(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def test():\n            return None\n        try:\n            app.test_client().get('\/')\n        except ValueError as e:\n            self.assert_equal(str(e), 'View function did not return a response')\n            pass\n        else:\n            self.assert_(\"Expected ValueError\")\n\n    def test_request_locals(self):\n        self.assert_equal(repr(flask.g), '<LocalProxy unbound>')\n        self.assertFalse(flask.g)\n\n    def test_test_app_proper_environ(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SERVER_NAME='localhost.localdomain:5000'\n        )\n        @app.route('\/')\n        def index():\n            return 'Foo'\n\n        @app.route('\/', subdomain='foo')\n        def subdomain():\n            return 'Foo SubDomain'\n\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'Foo')\n\n        rv = app.test_client().get('\/', 'http:\/\/localhost.localdomain:5000')\n        self.assert_equal(rv.data, 'Foo')\n\n        rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain:5000')\n        self.assert_equal(rv.data, 'Foo')\n\n        app.config.update(SERVER_NAME='localhost.localdomain')\n        rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain')\n        self.assert_equal(rv.data, 'Foo')\n\n        try:\n            app.config.update(SERVER_NAME='localhost.localdomain:443')\n            rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain')\n            # Werkzeug 0.8\n            self.assert_equal(rv.status_code, 404)\n        except ValueError as e:\n            # Werkzeug 0.7\n            self.assert_equal(str(e), \"the server name provided \" +\n                    \"('localhost.localdomain:443') does not match the \" + \\\n                    \"server name from the WSGI environment ('localhost.localdomain')\")\n\n        try:\n            app.config.update(SERVER_NAME='localhost.localdomain')\n            rv = app.test_client().get('\/', 'http:\/\/foo.localhost')\n            # Werkzeug 0.8\n            self.assert_equal(rv.status_code, 404)\n        except ValueError as e:\n            # Werkzeug 0.7\n            self.assert_equal(str(e), \"the server name provided \" + \\\n                    \"('localhost.localdomain') does not match the \" + \\\n                    \"server name from the WSGI environment ('foo.localhost')\")\n\n        rv = app.test_client().get('\/', 'http:\/\/foo.localhost.localdomain')\n        self.assert_equal(rv.data, 'Foo SubDomain')\n\n    def test_exception_propagation(self):\n        def apprunner(configkey):\n            app = flask.Flask(__name__)\n            @app.route('\/')\n            def index():\n                1\/0\n            c = app.test_client()\n            if config_key is not None:\n                app.config[config_key] = True\n                try:\n                    resp = c.get('\/')\n                except Exception:\n                    pass\n                else:\n                    self.fail('expected exception')\n            else:\n                self.assert_equal(c.get('\/').status_code, 500)\n\n        # we have to run this test in an isolated thread because if the\n        # debug flag is set to true and an exception happens the context is\n        # not torn down.  This causes other tests that run after this fail\n        # when they expect no exception on the stack.\n        for config_key in 'TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', None:\n            t = Thread(target=apprunner, args=(config_key,))\n            t.start()\n            t.join()\n\n    def test_max_content_length(self):\n        app = flask.Flask(__name__)\n        app.config['MAX_CONTENT_LENGTH'] = 64\n        @app.before_request\n        def always_first():\n            flask.request.form['myfile']\n            self.assert_(False)\n        @app.route('\/accept', methods=['POST'])\n        def accept_file():\n            flask.request.form['myfile']\n            self.assert_(False)\n        @app.errorhandler(413)\n        def catcher(error):\n            return '42'\n\n        c = app.test_client()\n        rv = c.post('\/accept', data={'myfile': 'foo' * 100})\n        self.assert_equal(rv.data, '42')\n\n    def test_url_processors(self):\n        app = flask.Flask(__name__)\n\n        @app.url_defaults\n        def add_language_code(endpoint, values):\n            if flask.g.lang_code is not None and \\\n               app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n                values.setdefault('lang_code', flask.g.lang_code)\n\n        @app.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop('lang_code', None)\n\n        @app.route('\/<lang_code>\/')\n        def index():\n            return flask.url_for('about')\n\n        @app.route('\/<lang_code>\/about')\n        def about():\n            return flask.url_for('something_else')\n\n        @app.route('\/foo')\n        def something_else():\n            return flask.url_for('about', lang_code='en')\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/de\/').data, '\/de\/about')\n        self.assert_equal(c.get('\/de\/about').data, '\/foo')\n        self.assert_equal(c.get('\/foo').data, '\/en\/about')\n        \n    def test_inject_blueprint_url_defaults(self):\n        app = flask.Flask(__name__)\n        bp = flask.Blueprint('foo.bar.baz', __name__, \n                       template_folder='template')\n\n        @bp.url_defaults\n        def bp_defaults(endpoint, values):\n            values['page'] = 'login'\n        @bp.route('\/<page>')\n        def view(page): pass\n\n        app.register_blueprint(bp)\n\n        values = dict()\n        app.inject_url_defaults('foo.bar.baz.view', values)\n        expected = dict(page='login')\n        self.assert_equal(values, expected)\n\n        with app.test_request_context('\/somepage'):\n            url = flask.url_for('foo.bar.baz.view')\n        expected = '\/login'\n        self.assert_equal(url, expected)\n\n    def test_debug_mode_complains_after_first_request(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        @app.route('\/')\n        def index():\n            return 'Awesome'\n        self.assert_(not app.got_first_request)\n        self.assert_equal(app.test_client().get('\/').data, 'Awesome')\n        try:\n            @app.route('\/foo')\n            def broken():\n                return 'Meh'\n        except AssertionError as e:\n            self.assert_('A setup function was called' in str(e))\n        else:\n            self.fail('Expected exception')\n\n        app.debug = False\n        @app.route('\/foo')\n        def working():\n            return 'Meh'\n        self.assert_equal(app.test_client().get('\/foo').data, 'Meh')\n        self.assert_(app.got_first_request)\n\n    def test_before_first_request_functions(self):\n        got = []\n        app = flask.Flask(__name__)\n        @app.before_first_request\n        def foo():\n            got.append(42)\n        c = app.test_client()\n        c.get('\/')\n        self.assert_equal(got, [42])\n        c.get('\/')\n        self.assert_equal(got, [42])\n        self.assert_(app.got_first_request)\n\n    def test_routing_redirect_debugging(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        @app.route('\/foo\/', methods=['GET', 'POST'])\n        def foo():\n            return 'success'\n        with app.test_client() as c:\n            try:\n                c.post('\/foo', data={})\n            except AssertionError as e:\n                self.assert_('http:\/\/localhost\/foo\/' in str(e))\n                self.assert_('Make sure to directly send your POST-request '\n                             'to this URL' in str(e))\n            else:\n                self.fail('Expected exception')\n\n            rv = c.get('\/foo', data={}, follow_redirects=True)\n            self.assert_equal(rv.data, 'success')\n\n        app.debug = False\n        with app.test_client() as c:\n            rv = c.post('\/foo', data={}, follow_redirects=True)\n            self.assert_equal(rv.data, 'success')\n\n    def test_route_decorator_custom_endpoint(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        @app.route('\/foo\/')\n        def foo():\n            return flask.request.endpoint\n\n        @app.route('\/bar\/', endpoint='bar')\n        def for_bar():\n            return flask.request.endpoint\n\n        @app.route('\/bar\/123', endpoint='123')\n        def for_bar_foo():\n            return flask.request.endpoint\n\n        with app.test_request_context():\n            assert flask.url_for('foo') == '\/foo\/'\n            assert flask.url_for('bar') == '\/bar\/'\n            assert flask.url_for('123') == '\/bar\/123'\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/foo\/').data, 'foo')\n        self.assertEqual(c.get('\/bar\/').data, 'bar')\n        self.assertEqual(c.get('\/bar\/123').data, '123')\n\n    def test_preserve_only_once(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        @app.route('\/fail')\n        def fail_func():\n            1\/0\n\n        c = app.test_client()\n        for x in range(3):\n            with self.assert_raises(ZeroDivisionError):\n                c.get('\/fail')\n\n        self.assert_(flask._request_ctx_stack.top is not None)\n        self.assert_(flask._app_ctx_stack.top is not None)\n        # implicit appctx disappears too\n        flask._request_ctx_stack.top.pop()\n        self.assert_(flask._request_ctx_stack.top is None)\n        self.assert_(flask._app_ctx_stack.top is None)\n\n\nclass SubdomainTestCase(FlaskTestCase):\n\n    def test_basic_support(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'localhost'\n        @app.route('\/')\n        def normal_index():\n            return 'normal index'\n        @app.route('\/', subdomain='test')\n        def test_index():\n            return 'test index'\n\n        c = app.test_client()\n        rv = c.get('\/', 'http:\/\/localhost\/')\n        self.assert_equal(rv.data, 'normal index')\n\n        rv = c.get('\/', 'http:\/\/test.localhost\/')\n        self.assert_equal(rv.data, 'test index')\n\n    @emits_module_deprecation_warning\n    def test_module_static_path_subdomain(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'example.com'\n        from subdomaintestmodule import mod\n        app.register_module(mod)\n        c = app.test_client()\n        rv = c.get('\/static\/hello.txt', 'http:\/\/foo.example.com\/')\n        self.assert_equal(rv.data.strip(), 'Hello Subdomain')\n\n    def test_subdomain_matching(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'localhost'\n        @app.route('\/', subdomain='<user>')\n        def index(user):\n            return 'index for %s' % user\n\n        c = app.test_client()\n        rv = c.get('\/', 'http:\/\/mitsuhiko.localhost\/')\n        self.assert_equal(rv.data, 'index for mitsuhiko')\n\n    def test_subdomain_matching_with_ports(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'localhost:3000'\n        @app.route('\/', subdomain='<user>')\n        def index(user):\n            return 'index for %s' % user\n\n        c = app.test_client()\n        rv = c.get('\/', 'http:\/\/mitsuhiko.localhost:3000\/')\n        self.assert_equal(rv.data, 'index for mitsuhiko')\n\n    @emits_module_deprecation_warning\n    def test_module_subdomain_support(self):\n        app = flask.Flask(__name__)\n        mod = flask.Module(__name__, 'test', subdomain='testing')\n        app.config['SERVER_NAME'] = 'localhost'\n\n        @mod.route('\/test')\n        def test():\n            return 'Test'\n\n        @mod.route('\/outside', subdomain='xtesting')\n        def bar():\n            return 'Outside'\n\n        app.register_module(mod)\n\n        c = app.test_client()\n        rv = c.get('\/test', 'http:\/\/testing.localhost\/')\n        self.assert_equal(rv.data, 'Test')\n        rv = c.get('\/outside', 'http:\/\/xtesting.localhost\/')\n        self.assert_equal(rv.data, 'Outside')\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))\n    suite.addTest(unittest.makeSuite(SubdomainTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.blueprints\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Blueprints (and currently modules)\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nimport warnings\nfrom flask.testsuite import FlaskTestCase, emits_module_deprecation_warning\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_cache_control_header\nfrom jinja2 import TemplateNotFound\nimport six\n\n\n# import moduleapp here because it uses deprecated features and we don't\n# want to see the warnings\nwarnings.simplefilter('ignore', DeprecationWarning)\nfrom moduleapp import app as moduleapp\nwarnings.simplefilter('default', DeprecationWarning)\n\n\nclass ModuleTestCase(FlaskTestCase):\n\n    @emits_module_deprecation_warning\n    def test_basic_module(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.route('\/')\n        def admin_index():\n            return 'admin index'\n        @admin.route('\/login')\n        def admin_login():\n            return 'admin login'\n        @admin.route('\/logout')\n        def admin_logout():\n            return 'admin logout'\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, 'the index')\n        self.assert_equal(c.get('\/admin\/').data, 'admin index')\n        self.assert_equal(c.get('\/admin\/login').data, 'admin login')\n        self.assert_equal(c.get('\/admin\/logout').data, 'admin logout')\n\n    @emits_module_deprecation_warning\n    def test_default_endpoint_name(self):\n        app = flask.Flask(__name__)\n        mod = flask.Module(__name__, 'frontend')\n        def index():\n            return 'Awesome'\n        mod.add_url_rule('\/', view_func=index)\n        app.register_module(mod)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'Awesome')\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('frontend.index'), '\/')\n\n    @emits_module_deprecation_warning\n    def test_request_processing(self):\n        catched = []\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.before_request\n        def before_admin_request():\n            catched.append('before-admin')\n        @admin.after_request\n        def after_admin_request(response):\n            catched.append('after-admin')\n            return response\n        @admin.route('\/')\n        def admin_index():\n            return 'the admin'\n        @app.before_request\n        def before_request():\n            catched.append('before-app')\n        @app.after_request\n        def after_request(response):\n            catched.append('after-app')\n            return response\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/').data, 'the index')\n        self.assert_equal(catched, ['before-app', 'after-app'])\n        del catched[:]\n\n        self.assert_equal(c.get('\/admin\/').data, 'the admin')\n        self.assert_equal(catched, ['before-app', 'before-admin',\n                           'after-admin', 'after-app'])\n\n    @emits_module_deprecation_warning\n    def test_context_processors(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @app.context_processor\n        def inject_all_regualr():\n            return {'a': 1}\n        @admin.context_processor\n        def inject_admin():\n            return {'b': 2}\n        @admin.app_context_processor\n        def inject_all_module():\n            return {'c': 3}\n        @app.route('\/')\n        def index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        @admin.route('\/')\n        def admin_index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, '13')\n        self.assert_equal(c.get('\/admin\/').data, '123')\n\n    @emits_module_deprecation_warning\n    def test_late_binding(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.route('\/')\n        def index():\n            return '42'\n        app.register_module(admin, url_prefix='\/admin')\n        self.assert_equal(app.test_client().get('\/admin\/').data, '42')\n\n    @emits_module_deprecation_warning\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.app_errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @admin.app_errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @admin.route('\/')\n        def index():\n            flask.abort(404)\n        @admin.route('\/error')\n        def error():\n            1 \/\/ 0\n        app.register_module(admin)\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, 'not found')\n        rv = c.get('\/error')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_equal('internal server error', rv.data)\n\n    def test_templates_and_static(self):\n        app = moduleapp\n        app.testing = True\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, 'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), 'Admin File')\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), '\/* nested file *\/')\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_safe_access(self):\n        app = moduleapp\n\n        with app.test_request_context():\n            f = app.view_functions['admin.static']\n\n            try:\n                f('\/etc\/passwd')\n            except NotFound:\n                pass\n            else:\n                self.assert_(0, 'expected exception')\n            try:\n                f('..\/__init__.py')\n            except NotFound:\n                pass\n            else:\n                self.assert_(0, 'expected exception')\n\n            # testcase for a security issue that may exist on windows systems\n            import os\n            import ntpath\n            old_path = os.path\n            os.path = ntpath\n            try:\n                try:\n                    f('..\\\\__init__.py')\n                except NotFound:\n                    pass\n                else:\n                    self.assert_(0, 'expected exception')\n            finally:\n                os.path = old_path\n\n    @emits_module_deprecation_warning\n    def test_endpoint_decorator(self):\n        from werkzeug.routing import Submount, Rule\n        from flask import Module\n\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n        module = Module(__name__, __name__)\n\n        @module.endpoint('bar')\n        def bar():\n            return 'bar'\n\n        @module.endpoint('index')\n        def index():\n            return 'index'\n\n        app.register_module(module)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, 'index')\n        self.assert_equal(c.get('\/foo\/bar').data, 'bar')\n\n\nclass BlueprintTestCase(FlaskTestCase):\n\n    def test_blueprint_specific_error_handling(self):\n        frontend = flask.Blueprint('frontend', __name__)\n        backend = flask.Blueprint('backend', __name__)\n        sideend = flask.Blueprint('sideend', __name__)\n\n        @frontend.errorhandler(403)\n        def frontend_forbidden(e):\n            return 'frontend says no', 403\n\n        @frontend.route('\/frontend-no')\n        def frontend_no():\n            flask.abort(403)\n\n        @backend.errorhandler(403)\n        def backend_forbidden(e):\n            return 'backend says no', 403\n\n        @backend.route('\/backend-no')\n        def backend_no():\n            flask.abort(403)\n\n        @sideend.route('\/what-is-a-sideend')\n        def sideend_no():\n            flask.abort(403)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n        app.register_blueprint(sideend)\n\n        @app.errorhandler(403)\n        def app_forbidden(e):\n            return 'application itself says no', 403\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/frontend-no').data, 'frontend says no')\n        self.assert_equal(c.get('\/backend-no').data, 'backend says no')\n        self.assert_equal(c.get('\/what-is-a-sideend').data, 'application itself says no')\n\n    def test_blueprint_url_definitions(self):\n        bp = flask.Blueprint('test', __name__)\n\n        @bp.route('\/foo', defaults={'baz': 42})\n        def foo(bar, baz):\n            return '%s\/%d' % (bar, baz)\n\n        @bp.route('\/bar')\n        def bar(bar):\n            return six.text_type(bar)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/1', url_defaults={'bar': 23})\n        app.register_blueprint(bp, url_prefix='\/2', url_defaults={'bar': 19})\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/1\/foo').data, u'23\/42')\n        self.assert_equal(c.get('\/2\/foo').data, u'19\/42')\n        self.assert_equal(c.get('\/1\/bar').data, u'23')\n        self.assert_equal(c.get('\/2\/bar').data, u'19')\n\n    def test_blueprint_url_processors(self):\n        bp = flask.Blueprint('frontend', __name__, url_prefix='\/<lang_code>')\n\n        @bp.url_defaults\n        def add_language_code(endpoint, values):\n            values.setdefault('lang_code', flask.g.lang_code)\n\n        @bp.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop('lang_code')\n\n        @bp.route('\/')\n        def index():\n            return flask.url_for('.about')\n\n        @bp.route('\/about')\n        def about():\n            return flask.url_for('.index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/de\/').data, '\/de\/about')\n        self.assert_equal(c.get('\/de\/about').data, '\/de\/')\n\n    def test_templates_and_static(self):\n        from blueprintapp import app\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, 'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), 'Admin File')\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), '\/* nested file *\/')\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            expected_max_age = 3600\n            if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == expected_max_age:\n                expected_max_age = 7200\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = expected_max_age\n            rv = c.get('\/admin\/static\/css\/test.css')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, expected_max_age)\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_default_static_cache_timeout(self):\n        app = flask.Flask(__name__)\n        class MyBlueprint(flask.Blueprint):\n            def get_send_file_max_age(self, filename):\n                return 100\n\n        blueprint = MyBlueprint('blueprint', __name__, static_folder='static')\n        app.register_blueprint(blueprint)\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            with app.test_request_context():\n                unexpected_max_age = 3600\n                if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == unexpected_max_age:\n                    unexpected_max_age = 7200\n                app.config['SEND_FILE_MAX_AGE_DEFAULT'] = unexpected_max_age\n                rv = blueprint.send_static_file('index.html')\n                cc = parse_cache_control_header(rv.headers['Cache-Control'])\n                self.assert_equal(cc.max_age, 100)\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n    def test_templates_list(self):\n        from blueprintapp import app\n        templates = sorted(app.jinja_env.list_templates())\n        self.assert_equal(templates, ['admin\/index.html',\n                                     'frontend\/index.html'])\n\n    def test_dotted_names(self):\n        frontend = flask.Blueprint('myapp.frontend', __name__)\n        backend = flask.Blueprint('myapp.backend', __name__)\n\n        @frontend.route('\/fe')\n        def frontend_index():\n            return flask.url_for('myapp.backend.backend_index')\n\n        @frontend.route('\/fe2')\n        def frontend_page2():\n            return flask.url_for('.frontend_index')\n\n        @backend.route('\/be')\n        def backend_index():\n            return flask.url_for('myapp.frontend.frontend_index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/fe').data.strip(), '\/be')\n        self.assert_equal(c.get('\/fe2').data.strip(), '\/fe')\n        self.assert_equal(c.get('\/be').data.strip(), '\/fe')\n\n    def test_empty_url_defaults(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/', defaults={'page': 1})\n        @bp.route('\/page\/<int:page>')\n        def something(page):\n            return str(page)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, '1')\n        self.assert_equal(c.get('\/page\/2').data, '2')\n\n    def test_route_decorator_custom_endpoint(self):\n\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar', endpoint='bar')\n        def foo_bar():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/123', endpoint='123')\n        def foo_bar_foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/foo')\n        def bar_foo():\n            return flask.request.endpoint\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        @app.route('\/')\n        def index():\n            return flask.request.endpoint\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/').data, 'index')\n        self.assertEqual(c.get('\/py\/foo').data, 'bp.foo')\n        self.assertEqual(c.get('\/py\/bar').data, 'bp.bar')\n        self.assertEqual(c.get('\/py\/bar\/123').data, 'bp.123')\n        self.assertEqual(c.get('\/py\/bar\/foo').data, 'bp.bar_foo')\n\n    def test_route_decorator_custom_endpoint_with_dots(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        try:\n            @bp.route('\/bar', endpoint='bar.bar')\n            def foo_bar():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        try:\n            @bp.route('\/bar\/123', endpoint='bar.123')\n            def foo_bar_foo():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        def foo_foo_foo():\n            pass\n\n        self.assertRaises(\n            AssertionError,\n            lambda: bp.add_url_rule(\n                '\/bar\/123', endpoint='bar.123', view_func=foo_foo_foo\n            )\n        )\n\n        self.assertRaises(\n            AssertionError,\n            bp.route('\/bar\/123', endpoint='bar.123'),\n            lambda: None\n        )\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/py\/foo').data, 'bp.foo')\n        # The rule's din't actually made it through\n        rv = c.get('\/py\/bar')\n        assert rv.status_code == 404\n        rv = c.get('\/py\/bar\/123')\n        assert rv.status_code == 404\n\n    def test_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('my_reverse' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_add_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('my_reverse' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('strrev')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('strrev' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_add_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'strrev')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('strrev' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_template_filter_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_add_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def super_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(super_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('super_reverse')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_add_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'super_reverse')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('is_boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['is_boolean'](False))\n\n    def test_add_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('is_boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['is_boolean'](False))\n\n    def test_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_template_test_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_add_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_add_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(BlueprintTestCase))\n    suite.addTest(unittest.makeSuite(ModuleTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.app\n    ~~~~~~~~~\n\n    This module implements the central WSGI application object.\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nfrom threading import Lock\nfrom datetime import timedelta\nfrom itertools import chain\nfrom functools import update_wrapper\n\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.routing import Map, Rule, RequestRedirect, BuildError\nfrom werkzeug.exceptions import HTTPException, InternalServerError, \\\n     MethodNotAllowed, BadRequest\n\nfrom .helpers import _PackageBoundObject, url_for, get_flashed_messages, \\\n    locked_cached_property, _endpoint_from_view_func, find_package\nfrom . import json\nfrom .wrappers import Request, Response\nfrom .config import ConfigAttribute, Config\nfrom .ctx import RequestContext, AppContext, _AppCtxGlobals\nfrom .globals import _request_ctx_stack, request, session, g\nfrom .sessions import SecureCookieSessionInterface\nfrom .module import blueprint_is_module\nfrom .templating import DispatchingJinjaLoader, Environment, \\\n    _default_template_ctx_processor\nfrom .signals import request_started, request_finished, got_request_exception, \\\n    request_tearing_down, appcontext_tearing_down\nfrom flask._compat import reraise, string_types, integer_types\n\n# a lock used for logger initialization\n_logger_lock = Lock()\n\n\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\n\n\ndef setupmethod(f):\n    \"\"\"Wraps a method so that it performs a check in debug mode if the\n    first request was already handled.\n    \"\"\"\n    def wrapper_func(self, *args, **kwargs):\n        if self.debug and self._got_first_request:\n            raise AssertionError('A setup function was called after the '\n                'first request was handled.  This usually indicates a bug '\n                'in the application where a module was not imported '\n                'and decorators or other functionality was called too late.\\n'\n                'To fix this make sure to import all your view modules, '\n                'database models and everything related at a central place '\n                'before the application starts serving requests.')\n        return f(self, *args, **kwargs)\n    return update_wrapper(wrapper_func, f)\n\n\nclass Flask(_PackageBoundObject):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an `__init__.py` file inside) or a standard module (just a `.py` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the `__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea what\n        belongs to your application.  This name is used to find resources\n        on the file system, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in `yourapplication\/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: the folder with static files that should be served\n                          at `static_url_path`.  Defaults to the ``'static'``\n                          folder in the root path of the application.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to `True` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    \"\"\"\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class = Response\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on expected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is not application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    # Backwards compatibility support\n    def _get_request_globals_class(self):\n        return self.app_ctx_globals_class\n    def _set_request_globals_class(self, value):\n        from warnings import warn\n        warn(DeprecationWarning('request_globals_class attribute is now '\n                                'called app_ctx_globals_class'))\n        self.app_ctx_globals_class = value\n    request_globals_class = property(_get_request_globals_class,\n                                     _set_request_globals_class)\n    del _get_request_globals_class, _set_request_globals_class\n\n    #: The debug flag.  Set this to `True` to enable debugging of the\n    #: application.  In debug mode the debugger will kick in when an unhandled\n    #: exception ocurrs and the integrated server will automatically reload\n    #: the application if changes in the code are detected.\n    #:\n    #: This attribute can also be configured from the config with the `DEBUG`\n    #: configuration key.  Defaults to `False`.\n    debug = ConfigAttribute('DEBUG')\n\n    #: The testing flag.  Set this to `True` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate unittest helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `TESTING` configuration key.  Defaults to `False`.\n    testing = ConfigAttribute('TESTING')\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and other things.  Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `SECRET_KEY` configuration key.  Defaults to `None`.\n    secret_key = ConfigAttribute('SECRET_KEY')\n\n    #: The secure cookie uses this for the name of the session cookie.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `SESSION_COOKIE_NAME` configuration key.  Defaults to ``'session'``\n    session_cookie_name = ConfigAttribute('SESSION_COOKIE_NAME')\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `PERMANENT_SESSION_LIFETIME` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute('PERMANENT_SESSION_LIFETIME',\n        get_converter=_make_timedelta)\n\n    #: Enable this if you want to use the X-Sendfile feature.  Keep in\n    #: mind that the server has to support this.  This only affects files\n    #: sent with the :func:`send_file` method.\n    #:\n    #: .. versionadded:: 0.2\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `USE_X_SENDFILE` configuration key.  Defaults to `False`.\n    use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')\n\n    #: The name of the logger to use.  By default the logger name is the\n    #: package name passed to the constructor.\n    #:\n    #: .. versionadded:: 0.4\n    logger_name = ConfigAttribute('LOGGER_NAME')\n\n    #: Enable the deprecated module support?  This is active by default\n    #: in 0.7 but will be changed to False in 0.8.  With Flask 1.0 modules\n    #: will be removed in favor of Blueprints\n    enable_modules = True\n\n    #: The logging format used for the debug logger.  This is only used when\n    #: the application is in debug mode, otherwise the attached logging\n    #: handler does the formatting.\n    #:\n    #: .. versionadded:: 0.3\n    debug_log_format = (\n        '-' * 80 + '\\n' +\n        '%(levelname)s in %(module)s [%(pathname)s:%(lineno)d]:\\n' +\n        '%(message)s\\n' +\n        '-' * 80\n    )\n\n    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_encoder = json.JSONEncoder\n\n    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_decoder = json.JSONDecoder\n\n    #: Options that are passed directly to the Jinja2 environment.\n    jinja_options = ImmutableDict(\n        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']\n    )\n\n    #: Default configuration parameters.\n    default_config = ImmutableDict({\n        'DEBUG':                                False,\n        'TESTING':                              False,\n        'PROPAGATE_EXCEPTIONS':                 None,\n        'PRESERVE_CONTEXT_ON_EXCEPTION':        None,\n        'SECRET_KEY':                           None,\n        'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n        'USE_X_SENDFILE':                       False,\n        'LOGGER_NAME':                          None,\n        'SERVER_NAME':                          None,\n        'APPLICATION_ROOT':                     None,\n        'SESSION_COOKIE_NAME':                  'session',\n        'SESSION_COOKIE_DOMAIN':                None,\n        'SESSION_COOKIE_PATH':                  None,\n        'SESSION_COOKIE_HTTPONLY':              True,\n        'SESSION_COOKIE_SECURE':                False,\n        'MAX_CONTENT_LENGTH':                   None,\n        'SEND_FILE_MAX_AGE_DEFAULT':            12 * 60 * 60, # 12 hours\n        'TRAP_BAD_REQUEST_ERRORS':              False,\n        'TRAP_HTTP_EXCEPTIONS':                 False,\n        'PREFERRED_URL_SCHEME':                 'http',\n        'JSON_AS_ASCII':                        True\n    })\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: the test client that is used with when `test_client` is used.\n    #:\n    #: .. versionadded:: 0.7\n    test_client_class = None\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface = SecureCookieSessionInterface()\n\n    def __init__(self, import_name, static_path=None, static_url_path=None,\n                 static_folder='static', template_folder='templates',\n                 instance_path=None, instance_relative_config=False):\n        _PackageBoundObject.__init__(self, import_name,\n                                     template_folder=template_folder)\n        if static_path is not None:\n            from warnings import warn\n            warn(DeprecationWarning('static_path is now called '\n                                    'static_url_path'), stacklevel=2)\n            static_url_path = static_path\n\n        if static_url_path is not None:\n            self.static_url_path = static_url_path\n        if static_folder is not None:\n            self.static_folder = static_folder\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError('If an instance path is provided it must be '\n                             'absolute.  A relative path was given instead.')\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        # Prepare the deferred setup of the logger.\n        self._logger = None\n        self.logger_name = self.import_name\n\n        #: A dictionary of all view functions registered.  The keys will\n        #: be function names which are also used to generate URLs and\n        #: the values are the function objects themselves.\n        #: To register a view function, use the :meth:`route` decorator.\n        self.view_functions = {}\n\n        # support for the now deprecated `error_handlers` attribute.  The\n        # :attr:`error_handler_spec` shall be used now.\n        self._error_handlers = {}\n\n        #: A dictionary of all registered error handlers.  The key is `None`\n        #: for error handlers active on the application, otherwise the key is\n        #: the name of the blueprint.  Each key points to another dictionary\n        #: where they key is the status code of the http exception.  The\n        #: special key `None` points to a list of tuples where the first item\n        #: is the class for the instance check and the second the error handler\n        #: function.\n        #:\n        #: To register a error handler, use the :meth:`errorhandler`\n        #: decorator.\n        self.error_handler_spec = {None: self._error_handlers}\n\n        #: A list of functions that are called when :meth:`url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n        #: is called with `error`, `endpoint` and `values`.  If a function\n        #: returns `None` or raises a `BuildError` the next function is\n        #: tried.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers = []\n\n        #: A dictionary with lists of functions that should be called at the\n        #: beginning of the request.  The key of the dictionary is the name of\n        #: the blueprint this function is active for, `None` for all requests.\n        #: This can for example be used to open database connections or\n        #: getting hold of the currently logged in user.  To register a\n        #: function here, use the :meth:`before_request` decorator.\n        self.before_request_funcs = {}\n\n        #: A lists of functions that should be called at the beginning of the\n        #: first request to this instance.  To register a function here, use\n        #: the :meth:`before_first_request` decorator.\n        #:\n        #: .. versionadded:: 0.8\n        self.before_first_request_funcs = []\n\n        #: A dictionary with lists of functions that should be called after\n        #: each request.  The key of the dictionary is the name of the blueprint\n        #: this function is active for, `None` for all requests.  This can for\n        #: example be used to open database connections or getting hold of the\n        #: currently logged in user.  To register a function here, use the\n        #: :meth:`after_request` decorator.\n        self.after_request_funcs = {}\n\n        #: A dictionary with lists of functions that are called after\n        #: each request, even if an exception has occurred. The key of the\n        #: dictionary is the name of the blueprint this function is active for,\n        #: `None` for all requests. These functions are not allowed to modify\n        #: the request, and their return values are ignored. If an exception\n        #: occurred while processing the request, it gets passed to each\n        #: teardown_request function. To register a function here, use the\n        #: :meth:`teardown_request` decorator.\n        #:\n        #: .. versionadded:: 0.7\n        self.teardown_request_funcs = {}\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs = []\n\n        #: A dictionary with lists of functions that can be used as URL\n        #: value processor functions.  Whenever a URL is built these functions\n        #: are called to modify the dictionary of values in place.  The key\n        #: `None` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #:\n        #: .. versionadded:: 0.7\n        self.url_value_preprocessors = {}\n\n        #: A dictionary with lists of functions that can be used as URL value\n        #: preprocessors.  The key `None` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #: of URL values before they are used as the keyword arguments of the\n        #: view function.  For each function registered this one should also\n        #: provide a :meth:`url_defaults` function that adds the parameters\n        #: automatically again that were removed that way.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_default_functions = {}\n\n        #: A dictionary with list of functions that are called without argument\n        #: to populate the template context.  The key of the dictionary is the\n        #: name of the blueprint this function is active for, `None` for all\n        #: requests.  Each returns a dictionary that the template context is\n        #: updated with.  To register a function here, use the\n        #: :meth:`context_processor` decorator.\n        self.template_context_processors = {\n            None: [_default_template_ctx_processor]\n        }\n\n        #: all the attached blueprints in a directory by name.  Blueprints\n        #: can be attached multiple times so this dictionary does not tell\n        #: you how often they got attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.  For backwards compatibility extensions should register\n        #: themselves like this::\n        #:\n        #:      if not hasattr(app, 'extensions'):\n        #:          app.extensions = {}\n        #:      app.extensions['extensionname'] = SomeObject()\n        #:\n        #: The key must match the name of the `flaskext` module.  For example in\n        #: case of a \"Flask-Foo\" extension in `flaskext.foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(BaseConverter.to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = Map()\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n\n        # register the static folder for the application.  Do that even\n        # if the folder does not exist.  First of all it might be created\n        # while the server is running (usually happens during development)\n        # but also because google appengine stores static files somewhere\n        # else when mapped with the .yml file.\n        if self.has_static_folder:\n            self.add_url_rule(self.static_url_path + '\/<path:filename>',\n                              endpoint='static',\n                              view_func=self.send_static_file)\n\n    def _get_error_handlers(self):\n        from warnings import warn\n        warn(DeprecationWarning('error_handlers is deprecated, use the '\n            'new error_handler_spec attribute instead.'), stacklevel=1)\n        return self._error_handlers\n    def _set_error_handlers(self, value):\n        self._error_handlers = value\n        self.error_handler_spec[None] = value\n    error_handlers = property(_get_error_handlers, _set_error_handlers)\n    del _get_error_handlers, _set_error_handlers\n\n    @locked_cached_property\n    def name(self):\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overriden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == '__main__':\n            fn = getattr(sys.modules['__main__'], '__file__', None)\n            if fn is None:\n                return '__main__'\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @property\n    def propagate_exceptions(self):\n        \"\"\"Returns the value of the `PROPAGATE_EXCEPTIONS` configuration\n        value in case it's set, otherwise a sensible default is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PROPAGATE_EXCEPTIONS']\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n\n    @property\n    def preserve_context_on_exception(self):\n        \"\"\"Returns the value of the `PRESERVE_CONTEXT_ON_EXCEPTION`\n        configuration value in case it's set, otherwise a sensible default\n        is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PRESERVE_CONTEXT_ON_EXCEPTION']\n        if rv is not None:\n            return rv\n        return self.debug\n\n    @property\n    def logger(self):\n        \"\"\"A :class:`logging.Logger` object for this application.  The\n        default configuration is to log to stderr if the application is\n        in debug mode.  This logger can be used to (surprise) log messages.\n        Here some examples::\n\n            app.logger.debug('A value for debugging')\n            app.logger.warning('A warning occurred (%d apples)', 42)\n            app.logger.error('An error occurred')\n\n        .. versionadded:: 0.3\n        \"\"\"\n        if self._logger and self._logger.name == self.logger_name:\n            return self._logger\n        with _logger_lock:\n            if self._logger and self._logger.name == self.logger_name:\n                return self._logger\n            from flask.logging import create_logger\n            self._logger = rv = create_logger(self)\n            return rv\n\n    @locked_cached_property\n    def jinja_env(self):\n        \"\"\"The Jinja2 environment used to load templates.\"\"\"\n        return self.create_jinja_environment()\n\n    @property\n    def got_first_request(self):\n        \"\"\"This attribute is set to `True` if the application started\n        handling the first request.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        return self._got_first_request\n\n    def make_config(self, instance_relative=False):\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        return Config(root_path, self.default_config)\n\n    def auto_find_instance_path(self):\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, 'instance')\n        return os.path.join(prefix, 'var', self.name + '-instance')\n\n    def open_instance_resource(self, resource, mode='rb'):\n        \"\"\"Opens a resource from the application's instance folder\n        (:attr:`instance_path`).  Otherwise works like\n        :meth:`open_resource`.  Instance resources can also be opened for\n        writing.\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        \"\"\"\n        return open(os.path.join(self.instance_path, resource), mode)\n\n    def create_jinja_environment(self):\n        \"\"\"Creates the Jinja2 environment based on :attr:`jinja_options`\n        and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds\n        the Jinja2 globals and filters after initialization.  Override\n        this function to customize the behavior.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        options = dict(self.jinja_options)\n        if 'autoescape' not in options:\n            options['autoescape'] = self.select_jinja_autoescape\n        rv = Environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g\n        )\n        rv.filters['tojson'] = json.htmlsafe_dumps\n        return rv\n\n    def create_global_jinja_loader(self):\n        \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n\n    def init_jinja_globals(self):\n        \"\"\"Deprecated.  Used to initialize the Jinja2 globals.\n\n        .. versionadded:: 0.5\n        .. versionchanged:: 0.7\n           This method is deprecated with 0.7.  Override\n           :meth:`create_jinja_environment` instead.\n        \"\"\"\n\n    def select_jinja_autoescape(self, filename):\n        \"\"\"Returns `True` if autoescaping should be active for the given\n        template name.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return False\n        return filename.endswith(('.html', '.htm', '.xml', '.xhtml'))\n\n    def update_template_context(self, context):\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overriden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        # make sure the original values win.  This makes it possible to\n        # easier add new variables in context processors without breaking\n        # existing views.\n        context.update(orig_ctx)\n\n    def run(self, host=None, port=None, debug=None, **options):\n        \"\"\"Runs the application on a local development server.  If the\n        :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to `True` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n                     have the server available externally as well. Defaults to\n                     ``'127.0.0.1'``.\n        :param port: the port of the webserver. Defaults to ``5000``.\n        :param debug: if given, enable or disable debug mode.\n                      See :attr:`debug`.\n        :param options: the options to be forwarded to the underlying\n                        Werkzeug server.  See\n                        :func:`werkzeug.serving.run_simple` for more\n                        information.\n        \"\"\"\n        from werkzeug.serving import run_simple\n        if host is None:\n            host = '127.0.0.1'\n        if port is None:\n            port = 5000\n        if debug is not None:\n            self.debug = bool(debug)\n        options.setdefault('use_reloader', self.debug)\n        options.setdefault('use_debugger', self.debug)\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # resetted normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False\n\n    def test_client(self, use_cookies=True):\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :ref:`testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a `with` block to defer the closing down\n        of the context until the end of the `with` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('\/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for `with` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from flask.testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies)\n\n    def open_session(self, request):\n        \"\"\"Creates or opens a new session.  Default implementation stores all\n        session data in a signed cookie.  This requires that the\n        :attr:`secret_key` is set.  Instead of overriding this method\n        we recommend replacing the :class:`session_interface`.\n\n        :param request: an instance of :attr:`request_class`.\n        \"\"\"\n        return self.session_interface.open_session(self, request)\n\n    def save_session(self, session, response):\n        \"\"\"Saves the session if it needs updates.  For the default\n        implementation, check :meth:`open_session`.  Instead of overriding this\n        method we recommend replacing the :class:`session_interface`.\n\n        :param session: the session to be saved (a\n                        :class:`~werkzeug.contrib.securecookie.SecureCookie`\n                        object)\n        :param response: an instance of :attr:`response_class`\n        \"\"\"\n        return self.session_interface.save_session(self, session, response)\n\n    def make_null_session(self):\n        \"\"\"Creates a new instance of a missing session.  Instead of overriding\n        this method we recommend replacing the :class:`session_interface`.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return self.session_interface.make_null_session(self)\n\n    def register_module(self, module, **options):\n        \"\"\"Registers a module with this application.  The keyword argument\n        of this function are the same as the ones for the constructor of the\n        :class:`Module` class and will override the values of the module if\n        provided.\n\n        .. versionchanged:: 0.7\n           The module system was deprecated in favor for the blueprint\n           system.\n        \"\"\"\n        assert blueprint_is_module(module), 'register_module requires ' \\\n            'actual module objects.  Please upgrade to blueprints though.'\n        if not self.enable_modules:\n            raise RuntimeError('Module support was disabled but code '\n                'attempted to register a module named %r' % module)\n        else:\n            from warnings import warn\n            warn(DeprecationWarning('Modules are deprecated.  Upgrade to '\n                'using blueprints.  Have a look into the documentation for '\n                'more information.  If this module was registered by a '\n                'Flask-Extension upgrade the extension or contact the author '\n                'of that extension instead.  (Registered %r)' % module),\n                stacklevel=2)\n\n        self.register_blueprint(module, **options)\n\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        \"\"\"Registers a blueprint on the application.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, \\\n                'A blueprint\\'s name collision occurred between %r and ' \\\n                '%r.  Both share the same name \"%s\".  Blueprints that ' \\\n                'are created on the fly need unique names.' % \\\n                (blueprint, self.blueprints[blueprint.name], blueprint.name)\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n\n    @setupmethod\n    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n        \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n        decorator.  If a view_func is provided it will be registered with the\n        endpoint.\n\n        Basically this example::\n\n            @app.route('\/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('\/', 'index', index)\n\n        If the view_func is not provided you will need to connect the endpoint\n        to a view function like so::\n\n            app.view_functions['index'] = index\n\n        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n        to customize the behavior via subclassing you only need to change\n        this method.\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        .. versionchanged:: 0.2\n           `view_func` parameter added.\n\n        .. versionchanged:: 0.6\n           `OPTIONS` is added automatically as method.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (`GET`, `POST` etc.).  By default a rule\n                        just listens for `GET` (and implicitly `HEAD`).\n                        Starting with Flask 0.6, `OPTIONS` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options['endpoint'] = endpoint\n        methods = options.pop('methods', None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only `GET` as default.\n        if methods is None:\n            methods = getattr(view_func, 'methods', None) or ('GET',)\n        methods = set(methods)\n\n        # Methods that should always be added\n        required_methods = set(getattr(view_func, 'required_methods', ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        provide_automatic_options = getattr(view_func,\n            'provide_automatic_options', None)\n\n        if provide_automatic_options is None:\n            if 'OPTIONS' not in methods:\n                provide_automatic_options = True\n                required_methods.add('OPTIONS')\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        # due to a werkzeug bug we need to make sure that the defaults are\n        # None if they are an empty dictionary.  This should not be necessary\n        # with Werkzeug 0.7\n        options['defaults'] = options.get('defaults') or None\n\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func is not view_func:\n                raise AssertionError('View function mapping is overwriting an '\n                                     'existing endpoint function: %s' % endpoint)\n            self.view_functions[endpoint] = view_func\n\n    def route(self, rule, **options):\n        \"\"\"A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as :meth:`add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('\/')\n            def index():\n                return 'Hello World'\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (`GET`, `POST` etc.).  By default a rule\n                        just listens for `GET` (and implicitly `HEAD`).\n                        Starting with Flask 0.6, `OPTIONS` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        def decorator(f):\n            endpoint = options.pop('endpoint', None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n        return decorator\n\n    @setupmethod\n    def endpoint(self, endpoint):\n        \"\"\"A decorator to register a function as an endpoint.\n        Example::\n\n            @app.endpoint('example.endpoint')\n            def example():\n                return \"example\"\n\n        :param endpoint: the name of the endpoint\n        \"\"\"\n        def decorator(f):\n            self.view_functions[endpoint] = f\n            return f\n        return decorator\n\n    @setupmethod\n    def errorhandler(self, code_or_exception):\n        \"\"\"A decorator that is used to register a function give a given\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        You can also register a function as error handler without using\n        the :meth:`errorhandler` decorator.  The following example is\n        equivalent to the one above::\n\n            def page_not_found(error):\n                return 'This page does not exist', 404\n            app.error_handler_spec[None][404] = page_not_found\n\n        Setting error handlers via assignments to :attr:`error_handler_spec`\n        however is discouraged as it requires fidling with nested dictionaries\n        and the special case for arbitrary exception types.\n\n        The first `None` refers to the active blueprint.  If the error\n        handler should be application wide `None` shall be used.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code: the code as integer for the handler\n        \"\"\"\n        def decorator(f):\n            self._register_error_handler(None, code_or_exception, f)\n            return f\n        return decorator\n\n    def register_error_handler(self, code_or_exception, f):\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._register_error_handler(None, code_or_exception, f)\n\n    @setupmethod\n    def _register_error_handler(self, key, code_or_exception, f):\n        if isinstance(code_or_exception, HTTPException):\n            code_or_exception = code_or_exception.code\n        if isinstance(code_or_exception, integer_types):\n            assert code_or_exception != 500 or key is None, \\\n                'It is currently not possible to register a 500 internal ' \\\n                'server error on a per-blueprint level.'\n            self.error_handler_spec.setdefault(key, {})[code_or_exception] = f\n        else:\n            self.error_handler_spec.setdefault(key, {}).setdefault(None, []) \\\n                .append((code_or_exception, f))\n\n    @setupmethod\n    def template_filter(self, name=None):\n        \"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        \"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f\n\n    @setupmethod\n    def template_test(self, name=None):\n        \"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        \"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f\n\n\n    @setupmethod\n    def template_global(self, name=None):\n        \"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        \"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f\n\n    @setupmethod\n    def before_request(self, f):\n        \"\"\"Registers a function to run before each request.\"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def before_first_request(self, f):\n        \"\"\"Registers a function to be run before the first request to this\n        instance of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.before_first_request_funcs.append(f)\n\n    @setupmethod\n    def after_request(self, f):\n        \"\"\"Register a function to be run after each request.  Your function\n        must take one parameter, a :attr:`response_class` object and return\n        a new response object or the same (see :meth:`process_response`).\n\n        As of Flask 0.7 this function might not be executed at the end of the\n        request in case an unhandled exception occurred.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_request(self, f):\n        \"\"\"Register a function to be run at the end of each request,\n        regardless of whether there was an exception or not.  These functions\n        are executed when the request context is popped, even if not an\n        actual request was performed.\n\n        Example::\n\n            ctx = app.test_request_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the request context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Generally teardown functions must take every necessary step to avoid\n        that they will fail.  If they do execute code that might fail they\n        will have to surround the execution of these code by try\/except\n        statements and log occurring errors.\n\n        When a teardown function was called because of a exception it will\n        be passed an error object.\n\n        .. admonition:: Debug Note\n\n           In debug mode Flask will not tear down a request on an exception\n           immediately.  Instead if will keep it alive so that the interactive\n           debugger can still access it.  This behavior can be controlled\n           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_appcontext(self, f):\n        \"\"\"Registers a function to be called when the application context\n        ends.  These functions are typically also called when the request\n        context is popped.\n\n        Example::\n\n            ctx = app.app_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the app context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Since a request context typically also manages an application\n        context it would also be called when you pop a request context.\n\n        When a teardown function was called because of an exception it will\n        be passed an error object.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n\n    @setupmethod\n    def context_processor(self, f):\n        \"\"\"Registers a template context processor function.\"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n\n    @setupmethod\n    def url_value_preprocessor(self, f):\n        \"\"\"Registers a function as URL value preprocessor for all view\n        functions of the application.  It's called before the view functions\n        are called and can modify the url values provided.\n        \"\"\"\n        self.url_value_preprocessors.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def url_defaults(self, f):\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n        \"\"\"\n        self.url_default_functions.setdefault(None, []).append(f)\n        return f\n\n    def handle_http_exception(self, e):\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        handlers = self.error_handler_spec.get(request.blueprint)\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n        if handlers and e.code in handlers:\n            handler = handlers[e.code]\n        else:\n            handler = self.error_handler_spec[None].get(e.code)\n        if handler is None:\n            return e\n        return handler(e)\n\n    def trap_http_exception(self, e):\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return `False` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to `True`.  It\n        also returns `True` if ``TRAP_HTTP_EXCEPTIONS`` is set to `True`.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns `True` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config['TRAP_HTTP_EXCEPTIONS']:\n            return True\n        if self.config['TRAP_BAD_REQUEST_ERRORS']:\n            return isinstance(e, BadRequest)\n        return False\n\n    def handle_user_exception(self, e):\n        \"\"\"This method is called whenever an exception occurs that should be\n        handled.  A special case are\n        :class:`~werkzeug.exception.HTTPException`\\s which are forwarded by\n        this function to the :meth:`handle_http_exception` method.  This\n        function will either return a response value or reraise the\n        exception with the same traceback.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        assert exc_value is e\n\n        # ensure not to trash sys.exc_info() at that point in case someone\n        # wants the traceback preserved in handle_http_exception.  Of course\n        # we cannot prevent users from trashing it themselves in a custom\n        # trap_http_exception method so that's their fault then.\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        blueprint_handlers = ()\n        handlers = self.error_handler_spec.get(request.blueprint)\n        if handlers is not None:\n            blueprint_handlers = handlers.get(None, ())\n        app_handlers = self.error_handler_spec[None].get(None, ())\n        for typecheck, handler in chain(blueprint_handlers, app_handlers):\n            if isinstance(e, typecheck):\n                return handler(e)\n\n        reraise(exc_type, exc_value, tb)\n\n    def handle_exception(self, e):\n        \"\"\"Default exception handling that kicks in when an exception\n        occurs that is not caught.  In debug mode the exception will\n        be re-raised immediately, otherwise it is logged and the handler\n        for a 500 internal server error is used.  If no such handler\n        exists, a default 500 internal server error message is displayed.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n\n        got_request_exception.send(self, exception=e)\n        handler = self.error_handler_spec[None].get(500)\n\n        if self.propagate_exceptions:\n            # if we want to repropagate the exception, we can attempt to\n            # raise it with the whole traceback in case we can do that\n            # (the function was actually called from the except part)\n            # otherwise, we just raise the error again\n            if exc_value is e:\n                reraise(exc_type, exc_value, tb)\n            else:\n                raise e\n\n        self.log_exception((exc_type, exc_value, tb))\n        if handler is None:\n            return InternalServerError()\n        return handler(e)\n\n    def log_exception(self, exc_info):\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error('Exception on %s [%s]' % (\n            request.path,\n            request.method\n        ), exc_info=exc_info)\n\n    def raise_routing_exception(self, request):\n        \"\"\"Exceptions that are recording during routing are reraised with\n        this method.  During debug we are not reraising redirect requests\n        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n        a different error instead to help debug situations.\n\n        :internal:\n        \"\"\"\n        if not self.debug \\\n           or not isinstance(request.routing_exception, RequestRedirect) \\\n           or request.method in ('GET', 'HEAD', 'OPTIONS'):\n            raise request.routing_exception\n\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n\n    def dispatch_request(self):\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if getattr(rule, 'provide_automatic_options', False) \\\n           and req.method == 'OPTIONS':\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        return self.view_functions[rule.endpoint](**req.view_args)\n\n    def full_dispatch_request(self):\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        response = self.make_response(rv)\n        response = self.process_response(response)\n        request_finished.send(self, response=response)\n        return response\n\n    def try_trigger_before_first_request_functions(self):\n        \"\"\"Called before each request and will ensure that it triggers\n        the :attr:`before_first_request_funcs` and only exactly once per\n        application instance (which means process usually).\n\n        :internal:\n        \"\"\"\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            self._got_first_request = True\n            for func in self.before_first_request_funcs:\n                func()\n\n    def make_default_options_response(self):\n        \"\"\"This method is called to create the default `OPTIONS` response.\n        This can be changed through subclassing to change the default\n        behavior of `OPTIONS` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        adapter = _request_ctx_stack.top.url_adapter\n        if hasattr(adapter, 'allowed_methods'):\n            methods = adapter.allowed_methods()\n        else:\n            # fallback for Werkzeug < 0.7\n            methods = []\n            try:\n                adapter.match(method='--')\n            except MethodNotAllowed as e:\n                methods = e.valid_methods\n            except HTTPException as e:\n                pass\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n\n    def make_response(self, rv):\n        \"\"\"Converts the return value from a view function to a real\n        response object that is an instance of :attr:`response_class`.\n\n        The following types are allowed for `rv`:\n\n        .. tabularcolumns:: |p{3.5cm}|p{9.5cm}|\n\n        ======================= ===========================================\n        :attr:`response_class`  the object is returned unchanged\n        :class:`str`            a response object is created with the\n                                string as body\n        :class:`unicode`        a response object is created with the\n                                string encoded to utf-8 as body\n        a WSGI function         the function is called as WSGI application\n                                and buffered as response object\n        :class:`tuple`          A tuple in the form ``(response, status,\n                                headers)`` where `response` is any of the\n                                types defined here, `status` is a string\n                                or an integer and `headers` is a list of\n                                a dictionary with header values.\n        ======================= ===========================================\n\n        :param rv: the return value from the view function\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n        status = headers = None\n        if isinstance(rv, tuple):\n            rv, status, headers = rv + (None,) * (3 - len(rv))\n\n        if rv is None:\n            raise ValueError('View function did not return a response')\n\n        if not isinstance(rv, self.response_class):\n            # When we create a response object directly, we let the constructor\n            # set the headers and status.  We do this because there can be\n            # some extra logic involved when creating these objects with\n            # specific values (like defualt content type selection).\n            if isinstance(rv, string_types):\n                rv = self.response_class(rv, headers=headers, status=status)\n                headers = status = None\n            else:\n                rv = self.response_class.force_type(rv, request.environ)\n\n        if status is not None:\n            if isinstance(status, string_types):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.extend(headers)\n\n        return rv\n\n    def create_url_adapter(self, request):\n        \"\"\"Creates a URL adapter for the given request.  The URL adapter\n        is created at a point where the request context is not yet set up\n        so the request is passed explicitly.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n           This can now also be called without a request object when the\n           URL adapter is created for the application context.\n        \"\"\"\n        if request is not None:\n            return self.url_map.bind_to_environ(request.environ,\n                server_name=self.config['SERVER_NAME'])\n        # We need at the very least the server name to be set for this\n        # to work.\n        if self.config['SERVER_NAME'] is not None:\n            return self.url_map.bind(\n                self.config['SERVER_NAME'],\n                script_name=self.config['APPLICATION_ROOT'] or '\/',\n                url_scheme=self.config['PREFERRED_URL_SCHEME'])\n\n    def inject_url_defaults(self, endpoint, values):\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        funcs = self.url_default_functions.get(None, ())\n        if '.' in endpoint:\n            bp = endpoint.rsplit('.', 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n\n    def handle_url_build_error(self, error, endpoint, values):\n        \"\"\"Handle :class:`~werkzeug.routing.BuildError` on :meth:`url_for`.\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n                if rv is not None:\n                    return rv\n            except BuildError as error:\n                pass\n\n        # At this point we want to reraise the exception.  If the error is\n        # still the same one we can reraise it with the original traceback,\n        # otherwise we raise it from here.\n        if error is exc_value:\n            reraise(exc_type, exc_value, tb)\n        raise error\n\n    def preprocess_request(self):\n        \"\"\"Called before the actual request dispatching and will\n        call every as :meth:`before_request` decorated function.\n        If any of these function returns a value it's handled as\n        if it was the return value from the view and further\n        request handling is stopped.\n\n        This also triggers the :meth:`url_value_processor` functions before\n        the actual :meth:`before_request` functions are called.\n        \"\"\"\n        bp = _request_ctx_stack.top.request.blueprint\n\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n\n    def process_response(self, response):\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.save_session(ctx.session, response)\n        return response\n\n    def do_teardown_request(self, exc=None):\n        \"\"\"Called after the actual request dispatching and will\n        call every as :meth:`teardown_request` decorated function.  This is\n        not actually called by the :class:`Flask` object itself but is always\n        triggered when the request context is popped.  That way we have a\n        tighter control over certain resources under testing environments.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.  Previously this was always using the\n           current exception information.\n        \"\"\"\n        if exc is None:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            rv = func(exc)\n        request_tearing_down.send(self, exc=exc)\n\n    def do_teardown_appcontext(self, exc=None):\n        \"\"\"Called when an application context is popped.  This works pretty\n        much the same as :meth:`do_teardown_request` but for the application\n        context.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is None:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n\n    def app_context(self):\n        \"\"\"Binds the application only.  For as long as the application is bound\n        to the current context the :data:`flask.current_app` points to that\n        application.  An application context is automatically created when a\n        request context is pushed if necessary.\n\n        Example usage::\n\n            with app.app_context():\n                ...\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ):\n        \"\"\"Creates a :class:`~flask.ctx.RequestContext` from the given\n        environment and binds it to the current context.  This must be used in\n        combination with the `with` statement because the request is only bound\n        to the current context for the duration of the `with` block.\n\n        Example usage::\n\n            with app.request_context(environ):\n                do_something_with(request)\n\n        The object returned can also be used without the `with` statement\n        which is useful for working in the shell.  The example above is\n        doing exactly the same as this code::\n\n            ctx = app.request_context(environ)\n            ctx.push()\n            try:\n                do_something_with(request)\n            finally:\n                ctx.pop()\n\n        .. versionchanged:: 0.3\n           Added support for non-with statement usage and `with` statement\n           is now passed the ctx object.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args, **kwargs):\n        \"\"\"Creates a WSGI environment from the given values (see\n        :func:`werkzeug.test.EnvironBuilder` for more information, this\n        function accepts the same arguments).\n        \"\"\"\n        from flask.testing import make_test_environ_builder\n        builder = make_test_environ_builder(self, *args, **kwargs)\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(self, environ, start_response):\n        \"\"\"The actual WSGI application.  This is not implemented in\n        `__call__` so that middlewares can be applied without losing a\n        reference to the class.  So instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n           The behavior of the before and after request callbacks was changed\n           under error conditions and a new callback was added that will\n           always execute at the end of the request, independent on if an\n           error occurred or not.  See :ref:`callbacks-and-errors`.\n\n        :param environ: a WSGI environment\n        :param start_response: a callable accepting a status code,\n                               a list of headers and an optional\n                               exception context to start the response\n        \"\"\"\n        with self.request_context(environ):\n            try:\n                response = self.full_dispatch_request()\n            except Exception as e:\n                response = self.make_response(self.handle_exception(e))\n            return response(environ, start_response)\n\n    @property\n    def modules(self):\n        from warnings import warn\n        warn(DeprecationWarning('Flask.modules is deprecated, use '\n                                'Flask.blueprints instead'), stacklevel=2)\n        return self.blueprints\n\n    def __call__(self, environ, start_response):\n        \"\"\"Shortcut for :attr:`wsgi_app`.\"\"\"\n        return self.wsgi_app(environ, start_response)\n\n    def __repr__(self):\n        return '<%s %r>' % (\n            self.__class__.__name__,\n            self.name,\n        )\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.blueprints\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Blueprints (and currently modules)\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nimport warnings\nfrom flask.testsuite import FlaskTestCase, emits_module_deprecation_warning\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_cache_control_header\nfrom jinja2 import TemplateNotFound\nimport six\n\n\n# import moduleapp here because it uses deprecated features and we don't\n# want to see the warnings\nwarnings.simplefilter('ignore', DeprecationWarning)\nfrom moduleapp import app as moduleapp\nwarnings.simplefilter('default', DeprecationWarning)\n\n\nclass ModuleTestCase(FlaskTestCase):\n\n    @emits_module_deprecation_warning\n    def test_basic_module(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.route('\/')\n        def admin_index():\n            return 'admin index'\n        @admin.route('\/login')\n        def admin_login():\n            return 'admin login'\n        @admin.route('\/logout')\n        def admin_logout():\n            return 'admin logout'\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, 'the index')\n        self.assert_equal(c.get('\/admin\/').data, 'admin index')\n        self.assert_equal(c.get('\/admin\/login').data, 'admin login')\n        self.assert_equal(c.get('\/admin\/logout').data, 'admin logout')\n\n    @emits_module_deprecation_warning\n    def test_default_endpoint_name(self):\n        app = flask.Flask(__name__)\n        mod = flask.Module(__name__, 'frontend')\n        def index():\n            return 'Awesome'\n        mod.add_url_rule('\/', view_func=index)\n        app.register_module(mod)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'Awesome')\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('frontend.index'), '\/')\n\n    @emits_module_deprecation_warning\n    def test_request_processing(self):\n        catched = []\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.before_request\n        def before_admin_request():\n            catched.append('before-admin')\n        @admin.after_request\n        def after_admin_request(response):\n            catched.append('after-admin')\n            return response\n        @admin.route('\/')\n        def admin_index():\n            return 'the admin'\n        @app.before_request\n        def before_request():\n            catched.append('before-app')\n        @app.after_request\n        def after_request(response):\n            catched.append('after-app')\n            return response\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/').data, 'the index')\n        self.assert_equal(catched, ['before-app', 'after-app'])\n        del catched[:]\n\n        self.assert_equal(c.get('\/admin\/').data, 'the admin')\n        self.assert_equal(catched, ['before-app', 'before-admin',\n                           'after-admin', 'after-app'])\n\n    @emits_module_deprecation_warning\n    def test_context_processors(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @app.context_processor\n        def inject_all_regualr():\n            return {'a': 1}\n        @admin.context_processor\n        def inject_admin():\n            return {'b': 2}\n        @admin.app_context_processor\n        def inject_all_module():\n            return {'c': 3}\n        @app.route('\/')\n        def index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        @admin.route('\/')\n        def admin_index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, '13')\n        self.assert_equal(c.get('\/admin\/').data, '123')\n\n    @emits_module_deprecation_warning\n    def test_late_binding(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.route('\/')\n        def index():\n            return '42'\n        app.register_module(admin, url_prefix='\/admin')\n        self.assert_equal(app.test_client().get('\/admin\/').data, '42')\n\n    @emits_module_deprecation_warning\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.app_errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @admin.app_errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @admin.route('\/')\n        def index():\n            flask.abort(404)\n        @admin.route('\/error')\n        def error():\n            1 \/\/ 0\n        app.register_module(admin)\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, 'not found')\n        rv = c.get('\/error')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_equal('internal server error', rv.data)\n\n    def test_templates_and_static(self):\n        app = moduleapp\n        app.testing = True\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, 'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), 'Admin File')\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), '\/* nested file *\/')\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_safe_access(self):\n        app = moduleapp\n\n        with app.test_request_context():\n            f = app.view_functions['admin.static']\n\n            try:\n                f('\/etc\/passwd')\n            except NotFound:\n                pass\n            else:\n                self.assert_(0, 'expected exception')\n            try:\n                f('..\/__init__.py')\n            except NotFound:\n                pass\n            else:\n                self.assert_(0, 'expected exception')\n\n            # testcase for a security issue that may exist on windows systems\n            import os\n            import ntpath\n            old_path = os.path\n            os.path = ntpath\n            try:\n                try:\n                    f('..\\\\__init__.py')\n                except NotFound:\n                    pass\n                else:\n                    self.assert_(0, 'expected exception')\n            finally:\n                os.path = old_path\n\n    @emits_module_deprecation_warning\n    def test_endpoint_decorator(self):\n        from werkzeug.routing import Submount, Rule\n        from flask import Module\n\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n        module = Module(__name__, __name__)\n\n        @module.endpoint('bar')\n        def bar():\n            return 'bar'\n\n        @module.endpoint('index')\n        def index():\n            return 'index'\n\n        app.register_module(module)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, 'index')\n        self.assert_equal(c.get('\/foo\/bar').data, 'bar')\n\n\nclass BlueprintTestCase(FlaskTestCase):\n\n    def test_blueprint_specific_error_handling(self):\n        frontend = flask.Blueprint('frontend', __name__)\n        backend = flask.Blueprint('backend', __name__)\n        sideend = flask.Blueprint('sideend', __name__)\n\n        @frontend.errorhandler(403)\n        def frontend_forbidden(e):\n            return 'frontend says no', 403\n\n        @frontend.route('\/frontend-no')\n        def frontend_no():\n            flask.abort(403)\n\n        @backend.errorhandler(403)\n        def backend_forbidden(e):\n            return 'backend says no', 403\n\n        @backend.route('\/backend-no')\n        def backend_no():\n            flask.abort(403)\n\n        @sideend.route('\/what-is-a-sideend')\n        def sideend_no():\n            flask.abort(403)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n        app.register_blueprint(sideend)\n\n        @app.errorhandler(403)\n        def app_forbidden(e):\n            return 'application itself says no', 403\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/frontend-no').data, 'frontend says no')\n        self.assert_equal(c.get('\/backend-no').data, 'backend says no')\n        self.assert_equal(c.get('\/what-is-a-sideend').data, 'application itself says no')\n\n    def test_blueprint_url_definitions(self):\n        bp = flask.Blueprint('test', __name__)\n\n        @bp.route('\/foo', defaults={'baz': 42})\n        def foo(bar, baz):\n            return '%s\/%d' % (bar, baz)\n\n        @bp.route('\/bar')\n        def bar(bar):\n            return six.text_type(bar)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/1', url_defaults={'bar': 23})\n        app.register_blueprint(bp, url_prefix='\/2', url_defaults={'bar': 19})\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/1\/foo').data, u'23\/42')\n        self.assert_equal(c.get('\/2\/foo').data, u'19\/42')\n        self.assert_equal(c.get('\/1\/bar').data, u'23')\n        self.assert_equal(c.get('\/2\/bar').data, u'19')\n\n    def test_blueprint_url_processors(self):\n        bp = flask.Blueprint('frontend', __name__, url_prefix='\/<lang_code>')\n\n        @bp.url_defaults\n        def add_language_code(endpoint, values):\n            values.setdefault('lang_code', flask.g.lang_code)\n\n        @bp.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop('lang_code')\n\n        @bp.route('\/')\n        def index():\n            return flask.url_for('.about')\n\n        @bp.route('\/about')\n        def about():\n            return flask.url_for('.index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/de\/').data, '\/de\/about')\n        self.assert_equal(c.get('\/de\/about').data, '\/de\/')\n\n    def test_templates_and_static(self):\n        from blueprintapp import app\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, 'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, 'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), 'Admin File')\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), '\/* nested file *\/')\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            expected_max_age = 3600\n            if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == expected_max_age:\n                expected_max_age = 7200\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = expected_max_age\n            rv = c.get('\/admin\/static\/css\/test.css')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, expected_max_age)\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_default_static_cache_timeout(self):\n        app = flask.Flask(__name__)\n        class MyBlueprint(flask.Blueprint):\n            def get_send_file_max_age(self, filename):\n                return 100\n\n        blueprint = MyBlueprint('blueprint', __name__, static_folder='static')\n        app.register_blueprint(blueprint)\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            with app.test_request_context():\n                unexpected_max_age = 3600\n                if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == unexpected_max_age:\n                    unexpected_max_age = 7200\n                app.config['SEND_FILE_MAX_AGE_DEFAULT'] = unexpected_max_age\n                rv = blueprint.send_static_file('index.html')\n                cc = parse_cache_control_header(rv.headers['Cache-Control'])\n                self.assert_equal(cc.max_age, 100)\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n    def test_templates_list(self):\n        from blueprintapp import app\n        templates = sorted(app.jinja_env.list_templates())\n        self.assert_equal(templates, ['admin\/index.html',\n                                     'frontend\/index.html'])\n\n    def test_dotted_names(self):\n        frontend = flask.Blueprint('myapp.frontend', __name__)\n        backend = flask.Blueprint('myapp.backend', __name__)\n\n        @frontend.route('\/fe')\n        def frontend_index():\n            return flask.url_for('myapp.backend.backend_index')\n\n        @frontend.route('\/fe2')\n        def frontend_page2():\n            return flask.url_for('.frontend_index')\n\n        @backend.route('\/be')\n        def backend_index():\n            return flask.url_for('myapp.frontend.frontend_index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/fe').data.strip(), '\/be')\n        self.assert_equal(c.get('\/fe2').data.strip(), '\/fe')\n        self.assert_equal(c.get('\/be').data.strip(), '\/fe')\n\n    def test_empty_url_defaults(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/', defaults={'page': 1})\n        @bp.route('\/page\/<int:page>')\n        def something(page):\n            return str(page)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, '1')\n        self.assert_equal(c.get('\/page\/2').data, '2')\n\n    def test_route_decorator_custom_endpoint(self):\n\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar', endpoint='bar')\n        def foo_bar():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/123', endpoint='123')\n        def foo_bar_foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/foo')\n        def bar_foo():\n            return flask.request.endpoint\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        @app.route('\/')\n        def index():\n            return flask.request.endpoint\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/').data, 'index')\n        self.assertEqual(c.get('\/py\/foo').data, 'bp.foo')\n        self.assertEqual(c.get('\/py\/bar').data, 'bp.bar')\n        self.assertEqual(c.get('\/py\/bar\/123').data, 'bp.123')\n        self.assertEqual(c.get('\/py\/bar\/foo').data, 'bp.bar_foo')\n\n    def test_route_decorator_custom_endpoint_with_dots(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        try:\n            @bp.route('\/bar', endpoint='bar.bar')\n            def foo_bar():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        try:\n            @bp.route('\/bar\/123', endpoint='bar.123')\n            def foo_bar_foo():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        def foo_foo_foo():\n            pass\n\n        self.assertRaises(\n            AssertionError,\n            lambda: bp.add_url_rule(\n                '\/bar\/123', endpoint='bar.123', view_func=foo_foo_foo\n            )\n        )\n\n        self.assertRaises(\n            AssertionError,\n            bp.route('\/bar\/123', endpoint='bar.123'),\n            lambda: None\n        )\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/py\/foo').data, 'bp.foo')\n        # The rule's din't actually made it through\n        rv = c.get('\/py\/bar')\n        assert rv.status_code == 404\n        rv = c.get('\/py\/bar\/123')\n        assert rv.status_code == 404\n\n    def test_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('my_reverse' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_add_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('my_reverse' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('strrev')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('strrev' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_add_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'strrev')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('strrev' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_template_filter_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_add_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def super_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(super_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('super_reverse')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_add_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'super_reverse')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('is_boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['is_boolean'](False))\n\n    def test_add_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('is_boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['is_boolean'](False))\n\n    def test_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_('boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_template_test_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_add_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_add_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(BlueprintTestCase))\n    suite.addTest(unittest.makeSuite(ModuleTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.config\n    ~~~~~~~~~~~~~~~~~~~~~~\n\n    Configuration and instances.\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nimport flask\nimport pkgutil\nimport unittest\nfrom contextlib import contextmanager\nfrom flask.testsuite import FlaskTestCase\n\n\n# config keys used for the ConfigTestCase\nTEST_KEY = 'foo'\nSECRET_KEY = 'devkey'\n\n\nclass ConfigTestCase(FlaskTestCase):\n\n    def common_object_test(self, app):\n        self.assert_equal(app.secret_key, 'devkey')\n        self.assert_equal(app.config['TEST_KEY'], 'foo')\n        self.assert_('ConfigTestCase' not in app.config)\n\n    def test_config_from_file(self):\n        app = flask.Flask(__name__)\n        app.config.from_pyfile(__file__.rsplit('.', 1)[0] + '.py')\n        self.common_object_test(app)\n\n    def test_config_from_object(self):\n        app = flask.Flask(__name__)\n        app.config.from_object(__name__)\n        self.common_object_test(app)\n\n    def test_config_from_class(self):\n        class Base(object):\n            TEST_KEY = 'foo'\n        class Test(Base):\n            SECRET_KEY = 'devkey'\n        app = flask.Flask(__name__)\n        app.config.from_object(Test)\n        self.common_object_test(app)\n\n    def test_config_from_envvar(self):\n        env = os.environ\n        try:\n            os.environ = {}\n            app = flask.Flask(__name__)\n            try:\n                app.config.from_envvar('FOO_SETTINGS')\n            except RuntimeError as e:\n                self.assert_(\"'FOO_SETTINGS' is not set\" in str(e))\n            else:\n                self.assert_(0, 'expected exception')\n            self.assert_(not app.config.from_envvar('FOO_SETTINGS', silent=True))\n\n            os.environ = {'FOO_SETTINGS': __file__.rsplit('.', 1)[0] + '.py'}\n            self.assert_(app.config.from_envvar('FOO_SETTINGS'))\n            self.common_object_test(app)\n        finally:\n            os.environ = env\n\n    def test_config_from_envvar_missing(self):\n        env = os.environ\n        try:\n            os.environ = {'FOO_SETTINGS': 'missing.cfg'}\n            try:\n                app = flask.Flask(__name__)\n                app.config.from_envvar('FOO_SETTINGS')\n            except IOError as e:\n                msg = str(e)\n                self.assert_(msg.startswith('[Errno 2] Unable to load configuration '\n                                            'file (No such file or directory):'))\n                self.assert_(msg.endswith(\"missing.cfg'\"))\n            else:\n                self.fail('expected IOError')\n            self.assertFalse(app.config.from_envvar('FOO_SETTINGS', silent=True))\n        finally:\n            os.environ = env\n\n    def test_config_missing(self):\n        app = flask.Flask(__name__)\n        try:\n            app.config.from_pyfile('missing.cfg')\n        except IOError as e:\n            msg = str(e)\n            self.assert_(msg.startswith('[Errno 2] Unable to load configuration '\n                                        'file (No such file or directory):'))\n            self.assert_(msg.endswith(\"missing.cfg'\"))\n        else:\n            self.assert_(0, 'expected config')\n        self.assert_(not app.config.from_pyfile('missing.cfg', silent=True))\n\n    def test_session_lifetime(self):\n        app = flask.Flask(__name__)\n        app.config['PERMANENT_SESSION_LIFETIME'] = 42\n        self.assert_equal(app.permanent_session_lifetime.seconds, 42)\n\n\nclass LimitedLoaderMockWrapper(object):\n    def __init__(self, loader):\n        self.loader = loader\n\n    def __getattr__(self, name):\n        if name in ('archive', 'get_filename'):\n            msg = 'Mocking a loader which does not have `%s.`' % name\n            raise AttributeError(msg)\n        return getattr(self.loader, name)\n\n\n@contextmanager\ndef patch_pkgutil_get_loader(wrapper_class=LimitedLoaderMockWrapper):\n    \"\"\"Patch pkgutil.get_loader to give loader without get_filename or archive.\n\n    This provides for tests where a system has custom loaders, e.g. Google App\n    Engine's HardenedModulesHook, which have neither the `get_filename` method\n    nor the `archive` attribute.\n    \"\"\"\n    old_get_loader = pkgutil.get_loader\n    def get_loader(*args, **kwargs):\n        return wrapper_class(old_get_loader(*args, **kwargs))\n    try:\n        pkgutil.get_loader = get_loader\n        yield\n    finally:\n        pkgutil.get_loader = old_get_loader\n\n\nclass InstanceTestCase(FlaskTestCase):\n\n    def test_explicit_instance_paths(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        try:\n            flask.Flask(__name__, instance_path='instance')\n        except ValueError as e:\n            self.assert_('must be absolute' in str(e))\n        else:\n            self.fail('Expected value error')\n\n        app = flask.Flask(__name__, instance_path=here)\n        self.assert_equal(app.instance_path, here)\n\n    def test_main_module_paths(self):\n        # Test an app with '__main__' as the import name, uses cwd.\n        from main_app import app\n        here = os.path.abspath(os.getcwd())\n        self.assert_equal(app.instance_path, os.path.join(here, 'instance'))\n        if 'main_app' in sys.modules:\n            del sys.modules['main_app']\n\n    def test_uninstalled_module_paths(self):\n        from config_module_app import app\n        here = os.path.abspath(os.path.dirname(__file__))\n        self.assert_equal(app.instance_path, os.path.join(here, 'test_apps', 'instance'))\n\n    def test_uninstalled_package_paths(self):\n        from config_package_app import app\n        here = os.path.abspath(os.path.dirname(__file__))\n        self.assert_equal(app.instance_path, os.path.join(here, 'test_apps', 'instance'))\n\n    def test_installed_module_paths(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        site_packages = os.path.join(expected_prefix, 'lib', 'python2.5', 'site-packages')\n        sys.path.append(site_packages)\n        try:\n            import site_app\n            self.assert_equal(site_app.app.instance_path,\n                              os.path.join(expected_prefix, 'var',\n                                           'site_app-instance'))\n        finally:\n            sys.prefix = real_prefix\n            sys.path.remove(site_packages)\n            if 'site_app' in sys.modules:\n                del sys.modules['site_app']\n\n    def test_installed_module_paths_with_limited_loader(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        site_packages = os.path.join(expected_prefix, 'lib', 'python2.5', 'site-packages')\n        sys.path.append(site_packages)\n        with patch_pkgutil_get_loader():\n            try:\n                import site_app\n                self.assert_equal(site_app.app.instance_path,\n                                  os.path.join(expected_prefix, 'var',\n                                               'site_app-instance'))\n            finally:\n                sys.prefix = real_prefix\n                sys.path.remove(site_packages)\n                if 'site_app' in sys.modules:\n                    del sys.modules['site_app']\n\n    def test_installed_package_paths(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        installed_path = os.path.join(expected_prefix, 'path')\n        sys.path.append(installed_path)\n        try:\n            import installed_package\n            self.assert_equal(installed_package.app.instance_path,\n                              os.path.join(expected_prefix, 'var',\n                                           'installed_package-instance'))\n        finally:\n            sys.prefix = real_prefix\n            sys.path.remove(installed_path)\n            if 'installed_package' in sys.modules:\n                del sys.modules['installed_package']\n\n    def test_installed_package_paths_with_limited_loader(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        installed_path = os.path.join(expected_prefix, 'path')\n        sys.path.append(installed_path)\n        with patch_pkgutil_get_loader():\n            try:\n                import installed_package\n                self.assert_equal(installed_package.app.instance_path,\n                                  os.path.join(expected_prefix, 'var',\n                                               'installed_package-instance'))\n            finally:\n                sys.prefix = real_prefix\n                sys.path.remove(installed_path)\n                if 'installed_package' in sys.modules:\n                    del sys.modules['installed_package']\n\n    def test_prefix_package_paths(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        site_packages = os.path.join(expected_prefix, 'lib', 'python2.5', 'site-packages')\n        sys.path.append(site_packages)\n        try:\n            import site_package\n            self.assert_equal(site_package.app.instance_path,\n                              os.path.join(expected_prefix, 'var',\n                                           'site_package-instance'))\n        finally:\n            sys.prefix = real_prefix\n            sys.path.remove(site_packages)\n            if 'site_package' in sys.modules:\n                del sys.modules['site_package']\n\n    def test_prefix_package_paths_with_limited_loader(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        site_packages = os.path.join(expected_prefix, 'lib', 'python2.5', 'site-packages')\n        sys.path.append(site_packages)\n        with patch_pkgutil_get_loader():\n            try:\n                import site_package\n                self.assert_equal(site_package.app.instance_path,\n                                  os.path.join(expected_prefix, 'var',\n                                               'site_package-instance'))\n            finally:\n                sys.prefix = real_prefix\n                sys.path.remove(site_packages)\n                if 'site_package' in sys.modules:\n                    del sys.modules['site_package']\n\n    def test_egg_installed_paths(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        site_packages = os.path.join(expected_prefix, 'lib', 'python2.5', 'site-packages')\n        egg_path = os.path.join(site_packages, 'SiteEgg.egg')\n        sys.path.append(site_packages)\n        sys.path.append(egg_path)\n        try:\n            import site_egg # in SiteEgg.egg\n            self.assert_equal(site_egg.app.instance_path,\n                              os.path.join(expected_prefix, 'var',\n                                           'site_egg-instance'))\n        finally:\n            sys.prefix = real_prefix\n            sys.path.remove(site_packages)\n            sys.path.remove(egg_path)\n            if 'site_egg' in sys.modules:\n                del sys.modules['site_egg']\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(ConfigTestCase))\n    suite.addTest(unittest.makeSuite(InstanceTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.deprecations\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Tests deprecation support.\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nfrom flask.testsuite import FlaskTestCase, catch_warnings\n\n\nclass DeprecationsTestCase(FlaskTestCase):\n    \"\"\"not used currently\"\"\"\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(DeprecationsTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.helpers\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Various helpers.\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport flask\nimport unittest\nfrom logging import StreamHandler\nfrom flask.testsuite import FlaskTestCase, catch_warnings, catch_stderr\nfrom werkzeug.http import parse_cache_control_header, parse_options_header\nimport six\nfrom flask._compat import StringIO\n\n\ndef has_encoding(name):\n    try:\n        import codecs\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n\n\nclass JSONTestCase(FlaskTestCase):\n\n    def test_json_bad_requests(self):\n        app = flask.Flask(__name__)\n        @app.route('\/json', methods=['POST'])\n        def return_json():\n            return six.text_type(flask.request.json)\n        c = app.test_client()\n        rv = c.post('\/json', data='malformed', content_type='application\/json')\n        self.assert_equal(rv.status_code, 400)\n\n    def test_json_bad_requests_content_type(self):\n        app = flask.Flask(__name__)\n        @app.route('\/json', methods=['POST'])\n        def return_json():\n            return six.text_type(flask.request.json)\n        c = app.test_client()\n        rv = c.post('\/json', data='malformed', content_type='application\/json')\n        self.assert_equal(rv.status_code, 400)\n        self.assert_equal(rv.mimetype, 'application\/json')\n        self.assert_('description' in flask.json.loads(rv.data))\n        self.assert_('<p>' not in flask.json.loads(rv.data)['description'])\n\n    def test_json_body_encoding(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            return flask.request.json\n\n        c = app.test_client()\n        resp = c.get('\/', data=u'\"H\u00e4llo W\u00f6rld\"'.encode('iso-8859-15'),\n                     content_type='application\/json; charset=iso-8859-15')\n        self.assert_equal(resp.data, u'H\u00e4llo W\u00f6rld'.encode('utf-8'))\n\n    def test_jsonify(self):\n        d = dict(a=23, b=42, c=[1, 2, 3])\n        app = flask.Flask(__name__)\n        @app.route('\/kw')\n        def return_kwargs():\n            return flask.jsonify(**d)\n        @app.route('\/dict')\n        def return_dict():\n            return flask.jsonify(d)\n        c = app.test_client()\n        for url in '\/kw', '\/dict':\n            rv = c.get(url)\n            self.assert_equal(rv.mimetype, 'application\/json')\n            self.assert_equal(flask.json.loads(rv.data), d)\n\n    def test_json_as_unicode(self):\n        app = flask.Flask(__name__)\n\n        app.config['JSON_AS_ASCII'] = True\n        with app.app_context():\n            rv = flask.json.dumps(u'\\N{SNOWMAN}')\n            self.assert_equal(rv, '\"\\\\u2603\"')\n\n        app.config['JSON_AS_ASCII'] = False\n        with app.app_context():\n            rv = flask.json.dumps(u'\\N{SNOWMAN}')\n            self.assert_equal(rv, u'\"\\u2603\"')\n\n    def test_json_attr(self):\n        app = flask.Flask(__name__)\n        @app.route('\/add', methods=['POST'])\n        def add():\n            return six.text_type(flask.request.json['a'] + flask.request.json['b'])\n        c = app.test_client()\n        rv = c.post('\/add', data=flask.json.dumps({'a': 1, 'b': 2}),\n                            content_type='application\/json')\n        self.assert_equal(rv.data, '3')\n\n    def test_template_escaping(self):\n        app = flask.Flask(__name__)\n        render = flask.render_template_string\n        with app.test_request_context():\n            rv = render('{{ \"<\/script>\"|tojson|safe }}')\n            self.assert_equal(rv, '\"<\\\\\/script>\"')\n            rv = render('{{ \"<\\0\/script>\"|tojson|safe }}')\n            self.assert_equal(rv, '\"<\\\\u0000\\\\\/script>\"')\n            rv = render('{{ \"<!--<script>\"|tojson|safe }}')\n            self.assert_equal(rv, '\"<\\\\u0021--<script>\"')\n\n    def test_json_customization(self):\n        class X(object):\n            def __init__(self, val):\n                self.val = val\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return '<%d>' % o.val\n                return flask.json.JSONEncoder.default(self, o)\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault('object_hook', self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n            def object_hook(self, obj):\n                if len(obj) == 1 and '_foo' in obj:\n                    return X(obj['_foo'])\n                return obj\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n        @app.route('\/', methods=['POST'])\n        def index():\n            return flask.json.dumps(flask.request.json['x'])\n        c = app.test_client()\n        rv = c.post('\/', data=flask.json.dumps({\n            'x': {'_foo': 42}\n        }), content_type='application\/json')\n        self.assertEqual(rv.data, '\"<42>\"')\n\n    def test_modified_url_encoding(self):\n        class ModifiedRequest(flask.Request):\n            url_charset = 'euc-kr'\n        app = flask.Flask(__name__)\n        app.request_class = ModifiedRequest\n        app.url_map.charset = 'euc-kr'\n\n        @app.route('\/')\n        def index():\n            return flask.request.args['foo']\n\n        rv = app.test_client().get(u'\/?foo=\uc815\uc0c1\ucc98\ub9ac'.encode('euc-kr'))\n        self.assert_equal(rv.status_code, 200)\n        self.assert_equal(rv.data, u'\uc815\uc0c1\ucc98\ub9ac'.encode('utf-8'))\n\n    if not has_encoding('euc-kr'):\n        test_modified_url_encoding = None\n\n\nclass SendfileTestCase(FlaskTestCase):\n\n    def test_send_file_regular(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.send_file('static\/index.html')\n            self.assert_(rv.direct_passthrough)\n            self.assert_equal(rv.mimetype, 'text\/html')\n            with app.open_resource('static\/index.html') as f:\n                self.assert_equal(rv.data, f.read())\n\n    def test_send_file_xsendfile(self):\n        app = flask.Flask(__name__)\n        app.use_x_sendfile = True\n        with app.test_request_context():\n            rv = flask.send_file('static\/index.html')\n            self.assert_(rv.direct_passthrough)\n            self.assert_('x-sendfile' in rv.headers)\n            self.assert_equal(rv.headers['x-sendfile'],\n                os.path.join(app.root_path, 'static\/index.html'))\n            self.assert_equal(rv.mimetype, 'text\/html')\n\n    def test_send_file_object(self):\n        app = flask.Flask(__name__)\n        with catch_warnings() as captured:\n            with app.test_request_context():\n                f = open(os.path.join(app.root_path, 'static\/index.html'))\n                rv = flask.send_file(f)\n                with app.open_resource('static\/index.html') as f:\n                    self.assert_equal(rv.data, f.read())\n                self.assert_equal(rv.mimetype, 'text\/html')\n            # mimetypes + etag\n            self.assert_equal(len(captured), 2)\n\n        app.use_x_sendfile = True\n        with catch_warnings() as captured:\n            with app.test_request_context():\n                f = open(os.path.join(app.root_path, 'static\/index.html'))\n                rv = flask.send_file(f)\n                self.assert_equal(rv.mimetype, 'text\/html')\n                self.assert_('x-sendfile' in rv.headers)\n                self.assert_equal(rv.headers['x-sendfile'],\n                    os.path.join(app.root_path, 'static\/index.html'))\n            # mimetypes + etag\n            self.assert_equal(len(captured), 2)\n\n        app.use_x_sendfile = False\n        with app.test_request_context():\n            with catch_warnings() as captured:\n                f = StringIO('Test')\n                rv = flask.send_file(f)\n                self.assert_equal(rv.data, 'Test')\n                self.assert_equal(rv.mimetype, 'application\/octet-stream')\n            # etags\n            self.assert_equal(len(captured), 1)\n            with catch_warnings() as captured:\n                f = StringIO('Test')\n                rv = flask.send_file(f, mimetype='text\/plain')\n                self.assert_equal(rv.data, 'Test')\n                self.assert_equal(rv.mimetype, 'text\/plain')\n            # etags\n            self.assert_equal(len(captured), 1)\n\n        app.use_x_sendfile = True\n        with catch_warnings() as captured:\n            with app.test_request_context():\n                f = StringIO('Test')\n                rv = flask.send_file(f)\n                self.assert_('x-sendfile' not in rv.headers)\n            # etags\n            self.assert_equal(len(captured), 1)\n\n    def test_attachment(self):\n        app = flask.Flask(__name__)\n        with catch_warnings() as captured:\n            with app.test_request_context():\n                f = open(os.path.join(app.root_path, 'static\/index.html'))\n                rv = flask.send_file(f, as_attachment=True)\n                value, options = parse_options_header(rv.headers['Content-Disposition'])\n                self.assert_equal(value, 'attachment')\n            # mimetypes + etag\n            self.assert_equal(len(captured), 2)\n\n        with app.test_request_context():\n            self.assert_equal(options['filename'], 'index.html')\n            rv = flask.send_file('static\/index.html', as_attachment=True)\n            value, options = parse_options_header(rv.headers['Content-Disposition'])\n            self.assert_equal(value, 'attachment')\n            self.assert_equal(options['filename'], 'index.html')\n\n        with app.test_request_context():\n            rv = flask.send_file(StringIO('Test'), as_attachment=True,\n                                 attachment_filename='index.txt',\n                                 add_etags=False)\n            self.assert_equal(rv.mimetype, 'text\/plain')\n            value, options = parse_options_header(rv.headers['Content-Disposition'])\n            self.assert_equal(value, 'attachment')\n            self.assert_equal(options['filename'], 'index.txt')\n\n    def test_static_file(self):\n        app = flask.Flask(__name__)\n        # default cache timeout is 12 hours\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 12 * 60 * 60)\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 12 * 60 * 60)\n        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 3600\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 3600)\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 3600)\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 10)\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 10)\n\n\nclass LoggingTestCase(FlaskTestCase):\n\n    def test_logger_cache(self):\n        app = flask.Flask(__name__)\n        logger1 = app.logger\n        self.assert_(app.logger is logger1)\n        self.assert_equal(logger1.name, __name__)\n        app.logger_name = __name__ + '\/test_logger_cache'\n        self.assert_(app.logger is not logger1)\n\n    def test_debug_log(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        @app.route('\/')\n        def index():\n            app.logger.warning('the standard library is dead')\n            app.logger.debug('this is a debug statement')\n            return ''\n\n        @app.route('\/exc')\n        def exc():\n            1\/0\n\n        with app.test_client() as c:\n            with catch_stderr() as err:\n                c.get('\/')\n                out = err.getvalue()\n                self.assert_('WARNING in helpers [' in out)\n                self.assert_(os.path.basename(__file__.rsplit('.', 1)[0] + '.py') in out)\n                self.assert_('the standard library is dead' in out)\n                self.assert_('this is a debug statement' in out)\n\n            with catch_stderr() as err:\n                try:\n                    c.get('\/exc')\n                except ZeroDivisionError:\n                    pass\n                else:\n                    self.assert_(False, 'debug log ate the exception')\n\n    def test_debug_log_override(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        app.logger_name = 'flask_tests\/test_debug_log_override'\n        app.logger.level = 10\n        self.assert_equal(app.logger.level, 10)\n\n    def test_exception_logging(self):\n        out = StringIO()\n        app = flask.Flask(__name__)\n        app.logger_name = 'flask_tests\/test_exception_logging'\n        app.logger.addHandler(StreamHandler(out))\n\n        @app.route('\/')\n        def index():\n            1\/0\n\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_('Internal Server Error' in rv.data)\n\n        err = out.getvalue()\n        self.assert_('Exception on \/ [GET]' in err)\n        self.assert_('Traceback (most recent call last):' in err)\n        self.assert_('1\/0' in err)\n        self.assert_('ZeroDivisionError:' in err)\n\n    def test_processor_exceptions(self):\n        app = flask.Flask(__name__)\n        @app.before_request\n        def before_request():\n            if trigger == 'before':\n                1\/0\n        @app.after_request\n        def after_request(response):\n            if trigger == 'after':\n                1\/0\n            return response\n        @app.route('\/')\n        def index():\n            return 'Foo'\n        @app.errorhandler(500)\n        def internal_server_error(e):\n            return 'Hello Server Error', 500\n        for trigger in 'before', 'after':\n            rv = app.test_client().get('\/')\n            self.assert_equal(rv.status_code, 500)\n            self.assert_equal(rv.data, 'Hello Server Error')\n\n    def test_url_for_with_anchor(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('index', _anchor='x y'),\n                              '\/#x%20y')\n\n    def test_url_for_with_scheme(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('index',\n                                            _external=True,\n                                            _scheme='https'),\n                              'https:\/\/localhost\/')\n\n    def test_url_for_with_scheme_not_external(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            self.assert_raises(ValueError,\n                               flask.url_for,\n                               'index',\n                               _scheme='https')\n\n    def test_url_with_method(self):\n        from flask.views import MethodView\n        app = flask.Flask(__name__)\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return 'List'\n                return 'Get %d' % id\n            def post(self):\n                return 'Create'\n        myview = MyView.as_view('myview')\n        app.add_url_rule('\/myview\/', methods=['GET'],\n                         view_func=myview)\n        app.add_url_rule('\/myview\/<int:id>', methods=['GET'],\n                         view_func=myview)\n        app.add_url_rule('\/myview\/create', methods=['POST'],\n                         view_func=myview)\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('myview', _method='GET'),\n                              '\/myview\/')\n            self.assert_equal(flask.url_for('myview', id=42, _method='GET'),\n                              '\/myview\/42')\n            self.assert_equal(flask.url_for('myview', _method='POST'),\n                              '\/myview\/create')\n\n\nclass NoImportsTestCase(FlaskTestCase):\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self):\n        try:\n            flask.Flask('importerror')\n        except NotImplementedError:\n            self.fail('Flask(import_name) is importing import_name.')\n\n\nclass StreamingTestCase(FlaskTestCase):\n\n    def test_streaming_with_context(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(flask.stream_with_context(generate()))\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        self.assertEqual(rv.data, 'Hello World!')\n\n    def test_streaming_with_context_as_decorator(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            @flask.stream_with_context\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(generate())\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        self.assertEqual(rv.data, 'Hello World!')\n\n    def test_streaming_with_context_and_custom_close(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        called = []\n        class Wrapper(object):\n            def __init__(self, gen):\n                self._gen = gen\n            def __iter__(self):\n                return self\n            def close(self):\n                called.append(42)\n            def next(self):\n                return six.advance_iterator(self._gen)\n        @app.route('\/')\n        def index():\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(flask.stream_with_context(\n                Wrapper(generate())))\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        self.assertEqual(rv.data, 'Hello World!')\n        self.assertEqual(called, [42])\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    if flask.json_available:\n        suite.addTest(unittest.makeSuite(JSONTestCase))\n    suite.addTest(unittest.makeSuite(SendfileTestCase))\n    suite.addTest(unittest.makeSuite(LoggingTestCase))\n    suite.addTest(unittest.makeSuite(NoImportsTestCase))\n    suite.addTest(unittest.makeSuite(StreamingTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.regression\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Tests regressions.\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport gc\nimport sys\nimport flask\nimport threading\nimport unittest\nfrom werkzeug.exceptions import NotFound\nfrom flask.testsuite import FlaskTestCase\n\n\n_gc_lock = threading.Lock()\n\n\nclass _NoLeakAsserter(object):\n\n    def __init__(self, testcase):\n        self.testcase = testcase\n\n    def __enter__(self):\n        gc.disable()\n        _gc_lock.acquire()\n        loc = flask._request_ctx_stack._local\n\n        # Force Python to track this dictionary at all times.\n        # This is necessary since Python only starts tracking\n        # dicts if they contain mutable objects.  It's a horrible,\n        # horrible hack but makes this kinda testable.\n        loc.__storage__['FOOO'] = [1, 2, 3]\n\n        gc.collect()\n        self.old_objects = len(gc.get_objects())\n\n    def __exit__(self, exc_type, exc_value, tb):\n        if not hasattr(sys, 'getrefcount'):\n            gc.collect()\n        new_objects = len(gc.get_objects())\n        if new_objects > self.old_objects:\n            self.testcase.fail('Example code leaked')\n        _gc_lock.release()\n        gc.enable()\n\n\nclass MemoryTestCase(FlaskTestCase):\n\n    def assert_no_leak(self):\n        return _NoLeakAsserter(self)\n\n    def test_memory_consumption(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('simple_template.html', whiskey=42)\n\n        def fire():\n            with app.test_client() as c:\n                rv = c.get('\/')\n                self.assert_equal(rv.status_code, 200)\n                self.assert_equal(rv.data, '<h1>42<\/h1>')\n\n        # Trigger caches\n        fire()\n\n        # This test only works on CPython 2.7.\n        if sys.version_info >= (2, 7) and \\\n                not hasattr(sys, 'pypy_translation_info'):\n            with self.assert_no_leak():\n                for x in range(10):\n                    fire()\n\n    def test_safe_join_toplevel_pardir(self):\n        from flask.helpers import safe_join\n        with self.assert_raises(NotFound):\n            safe_join('\/foo', '..')\n\n\nclass ExceptionTestCase(FlaskTestCase):\n\n    def test_aborting(self):\n        class Foo(Exception):\n            whatever = 42\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.errorhandler(Foo)\n        def handle_foo(e):\n            return str(e.whatever)\n        @app.route('\/')\n        def index():\n            raise flask.abort(flask.redirect(flask.url_for('test')))\n        @app.route('\/test')\n        def test():\n            raise Foo()\n\n        with app.test_client() as c:\n            rv = c.get('\/')\n            self.assertEqual(rv.headers['Location'], 'http:\/\/localhost\/test')\n            rv = c.get('\/test')\n            self.assertEqual(rv.data, '42')\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    if os.environ.get('RUN_FLASK_MEMORY_TESTS') == '1':\n        suite.addTest(unittest.makeSuite(MemoryTestCase))\n    suite.addTest(unittest.makeSuite(ExceptionTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.reqctx\n    ~~~~~~~~~~~~~~~~~~~~~~\n\n    Tests the request context.\n\n    :copyright: (c) 2012 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\ntry:\n    from greenlet import greenlet\nexcept ImportError:\n    greenlet = None\nfrom flask.testsuite import FlaskTestCase\n\n\nclass RequestContextTestCase(FlaskTestCase):\n\n    def test_teardown_on_pop(self):\n        buffer = []\n        app = flask.Flask(__name__)\n        @app.teardown_request\n        def end_of_request(exception):\n            buffer.append(exception)\n\n        ctx = app.test_request_context()\n        ctx.push()\n        self.assert_equal(buffer, [])\n        ctx.pop()\n        self.assert_equal(buffer, [None])\n\n    def test_proper_test_request_context(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SERVER_NAME='localhost.localdomain:5000'\n        )\n\n        @app.route('\/')\n        def index():\n            return None\n\n        @app.route('\/', subdomain='foo')\n        def sub():\n            return None\n\n        with app.test_request_context('\/'):\n            self.assert_equal(flask.url_for('index', _external=True), 'http:\/\/localhost.localdomain:5000\/')\n\n        with app.test_request_context('\/'):\n            self.assert_equal(flask.url_for('sub', _external=True), 'http:\/\/foo.localhost.localdomain:5000\/')\n\n        try:\n            with app.test_request_context('\/', environ_overrides={'HTTP_HOST': 'localhost'}):\n                pass\n        except Exception as e:\n            self.assert_(isinstance(e, ValueError))\n            self.assert_equal(str(e), \"the server name provided \" +\n                    \"('localhost.localdomain:5000') does not match the \" + \\\n                    \"server name from the WSGI environment ('localhost')\")\n\n        try:\n            app.config.update(SERVER_NAME='localhost')\n            with app.test_request_context('\/', environ_overrides={'SERVER_NAME': 'localhost'}):\n                pass\n        except ValueError as e:\n            raise ValueError(\n                \"No ValueError exception should have been raised \\\"%s\\\"\" % e\n            )\n\n        try:\n            app.config.update(SERVER_NAME='localhost:80')\n            with app.test_request_context('\/', environ_overrides={'SERVER_NAME': 'localhost:80'}):\n                pass\n        except ValueError as e:\n            raise ValueError(\n                \"No ValueError exception should have been raised \\\"%s\\\"\" % e\n            )\n\n    def test_context_binding(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return 'Hello %s!' % flask.request.args['name']\n        @app.route('\/meh')\n        def meh():\n            return flask.request.url\n\n        with app.test_request_context('\/?name=World'):\n            self.assert_equal(index(), 'Hello World!')\n        with app.test_request_context('\/meh'):\n            self.assert_equal(meh(), 'http:\/\/localhost\/meh')\n        self.assert_(flask._request_ctx_stack.top is None)\n\n    def test_context_test(self):\n        app = flask.Flask(__name__)\n        self.assert_(not flask.request)\n        self.assert_(not flask.has_request_context())\n        ctx = app.test_request_context()\n        ctx.push()\n        try:\n            self.assert_(flask.request)\n            self.assert_(flask.has_request_context())\n        finally:\n            ctx.pop()\n\n    def test_manual_context_binding(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return 'Hello %s!' % flask.request.args['name']\n\n        ctx = app.test_request_context('\/?name=World')\n        ctx.push()\n        self.assert_equal(index(), 'Hello World!')\n        ctx.pop()\n        try:\n            index()\n        except RuntimeError:\n            pass\n        else:\n            self.assert_(0, 'expected runtime error')\n\n    def test_greenlet_context_copying(self):\n        app = flask.Flask(__name__)\n        greenlets = []\n\n        @app.route('\/')\n        def index():\n            reqctx = flask._request_ctx_stack.top.copy()\n            def g():\n                self.assert_(not flask.request)\n                self.assert_(not flask.current_app)\n                with reqctx:\n                    self.assert_(flask.request)\n                    self.assert_equal(flask.current_app, app)\n                    self.assert_equal(flask.request.path, '\/')\n                    self.assert_equal(flask.request.args['foo'], 'bar')\n                self.assert_(not flask.request)\n                return 42\n            greenlets.append(greenlet(g))\n            return 'Hello World!'\n\n        rv = app.test_client().get('\/?foo=bar')\n        self.assert_equal(rv.data, 'Hello World!')\n\n        result = greenlets[0].run()\n        self.assert_equal(result, 42)\n\n    def test_greenlet_context_copying_api(self):\n        app = flask.Flask(__name__)\n        greenlets = []\n\n        @app.route('\/')\n        def index():\n            reqctx = flask._request_ctx_stack.top.copy()\n            @flask.copy_current_request_context\n            def g():\n                self.assert_(flask.request)\n                self.assert_equal(flask.current_app, app)\n                self.assert_equal(flask.request.path, '\/')\n                self.assert_equal(flask.request.args['foo'], 'bar')\n                return 42\n            greenlets.append(greenlet(g))\n            return 'Hello World!'\n\n        rv = app.test_client().get('\/?foo=bar')\n        self.assert_equal(rv.data, 'Hello World!')\n\n        result = greenlets[0].run()\n        self.assert_equal(result, 42)\n\n    # Disable test if we don't have greenlets available\n    if greenlet is None:\n        test_greenlet_context_copying = None\n        test_greenlet_context_copying_api = None\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(RequestContextTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.signals\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Signalling.\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nfrom flask.testsuite import FlaskTestCase\n\n\nclass SignalsTestCase(FlaskTestCase):\n\n    def test_template_rendered(self):\n        app = flask.Flask(__name__)\n\n        @app.route('\/')\n        def index():\n            return flask.render_template('simple_template.html', whiskey=42)\n\n        recorded = []\n        def record(sender, template, context):\n            recorded.append((template, context))\n\n        flask.template_rendered.connect(record, app)\n        try:\n            app.test_client().get('\/')\n            self.assert_equal(len(recorded), 1)\n            template, context = recorded[0]\n            self.assert_equal(template.name, 'simple_template.html')\n            self.assert_equal(context['whiskey'], 42)\n        finally:\n            flask.template_rendered.disconnect(record, app)\n\n    def test_request_signals(self):\n        app = flask.Flask(__name__)\n        calls = []\n\n        def before_request_signal(sender):\n            calls.append('before-signal')\n\n        def after_request_signal(sender, response):\n            self.assert_equal(response.data, 'stuff')\n            calls.append('after-signal')\n\n        @app.before_request\n        def before_request_handler():\n            calls.append('before-handler')\n\n        @app.after_request\n        def after_request_handler(response):\n            calls.append('after-handler')\n            response.data = 'stuff'\n            return response\n\n        @app.route('\/')\n        def index():\n            calls.append('handler')\n            return 'ignored anyway'\n\n        flask.request_started.connect(before_request_signal, app)\n        flask.request_finished.connect(after_request_signal, app)\n\n        try:\n            rv = app.test_client().get('\/')\n            self.assert_equal(rv.data, 'stuff')\n\n            self.assert_equal(calls, ['before-signal', 'before-handler',\n                             'handler', 'after-handler',\n                             'after-signal'])\n        finally:\n            flask.request_started.disconnect(before_request_signal, app)\n            flask.request_finished.disconnect(after_request_signal, app)\n\n    def test_request_exception_signal(self):\n        app = flask.Flask(__name__)\n        recorded = []\n\n        @app.route('\/')\n        def index():\n            1\/0\n\n        def record(sender, exception):\n            recorded.append(exception)\n\n        flask.got_request_exception.connect(record, app)\n        try:\n            self.assert_equal(app.test_client().get('\/').status_code, 500)\n            self.assert_equal(len(recorded), 1)\n            self.assert_(isinstance(recorded[0], ZeroDivisionError))\n        finally:\n            flask.got_request_exception.disconnect(record, app)\n\n    def test_flash_signal(self):\n        app = flask.Flask(__name__)\n        app.config['SECRET_KEY'] = 'secret'\n\n        @app.route('\/')\n        def index():\n            flask.flash('This is a flash message', category='notice')\n            return flask.redirect('\/other')\n\n        recorded = []\n        def record(sender, message, category):\n            recorded.append((message, category))\n\n        flask.message_flashed.connect(record, app)\n        try:\n            client = app.test_client()\n            with client.session_transaction():\n                client.get('\/')\n                self.assert_equal(len(recorded), 1)\n                message, category = recorded[0]\n                self.assert_equal(message, 'This is a flash message')\n                self.assert_equal(category, 'notice')\n        finally:\n            flask.message_flashed.disconnect(record, app)\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    if flask.signals_available:\n        suite.addTest(unittest.makeSuite(SignalsTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.subclassing\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Test that certain behavior of flask can be customized by\n    subclasses.\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport flask\nimport unittest\nfrom logging import StreamHandler\nfrom flask.testsuite import FlaskTestCase\nfrom flask._compat import StringIO\n\n\nclass FlaskSubclassingTestCase(FlaskTestCase):\n\n    def test_suppressed_exception_logging(self):\n        class SuppressedFlask(flask.Flask):\n            def log_exception(self, exc_info):\n                pass\n\n        out = StringIO()\n        app = SuppressedFlask(__name__)\n        app.logger_name = 'flask_tests\/test_suppressed_exception_logging'\n        app.logger.addHandler(StreamHandler(out))\n\n        @app.route('\/')\n        def index():\n            1\/0\n\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_('Internal Server Error' in rv.data)\n\n        err = out.getvalue()\n        self.assert_equal(err, '')\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(FlaskSubclassingTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.templating\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nfrom flask.testsuite import FlaskTestCase\n\n\nclass TemplatingTestCase(FlaskTestCase):\n\n    def test_context_processing(self):\n        app = flask.Flask(__name__)\n        @app.context_processor\n        def context_processor():\n            return {'injected_value': 42}\n        @app.route('\/')\n        def index():\n            return flask.render_template('context_template.html', value=23)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, '<p>23|42')\n\n    def test_original_win(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template_string('{{ config }}', config=42)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, '42')\n\n    def test_request_less_rendering(self):\n        app = flask.Flask(__name__)\n        app.config['WORLD_NAME'] = 'Special World'\n        @app.context_processor\n        def context_processor():\n            return dict(foo=42)\n\n        with app.app_context():\n            rv = flask.render_template_string('Hello {{ config.WORLD_NAME }} '\n                                              '{{ foo }}')\n            self.assert_equal(rv, 'Hello Special World 42')\n\n    def test_standard_context(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'development key'\n        @app.route('\/')\n        def index():\n            flask.g.foo = 23\n            flask.session['test'] = 'aha'\n            return flask.render_template_string('''\n                {{ request.args.foo }}\n                {{ g.foo }}\n                {{ config.DEBUG }}\n                {{ session.test }}\n            ''')\n        rv = app.test_client().get('\/?foo=42')\n        self.assert_equal(rv.data.split(), ['42', '23', 'False', 'aha'])\n\n    def test_escaping(self):\n        text = '<p>Hello World!'\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('escaping_template.html', text=text,\n                                         html=flask.Markup(text))\n        lines = app.test_client().get('\/').data.splitlines()\n        self.assert_equal(lines, [\n            '&lt;p&gt;Hello World!',\n            '<p>Hello World!',\n            '<p>Hello World!',\n            '<p>Hello World!',\n            '&lt;p&gt;Hello World!',\n            '<p>Hello World!'\n        ])\n\n    def test_no_escaping(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            self.assert_equal(flask.render_template_string('{{ foo }}',\n                              foo='<test>'), '<test>')\n            self.assert_equal(flask.render_template('mail.txt', foo='<test>'),\n                              '<test> Mail')\n\n    def test_macros(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            macro = flask.get_template_attribute('_macro.html', 'hello')\n            self.assert_equal(macro('World'), 'Hello World!')\n\n    def test_template_filter(self):\n        app = flask.Flask(__name__)\n        @app.template_filter()\n        def my_reverse(s):\n            return s[::-1]\n        self.assert_('my_reverse' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_add_template_filter(self):\n        app = flask.Flask(__name__)\n        def my_reverse(s):\n            return s[::-1]\n        app.add_template_filter(my_reverse)\n        self.assert_('my_reverse' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_template_filter_with_name(self):\n        app = flask.Flask(__name__)\n        @app.template_filter('strrev')\n        def my_reverse(s):\n            return s[::-1]\n        self.assert_('strrev' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_add_template_filter_with_name(self):\n        app = flask.Flask(__name__)\n        def my_reverse(s):\n            return s[::-1]\n        app.add_template_filter(my_reverse, 'strrev')\n        self.assert_('strrev' in app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_template_filter_with_template(self):\n        app = flask.Flask(__name__)\n        @app.template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_add_template_filter_with_template(self):\n        app = flask.Flask(__name__)\n        def super_reverse(s):\n            return s[::-1]\n        app.add_template_filter(super_reverse)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_template_filter_with_name_and_template(self):\n        app = flask.Flask(__name__)\n        @app.template_filter('super_reverse')\n        def my_reverse(s):\n            return s[::-1]\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_add_template_filter_with_name_and_template(self):\n        app = flask.Flask(__name__)\n        def my_reverse(s):\n            return s[::-1]\n        app.add_template_filter(my_reverse, 'super_reverse')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, 'dcba')\n\n    def test_template_test(self):\n        app = flask.Flask(__name__)\n        @app.template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        self.assert_('boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], boolean)\n        self.assert_(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test(self):\n        app = flask.Flask(__name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        app.add_template_test(boolean)\n        self.assert_('boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], boolean)\n        self.assert_(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_name(self):\n        app = flask.Flask(__name__)\n        @app.template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        self.assert_('boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test_with_name(self):\n        app = flask.Flask(__name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app.add_template_test(is_boolean, 'boolean')\n        self.assert_('boolean' in app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_template(self):\n        app = flask.Flask(__name__)\n        @app.template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_add_template_test_with_template(self):\n        app = flask.Flask(__name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        app.add_template_test(boolean)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_template_test_with_name_and_template(self):\n        app = flask.Flask(__name__)\n        @app.template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_add_template_test_with_name_and_template(self):\n        app = flask.Flask(__name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app.add_template_test(is_boolean, 'boolean')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_('Success!' in rv.data)\n\n    def test_add_template_global(self):\n        app = flask.Flask(__name__)\n        @app.template_global()\n        def get_stuff():\n            return 42\n        self.assert_('get_stuff' in app.jinja_env.globals.keys())\n        self.assert_equal(app.jinja_env.globals['get_stuff'], get_stuff)\n        self.assert_(app.jinja_env.globals['get_stuff'](), 42)\n        with app.app_context():\n            rv = flask.render_template_string('{{ get_stuff() }}')\n            self.assert_equal(rv, '42')\n\n    def test_custom_template_loader(self):\n        class MyFlask(flask.Flask):\n            def create_global_jinja_loader(self):\n                from jinja2 import DictLoader\n                return DictLoader({'index.html': 'Hello Custom World!'})\n        app = MyFlask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('index.html')\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.data, 'Hello Custom World!')\n\n    def test_iterable_loader(self):\n        app = flask.Flask(__name__)\n        @app.context_processor\n        def context_processor():\n            return {'whiskey': 'Jameson'}\n        @app.route('\/')\n        def index():\n            return flask.render_template(\n                ['no_template.xml', # should skip this one\n                'simple_template.html', # should render this\n                'context_template.html'],\n                value=23)\n\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, '<h1>Jameson<\/h1>')\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(TemplatingTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.testing\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Test client and more.\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nfrom flask.testsuite import FlaskTestCase\nimport six\n\n\nclass TestToolsTestCase(FlaskTestCase):\n\n    def test_environ_defaults_from_config(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.config['SERVER_NAME'] = 'example.com:1234'\n        app.config['APPLICATION_ROOT'] = '\/foo'\n        @app.route('\/')\n        def index():\n            return flask.request.url\n\n        ctx = app.test_request_context()\n        self.assert_equal(ctx.request.url, 'http:\/\/example.com:1234\/foo\/')\n        with app.test_client() as c:\n            rv = c.get('\/')\n            self.assert_equal(rv.data, 'http:\/\/example.com:1234\/foo\/')\n\n    def test_environ_defaults(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            return flask.request.url\n\n        ctx = app.test_request_context()\n        self.assert_equal(ctx.request.url, 'http:\/\/localhost\/')\n        with app.test_client() as c:\n            rv = c.get('\/')\n            self.assert_equal(rv.data, 'http:\/\/localhost\/')\n\n    def test_redirect_keep_session(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'testing'\n\n        @app.route('\/', methods=['GET', 'POST'])\n        def index():\n            if flask.request.method == 'POST':\n                return flask.redirect('\/getsession')\n            flask.session['data'] = 'foo'\n            return 'index'\n\n        @app.route('\/getsession')\n        def get_session():\n            return flask.session.get('data', '<missing>')\n\n        with app.test_client() as c:\n            rv = c.get('\/getsession')\n            assert rv.data == '<missing>'\n\n            rv = c.get('\/')\n            assert rv.data == 'index'\n            assert flask.session.get('data') == 'foo'\n            rv = c.post('\/', data={}, follow_redirects=True)\n            assert rv.data == 'foo'\n\n            # This support requires a new Werkzeug version\n            if not hasattr(c, 'redirect_client'):\n                assert flask.session.get('data') == 'foo'\n\n            rv = c.get('\/getsession')\n            assert rv.data == 'foo'\n\n    def test_session_transactions(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.secret_key = 'testing'\n\n        @app.route('\/')\n        def index():\n            return six.text_type(flask.session['foo'])\n\n        with app.test_client() as c:\n            with c.session_transaction() as sess:\n                self.assert_equal(len(sess), 0)\n                sess['foo'] = [42]\n                self.assert_equal(len(sess), 1)\n            rv = c.get('\/')\n            self.assert_equal(rv.data, '[42]')\n            with c.session_transaction() as sess:\n                self.assert_equal(len(sess), 1)\n                self.assert_equal(sess['foo'], [42])\n\n    def test_session_transactions_no_null_sessions(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n\n        with app.test_client() as c:\n            try:\n                with c.session_transaction() as sess:\n                    pass\n            except RuntimeError as e:\n                self.assert_('Session backend did not open a session' in str(e))\n            else:\n                self.fail('Expected runtime error')\n\n    def test_session_transactions_keep_context(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.secret_key = 'testing'\n\n        with app.test_client() as c:\n            rv = c.get('\/')\n            req = flask.request._get_current_object()\n            self.assert_(req is not None)\n            with c.session_transaction():\n                self.assert_(req is flask.request._get_current_object())\n\n    def test_session_transaction_needs_cookies(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        c = app.test_client(use_cookies=False)\n        try:\n            with c.session_transaction() as s:\n                pass\n        except RuntimeError as e:\n            self.assert_('cookies' in str(e))\n        else:\n            self.fail('Expected runtime error')\n\n    def test_test_client_context_binding(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            flask.g.value = 42\n            return 'Hello World!'\n\n        @app.route('\/other')\n        def other():\n            1\/0\n\n        with app.test_client() as c:\n            resp = c.get('\/')\n            self.assert_equal(flask.g.value, 42)\n            self.assert_equal(resp.data, 'Hello World!')\n            self.assert_equal(resp.status_code, 200)\n\n            resp = c.get('\/other')\n            self.assert_(not hasattr(flask.g, 'value'))\n            self.assert_('Internal Server Error' in resp.data)\n            self.assert_equal(resp.status_code, 500)\n            flask.g.value = 23\n\n        try:\n            flask.g.value\n        except (AttributeError, RuntimeError):\n            pass\n        else:\n            raise AssertionError('some kind of exception expected')\n\n    def test_reuse_client(self):\n        app = flask.Flask(__name__)\n        c = app.test_client()\n\n        with c:\n            self.assert_equal(c.get('\/').status_code, 404)\n\n        with c:\n            self.assert_equal(c.get('\/').status_code, 404)\n\n    def test_test_client_calls_teardown_handlers(self):\n        app = flask.Flask(__name__)\n        called = []\n        @app.teardown_request\n        def remember(error):\n            called.append(error)\n\n        with app.test_client() as c:\n            self.assert_equal(called, [])\n            c.get('\/')\n            self.assert_equal(called, [])\n        self.assert_equal(called, [None])\n\n        del called[:]\n        with app.test_client() as c:\n            self.assert_equal(called, [])\n            c.get('\/')\n            self.assert_equal(called, [])\n            c.get('\/')\n            self.assert_equal(called, [None])\n        self.assert_equal(called, [None, None])\n\n\nclass SubdomainTestCase(FlaskTestCase):\n\n    def setUp(self):\n        self.app = flask.Flask(__name__)\n        self.app.config['SERVER_NAME'] = 'example.com'\n        self.client = self.app.test_client()\n\n        self._ctx = self.app.test_request_context()\n        self._ctx.push()\n\n    def tearDown(self):\n        if self._ctx is not None:\n            self._ctx.pop()\n\n    def test_subdomain(self):\n        @self.app.route('\/', subdomain='<company_id>')\n        def view(company_id):\n            return company_id\n\n        url = flask.url_for('view', company_id='xxx')\n        response = self.client.get(url)\n\n        self.assertEquals(200, response.status_code)\n        self.assertEquals('xxx', response.data)\n\n\n    def test_nosubdomain(self):\n        @self.app.route('\/<company_id>')\n        def view(company_id):\n            return company_id\n\n        url = flask.url_for('view', company_id='xxx')\n        response = self.client.get(url)\n\n        self.assertEquals(200, response.status_code)\n        self.assertEquals('xxx', response.data)\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(TestToolsTestCase))\n    suite.addTest(unittest.makeSuite(SubdomainTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: ported some more stuff to py 3.3\n\nremoved init_jinja_globals hack from app.py after consulting mitsuhiko\n(didn't work on py 3.3 \"as is\")\n\nremoved with_statement future imports, not needed any more\n\nneeds more work on 2.7 as well as on 3.3\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.views\n    ~~~~~~~~~~~~~~~~~~~~~\n\n    Pluggable views.\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport flask.views\nimport unittest\nfrom flask.testsuite import FlaskTestCase\nfrom werkzeug.http import parse_set_header\n\nclass ViewTestCase(FlaskTestCase):\n\n    def common_test(self, app):\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/').data, 'GET')\n        self.assert_equal(c.post('\/').data, 'POST')\n        self.assert_equal(c.put('\/').status_code, 405)\n        meths = parse_set_header(c.open('\/', method='OPTIONS').headers['Allow'])\n        self.assert_equal(sorted(meths), ['GET', 'HEAD', 'OPTIONS', 'POST'])\n\n    def test_basic_view(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.View):\n            methods = ['GET', 'POST']\n            def dispatch_request(self):\n                return flask.request.method\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n        self.common_test(app)\n\n    def test_method_based_view(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.MethodView):\n            def get(self):\n                return 'GET'\n            def post(self):\n                return 'POST'\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n        self.common_test(app)\n\n    def test_view_patching(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.MethodView):\n            def get(self):\n                1\/0\n            def post(self):\n                1\/0\n\n        class Other(Index):\n            def get(self):\n                return 'GET'\n            def post(self):\n                return 'POST'\n\n        view = Index.as_view('index')\n        view.view_class = Other\n        app.add_url_rule('\/', view_func=view)\n        self.common_test(app)\n\n    def test_view_inheritance(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.MethodView):\n            def get(self):\n                return 'GET'\n            def post(self):\n                return 'POST'\n\n        class BetterIndex(Index):\n            def delete(self):\n                return 'DELETE'\n\n        app.add_url_rule('\/', view_func=BetterIndex.as_view('index'))\n        c = app.test_client()\n\n        meths = parse_set_header(c.open('\/', method='OPTIONS').headers['Allow'])\n        self.assert_equal(sorted(meths), ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST'])\n\n    def test_view_decorators(self):\n        app = flask.Flask(__name__)\n\n        def add_x_parachute(f):\n            def new_function(*args, **kwargs):\n                resp = flask.make_response(f(*args, **kwargs))\n                resp.headers['X-Parachute'] = 'awesome'\n                return resp\n            return new_function\n\n        class Index(flask.views.View):\n            decorators = [add_x_parachute]\n            def dispatch_request(self):\n                return 'Awesome'\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.headers['X-Parachute'], 'awesome')\n        self.assert_equal(rv.data, 'Awesome')\n\n    def test_implicit_head(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.MethodView):\n            def get(self):\n                return flask.Response('Blub', headers={\n                    'X-Method': flask.request.method\n                })\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.data, 'Blub')\n        self.assert_equal(rv.headers['X-Method'], 'GET')\n        rv = c.head('\/')\n        self.assert_equal(rv.data, '')\n        self.assert_equal(rv.headers['X-Method'], 'HEAD')\n\n    def test_explicit_head(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.MethodView):\n            def get(self):\n                return 'GET'\n            def head(self):\n                return flask.Response('', headers={'X-Method': 'HEAD'})\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.data, 'GET')\n        rv = c.head('\/')\n        self.assert_equal(rv.data, '')\n        self.assert_equal(rv.headers['X-Method'], 'HEAD')\n\n    def test_endpoint_override(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        class Index(flask.views.View):\n            methods = ['GET', 'POST']\n            def dispatch_request(self):\n                return flask.request.method\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n        with self.assert_raises(AssertionError):\n            app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n        # But these tests should still pass. We just log a warning.\n        self.common_test(app)\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(ViewTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: fix minitwit\/flaskr test errors, improve docs about file open mode\n\napp.open_resource needs to get called with the correct mode param (python3\nwill read bytes [not str] if the wrong mode is used), add mode param docs.\n\nrv.data is bytes, fix the data type we compare it with to be also bytes\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr Tests\n    ~~~~~~~~~~~~\n\n    Tests the Flaskr application.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport os\nimport flaskr\nimport unittest\nimport tempfile\n\n\nclass FlaskrTestCase(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Before each test, set up a blank database\"\"\"\n        self.db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()\n        flaskr.app.config['TESTING'] = True\n        self.app = flaskr.app.test_client()\n        flaskr.init_db()\n\n    def tearDown(self):\n        \"\"\"Get rid of the database again after each test.\"\"\"\n        os.close(self.db_fd)\n        os.unlink(flaskr.app.config['DATABASE'])\n\n    def login(self, username, password):\n        return self.app.post('\/login', data=dict(\n            username=username,\n            password=password\n        ), follow_redirects=True)\n\n    def logout(self):\n        return self.app.get('\/logout', follow_redirects=True)\n\n    # testing functions\n\n    def test_empty_db(self):\n        \"\"\"Start with a blank database.\"\"\"\n        rv = self.app.get('\/')\n        assert b'No entries here so far' in rv.data\n\n    def test_login_logout(self):\n        \"\"\"Make sure login and logout works\"\"\"\n        rv = self.login(flaskr.app.config['USERNAME'],\n                        flaskr.app.config['PASSWORD'])\n        assert b'You were logged in' in rv.data\n        rv = self.logout()\n        assert b'You were logged out' in rv.data\n        rv = self.login(flaskr.app.config['USERNAME'] + 'x',\n                        flaskr.app.config['PASSWORD'])\n        assert b'Invalid username' in rv.data\n        rv = self.login(flaskr.app.config['USERNAME'],\n                        flaskr.app.config['PASSWORD'] + 'x')\n        assert b'Invalid password' in rv.data\n\n    def test_messages(self):\n        \"\"\"Test that messages work\"\"\"\n        self.login(flaskr.app.config['USERNAME'],\n                   flaskr.app.config['PASSWORD'])\n        rv = self.app.post('\/add', data=dict(\n            title='<Hello>',\n            text='<strong>HTML<\/strong> allowed here'\n        ), follow_redirects=True)\n        assert b'No entries here so far' not in rv.data\n        assert b'&lt;Hello&gt;' in rv.data\n        assert b'<strong>HTML<\/strong> allowed here' in rv.data\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit\n    ~~~~~~~~\n\n    A microblogging application written with Flask and sqlite3.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport time\nfrom sqlite3 import dbapi2 as sqlite3\nfrom hashlib import md5\nfrom datetime import datetime\nfrom flask import Flask, request, session, url_for, redirect, \\\n     render_template, abort, g, flash, _app_ctx_stack\nfrom werkzeug import check_password_hash, generate_password_hash\n\n\n# configuration\nDATABASE = '\/tmp\/minitwit.db'\nPER_PAGE = 30\nDEBUG = True\nSECRET_KEY = 'development key'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('MINITWIT_SETTINGS', silent=True)\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        top.sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        top.sqlite_db.row_factory = sqlite3.Row\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_database(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef query_db(query, args=(), one=False):\n    \"\"\"Queries the database and returns a list of dictionaries.\"\"\"\n    cur = get_db().execute(query, args)\n    rv = cur.fetchall()\n    return (rv[0] if rv else None) if one else rv\n\n\ndef get_user_id(username):\n    \"\"\"Convenience method to look up the id for a username.\"\"\"\n    rv = query_db('select user_id from user where username = ?',\n                  [username], one=True)\n    return rv[0] if rv else None\n\n\ndef format_datetime(timestamp):\n    \"\"\"Format a timestamp for display.\"\"\"\n    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')\n\n\ndef gravatar_url(email, size=80):\n    \"\"\"Return the gravatar image for the given email address.\"\"\"\n    return 'http:\/\/www.gravatar.com\/avatar\/%s?d=identicon&s=%d' % \\\n        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)\n\n\n@app.before_request\ndef before_request():\n    g.user = None\n    if 'user_id' in session:\n        g.user = query_db('select * from user where user_id = ?',\n                          [session['user_id']], one=True)\n\n\n@app.route('\/')\ndef timeline():\n    \"\"\"Shows a users timeline or if no user is logged in it will\n    redirect to the public timeline.  This timeline shows the user's\n    messages as well as all the messages of followed users.\n    \"\"\"\n    if not g.user:\n        return redirect(url_for('public_timeline'))\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id and (\n            user.user_id = ? or\n            user.user_id in (select whom_id from follower\n                                    where who_id = ?))\n        order by message.pub_date desc limit ?''',\n        [session['user_id'], session['user_id'], PER_PAGE]))\n\n\n@app.route('\/public')\ndef public_timeline():\n    \"\"\"Displays the latest messages of all users.\"\"\"\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id\n        order by message.pub_date desc limit ?''', [PER_PAGE]))\n\n\n@app.route('\/<username>')\ndef user_timeline(username):\n    \"\"\"Display's a users tweets.\"\"\"\n    profile_user = query_db('select * from user where username = ?',\n                            [username], one=True)\n    if profile_user is None:\n        abort(404)\n    followed = False\n    if g.user:\n        followed = query_db('''select 1 from follower where\n            follower.who_id = ? and follower.whom_id = ?''',\n            [session['user_id'], profile_user['user_id']],\n            one=True) is not None\n    return render_template('timeline.html', messages=query_db('''\n            select message.*, user.* from message, user where\n            user.user_id = message.author_id and user.user_id = ?\n            order by message.pub_date desc limit ?''',\n            [profile_user['user_id'], PER_PAGE]), followed=followed,\n            profile_user=profile_user)\n\n\n@app.route('\/<username>\/follow')\ndef follow_user(username):\n    \"\"\"Adds the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    db = get_db()\n    db.execute('insert into follower (who_id, whom_id) values (?, ?)',\n              [session['user_id'], whom_id])\n    db.commit()\n    flash('You are now following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/<username>\/unfollow')\ndef unfollow_user(username):\n    \"\"\"Removes the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    db = get_db()\n    db.execute('delete from follower where who_id=? and whom_id=?',\n              [session['user_id'], whom_id])\n    db.commit()\n    flash('You are no longer following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/add_message', methods=['POST'])\ndef add_message():\n    \"\"\"Registers a new message for the user.\"\"\"\n    if 'user_id' not in session:\n        abort(401)\n    if request.form['text']:\n        db = get_db()\n        db.execute('''insert into message (author_id, text, pub_date)\n          values (?, ?, ?)''', (session['user_id'], request.form['text'],\n                                int(time.time())))\n        db.commit()\n        flash('Your message was recorded')\n    return redirect(url_for('timeline'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    \"\"\"Logs the user in.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        user = query_db('''select * from user where\n            username = ?''', [request.form['username']], one=True)\n        if user is None:\n            error = 'Invalid username'\n        elif not check_password_hash(user['pw_hash'],\n                                     request.form['password']):\n            error = 'Invalid password'\n        else:\n            flash('You were logged in')\n            session['user_id'] = user['user_id']\n            return redirect(url_for('timeline'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/register', methods=['GET', 'POST'])\ndef register():\n    \"\"\"Registers the user.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        if not request.form['username']:\n            error = 'You have to enter a username'\n        elif not request.form['email'] or \\\n                 '@' not in request.form['email']:\n            error = 'You have to enter a valid email address'\n        elif not request.form['password']:\n            error = 'You have to enter a password'\n        elif request.form['password'] != request.form['password2']:\n            error = 'The two passwords do not match'\n        elif get_user_id(request.form['username']) is not None:\n            error = 'The username is already taken'\n        else:\n            db = get_db()\n            db.execute('''insert into user (\n              username, email, pw_hash) values (?, ?, ?)''',\n              [request.form['username'], request.form['email'],\n               generate_password_hash(request.form['password'])])\n            db.commit()\n            flash('You were successfully registered and can login now')\n            return redirect(url_for('login'))\n    return render_template('register.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    \"\"\"Logs the user out.\"\"\"\n    flash('You were logged out')\n    session.pop('user_id', None)\n    return redirect(url_for('public_timeline'))\n\n\n# add some filters to jinja\napp.jinja_env.filters['datetimeformat'] = format_datetime\napp.jinja_env.filters['gravatar'] = gravatar_url\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: fix minitwit\/flaskr test errors, improve docs about file open mode\n\napp.open_resource needs to get called with the correct mode param (python3\nwill read bytes [not str] if the wrong mode is used), add mode param docs.\n\nrv.data is bytes, fix the data type we compare it with to be also bytes\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit Tests\n    ~~~~~~~~~~~~~~\n\n    Tests the MiniTwit application.\n\n    :copyright: (c) 2010 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport os\nimport minitwit\nimport unittest\nimport tempfile\n\n\nclass MiniTwitTestCase(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Before each test, set up a blank database\"\"\"\n        self.db_fd, minitwit.app.config['DATABASE'] = tempfile.mkstemp()\n        self.app = minitwit.app.test_client()\n        minitwit.init_db()\n\n    def tearDown(self):\n        \"\"\"Get rid of the database again after each test.\"\"\"\n        os.close(self.db_fd)\n        os.unlink(minitwit.app.config['DATABASE'])\n\n    # helper functions\n\n    def register(self, username, password, password2=None, email=None):\n        \"\"\"Helper function to register a user\"\"\"\n        if password2 is None:\n            password2 = password\n        if email is None:\n            email = username + '@example.com'\n        return self.app.post('\/register', data={\n            'username':     username,\n            'password':     password,\n            'password2':    password2,\n            'email':        email,\n        }, follow_redirects=True)\n\n    def login(self, username, password):\n        \"\"\"Helper function to login\"\"\"\n        return self.app.post('\/login', data={\n            'username': username,\n            'password': password\n        }, follow_redirects=True)\n\n    def register_and_login(self, username, password):\n        \"\"\"Registers and logs in in one go\"\"\"\n        self.register(username, password)\n        return self.login(username, password)\n\n    def logout(self):\n        \"\"\"Helper function to logout\"\"\"\n        return self.app.get('\/logout', follow_redirects=True)\n\n    def add_message(self, text):\n        \"\"\"Records a message\"\"\"\n        rv = self.app.post('\/add_message', data={'text': text},\n                                    follow_redirects=True)\n        if text:\n            assert b'Your message was recorded' in rv.data\n        return rv\n\n    # testing functions\n\n    def test_register(self):\n        \"\"\"Make sure registering works\"\"\"\n        rv = self.register('user1', 'default')\n        assert b'You were successfully registered ' \\\n               b'and can login now' in rv.data\n        rv = self.register('user1', 'default')\n        assert b'The username is already taken' in rv.data\n        rv = self.register('', 'default')\n        assert b'You have to enter a username' in rv.data\n        rv = self.register('meh', '')\n        assert b'You have to enter a password' in rv.data\n        rv = self.register('meh', 'x', 'y')\n        assert b'The two passwords do not match' in rv.data\n        rv = self.register('meh', 'foo', email='broken')\n        assert b'You have to enter a valid email address' in rv.data\n\n    def test_login_logout(self):\n        \"\"\"Make sure logging in and logging out works\"\"\"\n        rv = self.register_and_login('user1', 'default')\n        assert b'You were logged in' in rv.data\n        rv = self.logout()\n        assert b'You were logged out' in rv.data\n        rv = self.login('user1', 'wrongpassword')\n        assert b'Invalid password' in rv.data\n        rv = self.login('user2', 'wrongpassword')\n        assert b'Invalid username' in rv.data\n\n    def test_message_recording(self):\n        \"\"\"Check if adding messages works\"\"\"\n        self.register_and_login('foo', 'default')\n        self.add_message('test message 1')\n        self.add_message('<test message 2>')\n        rv = self.app.get('\/')\n        assert b'test message 1' in rv.data\n        assert b'&lt;test message 2&gt;' in rv.data\n\n    def test_timelines(self):\n        \"\"\"Make sure that timelines work\"\"\"\n        self.register_and_login('foo', 'default')\n        self.add_message('the message by foo')\n        self.logout()\n        self.register_and_login('bar', 'default')\n        self.add_message('the message by bar')\n        rv = self.app.get('\/public')\n        assert b'the message by foo' in rv.data\n        assert b'the message by bar' in rv.data\n\n        # bar's timeline should just show bar's message\n        rv = self.app.get('\/')\n        assert b'the message by foo' not in rv.data\n        assert b'the message by bar' in rv.data\n\n        # now let's follow foo\n        rv = self.app.get('\/foo\/follow', follow_redirects=True)\n        assert b'You are now following &#34;foo&#34;' in rv.data\n\n        # we should now see foo's message\n        rv = self.app.get('\/')\n        assert b'the message by foo' in rv.data\n        assert b'the message by bar' in rv.data\n\n        # but on the user's page we only want the user's message\n        rv = self.app.get('\/bar')\n        assert b'the message by foo' not in rv.data\n        assert b'the message by bar' in rv.data\n        rv = self.app.get('\/foo')\n        assert b'the message by foo' in rv.data\n        assert b'the message by bar' not in rv.data\n\n        # now unfollow and check if that worked\n        rv = self.app.get('\/foo\/unfollow', follow_redirects=True)\n        assert b'You are no longer following &#34;foo&#34;' in rv.data\n        rv = self.app.get('\/')\n        assert b'the message by foo' not in rv.data\n        assert b'the message by bar' in rv.data\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.app\n    ~~~~~~~~~\n\n    This module implements the central WSGI application object.\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nfrom threading import Lock\nfrom datetime import timedelta\nfrom itertools import chain\nfrom functools import update_wrapper\n\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.routing import Map, Rule, RequestRedirect, BuildError\nfrom werkzeug.exceptions import HTTPException, InternalServerError, \\\n     MethodNotAllowed, BadRequest\n\nfrom .helpers import _PackageBoundObject, url_for, get_flashed_messages, \\\n    locked_cached_property, _endpoint_from_view_func, find_package\nfrom . import json\nfrom .wrappers import Request, Response\nfrom .config import ConfigAttribute, Config\nfrom .ctx import RequestContext, AppContext, _AppCtxGlobals\nfrom .globals import _request_ctx_stack, request, session, g\nfrom .sessions import SecureCookieSessionInterface\nfrom .module import blueprint_is_module\nfrom .templating import DispatchingJinjaLoader, Environment, \\\n    _default_template_ctx_processor\nfrom .signals import request_started, request_finished, got_request_exception, \\\n    request_tearing_down, appcontext_tearing_down\nfrom ._compat import reraise, string_types, integer_types\n\n# a lock used for logger initialization\n_logger_lock = Lock()\n\n\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\n\n\ndef setupmethod(f):\n    \"\"\"Wraps a method so that it performs a check in debug mode if the\n    first request was already handled.\n    \"\"\"\n    def wrapper_func(self, *args, **kwargs):\n        if self.debug and self._got_first_request:\n            raise AssertionError('A setup function was called after the '\n                'first request was handled.  This usually indicates a bug '\n                'in the application where a module was not imported '\n                'and decorators or other functionality was called too late.\\n'\n                'To fix this make sure to import all your view modules, '\n                'database models and everything related at a central place '\n                'before the application starts serving requests.')\n        return f(self, *args, **kwargs)\n    return update_wrapper(wrapper_func, f)\n\n\nclass Flask(_PackageBoundObject):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an `__init__.py` file inside) or a standard module (just a `.py` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the `__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea what\n        belongs to your application.  This name is used to find resources\n        on the file system, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in `yourapplication\/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: the folder with static files that should be served\n                          at `static_url_path`.  Defaults to the ``'static'``\n                          folder in the root path of the application.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to `True` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    \"\"\"\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class = Response\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on expected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is not application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    # Backwards compatibility support\n    def _get_request_globals_class(self):\n        return self.app_ctx_globals_class\n    def _set_request_globals_class(self, value):\n        from warnings import warn\n        warn(DeprecationWarning('request_globals_class attribute is now '\n                                'called app_ctx_globals_class'))\n        self.app_ctx_globals_class = value\n    request_globals_class = property(_get_request_globals_class,\n                                     _set_request_globals_class)\n    del _get_request_globals_class, _set_request_globals_class\n\n    #: The debug flag.  Set this to `True` to enable debugging of the\n    #: application.  In debug mode the debugger will kick in when an unhandled\n    #: exception occurs and the integrated server will automatically reload\n    #: the application if changes in the code are detected.\n    #:\n    #: This attribute can also be configured from the config with the `DEBUG`\n    #: configuration key.  Defaults to `False`.\n    debug = ConfigAttribute('DEBUG')\n\n    #: The testing flag.  Set this to `True` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate unittest helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `TESTING` configuration key.  Defaults to `False`.\n    testing = ConfigAttribute('TESTING')\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and other things.  Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `SECRET_KEY` configuration key.  Defaults to `None`.\n    secret_key = ConfigAttribute('SECRET_KEY')\n\n    #: The secure cookie uses this for the name of the session cookie.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `SESSION_COOKIE_NAME` configuration key.  Defaults to ``'session'``\n    session_cookie_name = ConfigAttribute('SESSION_COOKIE_NAME')\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `PERMANENT_SESSION_LIFETIME` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute('PERMANENT_SESSION_LIFETIME',\n        get_converter=_make_timedelta)\n\n    #: Enable this if you want to use the X-Sendfile feature.  Keep in\n    #: mind that the server has to support this.  This only affects files\n    #: sent with the :func:`send_file` method.\n    #:\n    #: .. versionadded:: 0.2\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `USE_X_SENDFILE` configuration key.  Defaults to `False`.\n    use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')\n\n    #: The name of the logger to use.  By default the logger name is the\n    #: package name passed to the constructor.\n    #:\n    #: .. versionadded:: 0.4\n    logger_name = ConfigAttribute('LOGGER_NAME')\n\n    #: Enable the deprecated module support?  This is active by default\n    #: in 0.7 but will be changed to False in 0.8.  With Flask 1.0 modules\n    #: will be removed in favor of Blueprints\n    enable_modules = True\n\n    #: The logging format used for the debug logger.  This is only used when\n    #: the application is in debug mode, otherwise the attached logging\n    #: handler does the formatting.\n    #:\n    #: .. versionadded:: 0.3\n    debug_log_format = (\n        '-' * 80 + '\\n' +\n        '%(levelname)s in %(module)s [%(pathname)s:%(lineno)d]:\\n' +\n        '%(message)s\\n' +\n        '-' * 80\n    )\n\n    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_encoder = json.JSONEncoder\n\n    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_decoder = json.JSONDecoder\n\n    #: Options that are passed directly to the Jinja2 environment.\n    jinja_options = ImmutableDict(\n        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']\n    )\n\n    #: Default configuration parameters.\n    default_config = ImmutableDict({\n        'DEBUG':                                False,\n        'TESTING':                              False,\n        'PROPAGATE_EXCEPTIONS':                 None,\n        'PRESERVE_CONTEXT_ON_EXCEPTION':        None,\n        'SECRET_KEY':                           None,\n        'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n        'USE_X_SENDFILE':                       False,\n        'LOGGER_NAME':                          None,\n        'SERVER_NAME':                          None,\n        'APPLICATION_ROOT':                     None,\n        'SESSION_COOKIE_NAME':                  'session',\n        'SESSION_COOKIE_DOMAIN':                None,\n        'SESSION_COOKIE_PATH':                  None,\n        'SESSION_COOKIE_HTTPONLY':              True,\n        'SESSION_COOKIE_SECURE':                False,\n        'MAX_CONTENT_LENGTH':                   None,\n        'SEND_FILE_MAX_AGE_DEFAULT':            12 * 60 * 60, # 12 hours\n        'TRAP_BAD_REQUEST_ERRORS':              False,\n        'TRAP_HTTP_EXCEPTIONS':                 False,\n        'PREFERRED_URL_SCHEME':                 'http',\n        'JSON_AS_ASCII':                        True\n    })\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: the test client that is used with when `test_client` is used.\n    #:\n    #: .. versionadded:: 0.7\n    test_client_class = None\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface = SecureCookieSessionInterface()\n\n    def __init__(self, import_name, static_path=None, static_url_path=None,\n                 static_folder='static', template_folder='templates',\n                 instance_path=None, instance_relative_config=False):\n        _PackageBoundObject.__init__(self, import_name,\n                                     template_folder=template_folder)\n        if static_path is not None:\n            from warnings import warn\n            warn(DeprecationWarning('static_path is now called '\n                                    'static_url_path'), stacklevel=2)\n            static_url_path = static_path\n\n        if static_url_path is not None:\n            self.static_url_path = static_url_path\n        if static_folder is not None:\n            self.static_folder = static_folder\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError('If an instance path is provided it must be '\n                             'absolute.  A relative path was given instead.')\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        # Prepare the deferred setup of the logger.\n        self._logger = None\n        self.logger_name = self.import_name\n\n        #: A dictionary of all view functions registered.  The keys will\n        #: be function names which are also used to generate URLs and\n        #: the values are the function objects themselves.\n        #: To register a view function, use the :meth:`route` decorator.\n        self.view_functions = {}\n\n        # support for the now deprecated `error_handlers` attribute.  The\n        # :attr:`error_handler_spec` shall be used now.\n        self._error_handlers = {}\n\n        #: A dictionary of all registered error handlers.  The key is `None`\n        #: for error handlers active on the application, otherwise the key is\n        #: the name of the blueprint.  Each key points to another dictionary\n        #: where they key is the status code of the http exception.  The\n        #: special key `None` points to a list of tuples where the first item\n        #: is the class for the instance check and the second the error handler\n        #: function.\n        #:\n        #: To register a error handler, use the :meth:`errorhandler`\n        #: decorator.\n        self.error_handler_spec = {None: self._error_handlers}\n\n        #: A list of functions that are called when :meth:`url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n        #: is called with `error`, `endpoint` and `values`.  If a function\n        #: returns `None` or raises a `BuildError` the next function is\n        #: tried.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers = []\n\n        #: A dictionary with lists of functions that should be called at the\n        #: beginning of the request.  The key of the dictionary is the name of\n        #: the blueprint this function is active for, `None` for all requests.\n        #: This can for example be used to open database connections or\n        #: getting hold of the currently logged in user.  To register a\n        #: function here, use the :meth:`before_request` decorator.\n        self.before_request_funcs = {}\n\n        #: A lists of functions that should be called at the beginning of the\n        #: first request to this instance.  To register a function here, use\n        #: the :meth:`before_first_request` decorator.\n        #:\n        #: .. versionadded:: 0.8\n        self.before_first_request_funcs = []\n\n        #: A dictionary with lists of functions that should be called after\n        #: each request.  The key of the dictionary is the name of the blueprint\n        #: this function is active for, `None` for all requests.  This can for\n        #: example be used to open database connections or getting hold of the\n        #: currently logged in user.  To register a function here, use the\n        #: :meth:`after_request` decorator.\n        self.after_request_funcs = {}\n\n        #: A dictionary with lists of functions that are called after\n        #: each request, even if an exception has occurred. The key of the\n        #: dictionary is the name of the blueprint this function is active for,\n        #: `None` for all requests. These functions are not allowed to modify\n        #: the request, and their return values are ignored. If an exception\n        #: occurred while processing the request, it gets passed to each\n        #: teardown_request function. To register a function here, use the\n        #: :meth:`teardown_request` decorator.\n        #:\n        #: .. versionadded:: 0.7\n        self.teardown_request_funcs = {}\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs = []\n\n        #: A dictionary with lists of functions that can be used as URL\n        #: value processor functions.  Whenever a URL is built these functions\n        #: are called to modify the dictionary of values in place.  The key\n        #: `None` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #:\n        #: .. versionadded:: 0.7\n        self.url_value_preprocessors = {}\n\n        #: A dictionary with lists of functions that can be used as URL value\n        #: preprocessors.  The key `None` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #: of URL values before they are used as the keyword arguments of the\n        #: view function.  For each function registered this one should also\n        #: provide a :meth:`url_defaults` function that adds the parameters\n        #: automatically again that were removed that way.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_default_functions = {}\n\n        #: A dictionary with list of functions that are called without argument\n        #: to populate the template context.  The key of the dictionary is the\n        #: name of the blueprint this function is active for, `None` for all\n        #: requests.  Each returns a dictionary that the template context is\n        #: updated with.  To register a function here, use the\n        #: :meth:`context_processor` decorator.\n        self.template_context_processors = {\n            None: [_default_template_ctx_processor]\n        }\n\n        #: all the attached blueprints in a directory by name.  Blueprints\n        #: can be attached multiple times so this dictionary does not tell\n        #: you how often they got attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.  For backwards compatibility extensions should register\n        #: themselves like this::\n        #:\n        #:      if not hasattr(app, 'extensions'):\n        #:          app.extensions = {}\n        #:      app.extensions['extensionname'] = SomeObject()\n        #:\n        #: The key must match the name of the `flaskext` module.  For example in\n        #: case of a \"Flask-Foo\" extension in `flaskext.foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(BaseConverter.to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = Map()\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n\n        # register the static folder for the application.  Do that even\n        # if the folder does not exist.  First of all it might be created\n        # while the server is running (usually happens during development)\n        # but also because google appengine stores static files somewhere\n        # else when mapped with the .yml file.\n        if self.has_static_folder:\n            self.add_url_rule(self.static_url_path + '\/<path:filename>',\n                              endpoint='static',\n                              view_func=self.send_static_file)\n\n    def _get_error_handlers(self):\n        from warnings import warn\n        warn(DeprecationWarning('error_handlers is deprecated, use the '\n            'new error_handler_spec attribute instead.'), stacklevel=1)\n        return self._error_handlers\n    def _set_error_handlers(self, value):\n        self._error_handlers = value\n        self.error_handler_spec[None] = value\n    error_handlers = property(_get_error_handlers, _set_error_handlers)\n    del _get_error_handlers, _set_error_handlers\n\n    @locked_cached_property\n    def name(self):\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == '__main__':\n            fn = getattr(sys.modules['__main__'], '__file__', None)\n            if fn is None:\n                return '__main__'\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @property\n    def propagate_exceptions(self):\n        \"\"\"Returns the value of the `PROPAGATE_EXCEPTIONS` configuration\n        value in case it's set, otherwise a sensible default is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PROPAGATE_EXCEPTIONS']\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n\n    @property\n    def preserve_context_on_exception(self):\n        \"\"\"Returns the value of the `PRESERVE_CONTEXT_ON_EXCEPTION`\n        configuration value in case it's set, otherwise a sensible default\n        is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PRESERVE_CONTEXT_ON_EXCEPTION']\n        if rv is not None:\n            return rv\n        return self.debug\n\n    @property\n    def logger(self):\n        \"\"\"A :class:`logging.Logger` object for this application.  The\n        default configuration is to log to stderr if the application is\n        in debug mode.  This logger can be used to (surprise) log messages.\n        Here some examples::\n\n            app.logger.debug('A value for debugging')\n            app.logger.warning('A warning occurred (%d apples)', 42)\n            app.logger.error('An error occurred')\n\n        .. versionadded:: 0.3\n        \"\"\"\n        if self._logger and self._logger.name == self.logger_name:\n            return self._logger\n        with _logger_lock:\n            if self._logger and self._logger.name == self.logger_name:\n                return self._logger\n            from flask.logging import create_logger\n            self._logger = rv = create_logger(self)\n            return rv\n\n    @locked_cached_property\n    def jinja_env(self):\n        \"\"\"The Jinja2 environment used to load templates.\"\"\"\n        return self.create_jinja_environment()\n\n    @property\n    def got_first_request(self):\n        \"\"\"This attribute is set to `True` if the application started\n        handling the first request.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        return self._got_first_request\n\n    def make_config(self, instance_relative=False):\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        return Config(root_path, self.default_config)\n\n    def auto_find_instance_path(self):\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, 'instance')\n        return os.path.join(prefix, 'var', self.name + '-instance')\n\n    def open_instance_resource(self, resource, mode='rb'):\n        \"\"\"Opens a resource from the application's instance folder\n        (:attr:`instance_path`).  Otherwise works like\n        :meth:`open_resource`.  Instance resources can also be opened for\n        writing.\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        :param mode: resource file opening mode, default is 'rb'.\n        \"\"\"\n        return open(os.path.join(self.instance_path, resource), mode)\n\n    def create_jinja_environment(self):\n        \"\"\"Creates the Jinja2 environment based on :attr:`jinja_options`\n        and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds\n        the Jinja2 globals and filters after initialization.  Override\n        this function to customize the behavior.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        options = dict(self.jinja_options)\n        if 'autoescape' not in options:\n            options['autoescape'] = self.select_jinja_autoescape\n        rv = Environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g\n        )\n        rv.filters['tojson'] = json.htmlsafe_dumps\n        return rv\n\n    def create_global_jinja_loader(self):\n        \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n\n    def init_jinja_globals(self):\n        \"\"\"Deprecated.  Used to initialize the Jinja2 globals.\n\n        .. versionadded:: 0.5\n        .. versionchanged:: 0.7\n           This method is deprecated with 0.7.  Override\n           :meth:`create_jinja_environment` instead.\n        \"\"\"\n\n    def select_jinja_autoescape(self, filename):\n        \"\"\"Returns `True` if autoescaping should be active for the given\n        template name.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return False\n        return filename.endswith(('.html', '.htm', '.xml', '.xhtml'))\n\n    def update_template_context(self, context):\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        # make sure the original values win.  This makes it possible to\n        # easier add new variables in context processors without breaking\n        # existing views.\n        context.update(orig_ctx)\n\n    def run(self, host=None, port=None, debug=None, **options):\n        \"\"\"Runs the application on a local development server.  If the\n        :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to `True` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n                     have the server available externally as well. Defaults to\n                     ``'127.0.0.1'``.\n        :param port: the port of the webserver. Defaults to ``5000``.\n        :param debug: if given, enable or disable debug mode.\n                      See :attr:`debug`.\n        :param options: the options to be forwarded to the underlying\n                        Werkzeug server.  See\n                        :func:`werkzeug.serving.run_simple` for more\n                        information.\n        \"\"\"\n        from werkzeug.serving import run_simple\n        if host is None:\n            host = '127.0.0.1'\n        if port is None:\n            port = 5000\n        if debug is not None:\n            self.debug = bool(debug)\n        options.setdefault('use_reloader', self.debug)\n        options.setdefault('use_debugger', self.debug)\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # resetted normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False\n\n    def test_client(self, use_cookies=True):\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :ref:`testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a `with` block to defer the closing down\n        of the context until the end of the `with` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('\/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for `with` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from flask.testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies)\n\n    def open_session(self, request):\n        \"\"\"Creates or opens a new session.  Default implementation stores all\n        session data in a signed cookie.  This requires that the\n        :attr:`secret_key` is set.  Instead of overriding this method\n        we recommend replacing the :class:`session_interface`.\n\n        :param request: an instance of :attr:`request_class`.\n        \"\"\"\n        return self.session_interface.open_session(self, request)\n\n    def save_session(self, session, response):\n        \"\"\"Saves the session if it needs updates.  For the default\n        implementation, check :meth:`open_session`.  Instead of overriding this\n        method we recommend replacing the :class:`session_interface`.\n\n        :param session: the session to be saved (a\n                        :class:`~werkzeug.contrib.securecookie.SecureCookie`\n                        object)\n        :param response: an instance of :attr:`response_class`\n        \"\"\"\n        return self.session_interface.save_session(self, session, response)\n\n    def make_null_session(self):\n        \"\"\"Creates a new instance of a missing session.  Instead of overriding\n        this method we recommend replacing the :class:`session_interface`.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return self.session_interface.make_null_session(self)\n\n    def register_module(self, module, **options):\n        \"\"\"Registers a module with this application.  The keyword argument\n        of this function are the same as the ones for the constructor of the\n        :class:`Module` class and will override the values of the module if\n        provided.\n\n        .. versionchanged:: 0.7\n           The module system was deprecated in favor for the blueprint\n           system.\n        \"\"\"\n        assert blueprint_is_module(module), 'register_module requires ' \\\n            'actual module objects.  Please upgrade to blueprints though.'\n        if not self.enable_modules:\n            raise RuntimeError('Module support was disabled but code '\n                'attempted to register a module named %r' % module)\n        else:\n            from warnings import warn\n            warn(DeprecationWarning('Modules are deprecated.  Upgrade to '\n                'using blueprints.  Have a look into the documentation for '\n                'more information.  If this module was registered by a '\n                'Flask-Extension upgrade the extension or contact the author '\n                'of that extension instead.  (Registered %r)' % module),\n                stacklevel=2)\n\n        self.register_blueprint(module, **options)\n\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        \"\"\"Registers a blueprint on the application.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, \\\n                'A blueprint\\'s name collision occurred between %r and ' \\\n                '%r.  Both share the same name \"%s\".  Blueprints that ' \\\n                'are created on the fly need unique names.' % \\\n                (blueprint, self.blueprints[blueprint.name], blueprint.name)\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n\n    @setupmethod\n    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n        \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n        decorator.  If a view_func is provided it will be registered with the\n        endpoint.\n\n        Basically this example::\n\n            @app.route('\/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('\/', 'index', index)\n\n        If the view_func is not provided you will need to connect the endpoint\n        to a view function like so::\n\n            app.view_functions['index'] = index\n\n        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n        to customize the behavior via subclassing you only need to change\n        this method.\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        .. versionchanged:: 0.2\n           `view_func` parameter added.\n\n        .. versionchanged:: 0.6\n           `OPTIONS` is added automatically as method.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (`GET`, `POST` etc.).  By default a rule\n                        just listens for `GET` (and implicitly `HEAD`).\n                        Starting with Flask 0.6, `OPTIONS` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options['endpoint'] = endpoint\n        methods = options.pop('methods', None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only `GET` as default.\n        if methods is None:\n            methods = getattr(view_func, 'methods', None) or ('GET',)\n        methods = set(methods)\n\n        # Methods that should always be added\n        required_methods = set(getattr(view_func, 'required_methods', ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        provide_automatic_options = getattr(view_func,\n            'provide_automatic_options', None)\n\n        if provide_automatic_options is None:\n            if 'OPTIONS' not in methods:\n                provide_automatic_options = True\n                required_methods.add('OPTIONS')\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        # due to a werkzeug bug we need to make sure that the defaults are\n        # None if they are an empty dictionary.  This should not be necessary\n        # with Werkzeug 0.7\n        options['defaults'] = options.get('defaults') or None\n\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func is not view_func:\n                raise AssertionError('View function mapping is overwriting an '\n                                     'existing endpoint function: %s' % endpoint)\n            self.view_functions[endpoint] = view_func\n\n    def route(self, rule, **options):\n        \"\"\"A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as :meth:`add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('\/')\n            def index():\n                return 'Hello World'\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (`GET`, `POST` etc.).  By default a rule\n                        just listens for `GET` (and implicitly `HEAD`).\n                        Starting with Flask 0.6, `OPTIONS` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        def decorator(f):\n            endpoint = options.pop('endpoint', None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n        return decorator\n\n    @setupmethod\n    def endpoint(self, endpoint):\n        \"\"\"A decorator to register a function as an endpoint.\n        Example::\n\n            @app.endpoint('example.endpoint')\n            def example():\n                return \"example\"\n\n        :param endpoint: the name of the endpoint\n        \"\"\"\n        def decorator(f):\n            self.view_functions[endpoint] = f\n            return f\n        return decorator\n\n    @setupmethod\n    def errorhandler(self, code_or_exception):\n        \"\"\"A decorator that is used to register a function give a given\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        You can also register a function as error handler without using\n        the :meth:`errorhandler` decorator.  The following example is\n        equivalent to the one above::\n\n            def page_not_found(error):\n                return 'This page does not exist', 404\n            app.error_handler_spec[None][404] = page_not_found\n\n        Setting error handlers via assignments to :attr:`error_handler_spec`\n        however is discouraged as it requires fiddling with nested dictionaries\n        and the special case for arbitrary exception types.\n\n        The first `None` refers to the active blueprint.  If the error\n        handler should be application wide `None` shall be used.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code: the code as integer for the handler\n        \"\"\"\n        def decorator(f):\n            self._register_error_handler(None, code_or_exception, f)\n            return f\n        return decorator\n\n    def register_error_handler(self, code_or_exception, f):\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._register_error_handler(None, code_or_exception, f)\n\n    @setupmethod\n    def _register_error_handler(self, key, code_or_exception, f):\n        if isinstance(code_or_exception, HTTPException):\n            code_or_exception = code_or_exception.code\n        if isinstance(code_or_exception, integer_types):\n            assert code_or_exception != 500 or key is None, \\\n                'It is currently not possible to register a 500 internal ' \\\n                'server error on a per-blueprint level.'\n            self.error_handler_spec.setdefault(key, {})[code_or_exception] = f\n        else:\n            self.error_handler_spec.setdefault(key, {}).setdefault(None, []) \\\n                .append((code_or_exception, f))\n\n    @setupmethod\n    def template_filter(self, name=None):\n        \"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        \"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f\n\n    @setupmethod\n    def template_test(self, name=None):\n        \"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        \"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f\n\n\n    @setupmethod\n    def template_global(self, name=None):\n        \"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        \"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f\n\n    @setupmethod\n    def before_request(self, f):\n        \"\"\"Registers a function to run before each request.\"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def before_first_request(self, f):\n        \"\"\"Registers a function to be run before the first request to this\n        instance of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.before_first_request_funcs.append(f)\n\n    @setupmethod\n    def after_request(self, f):\n        \"\"\"Register a function to be run after each request.  Your function\n        must take one parameter, a :attr:`response_class` object and return\n        a new response object or the same (see :meth:`process_response`).\n\n        As of Flask 0.7 this function might not be executed at the end of the\n        request in case an unhandled exception occurred.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_request(self, f):\n        \"\"\"Register a function to be run at the end of each request,\n        regardless of whether there was an exception or not.  These functions\n        are executed when the request context is popped, even if not an\n        actual request was performed.\n\n        Example::\n\n            ctx = app.test_request_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the request context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Generally teardown functions must take every necessary step to avoid\n        that they will fail.  If they do execute code that might fail they\n        will have to surround the execution of these code by try\/except\n        statements and log occurring errors.\n\n        When a teardown function was called because of a exception it will\n        be passed an error object.\n\n        .. admonition:: Debug Note\n\n           In debug mode Flask will not tear down a request on an exception\n           immediately.  Instead if will keep it alive so that the interactive\n           debugger can still access it.  This behavior can be controlled\n           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_appcontext(self, f):\n        \"\"\"Registers a function to be called when the application context\n        ends.  These functions are typically also called when the request\n        context is popped.\n\n        Example::\n\n            ctx = app.app_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the app context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Since a request context typically also manages an application\n        context it would also be called when you pop a request context.\n\n        When a teardown function was called because of an exception it will\n        be passed an error object.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n\n    @setupmethod\n    def context_processor(self, f):\n        \"\"\"Registers a template context processor function.\"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n\n    @setupmethod\n    def url_value_preprocessor(self, f):\n        \"\"\"Registers a function as URL value preprocessor for all view\n        functions of the application.  It's called before the view functions\n        are called and can modify the url values provided.\n        \"\"\"\n        self.url_value_preprocessors.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def url_defaults(self, f):\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n        \"\"\"\n        self.url_default_functions.setdefault(None, []).append(f)\n        return f\n\n    def handle_http_exception(self, e):\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        handlers = self.error_handler_spec.get(request.blueprint)\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n        if handlers and e.code in handlers:\n            handler = handlers[e.code]\n        else:\n            handler = self.error_handler_spec[None].get(e.code)\n        if handler is None:\n            return e\n        return handler(e)\n\n    def trap_http_exception(self, e):\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return `False` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to `True`.  It\n        also returns `True` if ``TRAP_HTTP_EXCEPTIONS`` is set to `True`.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns `True` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config['TRAP_HTTP_EXCEPTIONS']:\n            return True\n        if self.config['TRAP_BAD_REQUEST_ERRORS']:\n            return isinstance(e, BadRequest)\n        return False\n\n    def handle_user_exception(self, e):\n        \"\"\"This method is called whenever an exception occurs that should be\n        handled.  A special case are\n        :class:`~werkzeug.exception.HTTPException`\\s which are forwarded by\n        this function to the :meth:`handle_http_exception` method.  This\n        function will either return a response value or reraise the\n        exception with the same traceback.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        assert exc_value is e\n\n        # ensure not to trash sys.exc_info() at that point in case someone\n        # wants the traceback preserved in handle_http_exception.  Of course\n        # we cannot prevent users from trashing it themselves in a custom\n        # trap_http_exception method so that's their fault then.\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        blueprint_handlers = ()\n        handlers = self.error_handler_spec.get(request.blueprint)\n        if handlers is not None:\n            blueprint_handlers = handlers.get(None, ())\n        app_handlers = self.error_handler_spec[None].get(None, ())\n        for typecheck, handler in chain(blueprint_handlers, app_handlers):\n            if isinstance(e, typecheck):\n                return handler(e)\n\n        reraise(exc_type, exc_value, tb)\n\n    def handle_exception(self, e):\n        \"\"\"Default exception handling that kicks in when an exception\n        occurs that is not caught.  In debug mode the exception will\n        be re-raised immediately, otherwise it is logged and the handler\n        for a 500 internal server error is used.  If no such handler\n        exists, a default 500 internal server error message is displayed.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n\n        got_request_exception.send(self, exception=e)\n        handler = self.error_handler_spec[None].get(500)\n\n        if self.propagate_exceptions:\n            # if we want to repropagate the exception, we can attempt to\n            # raise it with the whole traceback in case we can do that\n            # (the function was actually called from the except part)\n            # otherwise, we just raise the error again\n            if exc_value is e:\n                reraise(exc_type, exc_value, tb)\n            else:\n                raise e\n\n        self.log_exception((exc_type, exc_value, tb))\n        if handler is None:\n            return InternalServerError()\n        return handler(e)\n\n    def log_exception(self, exc_info):\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error('Exception on %s [%s]' % (\n            request.path,\n            request.method\n        ), exc_info=exc_info)\n\n    def raise_routing_exception(self, request):\n        \"\"\"Exceptions that are recording during routing are reraised with\n        this method.  During debug we are not reraising redirect requests\n        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n        a different error instead to help debug situations.\n\n        :internal:\n        \"\"\"\n        if not self.debug \\\n           or not isinstance(request.routing_exception, RequestRedirect) \\\n           or request.method in ('GET', 'HEAD', 'OPTIONS'):\n            raise request.routing_exception\n\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n\n    def dispatch_request(self):\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if getattr(rule, 'provide_automatic_options', False) \\\n           and req.method == 'OPTIONS':\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        return self.view_functions[rule.endpoint](**req.view_args)\n\n    def full_dispatch_request(self):\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        response = self.make_response(rv)\n        response = self.process_response(response)\n        request_finished.send(self, response=response)\n        return response\n\n    def try_trigger_before_first_request_functions(self):\n        \"\"\"Called before each request and will ensure that it triggers\n        the :attr:`before_first_request_funcs` and only exactly once per\n        application instance (which means process usually).\n\n        :internal:\n        \"\"\"\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            self._got_first_request = True\n            for func in self.before_first_request_funcs:\n                func()\n\n    def make_default_options_response(self):\n        \"\"\"This method is called to create the default `OPTIONS` response.\n        This can be changed through subclassing to change the default\n        behavior of `OPTIONS` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        adapter = _request_ctx_stack.top.url_adapter\n        if hasattr(adapter, 'allowed_methods'):\n            methods = adapter.allowed_methods()\n        else:\n            # fallback for Werkzeug < 0.7\n            methods = []\n            try:\n                adapter.match(method='--')\n            except MethodNotAllowed as e:\n                methods = e.valid_methods\n            except HTTPException as e:\n                pass\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n\n    def make_response(self, rv):\n        \"\"\"Converts the return value from a view function to a real\n        response object that is an instance of :attr:`response_class`.\n\n        The following types are allowed for `rv`:\n\n        .. tabularcolumns:: |p{3.5cm}|p{9.5cm}|\n\n        ======================= ===========================================\n        :attr:`response_class`  the object is returned unchanged\n        :class:`str`            a response object is created with the\n                                string as body\n        :class:`unicode`        a response object is created with the\n                                string encoded to utf-8 as body\n        a WSGI function         the function is called as WSGI application\n                                and buffered as response object\n        :class:`tuple`          A tuple in the form ``(response, status,\n                                headers)`` where `response` is any of the\n                                types defined here, `status` is a string\n                                or an integer and `headers` is a list of\n                                a dictionary with header values.\n        ======================= ===========================================\n\n        :param rv: the return value from the view function\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n        status = headers = None\n        if isinstance(rv, tuple):\n            rv, status, headers = rv + (None,) * (3 - len(rv))\n\n        if rv is None:\n            raise ValueError('View function did not return a response')\n\n        if not isinstance(rv, self.response_class):\n            # When we create a response object directly, we let the constructor\n            # set the headers and status.  We do this because there can be\n            # some extra logic involved when creating these objects with\n            # specific values (like default content type selection).\n            if isinstance(rv, string_types):\n                rv = self.response_class(rv, headers=headers, status=status)\n                headers = status = None\n            else:\n                rv = self.response_class.force_type(rv, request.environ)\n\n        if status is not None:\n            if isinstance(status, string_types):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.extend(headers)\n\n        return rv\n\n    def create_url_adapter(self, request):\n        \"\"\"Creates a URL adapter for the given request.  The URL adapter\n        is created at a point where the request context is not yet set up\n        so the request is passed explicitly.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n           This can now also be called without a request object when the\n           URL adapter is created for the application context.\n        \"\"\"\n        if request is not None:\n            return self.url_map.bind_to_environ(request.environ,\n                server_name=self.config['SERVER_NAME'])\n        # We need at the very least the server name to be set for this\n        # to work.\n        if self.config['SERVER_NAME'] is not None:\n            return self.url_map.bind(\n                self.config['SERVER_NAME'],\n                script_name=self.config['APPLICATION_ROOT'] or '\/',\n                url_scheme=self.config['PREFERRED_URL_SCHEME'])\n\n    def inject_url_defaults(self, endpoint, values):\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        funcs = self.url_default_functions.get(None, ())\n        if '.' in endpoint:\n            bp = endpoint.rsplit('.', 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n\n    def handle_url_build_error(self, error, endpoint, values):\n        \"\"\"Handle :class:`~werkzeug.routing.BuildError` on :meth:`url_for`.\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n                if rv is not None:\n                    return rv\n            except BuildError as error:\n                pass\n\n        # At this point we want to reraise the exception.  If the error is\n        # still the same one we can reraise it with the original traceback,\n        # otherwise we raise it from here.\n        if error is exc_value:\n            reraise(exc_type, exc_value, tb)\n        raise error\n\n    def preprocess_request(self):\n        \"\"\"Called before the actual request dispatching and will\n        call every as :meth:`before_request` decorated function.\n        If any of these function returns a value it's handled as\n        if it was the return value from the view and further\n        request handling is stopped.\n\n        This also triggers the :meth:`url_value_processor` functions before\n        the actual :meth:`before_request` functions are called.\n        \"\"\"\n        bp = _request_ctx_stack.top.request.blueprint\n\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n\n    def process_response(self, response):\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.save_session(ctx.session, response)\n        return response\n\n    def do_teardown_request(self, exc=None):\n        \"\"\"Called after the actual request dispatching and will\n        call every as :meth:`teardown_request` decorated function.  This is\n        not actually called by the :class:`Flask` object itself but is always\n        triggered when the request context is popped.  That way we have a\n        tighter control over certain resources under testing environments.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.  Previously this was always using the\n           current exception information.\n        \"\"\"\n        if exc is None:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            rv = func(exc)\n        request_tearing_down.send(self, exc=exc)\n\n    def do_teardown_appcontext(self, exc=None):\n        \"\"\"Called when an application context is popped.  This works pretty\n        much the same as :meth:`do_teardown_request` but for the application\n        context.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is None:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n\n    def app_context(self):\n        \"\"\"Binds the application only.  For as long as the application is bound\n        to the current context the :data:`flask.current_app` points to that\n        application.  An application context is automatically created when a\n        request context is pushed if necessary.\n\n        Example usage::\n\n            with app.app_context():\n                ...\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ):\n        \"\"\"Creates a :class:`~flask.ctx.RequestContext` from the given\n        environment and binds it to the current context.  This must be used in\n        combination with the `with` statement because the request is only bound\n        to the current context for the duration of the `with` block.\n\n        Example usage::\n\n            with app.request_context(environ):\n                do_something_with(request)\n\n        The object returned can also be used without the `with` statement\n        which is useful for working in the shell.  The example above is\n        doing exactly the same as this code::\n\n            ctx = app.request_context(environ)\n            ctx.push()\n            try:\n                do_something_with(request)\n            finally:\n                ctx.pop()\n\n        .. versionchanged:: 0.3\n           Added support for non-with statement usage and `with` statement\n           is now passed the ctx object.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args, **kwargs):\n        \"\"\"Creates a WSGI environment from the given values (see\n        :func:`werkzeug.test.EnvironBuilder` for more information, this\n        function accepts the same arguments).\n        \"\"\"\n        from flask.testing import make_test_environ_builder\n        builder = make_test_environ_builder(self, *args, **kwargs)\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(self, environ, start_response):\n        \"\"\"The actual WSGI application.  This is not implemented in\n        `__call__` so that middlewares can be applied without losing a\n        reference to the class.  So instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n           The behavior of the before and after request callbacks was changed\n           under error conditions and a new callback was added that will\n           always execute at the end of the request, independent on if an\n           error occurred or not.  See :ref:`callbacks-and-errors`.\n\n        :param environ: a WSGI environment\n        :param start_response: a callable accepting a status code,\n                               a list of headers and an optional\n                               exception context to start the response\n        \"\"\"\n        with self.request_context(environ):\n            try:\n                response = self.full_dispatch_request()\n            except Exception as e:\n                response = self.make_response(self.handle_exception(e))\n            return response(environ, start_response)\n\n    @property\n    def modules(self):\n        from warnings import warn\n        warn(DeprecationWarning('Flask.modules is deprecated, use '\n                                'Flask.blueprints instead'), stacklevel=2)\n        return self.blueprints\n\n    def __call__(self, environ, start_response):\n        \"\"\"Shortcut for :attr:`wsgi_app`.\"\"\"\n        return self.wsgi_app(environ, start_response)\n\n    def __repr__(self):\n        return '<%s %r>' % (\n            self.__class__.__name__,\n            self.name,\n        )\n\n\"\"\"\nGenerate tests which test: fix typos\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.blueprints\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Blueprints (and currently modules)\n\n    :copyright: (c) 2011 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nimport warnings\nfrom flask.testsuite import FlaskTestCase, emits_module_deprecation_warning\nfrom flask._compat import text_type\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_cache_control_header\nfrom jinja2 import TemplateNotFound\n\n\n# import moduleapp here because it uses deprecated features and we don't\n# want to see the warnings\nwarnings.simplefilter('ignore', DeprecationWarning)\nfrom moduleapp import app as moduleapp\nwarnings.simplefilter('default', DeprecationWarning)\n\n\nclass ModuleTestCase(FlaskTestCase):\n\n    @emits_module_deprecation_warning\n    def test_basic_module(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.route('\/')\n        def admin_index():\n            return 'admin index'\n        @admin.route('\/login')\n        def admin_login():\n            return 'admin login'\n        @admin.route('\/logout')\n        def admin_logout():\n            return 'admin logout'\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'the index')\n        self.assert_equal(c.get('\/admin\/').data, b'admin index')\n        self.assert_equal(c.get('\/admin\/login').data, b'admin login')\n        self.assert_equal(c.get('\/admin\/logout').data, b'admin logout')\n\n    @emits_module_deprecation_warning\n    def test_default_endpoint_name(self):\n        app = flask.Flask(__name__)\n        mod = flask.Module(__name__, 'frontend')\n        def index():\n            return 'Awesome'\n        mod.add_url_rule('\/', view_func=index)\n        app.register_module(mod)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'Awesome')\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('frontend.index'), '\/')\n\n    @emits_module_deprecation_warning\n    def test_request_processing(self):\n        catched = []\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.before_request\n        def before_admin_request():\n            catched.append('before-admin')\n        @admin.after_request\n        def after_admin_request(response):\n            catched.append('after-admin')\n            return response\n        @admin.route('\/')\n        def admin_index():\n            return 'the admin'\n        @app.before_request\n        def before_request():\n            catched.append('before-app')\n        @app.after_request\n        def after_request(response):\n            catched.append('after-app')\n            return response\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/').data, b'the index')\n        self.assert_equal(catched, ['before-app', 'after-app'])\n        del catched[:]\n\n        self.assert_equal(c.get('\/admin\/').data, b'the admin')\n        self.assert_equal(catched, ['before-app', 'before-admin',\n                           'after-admin', 'after-app'])\n\n    @emits_module_deprecation_warning\n    def test_context_processors(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @app.context_processor\n        def inject_all_regular():\n            return {'a': 1}\n        @admin.context_processor\n        def inject_admin():\n            return {'b': 2}\n        @admin.app_context_processor\n        def inject_all_module():\n            return {'c': 3}\n        @app.route('\/')\n        def index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        @admin.route('\/')\n        def admin_index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'13')\n        self.assert_equal(c.get('\/admin\/').data, b'123')\n\n    @emits_module_deprecation_warning\n    def test_late_binding(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.route('\/')\n        def index():\n            return '42'\n        app.register_module(admin, url_prefix='\/admin')\n        self.assert_equal(app.test_client().get('\/admin\/').data, b'42')\n\n    @emits_module_deprecation_warning\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.app_errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @admin.app_errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @admin.route('\/')\n        def index():\n            flask.abort(404)\n        @admin.route('\/error')\n        def error():\n            1 \/\/ 0\n        app.register_module(admin)\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, b'not found')\n        rv = c.get('\/error')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_equal(b'internal server error', rv.data)\n\n    def test_templates_and_static(self):\n        app = moduleapp\n        app.testing = True\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), b'Admin File')\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), b'\/* nested file *\/')\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_true(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_safe_access(self):\n        app = moduleapp\n\n        with app.test_request_context():\n            f = app.view_functions['admin.static']\n\n            try:\n                f('\/etc\/passwd')\n            except NotFound:\n                pass\n            else:\n                self.assert_true(0, 'expected exception')\n            try:\n                f('..\/__init__.py')\n            except NotFound:\n                pass\n            else:\n                self.assert_true(0, 'expected exception')\n\n            # testcase for a security issue that may exist on windows systems\n            import os\n            import ntpath\n            old_path = os.path\n            os.path = ntpath\n            try:\n                try:\n                    f('..\\\\__init__.py')\n                except NotFound:\n                    pass\n                else:\n                    self.assert_true(0, 'expected exception')\n            finally:\n                os.path = old_path\n\n    @emits_module_deprecation_warning\n    def test_endpoint_decorator(self):\n        from werkzeug.routing import Submount, Rule\n        from flask import Module\n\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n        module = Module(__name__, __name__)\n\n        @module.endpoint('bar')\n        def bar():\n            return 'bar'\n\n        @module.endpoint('index')\n        def index():\n            return 'index'\n\n        app.register_module(module)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, b'index')\n        self.assert_equal(c.get('\/foo\/bar').data, b'bar')\n\n\nclass BlueprintTestCase(FlaskTestCase):\n\n    def test_blueprint_specific_error_handling(self):\n        frontend = flask.Blueprint('frontend', __name__)\n        backend = flask.Blueprint('backend', __name__)\n        sideend = flask.Blueprint('sideend', __name__)\n\n        @frontend.errorhandler(403)\n        def frontend_forbidden(e):\n            return 'frontend says no', 403\n\n        @frontend.route('\/frontend-no')\n        def frontend_no():\n            flask.abort(403)\n\n        @backend.errorhandler(403)\n        def backend_forbidden(e):\n            return 'backend says no', 403\n\n        @backend.route('\/backend-no')\n        def backend_no():\n            flask.abort(403)\n\n        @sideend.route('\/what-is-a-sideend')\n        def sideend_no():\n            flask.abort(403)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n        app.register_blueprint(sideend)\n\n        @app.errorhandler(403)\n        def app_forbidden(e):\n            return 'application itself says no', 403\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/frontend-no').data, b'frontend says no')\n        self.assert_equal(c.get('\/backend-no').data, b'backend says no')\n        self.assert_equal(c.get('\/what-is-a-sideend').data, b'application itself says no')\n\n    def test_blueprint_url_definitions(self):\n        bp = flask.Blueprint('test', __name__)\n\n        @bp.route('\/foo', defaults={'baz': 42})\n        def foo(bar, baz):\n            return '%s\/%d' % (bar, baz)\n\n        @bp.route('\/bar')\n        def bar(bar):\n            return text_type(bar)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/1', url_defaults={'bar': 23})\n        app.register_blueprint(bp, url_prefix='\/2', url_defaults={'bar': 19})\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/1\/foo').data, b'23\/42')\n        self.assert_equal(c.get('\/2\/foo').data, b'19\/42')\n        self.assert_equal(c.get('\/1\/bar').data, b'23')\n        self.assert_equal(c.get('\/2\/bar').data, b'19')\n\n    def test_blueprint_url_processors(self):\n        bp = flask.Blueprint('frontend', __name__, url_prefix='\/<lang_code>')\n\n        @bp.url_defaults\n        def add_language_code(endpoint, values):\n            values.setdefault('lang_code', flask.g.lang_code)\n\n        @bp.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop('lang_code')\n\n        @bp.route('\/')\n        def index():\n            return flask.url_for('.about')\n\n        @bp.route('\/about')\n        def about():\n            return flask.url_for('.index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/de\/').data, b'\/de\/about')\n        self.assert_equal(c.get('\/de\/about').data, b'\/de\/')\n\n    def test_templates_and_static(self):\n        from blueprintapp import app\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), b'Admin File')\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), b'\/* nested file *\/')\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            expected_max_age = 3600\n            if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == expected_max_age:\n                expected_max_age = 7200\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = expected_max_age\n            rv = c.get('\/admin\/static\/css\/test.css')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, expected_max_age)\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_true(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_default_static_cache_timeout(self):\n        app = flask.Flask(__name__)\n        class MyBlueprint(flask.Blueprint):\n            def get_send_file_max_age(self, filename):\n                return 100\n\n        blueprint = MyBlueprint('blueprint', __name__, static_folder='static')\n        app.register_blueprint(blueprint)\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            with app.test_request_context():\n                unexpected_max_age = 3600\n                if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == unexpected_max_age:\n                    unexpected_max_age = 7200\n                app.config['SEND_FILE_MAX_AGE_DEFAULT'] = unexpected_max_age\n                rv = blueprint.send_static_file('index.html')\n                cc = parse_cache_control_header(rv.headers['Cache-Control'])\n                self.assert_equal(cc.max_age, 100)\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n    def test_templates_list(self):\n        from blueprintapp import app\n        templates = sorted(app.jinja_env.list_templates())\n        self.assert_equal(templates, ['admin\/index.html',\n                                     'frontend\/index.html'])\n\n    def test_dotted_names(self):\n        frontend = flask.Blueprint('myapp.frontend', __name__)\n        backend = flask.Blueprint('myapp.backend', __name__)\n\n        @frontend.route('\/fe')\n        def frontend_index():\n            return flask.url_for('myapp.backend.backend_index')\n\n        @frontend.route('\/fe2')\n        def frontend_page2():\n            return flask.url_for('.frontend_index')\n\n        @backend.route('\/be')\n        def backend_index():\n            return flask.url_for('myapp.frontend.frontend_index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/fe').data.strip(), b'\/be')\n        self.assert_equal(c.get('\/fe2').data.strip(), b'\/fe')\n        self.assert_equal(c.get('\/be').data.strip(), b'\/fe')\n\n    def test_empty_url_defaults(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/', defaults={'page': 1})\n        @bp.route('\/page\/<int:page>')\n        def something(page):\n            return str(page)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'1')\n        self.assert_equal(c.get('\/page\/2').data, b'2')\n\n    def test_route_decorator_custom_endpoint(self):\n\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar', endpoint='bar')\n        def foo_bar():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/123', endpoint='123')\n        def foo_bar_foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/foo')\n        def bar_foo():\n            return flask.request.endpoint\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        @app.route('\/')\n        def index():\n            return flask.request.endpoint\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/').data, b'index')\n        self.assertEqual(c.get('\/py\/foo').data, b'bp.foo')\n        self.assertEqual(c.get('\/py\/bar').data, b'bp.bar')\n        self.assertEqual(c.get('\/py\/bar\/123').data, b'bp.123')\n        self.assertEqual(c.get('\/py\/bar\/foo').data, b'bp.bar_foo')\n\n    def test_route_decorator_custom_endpoint_with_dots(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        try:\n            @bp.route('\/bar', endpoint='bar.bar')\n            def foo_bar():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        try:\n            @bp.route('\/bar\/123', endpoint='bar.123')\n            def foo_bar_foo():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        def foo_foo_foo():\n            pass\n\n        self.assertRaises(\n            AssertionError,\n            lambda: bp.add_url_rule(\n                '\/bar\/123', endpoint='bar.123', view_func=foo_foo_foo\n            )\n        )\n\n        self.assertRaises(\n            AssertionError,\n            bp.route('\/bar\/123', endpoint='bar.123'),\n            lambda: None\n        )\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/py\/foo').data, b'bp.foo')\n        # The rule's didn't actually made it through\n        rv = c.get('\/py\/bar')\n        assert rv.status_code == 404\n        rv = c.get('\/py\/bar\/123')\n        assert rv.status_code == 404\n\n    def test_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_add_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('strrev')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_add_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'strrev')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_filter_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def super_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(super_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('super_reverse')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'super_reverse')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('is_boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['is_boolean'](False))\n\n    def test_add_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('is_boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['is_boolean'](False))\n\n    def test_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_template_test_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(BlueprintTestCase))\n    suite.addTest(unittest.makeSuite(ModuleTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr Tests\n    ~~~~~~~~~~~~\n\n    Tests the Flaskr application.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport os\nimport flaskr\nimport unittest\nimport tempfile\n\n\nclass FlaskrTestCase(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Before each test, set up a blank database\"\"\"\n        self.db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()\n        flaskr.app.config['TESTING'] = True\n        self.app = flaskr.app.test_client()\n        flaskr.init_db()\n\n    def tearDown(self):\n        \"\"\"Get rid of the database again after each test.\"\"\"\n        os.close(self.db_fd)\n        os.unlink(flaskr.app.config['DATABASE'])\n\n    def login(self, username, password):\n        return self.app.post('\/login', data=dict(\n            username=username,\n            password=password\n        ), follow_redirects=True)\n\n    def logout(self):\n        return self.app.get('\/logout', follow_redirects=True)\n\n    # testing functions\n\n    def test_empty_db(self):\n        \"\"\"Start with a blank database.\"\"\"\n        rv = self.app.get('\/')\n        assert b'No entries here so far' in rv.data\n\n    def test_login_logout(self):\n        \"\"\"Make sure login and logout works\"\"\"\n        rv = self.login(flaskr.app.config['USERNAME'],\n                        flaskr.app.config['PASSWORD'])\n        assert b'You were logged in' in rv.data\n        rv = self.logout()\n        assert b'You were logged out' in rv.data\n        rv = self.login(flaskr.app.config['USERNAME'] + 'x',\n                        flaskr.app.config['PASSWORD'])\n        assert b'Invalid username' in rv.data\n        rv = self.login(flaskr.app.config['USERNAME'],\n                        flaskr.app.config['PASSWORD'] + 'x')\n        assert b'Invalid password' in rv.data\n\n    def test_messages(self):\n        \"\"\"Test that messages work\"\"\"\n        self.login(flaskr.app.config['USERNAME'],\n                   flaskr.app.config['PASSWORD'])\n        rv = self.app.post('\/add', data=dict(\n            title='<Hello>',\n            text='<strong>HTML<\/strong> allowed here'\n        ), follow_redirects=True)\n        assert b'No entries here so far' not in rv.data\n        assert b'&lt;Hello&gt;' in rv.data\n        assert b'<strong>HTML<\/strong> allowed here' in rv.data\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit\n    ~~~~~~~~\n\n    A microblogging application written with Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport time\nfrom sqlite3 import dbapi2 as sqlite3\nfrom hashlib import md5\nfrom datetime import datetime\nfrom flask import Flask, request, session, url_for, redirect, \\\n     render_template, abort, g, flash, _app_ctx_stack\nfrom werkzeug import check_password_hash, generate_password_hash\n\n\n# configuration\nDATABASE = '\/tmp\/minitwit.db'\nPER_PAGE = 30\nDEBUG = True\nSECRET_KEY = 'development key'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('MINITWIT_SETTINGS', silent=True)\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        top.sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        top.sqlite_db.row_factory = sqlite3.Row\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_database(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef query_db(query, args=(), one=False):\n    \"\"\"Queries the database and returns a list of dictionaries.\"\"\"\n    cur = get_db().execute(query, args)\n    rv = cur.fetchall()\n    return (rv[0] if rv else None) if one else rv\n\n\ndef get_user_id(username):\n    \"\"\"Convenience method to look up the id for a username.\"\"\"\n    rv = query_db('select user_id from user where username = ?',\n                  [username], one=True)\n    return rv[0] if rv else None\n\n\ndef format_datetime(timestamp):\n    \"\"\"Format a timestamp for display.\"\"\"\n    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')\n\n\ndef gravatar_url(email, size=80):\n    \"\"\"Return the gravatar image for the given email address.\"\"\"\n    return 'http:\/\/www.gravatar.com\/avatar\/%s?d=identicon&s=%d' % \\\n        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)\n\n\n@app.before_request\ndef before_request():\n    g.user = None\n    if 'user_id' in session:\n        g.user = query_db('select * from user where user_id = ?',\n                          [session['user_id']], one=True)\n\n\n@app.route('\/')\ndef timeline():\n    \"\"\"Shows a users timeline or if no user is logged in it will\n    redirect to the public timeline.  This timeline shows the user's\n    messages as well as all the messages of followed users.\n    \"\"\"\n    if not g.user:\n        return redirect(url_for('public_timeline'))\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id and (\n            user.user_id = ? or\n            user.user_id in (select whom_id from follower\n                                    where who_id = ?))\n        order by message.pub_date desc limit ?''',\n        [session['user_id'], session['user_id'], PER_PAGE]))\n\n\n@app.route('\/public')\ndef public_timeline():\n    \"\"\"Displays the latest messages of all users.\"\"\"\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id\n        order by message.pub_date desc limit ?''', [PER_PAGE]))\n\n\n@app.route('\/<username>')\ndef user_timeline(username):\n    \"\"\"Display's a users tweets.\"\"\"\n    profile_user = query_db('select * from user where username = ?',\n                            [username], one=True)\n    if profile_user is None:\n        abort(404)\n    followed = False\n    if g.user:\n        followed = query_db('''select 1 from follower where\n            follower.who_id = ? and follower.whom_id = ?''',\n            [session['user_id'], profile_user['user_id']],\n            one=True) is not None\n    return render_template('timeline.html', messages=query_db('''\n            select message.*, user.* from message, user where\n            user.user_id = message.author_id and user.user_id = ?\n            order by message.pub_date desc limit ?''',\n            [profile_user['user_id'], PER_PAGE]), followed=followed,\n            profile_user=profile_user)\n\n\n@app.route('\/<username>\/follow')\ndef follow_user(username):\n    \"\"\"Adds the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    db = get_db()\n    db.execute('insert into follower (who_id, whom_id) values (?, ?)',\n              [session['user_id'], whom_id])\n    db.commit()\n    flash('You are now following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/<username>\/unfollow')\ndef unfollow_user(username):\n    \"\"\"Removes the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    db = get_db()\n    db.execute('delete from follower where who_id=? and whom_id=?',\n              [session['user_id'], whom_id])\n    db.commit()\n    flash('You are no longer following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/add_message', methods=['POST'])\ndef add_message():\n    \"\"\"Registers a new message for the user.\"\"\"\n    if 'user_id' not in session:\n        abort(401)\n    if request.form['text']:\n        db = get_db()\n        db.execute('''insert into message (author_id, text, pub_date)\n          values (?, ?, ?)''', (session['user_id'], request.form['text'],\n                                int(time.time())))\n        db.commit()\n        flash('Your message was recorded')\n    return redirect(url_for('timeline'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    \"\"\"Logs the user in.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        user = query_db('''select * from user where\n            username = ?''', [request.form['username']], one=True)\n        if user is None:\n            error = 'Invalid username'\n        elif not check_password_hash(user['pw_hash'],\n                                     request.form['password']):\n            error = 'Invalid password'\n        else:\n            flash('You were logged in')\n            session['user_id'] = user['user_id']\n            return redirect(url_for('timeline'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/register', methods=['GET', 'POST'])\ndef register():\n    \"\"\"Registers the user.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        if not request.form['username']:\n            error = 'You have to enter a username'\n        elif not request.form['email'] or \\\n                 '@' not in request.form['email']:\n            error = 'You have to enter a valid email address'\n        elif not request.form['password']:\n            error = 'You have to enter a password'\n        elif request.form['password'] != request.form['password2']:\n            error = 'The two passwords do not match'\n        elif get_user_id(request.form['username']) is not None:\n            error = 'The username is already taken'\n        else:\n            db = get_db()\n            db.execute('''insert into user (\n              username, email, pw_hash) values (?, ?, ?)''',\n              [request.form['username'], request.form['email'],\n               generate_password_hash(request.form['password'])])\n            db.commit()\n            flash('You were successfully registered and can login now')\n            return redirect(url_for('login'))\n    return render_template('register.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    \"\"\"Logs the user out.\"\"\"\n    flash('You were logged out')\n    session.pop('user_id', None)\n    return redirect(url_for('public_timeline'))\n\n\n# add some filters to jinja\napp.jinja_env.filters['datetimeformat'] = format_datetime\napp.jinja_env.filters['gravatar'] = gravatar_url\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit Tests\n    ~~~~~~~~~~~~~~\n\n    Tests the MiniTwit application.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport os\nimport minitwit\nimport unittest\nimport tempfile\n\n\nclass MiniTwitTestCase(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Before each test, set up a blank database\"\"\"\n        self.db_fd, minitwit.app.config['DATABASE'] = tempfile.mkstemp()\n        self.app = minitwit.app.test_client()\n        minitwit.init_db()\n\n    def tearDown(self):\n        \"\"\"Get rid of the database again after each test.\"\"\"\n        os.close(self.db_fd)\n        os.unlink(minitwit.app.config['DATABASE'])\n\n    # helper functions\n\n    def register(self, username, password, password2=None, email=None):\n        \"\"\"Helper function to register a user\"\"\"\n        if password2 is None:\n            password2 = password\n        if email is None:\n            email = username + '@example.com'\n        return self.app.post('\/register', data={\n            'username':     username,\n            'password':     password,\n            'password2':    password2,\n            'email':        email,\n        }, follow_redirects=True)\n\n    def login(self, username, password):\n        \"\"\"Helper function to login\"\"\"\n        return self.app.post('\/login', data={\n            'username': username,\n            'password': password\n        }, follow_redirects=True)\n\n    def register_and_login(self, username, password):\n        \"\"\"Registers and logs in in one go\"\"\"\n        self.register(username, password)\n        return self.login(username, password)\n\n    def logout(self):\n        \"\"\"Helper function to logout\"\"\"\n        return self.app.get('\/logout', follow_redirects=True)\n\n    def add_message(self, text):\n        \"\"\"Records a message\"\"\"\n        rv = self.app.post('\/add_message', data={'text': text},\n                                    follow_redirects=True)\n        if text:\n            assert b'Your message was recorded' in rv.data\n        return rv\n\n    # testing functions\n\n    def test_register(self):\n        \"\"\"Make sure registering works\"\"\"\n        rv = self.register('user1', 'default')\n        assert b'You were successfully registered ' \\\n               b'and can login now' in rv.data\n        rv = self.register('user1', 'default')\n        assert b'The username is already taken' in rv.data\n        rv = self.register('', 'default')\n        assert b'You have to enter a username' in rv.data\n        rv = self.register('meh', '')\n        assert b'You have to enter a password' in rv.data\n        rv = self.register('meh', 'x', 'y')\n        assert b'The two passwords do not match' in rv.data\n        rv = self.register('meh', 'foo', email='broken')\n        assert b'You have to enter a valid email address' in rv.data\n\n    def test_login_logout(self):\n        \"\"\"Make sure logging in and logging out works\"\"\"\n        rv = self.register_and_login('user1', 'default')\n        assert b'You were logged in' in rv.data\n        rv = self.logout()\n        assert b'You were logged out' in rv.data\n        rv = self.login('user1', 'wrongpassword')\n        assert b'Invalid password' in rv.data\n        rv = self.login('user2', 'wrongpassword')\n        assert b'Invalid username' in rv.data\n\n    def test_message_recording(self):\n        \"\"\"Check if adding messages works\"\"\"\n        self.register_and_login('foo', 'default')\n        self.add_message('test message 1')\n        self.add_message('<test message 2>')\n        rv = self.app.get('\/')\n        assert b'test message 1' in rv.data\n        assert b'&lt;test message 2&gt;' in rv.data\n\n    def test_timelines(self):\n        \"\"\"Make sure that timelines work\"\"\"\n        self.register_and_login('foo', 'default')\n        self.add_message('the message by foo')\n        self.logout()\n        self.register_and_login('bar', 'default')\n        self.add_message('the message by bar')\n        rv = self.app.get('\/public')\n        assert b'the message by foo' in rv.data\n        assert b'the message by bar' in rv.data\n\n        # bar's timeline should just show bar's message\n        rv = self.app.get('\/')\n        assert b'the message by foo' not in rv.data\n        assert b'the message by bar' in rv.data\n\n        # now let's follow foo\n        rv = self.app.get('\/foo\/follow', follow_redirects=True)\n        assert b'You are now following &#34;foo&#34;' in rv.data\n\n        # we should now see foo's message\n        rv = self.app.get('\/')\n        assert b'the message by foo' in rv.data\n        assert b'the message by bar' in rv.data\n\n        # but on the user's page we only want the user's message\n        rv = self.app.get('\/bar')\n        assert b'the message by foo' not in rv.data\n        assert b'the message by bar' in rv.data\n        rv = self.app.get('\/foo')\n        assert b'the message by foo' in rv.data\n        assert b'the message by bar' not in rv.data\n\n        # now unfollow and check if that worked\n        rv = self.app.get('\/foo\/unfollow', follow_redirects=True)\n        assert b'You are no longer following &#34;foo&#34;' in rv.data\n        rv = self.app.get('\/')\n        assert b'the message by foo' not in rv.data\n        assert b'the message by bar' in rv.data\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.appctx\n    ~~~~~~~~~~~~~~~~~~~~~~\n\n    Tests the application context.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nfrom flask.testsuite import FlaskTestCase\n\n\nclass AppContextTestCase(FlaskTestCase):\n\n    def test_basic_url_generation(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'localhost'\n        app.config['PREFERRED_URL_SCHEME'] = 'https'\n\n        @app.route('\/')\n        def index():\n            pass\n\n        with app.app_context():\n            rv = flask.url_for('index')\n            self.assert_equal(rv, 'https:\/\/localhost\/')\n\n    def test_url_generation_requires_server_name(self):\n        app = flask.Flask(__name__)\n        with app.app_context():\n            with self.assert_raises(RuntimeError):\n                flask.url_for('index')\n\n    def test_url_generation_without_context_fails(self):\n        with self.assert_raises(RuntimeError):\n            flask.url_for('index')\n\n    def test_request_context_means_app_context(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            self.assert_equal(flask.current_app._get_current_object(), app)\n        self.assert_equal(flask._app_ctx_stack.top, None)\n\n    def test_app_context_provides_current_app(self):\n        app = flask.Flask(__name__)\n        with app.app_context():\n            self.assert_equal(flask.current_app._get_current_object(), app)\n        self.assert_equal(flask._app_ctx_stack.top, None)\n\n    def test_app_tearing_down(self):\n        cleanup_stuff = []\n        app = flask.Flask(__name__)\n        @app.teardown_appcontext\n        def cleanup(exception):\n            cleanup_stuff.append(exception)\n\n        with app.app_context():\n            pass\n\n        self.assert_equal(cleanup_stuff, [None])\n\n    def test_app_tearing_down_with_previous_exception(self):\n        cleanup_stuff = []\n        app = flask.Flask(__name__)\n        @app.teardown_appcontext\n        def cleanup(exception):\n            cleanup_stuff.append(exception)\n\n        try:\n            raise Exception('dummy')\n        except Exception:\n            pass\n\n        with app.app_context():\n            pass\n\n        self.assert_equal(cleanup_stuff, [None])\n\n    def test_custom_app_ctx_globals_class(self):\n        class CustomRequestGlobals(object):\n            def __init__(self):\n                self.spam = 'eggs'\n        app = flask.Flask(__name__)\n        app.app_ctx_globals_class = CustomRequestGlobals\n        with app.app_context():\n            self.assert_equal(\n                flask.render_template_string('{{ g.spam }}'), 'eggs')\n\n    def test_context_refcounts(self):\n        called = []\n        app = flask.Flask(__name__)\n        @app.teardown_request\n        def teardown_req(error=None):\n            called.append('request')\n        @app.teardown_appcontext\n        def teardown_app(error=None):\n            called.append('app')\n        @app.route('\/')\n        def index():\n            with flask._app_ctx_stack.top:\n                with flask._request_ctx_stack.top:\n                    pass\n            self.assert_true(flask._request_ctx_stack.top.request.environ\n                ['werkzeug.request'] is not None)\n            return u''\n        c = app.test_client()\n        c.get('\/')\n        self.assertEqual(called, ['request', 'app'])\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(AppContextTestCase))\n    return suite\n"}
{"prompt":"Python3\n#!\/usr\/bin\/env python\n# -*- coding: utf-8 -*-\n\"\"\"\n    make-release\n    ~~~~~~~~~~~~\n\n    Helper script that performs a release.  Does pretty much everything\n    automatically for us.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport sys\nimport os\nimport re\nfrom datetime import datetime, date\nfrom subprocess import Popen, PIPE\n\n_date_clean_re = re.compile(r'(\\d+)(st|nd|rd|th)')\n\n\ndef parse_changelog():\n    with open('CHANGES') as f:\n        lineiter = iter(f)\n        for line in lineiter:\n            match = re.search('^Version\\s+(.*)', line.strip())\n            if match is None:\n                continue\n            length = len(match.group(1))\n            version = match.group(1).strip()\n            if lineiter.next().count('-') != len(match.group(0)):\n                continue\n            while 1:\n                change_info = lineiter.next().strip()\n                if change_info:\n                    break\n\n            match = re.search(r'released on (\\w+\\s+\\d+\\w+\\s+\\d+)'\n                              r'(?:, codename (.*))?(?i)', change_info)\n            if match is None:\n                continue\n\n            datestr, codename = match.groups()\n            return version, parse_date(datestr), codename\n\n\ndef bump_version(version):\n    try:\n        parts = map(int, version.split('.'))\n    except ValueError:\n        fail('Current version is not numeric')\n    parts[-1] += 1\n    return '.'.join(map(str, parts))\n\n\ndef parse_date(string):\n    string = _date_clean_re.sub(r'\\1', string)\n    return datetime.strptime(string, '%B %d %Y')\n\n\ndef set_filename_version(filename, version_number, pattern):\n    changed = []\n    def inject_version(match):\n        before, old, after = match.groups()\n        changed.append(True)\n        return before + version_number + after\n    with open(filename) as f:\n        contents = re.sub(r\"^(\\s*%s\\s*=\\s*')(.+?)(')(?sm)\" % pattern,\n                          inject_version, f.read())\n\n    if not changed:\n        fail('Could not find %s in %s', pattern, filename)\n\n    with open(filename, 'w') as f:\n        f.write(contents)\n\n\ndef set_init_version(version):\n    info('Setting __init__.py version to %s', version)\n    set_filename_version('flask\/__init__.py', version, '__version__')\n\n\ndef set_setup_version(version):\n    info('Setting setup.py version to %s', version)\n    set_filename_version('setup.py', version, 'version')\n\n\ndef build_and_upload():\n    Popen([sys.executable, 'setup.py', 'release', 'sdist', 'upload']).wait()\n\n\ndef fail(message, *args):\n    print >> sys.stderr, 'Error:', message % args\n    sys.exit(1)\n\n\ndef info(message, *args):\n    print >> sys.stderr, message % args\n\n\ndef get_git_tags():\n    return set(Popen(['git', 'tag'], stdout=PIPE).communicate()[0].splitlines())\n\n\ndef git_is_clean():\n    return Popen(['git', 'diff', '--quiet']).wait() == 0\n\n\ndef make_git_commit(message, *args):\n    message = message % args\n    Popen(['git', 'commit', '-am', message]).wait()\n\n\ndef make_git_tag(tag):\n    info('Tagging \"%s\"', tag)\n    Popen(['git', 'tag', tag]).wait()\n\n\ndef main():\n    os.chdir(os.path.join(os.path.dirname(__file__), '..'))\n\n    rv = parse_changelog()\n    if rv is None:\n        fail('Could not parse changelog')\n\n    version, release_date, codename = rv\n    dev_version = bump_version(version) + '-dev'\n\n    info('Releasing %s (codename %s, release date %s)',\n         version, codename, release_date.strftime('%d\/%m\/%Y'))\n    tags = get_git_tags()\n\n    if version in tags:\n        fail('Version \"%s\" is already tagged', version)\n    if release_date.date() != date.today():\n        fail('Release date is not today (%s != %s)')\n\n    if not git_is_clean():\n        fail('You have uncommitted changes in git')\n\n    set_init_version(version)\n    set_setup_version(version)\n    make_git_commit('Bump version number to %s', version)\n    make_git_tag(version)\n    build_and_upload()\n    set_init_version(dev_version)\n    set_setup_version(dev_version)\n\n\nif __name__ == '__main__':\n    main()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.basic\n    ~~~~~~~~~~~~~~~~~~~~~\n\n    The basic functionality.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport re\nimport uuid\nimport flask\nimport pickle\nimport unittest\nfrom datetime import datetime\nfrom threading import Thread\nfrom flask.testsuite import FlaskTestCase, emits_module_deprecation_warning\nfrom flask._compat import text_type\nfrom werkzeug.exceptions import BadRequest, NotFound\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\n\n\nclass BasicFunctionalityTestCase(FlaskTestCase):\n\n    def test_options_work(self):\n        app = flask.Flask(__name__)\n        @app.route('\/', methods=['GET', 'POST'])\n        def index():\n            return 'Hello World'\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])\n        self.assert_equal(rv.data, b'')\n\n    def test_options_on_multiple_rules(self):\n        app = flask.Flask(__name__)\n        @app.route('\/', methods=['GET', 'POST'])\n        def index():\n            return 'Hello World'\n        @app.route('\/', methods=['PUT'])\n        def index_put():\n            return 'Aha!'\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'])\n\n    def test_options_handling_disabled(self):\n        app = flask.Flask(__name__)\n        def index():\n            return 'Hello World!'\n        index.provide_automatic_options = False\n        app.route('\/')(index)\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(rv.status_code, 405)\n\n        app = flask.Flask(__name__)\n        def index2():\n            return 'Hello World!'\n        index2.provide_automatic_options = True\n        app.route('\/', methods=['OPTIONS'])(index2)\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(sorted(rv.allow), ['OPTIONS'])\n\n    def test_request_dispatching(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.request.method\n        @app.route('\/more', methods=['GET', 'POST'])\n        def more():\n            return flask.request.method\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'GET')\n        rv = c.post('\/')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS'])\n        rv = c.head('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_false(rv.data) # head truncates\n        self.assert_equal(c.post('\/more').data, b'POST')\n        self.assert_equal(c.get('\/more').data, b'GET')\n        rv = c.delete('\/more')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])\n\n    def test_url_mapping(self):\n        app = flask.Flask(__name__)\n        def index():\n            return flask.request.method\n        def more():\n            return flask.request.method\n\n        app.add_url_rule('\/', 'index', index)\n        app.add_url_rule('\/more', 'more', more, methods=['GET', 'POST'])\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'GET')\n        rv = c.post('\/')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS'])\n        rv = c.head('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_false(rv.data) # head truncates\n        self.assert_equal(c.post('\/more').data, b'POST')\n        self.assert_equal(c.get('\/more').data, b'GET')\n        rv = c.delete('\/more')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])\n\n    def test_werkzeug_routing(self):\n        from werkzeug.routing import Submount, Rule\n        app = flask.Flask(__name__)\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n        def bar():\n            return 'bar'\n        def index():\n            return 'index'\n        app.view_functions['bar'] = bar\n        app.view_functions['index'] = index\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, b'index')\n        self.assert_equal(c.get('\/foo\/bar').data, b'bar')\n\n    def test_endpoint_decorator(self):\n        from werkzeug.routing import Submount, Rule\n        app = flask.Flask(__name__)\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n\n        @app.endpoint('bar')\n        def bar():\n            return 'bar'\n\n        @app.endpoint('index')\n        def index():\n            return 'index'\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, b'index')\n        self.assert_equal(c.get('\/foo\/bar').data, b'bar')\n\n    def test_session(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n        @app.route('\/set', methods=['POST'])\n        def set():\n            flask.session['value'] = flask.request.form['value']\n            return 'value set'\n        @app.route('\/get')\n        def get():\n            return flask.session['value']\n\n        c = app.test_client()\n        self.assert_equal(c.post('\/set', data={'value': '42'}).data, b'value set')\n        self.assert_equal(c.get('\/get').data, b'42')\n\n    def test_session_using_server_name(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='example.com'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com\/')\n        self.assert_in('domain=.example.com', rv.headers['set-cookie'].lower())\n        self.assert_in('httponly', rv.headers['set-cookie'].lower())\n\n    def test_session_using_server_name_and_port(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='example.com:8080'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/')\n        self.assert_in('domain=.example.com', rv.headers['set-cookie'].lower())\n        self.assert_in('httponly', rv.headers['set-cookie'].lower())\n\n    def test_session_using_server_name_port_and_path(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='example.com:8080',\n            APPLICATION_ROOT='\/foo'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/foo')\n        self.assert_in('domain=example.com', rv.headers['set-cookie'].lower())\n        self.assert_in('path=\/foo', rv.headers['set-cookie'].lower())\n        self.assert_in('httponly', rv.headers['set-cookie'].lower())\n\n    def test_session_using_application_root(self):\n        class PrefixPathMiddleware(object):\n            def __init__(self, app, prefix):\n                self.app = app\n                self.prefix = prefix\n            def __call__(self, environ, start_response):\n                environ['SCRIPT_NAME'] = self.prefix\n                return self.app(environ, start_response)\n\n        app = flask.Flask(__name__)\n        app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, '\/bar')\n        app.config.update(\n            SECRET_KEY='foo',\n            APPLICATION_ROOT='\/bar'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/')\n        self.assert_in('path=\/bar', rv.headers['set-cookie'].lower())\n\n    def test_session_using_session_settings(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='www.example.com:8080',\n            APPLICATION_ROOT='\/test',\n            SESSION_COOKIE_DOMAIN='.example.com',\n            SESSION_COOKIE_HTTPONLY=False,\n            SESSION_COOKIE_SECURE=True,\n            SESSION_COOKIE_PATH='\/'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/www.example.com:8080\/test\/')\n        cookie = rv.headers['set-cookie'].lower()\n        self.assert_in('domain=.example.com', cookie)\n        self.assert_in('path=\/', cookie)\n        self.assert_in('secure', cookie)\n        self.assert_not_in('httponly', cookie)\n\n    def test_missing_session(self):\n        app = flask.Flask(__name__)\n        def expect_exception(f, *args, **kwargs):\n            try:\n                f(*args, **kwargs)\n            except RuntimeError as e:\n                self.assert_true(e.args and 'session is unavailable' in e.args[0])\n            else:\n                self.assert_true(False, 'expected exception')\n        with app.test_request_context():\n            self.assert_true(flask.session.get('missing_key') is None)\n            expect_exception(flask.session.__setitem__, 'foo', 42)\n            expect_exception(flask.session.pop, 'foo')\n\n    def test_session_expiration(self):\n        permanent = True\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n        @app.route('\/')\n        def index():\n            flask.session['test'] = 42\n            flask.session.permanent = permanent\n            return ''\n\n        @app.route('\/test')\n        def test():\n            return text_type(flask.session.permanent)\n\n        client = app.test_client()\n        rv = client.get('\/')\n        self.assert_in('set-cookie', rv.headers)\n        match = re.search(r'\\bexpires=([^;]+)(?i)', rv.headers['set-cookie'])\n        expires = parse_date(match.group())\n        expected = datetime.utcnow() + app.permanent_session_lifetime\n        self.assert_equal(expires.year, expected.year)\n        self.assert_equal(expires.month, expected.month)\n        self.assert_equal(expires.day, expected.day)\n\n        rv = client.get('\/test')\n        self.assert_equal(rv.data, b'True')\n\n        permanent = False\n        rv = app.test_client().get('\/')\n        self.assert_in('set-cookie', rv.headers)\n        match = re.search(r'\\bexpires=([^;]+)', rv.headers['set-cookie'])\n        self.assert_true(match is None)\n\n    def test_session_stored_last(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'development-key'\n        app.testing = True\n\n        @app.after_request\n        def modify_session(response):\n            flask.session['foo'] = 42\n            return response\n        @app.route('\/')\n        def dump_session_contents():\n            return repr(flask.session.get('foo'))\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'None')\n        self.assert_equal(c.get('\/').data, b'42')\n\n    def test_session_special_types(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'development-key'\n        app.testing = True\n        now = datetime.utcnow().replace(microsecond=0)\n        the_uuid = uuid.uuid4()\n\n        @app.after_request\n        def modify_session(response):\n            flask.session['m'] = flask.Markup('Hello!')\n            flask.session['u'] = the_uuid\n            flask.session['dt'] = now\n            flask.session['b'] = b'\\xff'\n            flask.session['t'] = (1, 2, 3)\n            return response\n\n        @app.route('\/')\n        def dump_session_contents():\n            return pickle.dumps(dict(flask.session))\n\n        c = app.test_client()\n        c.get('\/')\n        rv = pickle.loads(c.get('\/').data)\n        self.assert_equal(rv['m'], flask.Markup('Hello!'))\n        self.assert_equal(type(rv['m']), flask.Markup)\n        self.assert_equal(rv['dt'], now)\n        self.assert_equal(rv['u'], the_uuid)\n        self.assert_equal(rv['b'], b'\\xff')\n        self.assert_equal(type(rv['b']), bytes)\n        self.assert_equal(rv['t'], (1, 2, 3))\n\n    def test_flashes(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n\n        with app.test_request_context():\n            self.assert_false(flask.session.modified)\n            flask.flash('Zap')\n            flask.session.modified = False\n            flask.flash('Zip')\n            self.assert_true(flask.session.modified)\n            self.assert_equal(list(flask.get_flashed_messages()), ['Zap', 'Zip'])\n\n    def test_extended_flashing(self):\n        # Be sure app.testing=True below, else tests can fail silently.\n        #\n        # Specifically, if app.testing is not set to True, the AssertionErrors\n        # in the view functions will cause a 500 response to the test client\n        # instead of propagating exceptions.\n\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n        app.testing = True\n\n        @app.route('\/')\n        def index():\n            flask.flash(u'Hello World')\n            flask.flash(u'Hello World', 'error')\n            flask.flash(flask.Markup(u'<em>Testing<\/em>'), 'warning')\n            return ''\n\n        @app.route('\/test\/')\n        def test():\n            messages = flask.get_flashed_messages()\n            self.assert_equal(len(messages), 3)\n            self.assert_equal(messages[0], u'Hello World')\n            self.assert_equal(messages[1], u'Hello World')\n            self.assert_equal(messages[2], flask.Markup(u'<em>Testing<\/em>'))\n            return ''\n\n        @app.route('\/test_with_categories\/')\n        def test_with_categories():\n            messages = flask.get_flashed_messages(with_categories=True)\n            self.assert_equal(len(messages), 3)\n            self.assert_equal(messages[0], ('message', u'Hello World'))\n            self.assert_equal(messages[1], ('error', u'Hello World'))\n            self.assert_equal(messages[2], ('warning', flask.Markup(u'<em>Testing<\/em>')))\n            return ''\n\n        @app.route('\/test_filter\/')\n        def test_filter():\n            messages = flask.get_flashed_messages(category_filter=['message'], with_categories=True)\n            self.assert_equal(len(messages), 1)\n            self.assert_equal(messages[0], ('message', u'Hello World'))\n            return ''\n\n        @app.route('\/test_filters\/')\n        def test_filters():\n            messages = flask.get_flashed_messages(category_filter=['message', 'warning'], with_categories=True)\n            self.assert_equal(len(messages), 2)\n            self.assert_equal(messages[0], ('message', u'Hello World'))\n            self.assert_equal(messages[1], ('warning', flask.Markup(u'<em>Testing<\/em>')))\n            return ''\n\n        @app.route('\/test_filters_without_returning_categories\/')\n        def test_filters2():\n            messages = flask.get_flashed_messages(category_filter=['message', 'warning'])\n            self.assert_equal(len(messages), 2)\n            self.assert_equal(messages[0], u'Hello World')\n            self.assert_equal(messages[1], flask.Markup(u'<em>Testing<\/em>'))\n            return ''\n\n        # Create new test client on each test to clean flashed messages.\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_with_categories\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_filter\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_filters\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_filters_without_returning_categories\/')\n\n    def test_request_processing(self):\n        app = flask.Flask(__name__)\n        evts = []\n        @app.before_request\n        def before_request():\n            evts.append('before')\n        @app.after_request\n        def after_request(response):\n            response.data += b'|after'\n            evts.append('after')\n            return response\n        @app.route('\/')\n        def index():\n            self.assert_in('before', evts)\n            self.assert_not_in('after', evts)\n            return 'request'\n        self.assert_not_in('after', evts)\n        rv = app.test_client().get('\/').data\n        self.assert_in('after', evts)\n        self.assert_equal(rv, b'request|after')\n\n    def test_after_request_processing(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            @flask.after_this_request\n            def foo(response):\n                response.headers['X-Foo'] = 'a header'\n                return response\n            return 'Test'\n        c = app.test_client()\n        resp = c.get('\/')\n        self.assertEqual(resp.status_code, 200)\n        self.assertEqual(resp.headers['X-Foo'], 'a header')\n\n    def test_teardown_request_handler(self):\n        called = []\n        app = flask.Flask(__name__)\n        @app.teardown_request\n        def teardown_request(exc):\n            called.append(True)\n            return \"Ignored\"\n        @app.route('\/')\n        def root():\n            return \"Response\"\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_in(b'Response', rv.data)\n        self.assert_equal(len(called), 1)\n\n    def test_teardown_request_handler_debug_mode(self):\n        called = []\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.teardown_request\n        def teardown_request(exc):\n            called.append(True)\n            return \"Ignored\"\n        @app.route('\/')\n        def root():\n            return \"Response\"\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_in(b'Response', rv.data)\n        self.assert_equal(len(called), 1)\n\n    def test_teardown_request_handler_error(self):\n        called = []\n        app = flask.Flask(__name__)\n        @app.teardown_request\n        def teardown_request1(exc):\n            self.assert_equal(type(exc), ZeroDivisionError)\n            called.append(True)\n            # This raises a new error and blows away sys.exc_info(), so we can\n            # test that all teardown_requests get passed the same original\n            # exception.\n            try:\n                raise TypeError()\n            except:\n                pass\n        @app.teardown_request\n        def teardown_request2(exc):\n            self.assert_equal(type(exc), ZeroDivisionError)\n            called.append(True)\n            # This raises a new error and blows away sys.exc_info(), so we can\n            # test that all teardown_requests get passed the same original\n            # exception.\n            try:\n                raise TypeError()\n            except:\n                pass\n        @app.route('\/')\n        def fails():\n            1 \/\/ 0\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_in(b'Internal Server Error', rv.data)\n        self.assert_equal(len(called), 2)\n\n    def test_before_after_request_order(self):\n        called = []\n        app = flask.Flask(__name__)\n        @app.before_request\n        def before1():\n            called.append(1)\n        @app.before_request\n        def before2():\n            called.append(2)\n        @app.after_request\n        def after1(response):\n            called.append(4)\n            return response\n        @app.after_request\n        def after2(response):\n            called.append(3)\n            return response\n        @app.teardown_request\n        def finish1(exc):\n            called.append(6)\n        @app.teardown_request\n        def finish2(exc):\n            called.append(5)\n        @app.route('\/')\n        def index():\n            return '42'\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'42')\n        self.assert_equal(called, [1, 2, 3, 4, 5, 6])\n\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        @app.errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @app.errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @app.route('\/')\n        def index():\n            flask.abort(404)\n        @app.route('\/error')\n        def error():\n            1 \/\/ 0\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, b'not found')\n        rv = c.get('\/error')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_equal(b'internal server error', rv.data)\n\n    def test_before_request_and_routing_errors(self):\n        app = flask.Flask(__name__)\n        @app.before_request\n        def attach_something():\n            flask.g.something = 'value'\n        @app.errorhandler(404)\n        def return_something(error):\n            return flask.g.something, 404\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, b'value')\n\n    def test_user_error_handling(self):\n        class MyException(Exception):\n            pass\n\n        app = flask.Flask(__name__)\n        @app.errorhandler(MyException)\n        def handle_my_exception(e):\n            self.assert_true(isinstance(e, MyException))\n            return '42'\n        @app.route('\/')\n        def index():\n            raise MyException()\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'42')\n\n    def test_trapping_of_bad_request_key_errors(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/fail')\n        def fail():\n            flask.request.form['missing_key']\n        c = app.test_client()\n        self.assert_equal(c.get('\/fail').status_code, 400)\n\n        app.config['TRAP_BAD_REQUEST_ERRORS'] = True\n        c = app.test_client()\n        try:\n            c.get('\/fail')\n        except KeyError as e:\n            self.assert_true(isinstance(e, BadRequest))\n        else:\n            self.fail('Expected exception')\n\n    def test_trapping_of_all_http_exceptions(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.config['TRAP_HTTP_EXCEPTIONS'] = True\n        @app.route('\/fail')\n        def fail():\n            flask.abort(404)\n\n        c = app.test_client()\n        try:\n            c.get('\/fail')\n        except NotFound as e:\n            pass\n        else:\n            self.fail('Expected exception')\n\n    def test_enctype_debug_helper(self):\n        from flask.debughelpers import DebugFilesKeyError\n        app = flask.Flask(__name__)\n        app.debug = True\n        @app.route('\/fail', methods=['POST'])\n        def index():\n            return flask.request.files['foo'].filename\n\n        # with statement is important because we leave an exception on the\n        # stack otherwise and we want to ensure that this is not the case\n        # to not negatively affect other tests.\n        with app.test_client() as c:\n            try:\n                c.post('\/fail', data={'foo': 'index.txt'})\n            except DebugFilesKeyError as e:\n                self.assert_in('no file contents were transmitted', str(e))\n                self.assert_in('This was submitted: \"index.txt\"', str(e))\n            else:\n                self.fail('Expected exception')\n\n    def test_response_creation(self):\n        app = flask.Flask(__name__)\n        @app.route('\/unicode')\n        def from_unicode():\n            return u'H\u00e4llo W\u00f6rld'\n        @app.route('\/string')\n        def from_string():\n            return u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n        @app.route('\/args')\n        def from_tuple():\n            return 'Meh', 400, {\n                'X-Foo': 'Testing',\n                'Content-Type': 'text\/plain; charset=utf-8'\n            }\n        c = app.test_client()\n        self.assert_equal(c.get('\/unicode').data, u'H\u00e4llo W\u00f6rld'.encode('utf-8'))\n        self.assert_equal(c.get('\/string').data, u'H\u00e4llo W\u00f6rld'.encode('utf-8'))\n        rv = c.get('\/args')\n        self.assert_equal(rv.data, b'Meh')\n        self.assert_equal(rv.headers['X-Foo'], 'Testing')\n        self.assert_equal(rv.status_code, 400)\n        self.assert_equal(rv.mimetype, 'text\/plain')\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.make_response()\n            self.assert_equal(rv.status_code, 200)\n            self.assert_equal(rv.data, b'')\n            self.assert_equal(rv.mimetype, 'text\/html')\n\n            rv = flask.make_response('Awesome')\n            self.assert_equal(rv.status_code, 200)\n            self.assert_equal(rv.data, b'Awesome')\n            self.assert_equal(rv.mimetype, 'text\/html')\n\n            rv = flask.make_response('W00t', 404)\n            self.assert_equal(rv.status_code, 404)\n            self.assert_equal(rv.data, b'W00t')\n            self.assert_equal(rv.mimetype, 'text\/html')\n\n    def test_make_response_with_response_instance(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.make_response(\n                flask.jsonify({'msg': 'W00t'}), 400)\n            self.assertEqual(rv.status_code, 400)\n            self.assertEqual(rv.data, b'{\\n  \"msg\": \"W00t\"\\n}')\n            self.assertEqual(rv.mimetype, 'application\/json')\n\n            rv = flask.make_response(\n                flask.Response(''), 400)\n            self.assertEqual(rv.status_code, 400)\n            self.assertEqual(rv.data, b'')\n            self.assertEqual(rv.mimetype, 'text\/html')\n\n            rv = flask.make_response(\n                flask.Response('', headers={'Content-Type': 'text\/html'}),\n                400, [('X-Foo', 'bar')])\n            self.assertEqual(rv.status_code, 400)\n            self.assertEqual(rv.headers['Content-Type'], 'text\/html')\n            self.assertEqual(rv.headers['X-Foo'], 'bar')\n\n    def test_url_generation(self):\n        app = flask.Flask(__name__)\n        @app.route('\/hello\/<name>', methods=['POST'])\n        def hello():\n            pass\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('hello', name='test x'), '\/hello\/test%20x')\n            self.assert_equal(flask.url_for('hello', name='test x', _external=True),\n                              'http:\/\/localhost\/hello\/test%20x')\n\n    def test_build_error_handler(self):\n        app = flask.Flask(__name__)\n\n        # Test base case, a URL which results in a BuildError.\n        with app.test_request_context():\n            self.assertRaises(BuildError, flask.url_for, 'spam')\n\n        # Verify the error is re-raised if not the current exception.\n        try:\n            with app.test_request_context():\n                flask.url_for('spam')\n        except BuildError as err:\n            error = err\n        try:\n            raise RuntimeError('Test case where BuildError is not current.')\n        except RuntimeError:\n            self.assertRaises(BuildError, app.handle_url_build_error, error, 'spam', {})\n\n        # Test a custom handler.\n        def handler(error, endpoint, values):\n            # Just a test.\n            return '\/test_handler\/'\n        app.url_build_error_handlers.append(handler)\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('spam'), '\/test_handler\/')\n\n    def test_custom_converters(self):\n        from werkzeug.routing import BaseConverter\n        class ListConverter(BaseConverter):\n            def to_python(self, value):\n                return value.split(',')\n            def to_url(self, value):\n                base_to_url = super(ListConverter, self).to_url\n                return ','.join(base_to_url(x) for x in value)\n        app = flask.Flask(__name__)\n        app.url_map.converters['list'] = ListConverter\n        @app.route('\/<list:args>')\n        def index(args):\n            return '|'.join(args)\n        c = app.test_client()\n        self.assert_equal(c.get('\/1,2,3').data, b'1|2|3')\n\n    def test_static_files(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        rv = app.test_client().get('\/static\/index.html')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_equal(rv.data.strip(), b'<h1>Hello World!<\/h1>')\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('static', filename='index.html'),\n                              '\/static\/index.html')\n        rv.close()\n\n    def test_none_response(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def test():\n            return None\n        try:\n            app.test_client().get('\/')\n        except ValueError as e:\n            self.assert_equal(str(e), 'View function did not return a response')\n            pass\n        else:\n            self.assert_true(\"Expected ValueError\")\n\n    def test_request_locals(self):\n        self.assert_equal(repr(flask.g), '<LocalProxy unbound>')\n        self.assertFalse(flask.g)\n\n    def test_test_app_proper_environ(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SERVER_NAME='localhost.localdomain:5000'\n        )\n        @app.route('\/')\n        def index():\n            return 'Foo'\n\n        @app.route('\/', subdomain='foo')\n        def subdomain():\n            return 'Foo SubDomain'\n\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'Foo')\n\n        rv = app.test_client().get('\/', 'http:\/\/localhost.localdomain:5000')\n        self.assert_equal(rv.data, b'Foo')\n\n        rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain:5000')\n        self.assert_equal(rv.data, b'Foo')\n\n        app.config.update(SERVER_NAME='localhost.localdomain')\n        rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain')\n        self.assert_equal(rv.data, b'Foo')\n\n        try:\n            app.config.update(SERVER_NAME='localhost.localdomain:443')\n            rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain')\n            # Werkzeug 0.8\n            self.assert_equal(rv.status_code, 404)\n        except ValueError as e:\n            # Werkzeug 0.7\n            self.assert_equal(str(e), \"the server name provided \" +\n                    \"('localhost.localdomain:443') does not match the \" + \\\n                    \"server name from the WSGI environment ('localhost.localdomain')\")\n\n        try:\n            app.config.update(SERVER_NAME='localhost.localdomain')\n            rv = app.test_client().get('\/', 'http:\/\/foo.localhost')\n            # Werkzeug 0.8\n            self.assert_equal(rv.status_code, 404)\n        except ValueError as e:\n            # Werkzeug 0.7\n            self.assert_equal(str(e), \"the server name provided \" + \\\n                    \"('localhost.localdomain') does not match the \" + \\\n                    \"server name from the WSGI environment ('foo.localhost')\")\n\n        rv = app.test_client().get('\/', 'http:\/\/foo.localhost.localdomain')\n        self.assert_equal(rv.data, b'Foo SubDomain')\n\n    def test_exception_propagation(self):\n        def apprunner(configkey):\n            app = flask.Flask(__name__)\n            @app.route('\/')\n            def index():\n                1 \/\/ 0\n            c = app.test_client()\n            if config_key is not None:\n                app.config[config_key] = True\n                try:\n                    resp = c.get('\/')\n                except Exception:\n                    pass\n                else:\n                    self.fail('expected exception')\n            else:\n                self.assert_equal(c.get('\/').status_code, 500)\n\n        # we have to run this test in an isolated thread because if the\n        # debug flag is set to true and an exception happens the context is\n        # not torn down.  This causes other tests that run after this fail\n        # when they expect no exception on the stack.\n        for config_key in 'TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', None:\n            t = Thread(target=apprunner, args=(config_key,))\n            t.start()\n            t.join()\n\n    def test_max_content_length(self):\n        app = flask.Flask(__name__)\n        app.config['MAX_CONTENT_LENGTH'] = 64\n        @app.before_request\n        def always_first():\n            flask.request.form['myfile']\n            self.assert_true(False)\n        @app.route('\/accept', methods=['POST'])\n        def accept_file():\n            flask.request.form['myfile']\n            self.assert_true(False)\n        @app.errorhandler(413)\n        def catcher(error):\n            return '42'\n\n        c = app.test_client()\n        rv = c.post('\/accept', data={'myfile': 'foo' * 100})\n        self.assert_equal(rv.data, b'42')\n\n    def test_url_processors(self):\n        app = flask.Flask(__name__)\n\n        @app.url_defaults\n        def add_language_code(endpoint, values):\n            if flask.g.lang_code is not None and \\\n               app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n                values.setdefault('lang_code', flask.g.lang_code)\n\n        @app.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop('lang_code', None)\n\n        @app.route('\/<lang_code>\/')\n        def index():\n            return flask.url_for('about')\n\n        @app.route('\/<lang_code>\/about')\n        def about():\n            return flask.url_for('something_else')\n\n        @app.route('\/foo')\n        def something_else():\n            return flask.url_for('about', lang_code='en')\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/de\/').data, b'\/de\/about')\n        self.assert_equal(c.get('\/de\/about').data, b'\/foo')\n        self.assert_equal(c.get('\/foo').data, b'\/en\/about')\n\n    def test_inject_blueprint_url_defaults(self):\n        app = flask.Flask(__name__)\n        bp = flask.Blueprint('foo.bar.baz', __name__,\n                       template_folder='template')\n\n        @bp.url_defaults\n        def bp_defaults(endpoint, values):\n            values['page'] = 'login'\n        @bp.route('\/<page>')\n        def view(page): pass\n\n        app.register_blueprint(bp)\n\n        values = dict()\n        app.inject_url_defaults('foo.bar.baz.view', values)\n        expected = dict(page='login')\n        self.assert_equal(values, expected)\n\n        with app.test_request_context('\/somepage'):\n            url = flask.url_for('foo.bar.baz.view')\n        expected = '\/login'\n        self.assert_equal(url, expected)\n\n    def test_nonascii_pathinfo(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n\n        @app.route(u'\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442')\n        def index():\n            return 'Hello World!'\n\n        c = app.test_client()\n        rv = c.get(u'\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442')\n        self.assert_equal(rv.data, b'Hello World!')\n\n    def test_debug_mode_complains_after_first_request(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        @app.route('\/')\n        def index():\n            return 'Awesome'\n        self.assert_false(app.got_first_request)\n        self.assert_equal(app.test_client().get('\/').data, b'Awesome')\n        try:\n            @app.route('\/foo')\n            def broken():\n                return 'Meh'\n        except AssertionError as e:\n            self.assert_in('A setup function was called', str(e))\n        else:\n            self.fail('Expected exception')\n\n        app.debug = False\n        @app.route('\/foo')\n        def working():\n            return 'Meh'\n        self.assert_equal(app.test_client().get('\/foo').data, b'Meh')\n        self.assert_true(app.got_first_request)\n\n    def test_before_first_request_functions(self):\n        got = []\n        app = flask.Flask(__name__)\n        @app.before_first_request\n        def foo():\n            got.append(42)\n        c = app.test_client()\n        c.get('\/')\n        self.assert_equal(got, [42])\n        c.get('\/')\n        self.assert_equal(got, [42])\n        self.assert_true(app.got_first_request)\n\n    def test_routing_redirect_debugging(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        @app.route('\/foo\/', methods=['GET', 'POST'])\n        def foo():\n            return 'success'\n        with app.test_client() as c:\n            try:\n                c.post('\/foo', data={})\n            except AssertionError as e:\n                self.assert_in('http:\/\/localhost\/foo\/', str(e))\n                self.assert_in('Make sure to directly send your POST-request '\n                               'to this URL', str(e))\n            else:\n                self.fail('Expected exception')\n\n            rv = c.get('\/foo', data={}, follow_redirects=True)\n            self.assert_equal(rv.data, b'success')\n\n        app.debug = False\n        with app.test_client() as c:\n            rv = c.post('\/foo', data={}, follow_redirects=True)\n            self.assert_equal(rv.data, b'success')\n\n    def test_route_decorator_custom_endpoint(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        @app.route('\/foo\/')\n        def foo():\n            return flask.request.endpoint\n\n        @app.route('\/bar\/', endpoint='bar')\n        def for_bar():\n            return flask.request.endpoint\n\n        @app.route('\/bar\/123', endpoint='123')\n        def for_bar_foo():\n            return flask.request.endpoint\n\n        with app.test_request_context():\n            assert flask.url_for('foo') == '\/foo\/'\n            assert flask.url_for('bar') == '\/bar\/'\n            assert flask.url_for('123') == '\/bar\/123'\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/foo\/').data, b'foo')\n        self.assertEqual(c.get('\/bar\/').data, b'bar')\n        self.assertEqual(c.get('\/bar\/123').data, b'123')\n\n    def test_preserve_only_once(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        @app.route('\/fail')\n        def fail_func():\n            1 \/\/ 0\n\n        c = app.test_client()\n        for x in range(3):\n            with self.assert_raises(ZeroDivisionError):\n                c.get('\/fail')\n\n        self.assert_true(flask._request_ctx_stack.top is not None)\n        self.assert_true(flask._app_ctx_stack.top is not None)\n        # implicit appctx disappears too\n        flask._request_ctx_stack.top.pop()\n        self.assert_true(flask._request_ctx_stack.top is None)\n        self.assert_true(flask._app_ctx_stack.top is None)\n\n    def test_preserve_remembers_exception(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        errors = []\n\n        @app.route('\/fail')\n        def fail_func():\n            1 \/\/ 0\n\n        @app.route('\/success')\n        def success_func():\n            return 'Okay'\n\n        @app.teardown_request\n        def teardown_handler(exc):\n            errors.append(exc)\n\n        c = app.test_client()\n\n        # After this failure we did not yet call the teardown handler\n        with self.assert_raises(ZeroDivisionError):\n            c.get('\/fail')\n        self.assert_equal(errors, [])\n\n        # But this request triggers it, and it's an error\n        c.get('\/success')\n        self.assert_equal(len(errors), 2)\n        self.assert_true(isinstance(errors[0], ZeroDivisionError))\n\n        # At this point another request does nothing.\n        c.get('\/success')\n        self.assert_equal(len(errors), 3)\n        self.assert_equal(errors[1], None)\n\n    def test_get_method_on_g(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n\n        with app.app_context():\n            self.assert_equal(flask.g.get('x'), None)\n            self.assert_equal(flask.g.get('x', 11), 11)\n            flask.g.x = 42\n            self.assert_equal(flask.g.get('x'), 42)\n            self.assert_equal(flask.g.x, 42)\n\n    def test_g_iteration_protocol(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n\n        with app.app_context():\n            flask.g.foo = 23\n            flask.g.bar = 42\n            self.assert_equal('foo' in flask.g, True)\n            self.assert_equal('foos' in flask.g, False)\n            self.assert_equal(sorted(flask.g), ['bar', 'foo'])\n\n\nclass SubdomainTestCase(FlaskTestCase):\n\n    def test_basic_support(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'localhost'\n        @app.route('\/')\n        def normal_index():\n            return 'normal index'\n        @app.route('\/', subdomain='test')\n        def test_index():\n            return 'test index'\n\n        c = app.test_client()\n        rv = c.get('\/', 'http:\/\/localhost\/')\n        self.assert_equal(rv.data, b'normal index')\n\n        rv = c.get('\/', 'http:\/\/test.localhost\/')\n        self.assert_equal(rv.data, b'test index')\n\n    @emits_module_deprecation_warning\n    def test_module_static_path_subdomain(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'example.com'\n        from subdomaintestmodule import mod\n        app.register_module(mod)\n        c = app.test_client()\n        rv = c.get('\/static\/hello.txt', 'http:\/\/foo.example.com\/')\n        rv.direct_passthrough = False\n        self.assert_equal(rv.data.strip(), b'Hello Subdomain')\n        rv.close()\n\n    def test_subdomain_matching(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'localhost'\n        @app.route('\/', subdomain='<user>')\n        def index(user):\n            return 'index for %s' % user\n\n        c = app.test_client()\n        rv = c.get('\/', 'http:\/\/mitsuhiko.localhost\/')\n        self.assert_equal(rv.data, b'index for mitsuhiko')\n\n    def test_subdomain_matching_with_ports(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'localhost:3000'\n        @app.route('\/', subdomain='<user>')\n        def index(user):\n            return 'index for %s' % user\n\n        c = app.test_client()\n        rv = c.get('\/', 'http:\/\/mitsuhiko.localhost:3000\/')\n        self.assert_equal(rv.data, b'index for mitsuhiko')\n\n    @emits_module_deprecation_warning\n    def test_module_subdomain_support(self):\n        app = flask.Flask(__name__)\n        mod = flask.Module(__name__, 'test', subdomain='testing')\n        app.config['SERVER_NAME'] = 'localhost'\n\n        @mod.route('\/test')\n        def test():\n            return 'Test'\n\n        @mod.route('\/outside', subdomain='xtesting')\n        def bar():\n            return 'Outside'\n\n        app.register_module(mod)\n\n        c = app.test_client()\n        rv = c.get('\/test', 'http:\/\/testing.localhost\/')\n        self.assert_equal(rv.data, b'Test')\n        rv = c.get('\/outside', 'http:\/\/xtesting.localhost\/')\n        self.assert_equal(rv.data, b'Outside')\n\n    def test_multi_route_rules(self):\n        app = flask.Flask(__name__)\n\n        @app.route('\/')\n        @app.route('\/<test>\/')\n        def index(test='a'):\n            return test\n\n        rv = app.test_client().open('\/')\n        self.assert_equal(rv.data, b'a')\n        rv = app.test_client().open('\/b\/')\n        self.assert_equal(rv.data, b'b')\n\n    def test_multi_route_class_views(self):\n        class View(object):\n            def __init__(self, app):\n                app.add_url_rule('\/', 'index', self.index)\n                app.add_url_rule('\/<test>\/', 'index', self.index)\n\n            def index(self, test='a'):\n                return test\n\n        app = flask.Flask(__name__)\n        _ = View(app)\n        rv = app.test_client().open('\/')\n        self.assert_equal(rv.data, b'a')\n        rv = app.test_client().open('\/b\/')\n        self.assert_equal(rv.data, b'b')\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))\n    suite.addTest(unittest.makeSuite(SubdomainTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.basic\n    ~~~~~~~~~~~~~~~~~~~~~\n\n    The basic functionality.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport re\nimport uuid\nimport flask\nimport pickle\nimport unittest\nfrom datetime import datetime\nfrom threading import Thread\nfrom flask.testsuite import FlaskTestCase, emits_module_deprecation_warning\nfrom flask._compat import text_type\nfrom werkzeug.exceptions import BadRequest, NotFound\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\n\n\nclass BasicFunctionalityTestCase(FlaskTestCase):\n\n    def test_options_work(self):\n        app = flask.Flask(__name__)\n        @app.route('\/', methods=['GET', 'POST'])\n        def index():\n            return 'Hello World'\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])\n        self.assert_equal(rv.data, b'')\n\n    def test_options_on_multiple_rules(self):\n        app = flask.Flask(__name__)\n        @app.route('\/', methods=['GET', 'POST'])\n        def index():\n            return 'Hello World'\n        @app.route('\/', methods=['PUT'])\n        def index_put():\n            return 'Aha!'\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'])\n\n    def test_options_handling_disabled(self):\n        app = flask.Flask(__name__)\n        def index():\n            return 'Hello World!'\n        index.provide_automatic_options = False\n        app.route('\/')(index)\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(rv.status_code, 405)\n\n        app = flask.Flask(__name__)\n        def index2():\n            return 'Hello World!'\n        index2.provide_automatic_options = True\n        app.route('\/', methods=['OPTIONS'])(index2)\n        rv = app.test_client().open('\/', method='OPTIONS')\n        self.assert_equal(sorted(rv.allow), ['OPTIONS'])\n\n    def test_request_dispatching(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.request.method\n        @app.route('\/more', methods=['GET', 'POST'])\n        def more():\n            return flask.request.method\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'GET')\n        rv = c.post('\/')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS'])\n        rv = c.head('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_false(rv.data) # head truncates\n        self.assert_equal(c.post('\/more').data, b'POST')\n        self.assert_equal(c.get('\/more').data, b'GET')\n        rv = c.delete('\/more')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])\n\n    def test_url_mapping(self):\n        app = flask.Flask(__name__)\n        def index():\n            return flask.request.method\n        def more():\n            return flask.request.method\n\n        app.add_url_rule('\/', 'index', index)\n        app.add_url_rule('\/more', 'more', more, methods=['GET', 'POST'])\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'GET')\n        rv = c.post('\/')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS'])\n        rv = c.head('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_false(rv.data) # head truncates\n        self.assert_equal(c.post('\/more').data, b'POST')\n        self.assert_equal(c.get('\/more').data, b'GET')\n        rv = c.delete('\/more')\n        self.assert_equal(rv.status_code, 405)\n        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])\n\n    def test_werkzeug_routing(self):\n        from werkzeug.routing import Submount, Rule\n        app = flask.Flask(__name__)\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n        def bar():\n            return 'bar'\n        def index():\n            return 'index'\n        app.view_functions['bar'] = bar\n        app.view_functions['index'] = index\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, b'index')\n        self.assert_equal(c.get('\/foo\/bar').data, b'bar')\n\n    def test_endpoint_decorator(self):\n        from werkzeug.routing import Submount, Rule\n        app = flask.Flask(__name__)\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n\n        @app.endpoint('bar')\n        def bar():\n            return 'bar'\n\n        @app.endpoint('index')\n        def index():\n            return 'index'\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, b'index')\n        self.assert_equal(c.get('\/foo\/bar').data, b'bar')\n\n    def test_session(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n        @app.route('\/set', methods=['POST'])\n        def set():\n            flask.session['value'] = flask.request.form['value']\n            return 'value set'\n        @app.route('\/get')\n        def get():\n            return flask.session['value']\n\n        c = app.test_client()\n        self.assert_equal(c.post('\/set', data={'value': '42'}).data, b'value set')\n        self.assert_equal(c.get('\/get').data, b'42')\n\n    def test_session_using_server_name(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='example.com'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com\/')\n        self.assert_in('domain=.example.com', rv.headers['set-cookie'].lower())\n        self.assert_in('httponly', rv.headers['set-cookie'].lower())\n\n    def test_session_using_server_name_and_port(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='example.com:8080'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/')\n        self.assert_in('domain=.example.com', rv.headers['set-cookie'].lower())\n        self.assert_in('httponly', rv.headers['set-cookie'].lower())\n\n    def test_session_using_server_name_port_and_path(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='example.com:8080',\n            APPLICATION_ROOT='\/foo'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/foo')\n        self.assert_in('domain=example.com', rv.headers['set-cookie'].lower())\n        self.assert_in('path=\/foo', rv.headers['set-cookie'].lower())\n        self.assert_in('httponly', rv.headers['set-cookie'].lower())\n\n    def test_session_using_application_root(self):\n        class PrefixPathMiddleware(object):\n            def __init__(self, app, prefix):\n                self.app = app\n                self.prefix = prefix\n            def __call__(self, environ, start_response):\n                environ['SCRIPT_NAME'] = self.prefix\n                return self.app(environ, start_response)\n\n        app = flask.Flask(__name__)\n        app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, '\/bar')\n        app.config.update(\n            SECRET_KEY='foo',\n            APPLICATION_ROOT='\/bar'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/')\n        self.assert_in('path=\/bar', rv.headers['set-cookie'].lower())\n\n    def test_session_using_session_settings(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SECRET_KEY='foo',\n            SERVER_NAME='www.example.com:8080',\n            APPLICATION_ROOT='\/test',\n            SESSION_COOKIE_DOMAIN='.example.com',\n            SESSION_COOKIE_HTTPONLY=False,\n            SESSION_COOKIE_SECURE=True,\n            SESSION_COOKIE_PATH='\/'\n        )\n        @app.route('\/')\n        def index():\n            flask.session['testing'] = 42\n            return 'Hello World'\n        rv = app.test_client().get('\/', 'http:\/\/www.example.com:8080\/test\/')\n        cookie = rv.headers['set-cookie'].lower()\n        self.assert_in('domain=.example.com', cookie)\n        self.assert_in('path=\/', cookie)\n        self.assert_in('secure', cookie)\n        self.assert_not_in('httponly', cookie)\n\n    def test_missing_session(self):\n        app = flask.Flask(__name__)\n        def expect_exception(f, *args, **kwargs):\n            try:\n                f(*args, **kwargs)\n            except RuntimeError as e:\n                self.assert_true(e.args and 'session is unavailable' in e.args[0])\n            else:\n                self.assert_true(False, 'expected exception')\n        with app.test_request_context():\n            self.assert_true(flask.session.get('missing_key') is None)\n            expect_exception(flask.session.__setitem__, 'foo', 42)\n            expect_exception(flask.session.pop, 'foo')\n\n    def test_session_expiration(self):\n        permanent = True\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n        @app.route('\/')\n        def index():\n            flask.session['test'] = 42\n            flask.session.permanent = permanent\n            return ''\n\n        @app.route('\/test')\n        def test():\n            return text_type(flask.session.permanent)\n\n        client = app.test_client()\n        rv = client.get('\/')\n        self.assert_in('set-cookie', rv.headers)\n        match = re.search(r'\\bexpires=([^;]+)(?i)', rv.headers['set-cookie'])\n        expires = parse_date(match.group())\n        expected = datetime.utcnow() + app.permanent_session_lifetime\n        self.assert_equal(expires.year, expected.year)\n        self.assert_equal(expires.month, expected.month)\n        self.assert_equal(expires.day, expected.day)\n\n        rv = client.get('\/test')\n        self.assert_equal(rv.data, b'True')\n\n        permanent = False\n        rv = app.test_client().get('\/')\n        self.assert_in('set-cookie', rv.headers)\n        match = re.search(r'\\bexpires=([^;]+)', rv.headers['set-cookie'])\n        self.assert_true(match is None)\n\n    def test_session_stored_last(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'development-key'\n        app.testing = True\n\n        @app.after_request\n        def modify_session(response):\n            flask.session['foo'] = 42\n            return response\n        @app.route('\/')\n        def dump_session_contents():\n            return repr(flask.session.get('foo'))\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'None')\n        self.assert_equal(c.get('\/').data, b'42')\n\n    def test_session_special_types(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'development-key'\n        app.testing = True\n        now = datetime.utcnow().replace(microsecond=0)\n        the_uuid = uuid.uuid4()\n\n        @app.after_request\n        def modify_session(response):\n            flask.session['m'] = flask.Markup('Hello!')\n            flask.session['u'] = the_uuid\n            flask.session['dt'] = now\n            flask.session['b'] = b'\\xff'\n            flask.session['t'] = (1, 2, 3)\n            return response\n\n        @app.route('\/')\n        def dump_session_contents():\n            return pickle.dumps(dict(flask.session))\n\n        c = app.test_client()\n        c.get('\/')\n        rv = pickle.loads(c.get('\/').data)\n        self.assert_equal(rv['m'], flask.Markup('Hello!'))\n        self.assert_equal(type(rv['m']), flask.Markup)\n        self.assert_equal(rv['dt'], now)\n        self.assert_equal(rv['u'], the_uuid)\n        self.assert_equal(rv['b'], b'\\xff')\n        self.assert_equal(type(rv['b']), bytes)\n        self.assert_equal(rv['t'], (1, 2, 3))\n\n    def test_flashes(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n\n        with app.test_request_context():\n            self.assert_false(flask.session.modified)\n            flask.flash('Zap')\n            flask.session.modified = False\n            flask.flash('Zip')\n            self.assert_true(flask.session.modified)\n            self.assert_equal(list(flask.get_flashed_messages()), ['Zap', 'Zip'])\n\n    def test_extended_flashing(self):\n        # Be sure app.testing=True below, else tests can fail silently.\n        #\n        # Specifically, if app.testing is not set to True, the AssertionErrors\n        # in the view functions will cause a 500 response to the test client\n        # instead of propagating exceptions.\n\n        app = flask.Flask(__name__)\n        app.secret_key = 'testkey'\n        app.testing = True\n\n        @app.route('\/')\n        def index():\n            flask.flash(u'Hello World')\n            flask.flash(u'Hello World', 'error')\n            flask.flash(flask.Markup(u'<em>Testing<\/em>'), 'warning')\n            return ''\n\n        @app.route('\/test\/')\n        def test():\n            messages = flask.get_flashed_messages()\n            self.assert_equal(len(messages), 3)\n            self.assert_equal(messages[0], u'Hello World')\n            self.assert_equal(messages[1], u'Hello World')\n            self.assert_equal(messages[2], flask.Markup(u'<em>Testing<\/em>'))\n            return ''\n\n        @app.route('\/test_with_categories\/')\n        def test_with_categories():\n            messages = flask.get_flashed_messages(with_categories=True)\n            self.assert_equal(len(messages), 3)\n            self.assert_equal(messages[0], ('message', u'Hello World'))\n            self.assert_equal(messages[1], ('error', u'Hello World'))\n            self.assert_equal(messages[2], ('warning', flask.Markup(u'<em>Testing<\/em>')))\n            return ''\n\n        @app.route('\/test_filter\/')\n        def test_filter():\n            messages = flask.get_flashed_messages(category_filter=['message'], with_categories=True)\n            self.assert_equal(len(messages), 1)\n            self.assert_equal(messages[0], ('message', u'Hello World'))\n            return ''\n\n        @app.route('\/test_filters\/')\n        def test_filters():\n            messages = flask.get_flashed_messages(category_filter=['message', 'warning'], with_categories=True)\n            self.assert_equal(len(messages), 2)\n            self.assert_equal(messages[0], ('message', u'Hello World'))\n            self.assert_equal(messages[1], ('warning', flask.Markup(u'<em>Testing<\/em>')))\n            return ''\n\n        @app.route('\/test_filters_without_returning_categories\/')\n        def test_filters2():\n            messages = flask.get_flashed_messages(category_filter=['message', 'warning'])\n            self.assert_equal(len(messages), 2)\n            self.assert_equal(messages[0], u'Hello World')\n            self.assert_equal(messages[1], flask.Markup(u'<em>Testing<\/em>'))\n            return ''\n\n        # Create new test client on each test to clean flashed messages.\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_with_categories\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_filter\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_filters\/')\n\n        c = app.test_client()\n        c.get('\/')\n        c.get('\/test_filters_without_returning_categories\/')\n\n    def test_request_processing(self):\n        app = flask.Flask(__name__)\n        evts = []\n        @app.before_request\n        def before_request():\n            evts.append('before')\n        @app.after_request\n        def after_request(response):\n            response.data += b'|after'\n            evts.append('after')\n            return response\n        @app.route('\/')\n        def index():\n            self.assert_in('before', evts)\n            self.assert_not_in('after', evts)\n            return 'request'\n        self.assert_not_in('after', evts)\n        rv = app.test_client().get('\/').data\n        self.assert_in('after', evts)\n        self.assert_equal(rv, b'request|after')\n\n    def test_after_request_processing(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            @flask.after_this_request\n            def foo(response):\n                response.headers['X-Foo'] = 'a header'\n                return response\n            return 'Test'\n        c = app.test_client()\n        resp = c.get('\/')\n        self.assertEqual(resp.status_code, 200)\n        self.assertEqual(resp.headers['X-Foo'], 'a header')\n\n    def test_teardown_request_handler(self):\n        called = []\n        app = flask.Flask(__name__)\n        @app.teardown_request\n        def teardown_request(exc):\n            called.append(True)\n            return \"Ignored\"\n        @app.route('\/')\n        def root():\n            return \"Response\"\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_in(b'Response', rv.data)\n        self.assert_equal(len(called), 1)\n\n    def test_teardown_request_handler_debug_mode(self):\n        called = []\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.teardown_request\n        def teardown_request(exc):\n            called.append(True)\n            return \"Ignored\"\n        @app.route('\/')\n        def root():\n            return \"Response\"\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_in(b'Response', rv.data)\n        self.assert_equal(len(called), 1)\n\n    def test_teardown_request_handler_error(self):\n        called = []\n        app = flask.Flask(__name__)\n        @app.teardown_request\n        def teardown_request1(exc):\n            self.assert_equal(type(exc), ZeroDivisionError)\n            called.append(True)\n            # This raises a new error and blows away sys.exc_info(), so we can\n            # test that all teardown_requests get passed the same original\n            # exception.\n            try:\n                raise TypeError()\n            except:\n                pass\n        @app.teardown_request\n        def teardown_request2(exc):\n            self.assert_equal(type(exc), ZeroDivisionError)\n            called.append(True)\n            # This raises a new error and blows away sys.exc_info(), so we can\n            # test that all teardown_requests get passed the same original\n            # exception.\n            try:\n                raise TypeError()\n            except:\n                pass\n        @app.route('\/')\n        def fails():\n            1 \/\/ 0\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_in(b'Internal Server Error', rv.data)\n        self.assert_equal(len(called), 2)\n\n    def test_before_after_request_order(self):\n        called = []\n        app = flask.Flask(__name__)\n        @app.before_request\n        def before1():\n            called.append(1)\n        @app.before_request\n        def before2():\n            called.append(2)\n        @app.after_request\n        def after1(response):\n            called.append(4)\n            return response\n        @app.after_request\n        def after2(response):\n            called.append(3)\n            return response\n        @app.teardown_request\n        def finish1(exc):\n            called.append(6)\n        @app.teardown_request\n        def finish2(exc):\n            called.append(5)\n        @app.route('\/')\n        def index():\n            return '42'\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'42')\n        self.assert_equal(called, [1, 2, 3, 4, 5, 6])\n\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        @app.errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @app.errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @app.route('\/')\n        def index():\n            flask.abort(404)\n        @app.route('\/error')\n        def error():\n            1 \/\/ 0\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, b'not found')\n        rv = c.get('\/error')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_equal(b'internal server error', rv.data)\n\n    def test_before_request_and_routing_errors(self):\n        app = flask.Flask(__name__)\n        @app.before_request\n        def attach_something():\n            flask.g.something = 'value'\n        @app.errorhandler(404)\n        def return_something(error):\n            return flask.g.something, 404\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, b'value')\n\n    def test_user_error_handling(self):\n        class MyException(Exception):\n            pass\n\n        app = flask.Flask(__name__)\n        @app.errorhandler(MyException)\n        def handle_my_exception(e):\n            self.assert_true(isinstance(e, MyException))\n            return '42'\n        @app.route('\/')\n        def index():\n            raise MyException()\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'42')\n\n    def test_trapping_of_bad_request_key_errors(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/fail')\n        def fail():\n            flask.request.form['missing_key']\n        c = app.test_client()\n        self.assert_equal(c.get('\/fail').status_code, 400)\n\n        app.config['TRAP_BAD_REQUEST_ERRORS'] = True\n        c = app.test_client()\n        try:\n            c.get('\/fail')\n        except KeyError as e:\n            self.assert_true(isinstance(e, BadRequest))\n        else:\n            self.fail('Expected exception')\n\n    def test_trapping_of_all_http_exceptions(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.config['TRAP_HTTP_EXCEPTIONS'] = True\n        @app.route('\/fail')\n        def fail():\n            flask.abort(404)\n\n        c = app.test_client()\n        try:\n            c.get('\/fail')\n        except NotFound as e:\n            pass\n        else:\n            self.fail('Expected exception')\n\n    def test_enctype_debug_helper(self):\n        from flask.debughelpers import DebugFilesKeyError\n        app = flask.Flask(__name__)\n        app.debug = True\n        @app.route('\/fail', methods=['POST'])\n        def index():\n            return flask.request.files['foo'].filename\n\n        # with statement is important because we leave an exception on the\n        # stack otherwise and we want to ensure that this is not the case\n        # to not negatively affect other tests.\n        with app.test_client() as c:\n            try:\n                c.post('\/fail', data={'foo': 'index.txt'})\n            except DebugFilesKeyError as e:\n                self.assert_in('no file contents were transmitted', str(e))\n                self.assert_in('This was submitted: \"index.txt\"', str(e))\n            else:\n                self.fail('Expected exception')\n\n    def test_response_creation(self):\n        app = flask.Flask(__name__)\n        @app.route('\/unicode')\n        def from_unicode():\n            return u'H\u00e4llo W\u00f6rld'\n        @app.route('\/string')\n        def from_string():\n            return u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n        @app.route('\/args')\n        def from_tuple():\n            return 'Meh', 400, {\n                'X-Foo': 'Testing',\n                'Content-Type': 'text\/plain; charset=utf-8'\n            }\n        c = app.test_client()\n        self.assert_equal(c.get('\/unicode').data, u'H\u00e4llo W\u00f6rld'.encode('utf-8'))\n        self.assert_equal(c.get('\/string').data, u'H\u00e4llo W\u00f6rld'.encode('utf-8'))\n        rv = c.get('\/args')\n        self.assert_equal(rv.data, b'Meh')\n        self.assert_equal(rv.headers['X-Foo'], 'Testing')\n        self.assert_equal(rv.status_code, 400)\n        self.assert_equal(rv.mimetype, 'text\/plain')\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.make_response()\n            self.assert_equal(rv.status_code, 200)\n            self.assert_equal(rv.data, b'')\n            self.assert_equal(rv.mimetype, 'text\/html')\n\n            rv = flask.make_response('Awesome')\n            self.assert_equal(rv.status_code, 200)\n            self.assert_equal(rv.data, b'Awesome')\n            self.assert_equal(rv.mimetype, 'text\/html')\n\n            rv = flask.make_response('W00t', 404)\n            self.assert_equal(rv.status_code, 404)\n            self.assert_equal(rv.data, b'W00t')\n            self.assert_equal(rv.mimetype, 'text\/html')\n\n    def test_make_response_with_response_instance(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.make_response(\n                flask.jsonify({'msg': 'W00t'}), 400)\n            self.assertEqual(rv.status_code, 400)\n            self.assertEqual(rv.data, b'{\\n  \"msg\": \"W00t\"\\n}')\n            self.assertEqual(rv.mimetype, 'application\/json')\n\n            rv = flask.make_response(\n                flask.Response(''), 400)\n            self.assertEqual(rv.status_code, 400)\n            self.assertEqual(rv.data, b'')\n            self.assertEqual(rv.mimetype, 'text\/html')\n\n            rv = flask.make_response(\n                flask.Response('', headers={'Content-Type': 'text\/html'}),\n                400, [('X-Foo', 'bar')])\n            self.assertEqual(rv.status_code, 400)\n            self.assertEqual(rv.headers['Content-Type'], 'text\/html')\n            self.assertEqual(rv.headers['X-Foo'], 'bar')\n\n    def test_url_generation(self):\n        app = flask.Flask(__name__)\n        @app.route('\/hello\/<name>', methods=['POST'])\n        def hello():\n            pass\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('hello', name='test x'), '\/hello\/test%20x')\n            self.assert_equal(flask.url_for('hello', name='test x', _external=True),\n                              'http:\/\/localhost\/hello\/test%20x')\n\n    def test_build_error_handler(self):\n        app = flask.Flask(__name__)\n\n        # Test base case, a URL which results in a BuildError.\n        with app.test_request_context():\n            self.assertRaises(BuildError, flask.url_for, 'spam')\n\n        # Verify the error is re-raised if not the current exception.\n        try:\n            with app.test_request_context():\n                flask.url_for('spam')\n        except BuildError as err:\n            error = err\n        try:\n            raise RuntimeError('Test case where BuildError is not current.')\n        except RuntimeError:\n            self.assertRaises(BuildError, app.handle_url_build_error, error, 'spam', {})\n\n        # Test a custom handler.\n        def handler(error, endpoint, values):\n            # Just a test.\n            return '\/test_handler\/'\n        app.url_build_error_handlers.append(handler)\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('spam'), '\/test_handler\/')\n\n    def test_custom_converters(self):\n        from werkzeug.routing import BaseConverter\n        class ListConverter(BaseConverter):\n            def to_python(self, value):\n                return value.split(',')\n            def to_url(self, value):\n                base_to_url = super(ListConverter, self).to_url\n                return ','.join(base_to_url(x) for x in value)\n        app = flask.Flask(__name__)\n        app.url_map.converters['list'] = ListConverter\n        @app.route('\/<list:args>')\n        def index(args):\n            return '|'.join(args)\n        c = app.test_client()\n        self.assert_equal(c.get('\/1,2,3').data, b'1|2|3')\n\n    def test_static_files(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        rv = app.test_client().get('\/static\/index.html')\n        self.assert_equal(rv.status_code, 200)\n        self.assert_equal(rv.data.strip(), b'<h1>Hello World!<\/h1>')\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('static', filename='index.html'),\n                              '\/static\/index.html')\n        rv.close()\n\n    def test_none_response(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def test():\n            return None\n        try:\n            app.test_client().get('\/')\n        except ValueError as e:\n            self.assert_equal(str(e), 'View function did not return a response')\n            pass\n        else:\n            self.assert_true(\"Expected ValueError\")\n\n    def test_request_locals(self):\n        self.assert_equal(repr(flask.g), '<LocalProxy unbound>')\n        self.assertFalse(flask.g)\n\n    def test_test_app_proper_environ(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SERVER_NAME='localhost.localdomain:5000'\n        )\n        @app.route('\/')\n        def index():\n            return 'Foo'\n\n        @app.route('\/', subdomain='foo')\n        def subdomain():\n            return 'Foo SubDomain'\n\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'Foo')\n\n        rv = app.test_client().get('\/', 'http:\/\/localhost.localdomain:5000')\n        self.assert_equal(rv.data, b'Foo')\n\n        rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain:5000')\n        self.assert_equal(rv.data, b'Foo')\n\n        app.config.update(SERVER_NAME='localhost.localdomain')\n        rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain')\n        self.assert_equal(rv.data, b'Foo')\n\n        try:\n            app.config.update(SERVER_NAME='localhost.localdomain:443')\n            rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain')\n            # Werkzeug 0.8\n            self.assert_equal(rv.status_code, 404)\n        except ValueError as e:\n            # Werkzeug 0.7\n            self.assert_equal(str(e), \"the server name provided \" +\n                    \"('localhost.localdomain:443') does not match the \" + \\\n                    \"server name from the WSGI environment ('localhost.localdomain')\")\n\n        try:\n            app.config.update(SERVER_NAME='localhost.localdomain')\n            rv = app.test_client().get('\/', 'http:\/\/foo.localhost')\n            # Werkzeug 0.8\n            self.assert_equal(rv.status_code, 404)\n        except ValueError as e:\n            # Werkzeug 0.7\n            self.assert_equal(str(e), \"the server name provided \" + \\\n                    \"('localhost.localdomain') does not match the \" + \\\n                    \"server name from the WSGI environment ('foo.localhost')\")\n\n        rv = app.test_client().get('\/', 'http:\/\/foo.localhost.localdomain')\n        self.assert_equal(rv.data, b'Foo SubDomain')\n\n    def test_exception_propagation(self):\n        def apprunner(configkey):\n            app = flask.Flask(__name__)\n            @app.route('\/')\n            def index():\n                1 \/\/ 0\n            c = app.test_client()\n            if config_key is not None:\n                app.config[config_key] = True\n                try:\n                    resp = c.get('\/')\n                except Exception:\n                    pass\n                else:\n                    self.fail('expected exception')\n            else:\n                self.assert_equal(c.get('\/').status_code, 500)\n\n        # we have to run this test in an isolated thread because if the\n        # debug flag is set to true and an exception happens the context is\n        # not torn down.  This causes other tests that run after this fail\n        # when they expect no exception on the stack.\n        for config_key in 'TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', None:\n            t = Thread(target=apprunner, args=(config_key,))\n            t.start()\n            t.join()\n\n    def test_max_content_length(self):\n        app = flask.Flask(__name__)\n        app.config['MAX_CONTENT_LENGTH'] = 64\n        @app.before_request\n        def always_first():\n            flask.request.form['myfile']\n            self.assert_true(False)\n        @app.route('\/accept', methods=['POST'])\n        def accept_file():\n            flask.request.form['myfile']\n            self.assert_true(False)\n        @app.errorhandler(413)\n        def catcher(error):\n            return '42'\n\n        c = app.test_client()\n        rv = c.post('\/accept', data={'myfile': 'foo' * 100})\n        self.assert_equal(rv.data, b'42')\n\n    def test_url_processors(self):\n        app = flask.Flask(__name__)\n\n        @app.url_defaults\n        def add_language_code(endpoint, values):\n            if flask.g.lang_code is not None and \\\n               app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n                values.setdefault('lang_code', flask.g.lang_code)\n\n        @app.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop('lang_code', None)\n\n        @app.route('\/<lang_code>\/')\n        def index():\n            return flask.url_for('about')\n\n        @app.route('\/<lang_code>\/about')\n        def about():\n            return flask.url_for('something_else')\n\n        @app.route('\/foo')\n        def something_else():\n            return flask.url_for('about', lang_code='en')\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/de\/').data, b'\/de\/about')\n        self.assert_equal(c.get('\/de\/about').data, b'\/foo')\n        self.assert_equal(c.get('\/foo').data, b'\/en\/about')\n\n    def test_inject_blueprint_url_defaults(self):\n        app = flask.Flask(__name__)\n        bp = flask.Blueprint('foo.bar.baz', __name__,\n                       template_folder='template')\n\n        @bp.url_defaults\n        def bp_defaults(endpoint, values):\n            values['page'] = 'login'\n        @bp.route('\/<page>')\n        def view(page): pass\n\n        app.register_blueprint(bp)\n\n        values = dict()\n        app.inject_url_defaults('foo.bar.baz.view', values)\n        expected = dict(page='login')\n        self.assert_equal(values, expected)\n\n        with app.test_request_context('\/somepage'):\n            url = flask.url_for('foo.bar.baz.view')\n        expected = '\/login'\n        self.assert_equal(url, expected)\n\n    def test_nonascii_pathinfo(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n\n        @app.route(u'\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442')\n        def index():\n            return 'Hello World!'\n\n        c = app.test_client()\n        rv = c.get(u'\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442')\n        self.assert_equal(rv.data, b'Hello World!')\n\n    def test_debug_mode_complains_after_first_request(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        @app.route('\/')\n        def index():\n            return 'Awesome'\n        self.assert_false(app.got_first_request)\n        self.assert_equal(app.test_client().get('\/').data, b'Awesome')\n        try:\n            @app.route('\/foo')\n            def broken():\n                return 'Meh'\n        except AssertionError as e:\n            self.assert_in('A setup function was called', str(e))\n        else:\n            self.fail('Expected exception')\n\n        app.debug = False\n        @app.route('\/foo')\n        def working():\n            return 'Meh'\n        self.assert_equal(app.test_client().get('\/foo').data, b'Meh')\n        self.assert_true(app.got_first_request)\n\n    def test_before_first_request_functions(self):\n        got = []\n        app = flask.Flask(__name__)\n        @app.before_first_request\n        def foo():\n            got.append(42)\n        c = app.test_client()\n        c.get('\/')\n        self.assert_equal(got, [42])\n        c.get('\/')\n        self.assert_equal(got, [42])\n        self.assert_true(app.got_first_request)\n\n    def test_routing_redirect_debugging(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        @app.route('\/foo\/', methods=['GET', 'POST'])\n        def foo():\n            return 'success'\n        with app.test_client() as c:\n            try:\n                c.post('\/foo', data={})\n            except AssertionError as e:\n                self.assert_in('http:\/\/localhost\/foo\/', str(e))\n                self.assert_in('Make sure to directly send your POST-request '\n                               'to this URL', str(e))\n            else:\n                self.fail('Expected exception')\n\n            rv = c.get('\/foo', data={}, follow_redirects=True)\n            self.assert_equal(rv.data, b'success')\n\n        app.debug = False\n        with app.test_client() as c:\n            rv = c.post('\/foo', data={}, follow_redirects=True)\n            self.assert_equal(rv.data, b'success')\n\n    def test_route_decorator_custom_endpoint(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        @app.route('\/foo\/')\n        def foo():\n            return flask.request.endpoint\n\n        @app.route('\/bar\/', endpoint='bar')\n        def for_bar():\n            return flask.request.endpoint\n\n        @app.route('\/bar\/123', endpoint='123')\n        def for_bar_foo():\n            return flask.request.endpoint\n\n        with app.test_request_context():\n            assert flask.url_for('foo') == '\/foo\/'\n            assert flask.url_for('bar') == '\/bar\/'\n            assert flask.url_for('123') == '\/bar\/123'\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/foo\/').data, b'foo')\n        self.assertEqual(c.get('\/bar\/').data, b'bar')\n        self.assertEqual(c.get('\/bar\/123').data, b'123')\n\n    def test_preserve_only_once(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        @app.route('\/fail')\n        def fail_func():\n            1 \/\/ 0\n\n        c = app.test_client()\n        for x in range(3):\n            with self.assert_raises(ZeroDivisionError):\n                c.get('\/fail')\n\n        self.assert_true(flask._request_ctx_stack.top is not None)\n        self.assert_true(flask._app_ctx_stack.top is not None)\n        # implicit appctx disappears too\n        flask._request_ctx_stack.top.pop()\n        self.assert_true(flask._request_ctx_stack.top is None)\n        self.assert_true(flask._app_ctx_stack.top is None)\n\n    def test_preserve_remembers_exception(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        errors = []\n\n        @app.route('\/fail')\n        def fail_func():\n            1 \/\/ 0\n\n        @app.route('\/success')\n        def success_func():\n            return 'Okay'\n\n        @app.teardown_request\n        def teardown_handler(exc):\n            errors.append(exc)\n\n        c = app.test_client()\n\n        # After this failure we did not yet call the teardown handler\n        with self.assert_raises(ZeroDivisionError):\n            c.get('\/fail')\n        self.assert_equal(errors, [])\n\n        # But this request triggers it, and it's an error\n        c.get('\/success')\n        self.assert_equal(len(errors), 2)\n        self.assert_true(isinstance(errors[0], ZeroDivisionError))\n\n        # At this point another request does nothing.\n        c.get('\/success')\n        self.assert_equal(len(errors), 3)\n        self.assert_equal(errors[1], None)\n\n    def test_get_method_on_g(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n\n        with app.app_context():\n            self.assert_equal(flask.g.get('x'), None)\n            self.assert_equal(flask.g.get('x', 11), 11)\n            flask.g.x = 42\n            self.assert_equal(flask.g.get('x'), 42)\n            self.assert_equal(flask.g.x, 42)\n\n    def test_g_iteration_protocol(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n\n        with app.app_context():\n            flask.g.foo = 23\n            flask.g.bar = 42\n            self.assert_equal('foo' in flask.g, True)\n            self.assert_equal('foos' in flask.g, False)\n            self.assert_equal(sorted(flask.g), ['bar', 'foo'])\n\n\nclass SubdomainTestCase(FlaskTestCase):\n\n    def test_basic_support(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'localhost'\n        @app.route('\/')\n        def normal_index():\n            return 'normal index'\n        @app.route('\/', subdomain='test')\n        def test_index():\n            return 'test index'\n\n        c = app.test_client()\n        rv = c.get('\/', 'http:\/\/localhost\/')\n        self.assert_equal(rv.data, b'normal index')\n\n        rv = c.get('\/', 'http:\/\/test.localhost\/')\n        self.assert_equal(rv.data, b'test index')\n\n    @emits_module_deprecation_warning\n    def test_module_static_path_subdomain(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'example.com'\n        from subdomaintestmodule import mod\n        app.register_module(mod)\n        c = app.test_client()\n        rv = c.get('\/static\/hello.txt', 'http:\/\/foo.example.com\/')\n        rv.direct_passthrough = False\n        self.assert_equal(rv.data.strip(), b'Hello Subdomain')\n        rv.close()\n\n    def test_subdomain_matching(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'localhost'\n        @app.route('\/', subdomain='<user>')\n        def index(user):\n            return 'index for %s' % user\n\n        c = app.test_client()\n        rv = c.get('\/', 'http:\/\/mitsuhiko.localhost\/')\n        self.assert_equal(rv.data, b'index for mitsuhiko')\n\n    def test_subdomain_matching_with_ports(self):\n        app = flask.Flask(__name__)\n        app.config['SERVER_NAME'] = 'localhost:3000'\n        @app.route('\/', subdomain='<user>')\n        def index(user):\n            return 'index for %s' % user\n\n        c = app.test_client()\n        rv = c.get('\/', 'http:\/\/mitsuhiko.localhost:3000\/')\n        self.assert_equal(rv.data, b'index for mitsuhiko')\n\n    @emits_module_deprecation_warning\n    def test_module_subdomain_support(self):\n        app = flask.Flask(__name__)\n        mod = flask.Module(__name__, 'test', subdomain='testing')\n        app.config['SERVER_NAME'] = 'localhost'\n\n        @mod.route('\/test')\n        def test():\n            return 'Test'\n\n        @mod.route('\/outside', subdomain='xtesting')\n        def bar():\n            return 'Outside'\n\n        app.register_module(mod)\n\n        c = app.test_client()\n        rv = c.get('\/test', 'http:\/\/testing.localhost\/')\n        self.assert_equal(rv.data, b'Test')\n        rv = c.get('\/outside', 'http:\/\/xtesting.localhost\/')\n        self.assert_equal(rv.data, b'Outside')\n\n    def test_multi_route_rules(self):\n        app = flask.Flask(__name__)\n\n        @app.route('\/')\n        @app.route('\/<test>\/')\n        def index(test='a'):\n            return test\n\n        rv = app.test_client().open('\/')\n        self.assert_equal(rv.data, b'a')\n        rv = app.test_client().open('\/b\/')\n        self.assert_equal(rv.data, b'b')\n\n    def test_multi_route_class_views(self):\n        class View(object):\n            def __init__(self, app):\n                app.add_url_rule('\/', 'index', self.index)\n                app.add_url_rule('\/<test>\/', 'index', self.index)\n\n            def index(self, test='a'):\n                return test\n\n        app = flask.Flask(__name__)\n        _ = View(app)\n        rv = app.test_client().open('\/')\n        self.assert_equal(rv.data, b'a')\n        rv = app.test_client().open('\/b\/')\n        self.assert_equal(rv.data, b'b')\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))\n    suite.addTest(unittest.makeSuite(SubdomainTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.blueprints\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Blueprints (and currently modules)\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nimport warnings\nfrom flask.testsuite import FlaskTestCase, emits_module_deprecation_warning\nfrom flask._compat import text_type\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_cache_control_header\nfrom jinja2 import TemplateNotFound\n\n\n# import moduleapp here because it uses deprecated features and we don't\n# want to see the warnings\nwarnings.simplefilter('ignore', DeprecationWarning)\nfrom moduleapp import app as moduleapp\nwarnings.simplefilter('default', DeprecationWarning)\n\n\nclass ModuleTestCase(FlaskTestCase):\n\n    @emits_module_deprecation_warning\n    def test_basic_module(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.route('\/')\n        def admin_index():\n            return 'admin index'\n        @admin.route('\/login')\n        def admin_login():\n            return 'admin login'\n        @admin.route('\/logout')\n        def admin_logout():\n            return 'admin logout'\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'the index')\n        self.assert_equal(c.get('\/admin\/').data, b'admin index')\n        self.assert_equal(c.get('\/admin\/login').data, b'admin login')\n        self.assert_equal(c.get('\/admin\/logout').data, b'admin logout')\n\n    @emits_module_deprecation_warning\n    def test_default_endpoint_name(self):\n        app = flask.Flask(__name__)\n        mod = flask.Module(__name__, 'frontend')\n        def index():\n            return 'Awesome'\n        mod.add_url_rule('\/', view_func=index)\n        app.register_module(mod)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'Awesome')\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('frontend.index'), '\/')\n\n    @emits_module_deprecation_warning\n    def test_request_processing(self):\n        catched = []\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.before_request\n        def before_admin_request():\n            catched.append('before-admin')\n        @admin.after_request\n        def after_admin_request(response):\n            catched.append('after-admin')\n            return response\n        @admin.route('\/')\n        def admin_index():\n            return 'the admin'\n        @app.before_request\n        def before_request():\n            catched.append('before-app')\n        @app.after_request\n        def after_request(response):\n            catched.append('after-app')\n            return response\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/').data, b'the index')\n        self.assert_equal(catched, ['before-app', 'after-app'])\n        del catched[:]\n\n        self.assert_equal(c.get('\/admin\/').data, b'the admin')\n        self.assert_equal(catched, ['before-app', 'before-admin',\n                           'after-admin', 'after-app'])\n\n    @emits_module_deprecation_warning\n    def test_context_processors(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @app.context_processor\n        def inject_all_regular():\n            return {'a': 1}\n        @admin.context_processor\n        def inject_admin():\n            return {'b': 2}\n        @admin.app_context_processor\n        def inject_all_module():\n            return {'c': 3}\n        @app.route('\/')\n        def index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        @admin.route('\/')\n        def admin_index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'13')\n        self.assert_equal(c.get('\/admin\/').data, b'123')\n\n    @emits_module_deprecation_warning\n    def test_late_binding(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.route('\/')\n        def index():\n            return '42'\n        app.register_module(admin, url_prefix='\/admin')\n        self.assert_equal(app.test_client().get('\/admin\/').data, b'42')\n\n    @emits_module_deprecation_warning\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.app_errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @admin.app_errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @admin.route('\/')\n        def index():\n            flask.abort(404)\n        @admin.route('\/error')\n        def error():\n            1 \/\/ 0\n        app.register_module(admin)\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, b'not found')\n        rv = c.get('\/error')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_equal(b'internal server error', rv.data)\n\n    def test_templates_and_static(self):\n        app = moduleapp\n        app.testing = True\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), b'Admin File')\n        rv.close()\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), b'\/* nested file *\/')\n        rv.close()\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_true(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_safe_access(self):\n        app = moduleapp\n\n        with app.test_request_context():\n            f = app.view_functions['admin.static']\n\n            try:\n                f('\/etc\/passwd')\n            except NotFound:\n                pass\n            else:\n                self.assert_true(0, 'expected exception')\n            try:\n                f('..\/__init__.py')\n            except NotFound:\n                pass\n            else:\n                self.assert_true(0, 'expected exception')\n\n            # testcase for a security issue that may exist on windows systems\n            import os\n            import ntpath\n            old_path = os.path\n            os.path = ntpath\n            try:\n                try:\n                    f('..\\\\__init__.py')\n                except NotFound:\n                    pass\n                else:\n                    self.assert_true(0, 'expected exception')\n            finally:\n                os.path = old_path\n\n    @emits_module_deprecation_warning\n    def test_endpoint_decorator(self):\n        from werkzeug.routing import Submount, Rule\n        from flask import Module\n\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n        module = Module(__name__, __name__)\n\n        @module.endpoint('bar')\n        def bar():\n            return 'bar'\n\n        @module.endpoint('index')\n        def index():\n            return 'index'\n\n        app.register_module(module)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, b'index')\n        self.assert_equal(c.get('\/foo\/bar').data, b'bar')\n\n\nclass BlueprintTestCase(FlaskTestCase):\n\n    def test_blueprint_specific_error_handling(self):\n        frontend = flask.Blueprint('frontend', __name__)\n        backend = flask.Blueprint('backend', __name__)\n        sideend = flask.Blueprint('sideend', __name__)\n\n        @frontend.errorhandler(403)\n        def frontend_forbidden(e):\n            return 'frontend says no', 403\n\n        @frontend.route('\/frontend-no')\n        def frontend_no():\n            flask.abort(403)\n\n        @backend.errorhandler(403)\n        def backend_forbidden(e):\n            return 'backend says no', 403\n\n        @backend.route('\/backend-no')\n        def backend_no():\n            flask.abort(403)\n\n        @sideend.route('\/what-is-a-sideend')\n        def sideend_no():\n            flask.abort(403)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n        app.register_blueprint(sideend)\n\n        @app.errorhandler(403)\n        def app_forbidden(e):\n            return 'application itself says no', 403\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/frontend-no').data, b'frontend says no')\n        self.assert_equal(c.get('\/backend-no').data, b'backend says no')\n        self.assert_equal(c.get('\/what-is-a-sideend').data, b'application itself says no')\n\n    def test_blueprint_url_definitions(self):\n        bp = flask.Blueprint('test', __name__)\n\n        @bp.route('\/foo', defaults={'baz': 42})\n        def foo(bar, baz):\n            return '%s\/%d' % (bar, baz)\n\n        @bp.route('\/bar')\n        def bar(bar):\n            return text_type(bar)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/1', url_defaults={'bar': 23})\n        app.register_blueprint(bp, url_prefix='\/2', url_defaults={'bar': 19})\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/1\/foo').data, b'23\/42')\n        self.assert_equal(c.get('\/2\/foo').data, b'19\/42')\n        self.assert_equal(c.get('\/1\/bar').data, b'23')\n        self.assert_equal(c.get('\/2\/bar').data, b'19')\n\n    def test_blueprint_url_processors(self):\n        bp = flask.Blueprint('frontend', __name__, url_prefix='\/<lang_code>')\n\n        @bp.url_defaults\n        def add_language_code(endpoint, values):\n            values.setdefault('lang_code', flask.g.lang_code)\n\n        @bp.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop('lang_code')\n\n        @bp.route('\/')\n        def index():\n            return flask.url_for('.about')\n\n        @bp.route('\/about')\n        def about():\n            return flask.url_for('.index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/de\/').data, b'\/de\/about')\n        self.assert_equal(c.get('\/de\/about').data, b'\/de\/')\n\n    def test_templates_and_static(self):\n        from blueprintapp import app\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), b'Admin File')\n        rv.close()\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), b'\/* nested file *\/')\n        rv.close()\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            expected_max_age = 3600\n            if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == expected_max_age:\n                expected_max_age = 7200\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = expected_max_age\n            rv = c.get('\/admin\/static\/css\/test.css')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, expected_max_age)\n            rv.close()\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_true(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_default_static_cache_timeout(self):\n        app = flask.Flask(__name__)\n        class MyBlueprint(flask.Blueprint):\n            def get_send_file_max_age(self, filename):\n                return 100\n\n        blueprint = MyBlueprint('blueprint', __name__, static_folder='static')\n        app.register_blueprint(blueprint)\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            with app.test_request_context():\n                unexpected_max_age = 3600\n                if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == unexpected_max_age:\n                    unexpected_max_age = 7200\n                app.config['SEND_FILE_MAX_AGE_DEFAULT'] = unexpected_max_age\n                rv = blueprint.send_static_file('index.html')\n                cc = parse_cache_control_header(rv.headers['Cache-Control'])\n                self.assert_equal(cc.max_age, 100)\n                rv.close()\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n    def test_templates_list(self):\n        from blueprintapp import app\n        templates = sorted(app.jinja_env.list_templates())\n        self.assert_equal(templates, ['admin\/index.html',\n                                     'frontend\/index.html'])\n\n    def test_dotted_names(self):\n        frontend = flask.Blueprint('myapp.frontend', __name__)\n        backend = flask.Blueprint('myapp.backend', __name__)\n\n        @frontend.route('\/fe')\n        def frontend_index():\n            return flask.url_for('myapp.backend.backend_index')\n\n        @frontend.route('\/fe2')\n        def frontend_page2():\n            return flask.url_for('.frontend_index')\n\n        @backend.route('\/be')\n        def backend_index():\n            return flask.url_for('myapp.frontend.frontend_index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/fe').data.strip(), b'\/be')\n        self.assert_equal(c.get('\/fe2').data.strip(), b'\/fe')\n        self.assert_equal(c.get('\/be').data.strip(), b'\/fe')\n\n    def test_dotted_names_from_app(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        test = flask.Blueprint('test', __name__)\n\n        @app.route('\/')\n        def app_index():\n            return flask.url_for('test.index')\n\n        @test.route('\/test\/')\n        def index():\n            return flask.url_for('app_index')\n\n        app.register_blueprint(test)\n\n        with app.test_client() as c:\n            rv = c.get('\/')\n            self.assert_equal(rv.data, b'\/test\/')\n\n    def test_empty_url_defaults(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/', defaults={'page': 1})\n        @bp.route('\/page\/<int:page>')\n        def something(page):\n            return str(page)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'1')\n        self.assert_equal(c.get('\/page\/2').data, b'2')\n\n    def test_route_decorator_custom_endpoint(self):\n\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar', endpoint='bar')\n        def foo_bar():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/123', endpoint='123')\n        def foo_bar_foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/foo')\n        def bar_foo():\n            return flask.request.endpoint\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        @app.route('\/')\n        def index():\n            return flask.request.endpoint\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/').data, b'index')\n        self.assertEqual(c.get('\/py\/foo').data, b'bp.foo')\n        self.assertEqual(c.get('\/py\/bar').data, b'bp.bar')\n        self.assertEqual(c.get('\/py\/bar\/123').data, b'bp.123')\n        self.assertEqual(c.get('\/py\/bar\/foo').data, b'bp.bar_foo')\n\n    def test_route_decorator_custom_endpoint_with_dots(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        try:\n            @bp.route('\/bar', endpoint='bar.bar')\n            def foo_bar():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        try:\n            @bp.route('\/bar\/123', endpoint='bar.123')\n            def foo_bar_foo():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        def foo_foo_foo():\n            pass\n\n        self.assertRaises(\n            AssertionError,\n            lambda: bp.add_url_rule(\n                '\/bar\/123', endpoint='bar.123', view_func=foo_foo_foo\n            )\n        )\n\n        self.assertRaises(\n            AssertionError,\n            bp.route('\/bar\/123', endpoint='bar.123'),\n            lambda: None\n        )\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/py\/foo').data, b'bp.foo')\n        # The rule's didn't actually made it through\n        rv = c.get('\/py\/bar')\n        assert rv.status_code == 404\n        rv = c.get('\/py\/bar\/123')\n        assert rv.status_code == 404\n\n    def test_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_add_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('strrev')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_add_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'strrev')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_filter_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def super_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(super_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('super_reverse')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'super_reverse')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('is_boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['is_boolean'](False))\n\n    def test_add_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('is_boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['is_boolean'](False))\n\n    def test_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_template_test_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(BlueprintTestCase))\n    suite.addTest(unittest.makeSuite(ModuleTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.app\n    ~~~~~~~~~\n\n    This module implements the central WSGI application object.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nfrom threading import Lock\nfrom datetime import timedelta\nfrom itertools import chain\nfrom functools import update_wrapper\n\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.routing import Map, Rule, RequestRedirect, BuildError\nfrom werkzeug.exceptions import HTTPException, InternalServerError, \\\n     MethodNotAllowed, BadRequest\n\nfrom .helpers import _PackageBoundObject, url_for, get_flashed_messages, \\\n     locked_cached_property, _endpoint_from_view_func, find_package\nfrom . import json\nfrom .wrappers import Request, Response\nfrom .config import ConfigAttribute, Config\nfrom .ctx import RequestContext, AppContext, _AppCtxGlobals\nfrom .globals import _request_ctx_stack, request, session, g\nfrom .sessions import SecureCookieSessionInterface\nfrom .module import blueprint_is_module\nfrom .templating import DispatchingJinjaLoader, Environment, \\\n     _default_template_ctx_processor\nfrom .signals import request_started, request_finished, got_request_exception, \\\n     request_tearing_down, appcontext_tearing_down\nfrom ._compat import reraise, string_types, text_type, integer_types\n\n# a lock used for logger initialization\n_logger_lock = Lock()\n\n\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\n\n\ndef setupmethod(f):\n    \"\"\"Wraps a method so that it performs a check in debug mode if the\n    first request was already handled.\n    \"\"\"\n    def wrapper_func(self, *args, **kwargs):\n        if self.debug and self._got_first_request:\n            raise AssertionError('A setup function was called after the '\n                'first request was handled.  This usually indicates a bug '\n                'in the application where a module was not imported '\n                'and decorators or other functionality was called too late.\\n'\n                'To fix this make sure to import all your view modules, '\n                'database models and everything related at a central place '\n                'before the application starts serving requests.')\n        return f(self, *args, **kwargs)\n    return update_wrapper(wrapper_func, f)\n\n\nclass Flask(_PackageBoundObject):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an `__init__.py` file inside) or a standard module (just a `.py` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the `__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea what\n        belongs to your application.  This name is used to find resources\n        on the file system, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in `yourapplication\/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: the folder with static files that should be served\n                          at `static_url_path`.  Defaults to the ``'static'``\n                          folder in the root path of the application.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to `True` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    \"\"\"\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class = Response\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on expected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is not application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    # Backwards compatibility support\n    def _get_request_globals_class(self):\n        return self.app_ctx_globals_class\n    def _set_request_globals_class(self, value):\n        from warnings import warn\n        warn(DeprecationWarning('request_globals_class attribute is now '\n                                'called app_ctx_globals_class'))\n        self.app_ctx_globals_class = value\n    request_globals_class = property(_get_request_globals_class,\n                                     _set_request_globals_class)\n    del _get_request_globals_class, _set_request_globals_class\n\n    #: The debug flag.  Set this to `True` to enable debugging of the\n    #: application.  In debug mode the debugger will kick in when an unhandled\n    #: exception occurs and the integrated server will automatically reload\n    #: the application if changes in the code are detected.\n    #:\n    #: This attribute can also be configured from the config with the `DEBUG`\n    #: configuration key.  Defaults to `False`.\n    debug = ConfigAttribute('DEBUG')\n\n    #: The testing flag.  Set this to `True` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate unittest helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `TESTING` configuration key.  Defaults to `False`.\n    testing = ConfigAttribute('TESTING')\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and other things.  Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `SECRET_KEY` configuration key.  Defaults to `None`.\n    secret_key = ConfigAttribute('SECRET_KEY')\n\n    #: The secure cookie uses this for the name of the session cookie.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `SESSION_COOKIE_NAME` configuration key.  Defaults to ``'session'``\n    session_cookie_name = ConfigAttribute('SESSION_COOKIE_NAME')\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `PERMANENT_SESSION_LIFETIME` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute('PERMANENT_SESSION_LIFETIME',\n        get_converter=_make_timedelta)\n\n    #: Enable this if you want to use the X-Sendfile feature.  Keep in\n    #: mind that the server has to support this.  This only affects files\n    #: sent with the :func:`send_file` method.\n    #:\n    #: .. versionadded:: 0.2\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `USE_X_SENDFILE` configuration key.  Defaults to `False`.\n    use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')\n\n    #: The name of the logger to use.  By default the logger name is the\n    #: package name passed to the constructor.\n    #:\n    #: .. versionadded:: 0.4\n    logger_name = ConfigAttribute('LOGGER_NAME')\n\n    #: Enable the deprecated module support?  This is active by default\n    #: in 0.7 but will be changed to False in 0.8.  With Flask 1.0 modules\n    #: will be removed in favor of Blueprints\n    enable_modules = True\n\n    #: The logging format used for the debug logger.  This is only used when\n    #: the application is in debug mode, otherwise the attached logging\n    #: handler does the formatting.\n    #:\n    #: .. versionadded:: 0.3\n    debug_log_format = (\n        '-' * 80 + '\\n' +\n        '%(levelname)s in %(module)s [%(pathname)s:%(lineno)d]:\\n' +\n        '%(message)s\\n' +\n        '-' * 80\n    )\n\n    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_encoder = json.JSONEncoder\n\n    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_decoder = json.JSONDecoder\n\n    #: Options that are passed directly to the Jinja2 environment.\n    jinja_options = ImmutableDict(\n        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']\n    )\n\n    #: Default configuration parameters.\n    default_config = ImmutableDict({\n        'DEBUG':                                False,\n        'TESTING':                              False,\n        'PROPAGATE_EXCEPTIONS':                 None,\n        'PRESERVE_CONTEXT_ON_EXCEPTION':        None,\n        'SECRET_KEY':                           None,\n        'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n        'USE_X_SENDFILE':                       False,\n        'LOGGER_NAME':                          None,\n        'SERVER_NAME':                          None,\n        'APPLICATION_ROOT':                     None,\n        'SESSION_COOKIE_NAME':                  'session',\n        'SESSION_COOKIE_DOMAIN':                None,\n        'SESSION_COOKIE_PATH':                  None,\n        'SESSION_COOKIE_HTTPONLY':              True,\n        'SESSION_COOKIE_SECURE':                False,\n        'MAX_CONTENT_LENGTH':                   None,\n        'SEND_FILE_MAX_AGE_DEFAULT':            12 * 60 * 60, # 12 hours\n        'TRAP_BAD_REQUEST_ERRORS':              False,\n        'TRAP_HTTP_EXCEPTIONS':                 False,\n        'PREFERRED_URL_SCHEME':                 'http',\n        'JSON_AS_ASCII':                        True,\n        'JSON_SORT_KEYS':                       True,\n        'JSONIFY_PRETTYPRINT_REGULAR':          True,\n    })\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: the test client that is used with when `test_client` is used.\n    #:\n    #: .. versionadded:: 0.7\n    test_client_class = None\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface = SecureCookieSessionInterface()\n\n    def __init__(self, import_name, static_path=None, static_url_path=None,\n                 static_folder='static', template_folder='templates',\n                 instance_path=None, instance_relative_config=False):\n        _PackageBoundObject.__init__(self, import_name,\n                                     template_folder=template_folder)\n        if static_path is not None:\n            from warnings import warn\n            warn(DeprecationWarning('static_path is now called '\n                                    'static_url_path'), stacklevel=2)\n            static_url_path = static_path\n\n        if static_url_path is not None:\n            self.static_url_path = static_url_path\n        if static_folder is not None:\n            self.static_folder = static_folder\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError('If an instance path is provided it must be '\n                             'absolute.  A relative path was given instead.')\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        # Prepare the deferred setup of the logger.\n        self._logger = None\n        self.logger_name = self.import_name\n\n        #: A dictionary of all view functions registered.  The keys will\n        #: be function names which are also used to generate URLs and\n        #: the values are the function objects themselves.\n        #: To register a view function, use the :meth:`route` decorator.\n        self.view_functions = {}\n\n        # support for the now deprecated `error_handlers` attribute.  The\n        # :attr:`error_handler_spec` shall be used now.\n        self._error_handlers = {}\n\n        #: A dictionary of all registered error handlers.  The key is `None`\n        #: for error handlers active on the application, otherwise the key is\n        #: the name of the blueprint.  Each key points to another dictionary\n        #: where they key is the status code of the http exception.  The\n        #: special key `None` points to a list of tuples where the first item\n        #: is the class for the instance check and the second the error handler\n        #: function.\n        #:\n        #: To register a error handler, use the :meth:`errorhandler`\n        #: decorator.\n        self.error_handler_spec = {None: self._error_handlers}\n\n        #: A list of functions that are called when :meth:`url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n        #: is called with `error`, `endpoint` and `values`.  If a function\n        #: returns `None` or raises a `BuildError` the next function is\n        #: tried.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers = []\n\n        #: A dictionary with lists of functions that should be called at the\n        #: beginning of the request.  The key of the dictionary is the name of\n        #: the blueprint this function is active for, `None` for all requests.\n        #: This can for example be used to open database connections or\n        #: getting hold of the currently logged in user.  To register a\n        #: function here, use the :meth:`before_request` decorator.\n        self.before_request_funcs = {}\n\n        #: A lists of functions that should be called at the beginning of the\n        #: first request to this instance.  To register a function here, use\n        #: the :meth:`before_first_request` decorator.\n        #:\n        #: .. versionadded:: 0.8\n        self.before_first_request_funcs = []\n\n        #: A dictionary with lists of functions that should be called after\n        #: each request.  The key of the dictionary is the name of the blueprint\n        #: this function is active for, `None` for all requests.  This can for\n        #: example be used to open database connections or getting hold of the\n        #: currently logged in user.  To register a function here, use the\n        #: :meth:`after_request` decorator.\n        self.after_request_funcs = {}\n\n        #: A dictionary with lists of functions that are called after\n        #: each request, even if an exception has occurred. The key of the\n        #: dictionary is the name of the blueprint this function is active for,\n        #: `None` for all requests. These functions are not allowed to modify\n        #: the request, and their return values are ignored. If an exception\n        #: occurred while processing the request, it gets passed to each\n        #: teardown_request function. To register a function here, use the\n        #: :meth:`teardown_request` decorator.\n        #:\n        #: .. versionadded:: 0.7\n        self.teardown_request_funcs = {}\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs = []\n\n        #: A dictionary with lists of functions that can be used as URL\n        #: value processor functions.  Whenever a URL is built these functions\n        #: are called to modify the dictionary of values in place.  The key\n        #: `None` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #:\n        #: .. versionadded:: 0.7\n        self.url_value_preprocessors = {}\n\n        #: A dictionary with lists of functions that can be used as URL value\n        #: preprocessors.  The key `None` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #: of URL values before they are used as the keyword arguments of the\n        #: view function.  For each function registered this one should also\n        #: provide a :meth:`url_defaults` function that adds the parameters\n        #: automatically again that were removed that way.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_default_functions = {}\n\n        #: A dictionary with list of functions that are called without argument\n        #: to populate the template context.  The key of the dictionary is the\n        #: name of the blueprint this function is active for, `None` for all\n        #: requests.  Each returns a dictionary that the template context is\n        #: updated with.  To register a function here, use the\n        #: :meth:`context_processor` decorator.\n        self.template_context_processors = {\n            None: [_default_template_ctx_processor]\n        }\n\n        #: all the attached blueprints in a dictionary by name.  Blueprints\n        #: can be attached multiple times so this dictionary does not tell\n        #: you how often they got attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.  For backwards compatibility extensions should register\n        #: themselves like this::\n        #:\n        #:      if not hasattr(app, 'extensions'):\n        #:          app.extensions = {}\n        #:      app.extensions['extensionname'] = SomeObject()\n        #:\n        #: The key must match the name of the `flaskext` module.  For example in\n        #: case of a \"Flask-Foo\" extension in `flaskext.foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(BaseConverter.to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = Map()\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n\n        # register the static folder for the application.  Do that even\n        # if the folder does not exist.  First of all it might be created\n        # while the server is running (usually happens during development)\n        # but also because google appengine stores static files somewhere\n        # else when mapped with the .yml file.\n        if self.has_static_folder:\n            self.add_url_rule(self.static_url_path + '\/<path:filename>',\n                              endpoint='static',\n                              view_func=self.send_static_file)\n\n    def _get_error_handlers(self):\n        from warnings import warn\n        warn(DeprecationWarning('error_handlers is deprecated, use the '\n            'new error_handler_spec attribute instead.'), stacklevel=1)\n        return self._error_handlers\n    def _set_error_handlers(self, value):\n        self._error_handlers = value\n        self.error_handler_spec[None] = value\n    error_handlers = property(_get_error_handlers, _set_error_handlers)\n    del _get_error_handlers, _set_error_handlers\n\n    @locked_cached_property\n    def name(self):\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == '__main__':\n            fn = getattr(sys.modules['__main__'], '__file__', None)\n            if fn is None:\n                return '__main__'\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @property\n    def propagate_exceptions(self):\n        \"\"\"Returns the value of the `PROPAGATE_EXCEPTIONS` configuration\n        value in case it's set, otherwise a sensible default is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PROPAGATE_EXCEPTIONS']\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n\n    @property\n    def preserve_context_on_exception(self):\n        \"\"\"Returns the value of the `PRESERVE_CONTEXT_ON_EXCEPTION`\n        configuration value in case it's set, otherwise a sensible default\n        is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PRESERVE_CONTEXT_ON_EXCEPTION']\n        if rv is not None:\n            return rv\n        return self.debug\n\n    @property\n    def logger(self):\n        \"\"\"A :class:`logging.Logger` object for this application.  The\n        default configuration is to log to stderr if the application is\n        in debug mode.  This logger can be used to (surprise) log messages.\n        Here some examples::\n\n            app.logger.debug('A value for debugging')\n            app.logger.warning('A warning occurred (%d apples)', 42)\n            app.logger.error('An error occurred')\n\n        .. versionadded:: 0.3\n        \"\"\"\n        if self._logger and self._logger.name == self.logger_name:\n            return self._logger\n        with _logger_lock:\n            if self._logger and self._logger.name == self.logger_name:\n                return self._logger\n            from flask.logging import create_logger\n            self._logger = rv = create_logger(self)\n            return rv\n\n    @locked_cached_property\n    def jinja_env(self):\n        \"\"\"The Jinja2 environment used to load templates.\"\"\"\n        return self.create_jinja_environment()\n\n    @property\n    def got_first_request(self):\n        \"\"\"This attribute is set to `True` if the application started\n        handling the first request.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        return self._got_first_request\n\n    def make_config(self, instance_relative=False):\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        return Config(root_path, self.default_config)\n\n    def auto_find_instance_path(self):\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, 'instance')\n        return os.path.join(prefix, 'var', self.name + '-instance')\n\n    def open_instance_resource(self, resource, mode='rb'):\n        \"\"\"Opens a resource from the application's instance folder\n        (:attr:`instance_path`).  Otherwise works like\n        :meth:`open_resource`.  Instance resources can also be opened for\n        writing.\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        :param mode: resource file opening mode, default is 'rb'.\n        \"\"\"\n        return open(os.path.join(self.instance_path, resource), mode)\n\n    def create_jinja_environment(self):\n        \"\"\"Creates the Jinja2 environment based on :attr:`jinja_options`\n        and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds\n        the Jinja2 globals and filters after initialization.  Override\n        this function to customize the behavior.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        options = dict(self.jinja_options)\n        if 'autoescape' not in options:\n            options['autoescape'] = self.select_jinja_autoescape\n        rv = Environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g\n        )\n        rv.filters['tojson'] = json.tojson_filter\n        return rv\n\n    def create_global_jinja_loader(self):\n        \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n\n    def init_jinja_globals(self):\n        \"\"\"Deprecated.  Used to initialize the Jinja2 globals.\n\n        .. versionadded:: 0.5\n        .. versionchanged:: 0.7\n           This method is deprecated with 0.7.  Override\n           :meth:`create_jinja_environment` instead.\n        \"\"\"\n\n    def select_jinja_autoescape(self, filename):\n        \"\"\"Returns `True` if autoescaping should be active for the given\n        template name.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return False\n        return filename.endswith(('.html', '.htm', '.xml', '.xhtml'))\n\n    def update_template_context(self, context):\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        # make sure the original values win.  This makes it possible to\n        # easier add new variables in context processors without breaking\n        # existing views.\n        context.update(orig_ctx)\n\n    def run(self, host=None, port=None, debug=None, **options):\n        \"\"\"Runs the application on a local development server.  If the\n        :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to `True` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        .. versionchanged:: 0.10\n           The default port is now picked from the ``SERVER_NAME`` variable.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n                     have the server available externally as well. Defaults to\n                     ``'127.0.0.1'``.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n                     port defined in the ``SERVER_NAME`` config variable if\n                     present.\n        :param debug: if given, enable or disable debug mode.\n                      See :attr:`debug`.\n        :param options: the options to be forwarded to the underlying\n                        Werkzeug server.  See\n                        :func:`werkzeug.serving.run_simple` for more\n                        information.\n        \"\"\"\n        from werkzeug.serving import run_simple\n        if host is None:\n            host = '127.0.0.1'\n        if port is None:\n            server_name = self.config['SERVER_NAME']\n            if server_name and ':' in server_name:\n                port = int(server_name.rsplit(':', 1)[1])\n            else:\n                port = 5000\n        if debug is not None:\n            self.debug = bool(debug)\n        options.setdefault('use_reloader', self.debug)\n        options.setdefault('use_debugger', self.debug)\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # resetted normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False\n\n    def test_client(self, use_cookies=True):\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :ref:`testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a `with` block to defer the closing down\n        of the context until the end of the `with` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('\/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for `with` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from flask.testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies)\n\n    def open_session(self, request):\n        \"\"\"Creates or opens a new session.  Default implementation stores all\n        session data in a signed cookie.  This requires that the\n        :attr:`secret_key` is set.  Instead of overriding this method\n        we recommend replacing the :class:`session_interface`.\n\n        :param request: an instance of :attr:`request_class`.\n        \"\"\"\n        return self.session_interface.open_session(self, request)\n\n    def save_session(self, session, response):\n        \"\"\"Saves the session if it needs updates.  For the default\n        implementation, check :meth:`open_session`.  Instead of overriding this\n        method we recommend replacing the :class:`session_interface`.\n\n        :param session: the session to be saved (a\n                        :class:`~werkzeug.contrib.securecookie.SecureCookie`\n                        object)\n        :param response: an instance of :attr:`response_class`\n        \"\"\"\n        return self.session_interface.save_session(self, session, response)\n\n    def make_null_session(self):\n        \"\"\"Creates a new instance of a missing session.  Instead of overriding\n        this method we recommend replacing the :class:`session_interface`.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return self.session_interface.make_null_session(self)\n\n    def register_module(self, module, **options):\n        \"\"\"Registers a module with this application.  The keyword argument\n        of this function are the same as the ones for the constructor of the\n        :class:`Module` class and will override the values of the module if\n        provided.\n\n        .. versionchanged:: 0.7\n           The module system was deprecated in favor for the blueprint\n           system.\n        \"\"\"\n        assert blueprint_is_module(module), 'register_module requires ' \\\n            'actual module objects.  Please upgrade to blueprints though.'\n        if not self.enable_modules:\n            raise RuntimeError('Module support was disabled but code '\n                'attempted to register a module named %r' % module)\n        else:\n            from warnings import warn\n            warn(DeprecationWarning('Modules are deprecated.  Upgrade to '\n                'using blueprints.  Have a look into the documentation for '\n                'more information.  If this module was registered by a '\n                'Flask-Extension upgrade the extension or contact the author '\n                'of that extension instead.  (Registered %r)' % module),\n                stacklevel=2)\n\n        self.register_blueprint(module, **options)\n\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        \"\"\"Registers a blueprint on the application.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, \\\n                'A blueprint\\'s name collision occurred between %r and ' \\\n                '%r.  Both share the same name \"%s\".  Blueprints that ' \\\n                'are created on the fly need unique names.' % \\\n                (blueprint, self.blueprints[blueprint.name], blueprint.name)\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n\n    @setupmethod\n    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n        \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n        decorator.  If a view_func is provided it will be registered with the\n        endpoint.\n\n        Basically this example::\n\n            @app.route('\/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('\/', 'index', index)\n\n        If the view_func is not provided you will need to connect the endpoint\n        to a view function like so::\n\n            app.view_functions['index'] = index\n\n        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n        to customize the behavior via subclassing you only need to change\n        this method.\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        .. versionchanged:: 0.2\n           `view_func` parameter added.\n\n        .. versionchanged:: 0.6\n           `OPTIONS` is added automatically as method.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (`GET`, `POST` etc.).  By default a rule\n                        just listens for `GET` (and implicitly `HEAD`).\n                        Starting with Flask 0.6, `OPTIONS` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options['endpoint'] = endpoint\n        methods = options.pop('methods', None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only `GET` as default.\n        if methods is None:\n            methods = getattr(view_func, 'methods', None) or ('GET',)\n        methods = set(methods)\n\n        # Methods that should always be added\n        required_methods = set(getattr(view_func, 'required_methods', ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        provide_automatic_options = getattr(view_func,\n            'provide_automatic_options', None)\n\n        if provide_automatic_options is None:\n            if 'OPTIONS' not in methods:\n                provide_automatic_options = True\n                required_methods.add('OPTIONS')\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        # due to a werkzeug bug we need to make sure that the defaults are\n        # None if they are an empty dictionary.  This should not be necessary\n        # with Werkzeug 0.7\n        options['defaults'] = options.get('defaults') or None\n\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError('View function mapping is overwriting an '\n                                     'existing endpoint function: %s' % endpoint)\n            self.view_functions[endpoint] = view_func\n\n    def route(self, rule, **options):\n        \"\"\"A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as :meth:`add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('\/')\n            def index():\n                return 'Hello World'\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (`GET`, `POST` etc.).  By default a rule\n                        just listens for `GET` (and implicitly `HEAD`).\n                        Starting with Flask 0.6, `OPTIONS` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        def decorator(f):\n            endpoint = options.pop('endpoint', None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n        return decorator\n\n    @setupmethod\n    def endpoint(self, endpoint):\n        \"\"\"A decorator to register a function as an endpoint.\n        Example::\n\n            @app.endpoint('example.endpoint')\n            def example():\n                return \"example\"\n\n        :param endpoint: the name of the endpoint\n        \"\"\"\n        def decorator(f):\n            self.view_functions[endpoint] = f\n            return f\n        return decorator\n\n    @setupmethod\n    def errorhandler(self, code_or_exception):\n        \"\"\"A decorator that is used to register a function give a given\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        You can also register a function as error handler without using\n        the :meth:`errorhandler` decorator.  The following example is\n        equivalent to the one above::\n\n            def page_not_found(error):\n                return 'This page does not exist', 404\n            app.error_handler_spec[None][404] = page_not_found\n\n        Setting error handlers via assignments to :attr:`error_handler_spec`\n        however is discouraged as it requires fiddling with nested dictionaries\n        and the special case for arbitrary exception types.\n\n        The first `None` refers to the active blueprint.  If the error\n        handler should be application wide `None` shall be used.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code: the code as integer for the handler\n        \"\"\"\n        def decorator(f):\n            self._register_error_handler(None, code_or_exception, f)\n            return f\n        return decorator\n\n    def register_error_handler(self, code_or_exception, f):\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._register_error_handler(None, code_or_exception, f)\n\n    @setupmethod\n    def _register_error_handler(self, key, code_or_exception, f):\n        if isinstance(code_or_exception, HTTPException):\n            code_or_exception = code_or_exception.code\n        if isinstance(code_or_exception, integer_types):\n            assert code_or_exception != 500 or key is None, \\\n                'It is currently not possible to register a 500 internal ' \\\n                'server error on a per-blueprint level.'\n            self.error_handler_spec.setdefault(key, {})[code_or_exception] = f\n        else:\n            self.error_handler_spec.setdefault(key, {}).setdefault(None, []) \\\n                .append((code_or_exception, f))\n\n    @setupmethod\n    def template_filter(self, name=None):\n        \"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        \"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f\n\n    @setupmethod\n    def template_test(self, name=None):\n        \"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        \"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f\n\n\n    @setupmethod\n    def template_global(self, name=None):\n        \"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        \"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f\n\n    @setupmethod\n    def before_request(self, f):\n        \"\"\"Registers a function to run before each request.\"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def before_first_request(self, f):\n        \"\"\"Registers a function to be run before the first request to this\n        instance of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.before_first_request_funcs.append(f)\n\n    @setupmethod\n    def after_request(self, f):\n        \"\"\"Register a function to be run after each request.  Your function\n        must take one parameter, a :attr:`response_class` object and return\n        a new response object or the same (see :meth:`process_response`).\n\n        As of Flask 0.7 this function might not be executed at the end of the\n        request in case an unhandled exception occurred.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_request(self, f):\n        \"\"\"Register a function to be run at the end of each request,\n        regardless of whether there was an exception or not.  These functions\n        are executed when the request context is popped, even if not an\n        actual request was performed.\n\n        Example::\n\n            ctx = app.test_request_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the request context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Generally teardown functions must take every necessary step to avoid\n        that they will fail.  If they do execute code that might fail they\n        will have to surround the execution of these code by try\/except\n        statements and log occurring errors.\n\n        When a teardown function was called because of a exception it will\n        be passed an error object.\n\n        .. admonition:: Debug Note\n\n           In debug mode Flask will not tear down a request on an exception\n           immediately.  Instead if will keep it alive so that the interactive\n           debugger can still access it.  This behavior can be controlled\n           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_appcontext(self, f):\n        \"\"\"Registers a function to be called when the application context\n        ends.  These functions are typically also called when the request\n        context is popped.\n\n        Example::\n\n            ctx = app.app_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the app context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Since a request context typically also manages an application\n        context it would also be called when you pop a request context.\n\n        When a teardown function was called because of an exception it will\n        be passed an error object.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n\n    @setupmethod\n    def context_processor(self, f):\n        \"\"\"Registers a template context processor function.\"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n\n    @setupmethod\n    def url_value_preprocessor(self, f):\n        \"\"\"Registers a function as URL value preprocessor for all view\n        functions of the application.  It's called before the view functions\n        are called and can modify the url values provided.\n        \"\"\"\n        self.url_value_preprocessors.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def url_defaults(self, f):\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n        \"\"\"\n        self.url_default_functions.setdefault(None, []).append(f)\n        return f\n\n    def handle_http_exception(self, e):\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        handlers = self.error_handler_spec.get(request.blueprint)\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n        if handlers and e.code in handlers:\n            handler = handlers[e.code]\n        else:\n            handler = self.error_handler_spec[None].get(e.code)\n        if handler is None:\n            return e\n        return handler(e)\n\n    def trap_http_exception(self, e):\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return `False` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to `True`.  It\n        also returns `True` if ``TRAP_HTTP_EXCEPTIONS`` is set to `True`.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns `True` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config['TRAP_HTTP_EXCEPTIONS']:\n            return True\n        if self.config['TRAP_BAD_REQUEST_ERRORS']:\n            return isinstance(e, BadRequest)\n        return False\n\n    def handle_user_exception(self, e):\n        \"\"\"This method is called whenever an exception occurs that should be\n        handled.  A special case are\n        :class:`~werkzeug.exception.HTTPException`\\s which are forwarded by\n        this function to the :meth:`handle_http_exception` method.  This\n        function will either return a response value or reraise the\n        exception with the same traceback.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        assert exc_value is e\n\n        # ensure not to trash sys.exc_info() at that point in case someone\n        # wants the traceback preserved in handle_http_exception.  Of course\n        # we cannot prevent users from trashing it themselves in a custom\n        # trap_http_exception method so that's their fault then.\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        blueprint_handlers = ()\n        handlers = self.error_handler_spec.get(request.blueprint)\n        if handlers is not None:\n            blueprint_handlers = handlers.get(None, ())\n        app_handlers = self.error_handler_spec[None].get(None, ())\n        for typecheck, handler in chain(blueprint_handlers, app_handlers):\n            if isinstance(e, typecheck):\n                return handler(e)\n\n        reraise(exc_type, exc_value, tb)\n\n    def handle_exception(self, e):\n        \"\"\"Default exception handling that kicks in when an exception\n        occurs that is not caught.  In debug mode the exception will\n        be re-raised immediately, otherwise it is logged and the handler\n        for a 500 internal server error is used.  If no such handler\n        exists, a default 500 internal server error message is displayed.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n\n        got_request_exception.send(self, exception=e)\n        handler = self.error_handler_spec[None].get(500)\n\n        if self.propagate_exceptions:\n            # if we want to repropagate the exception, we can attempt to\n            # raise it with the whole traceback in case we can do that\n            # (the function was actually called from the except part)\n            # otherwise, we just raise the error again\n            if exc_value is e:\n                reraise(exc_type, exc_value, tb)\n            else:\n                raise e\n\n        self.log_exception((exc_type, exc_value, tb))\n        if handler is None:\n            return InternalServerError()\n        return handler(e)\n\n    def log_exception(self, exc_info):\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error('Exception on %s [%s]' % (\n            request.path,\n            request.method\n        ), exc_info=exc_info)\n\n    def raise_routing_exception(self, request):\n        \"\"\"Exceptions that are recording during routing are reraised with\n        this method.  During debug we are not reraising redirect requests\n        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n        a different error instead to help debug situations.\n\n        :internal:\n        \"\"\"\n        if not self.debug \\\n           or not isinstance(request.routing_exception, RequestRedirect) \\\n           or request.method in ('GET', 'HEAD', 'OPTIONS'):\n            raise request.routing_exception\n\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n\n    def dispatch_request(self):\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if getattr(rule, 'provide_automatic_options', False) \\\n           and req.method == 'OPTIONS':\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        return self.view_functions[rule.endpoint](**req.view_args)\n\n    def full_dispatch_request(self):\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        response = self.make_response(rv)\n        response = self.process_response(response)\n        request_finished.send(self, response=response)\n        return response\n\n    def try_trigger_before_first_request_functions(self):\n        \"\"\"Called before each request and will ensure that it triggers\n        the :attr:`before_first_request_funcs` and only exactly once per\n        application instance (which means process usually).\n\n        :internal:\n        \"\"\"\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            self._got_first_request = True\n            for func in self.before_first_request_funcs:\n                func()\n\n    def make_default_options_response(self):\n        \"\"\"This method is called to create the default `OPTIONS` response.\n        This can be changed through subclassing to change the default\n        behavior of `OPTIONS` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        adapter = _request_ctx_stack.top.url_adapter\n        if hasattr(adapter, 'allowed_methods'):\n            methods = adapter.allowed_methods()\n        else:\n            # fallback for Werkzeug < 0.7\n            methods = []\n            try:\n                adapter.match(method='--')\n            except MethodNotAllowed as e:\n                methods = e.valid_methods\n            except HTTPException as e:\n                pass\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n\n    def should_ignore_error(self, error):\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns `True` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False\n\n    def make_response(self, rv):\n        \"\"\"Converts the return value from a view function to a real\n        response object that is an instance of :attr:`response_class`.\n\n        The following types are allowed for `rv`:\n\n        .. tabularcolumns:: |p{3.5cm}|p{9.5cm}|\n\n        ======================= ===========================================\n        :attr:`response_class`  the object is returned unchanged\n        :class:`str`            a response object is created with the\n                                string as body\n        :class:`unicode`        a response object is created with the\n                                string encoded to utf-8 as body\n        a WSGI function         the function is called as WSGI application\n                                and buffered as response object\n        :class:`tuple`          A tuple in the form ``(response, status,\n                                headers)`` where `response` is any of the\n                                types defined here, `status` is a string\n                                or an integer and `headers` is a list of\n                                a dictionary with header values.\n        ======================= ===========================================\n\n        :param rv: the return value from the view function\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n        status = headers = None\n        if isinstance(rv, tuple):\n            rv, status, headers = rv + (None,) * (3 - len(rv))\n\n        if rv is None:\n            raise ValueError('View function did not return a response')\n\n        if not isinstance(rv, self.response_class):\n            # When we create a response object directly, we let the constructor\n            # set the headers and status.  We do this because there can be\n            # some extra logic involved when creating these objects with\n            # specific values (like default content type selection).\n            if isinstance(rv, (text_type, bytes, bytearray)):\n                rv = self.response_class(rv, headers=headers, status=status)\n                headers = status = None\n            else:\n                rv = self.response_class.force_type(rv, request.environ)\n\n        if status is not None:\n            if isinstance(status, string_types):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.extend(headers)\n\n        return rv\n\n    def create_url_adapter(self, request):\n        \"\"\"Creates a URL adapter for the given request.  The URL adapter\n        is created at a point where the request context is not yet set up\n        so the request is passed explicitly.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n           This can now also be called without a request object when the\n           URL adapter is created for the application context.\n        \"\"\"\n        if request is not None:\n            return self.url_map.bind_to_environ(request.environ,\n                server_name=self.config['SERVER_NAME'])\n        # We need at the very least the server name to be set for this\n        # to work.\n        if self.config['SERVER_NAME'] is not None:\n            return self.url_map.bind(\n                self.config['SERVER_NAME'],\n                script_name=self.config['APPLICATION_ROOT'] or '\/',\n                url_scheme=self.config['PREFERRED_URL_SCHEME'])\n\n    def inject_url_defaults(self, endpoint, values):\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        funcs = self.url_default_functions.get(None, ())\n        if '.' in endpoint:\n            bp = endpoint.rsplit('.', 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n\n    def handle_url_build_error(self, error, endpoint, values):\n        \"\"\"Handle :class:`~werkzeug.routing.BuildError` on :meth:`url_for`.\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n                if rv is not None:\n                    return rv\n            except BuildError as error:\n                pass\n\n        # At this point we want to reraise the exception.  If the error is\n        # still the same one we can reraise it with the original traceback,\n        # otherwise we raise it from here.\n        if error is exc_value:\n            reraise(exc_type, exc_value, tb)\n        raise error\n\n    def preprocess_request(self):\n        \"\"\"Called before the actual request dispatching and will\n        call every as :meth:`before_request` decorated function.\n        If any of these function returns a value it's handled as\n        if it was the return value from the view and further\n        request handling is stopped.\n\n        This also triggers the :meth:`url_value_processor` functions before\n        the actual :meth:`before_request` functions are called.\n        \"\"\"\n        bp = _request_ctx_stack.top.request.blueprint\n\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n\n    def process_response(self, response):\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.save_session(ctx.session, response)\n        return response\n\n    def do_teardown_request(self, exc=None):\n        \"\"\"Called after the actual request dispatching and will\n        call every as :meth:`teardown_request` decorated function.  This is\n        not actually called by the :class:`Flask` object itself but is always\n        triggered when the request context is popped.  That way we have a\n        tighter control over certain resources under testing environments.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.  Previously this was always using the\n           current exception information.\n        \"\"\"\n        if exc is None:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            rv = func(exc)\n        request_tearing_down.send(self, exc=exc)\n\n    def do_teardown_appcontext(self, exc=None):\n        \"\"\"Called when an application context is popped.  This works pretty\n        much the same as :meth:`do_teardown_request` but for the application\n        context.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is None:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n\n    def app_context(self):\n        \"\"\"Binds the application only.  For as long as the application is bound\n        to the current context the :data:`flask.current_app` points to that\n        application.  An application context is automatically created when a\n        request context is pushed if necessary.\n\n        Example usage::\n\n            with app.app_context():\n                ...\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ):\n        \"\"\"Creates a :class:`~flask.ctx.RequestContext` from the given\n        environment and binds it to the current context.  This must be used in\n        combination with the `with` statement because the request is only bound\n        to the current context for the duration of the `with` block.\n\n        Example usage::\n\n            with app.request_context(environ):\n                do_something_with(request)\n\n        The object returned can also be used without the `with` statement\n        which is useful for working in the shell.  The example above is\n        doing exactly the same as this code::\n\n            ctx = app.request_context(environ)\n            ctx.push()\n            try:\n                do_something_with(request)\n            finally:\n                ctx.pop()\n\n        .. versionchanged:: 0.3\n           Added support for non-with statement usage and `with` statement\n           is now passed the ctx object.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args, **kwargs):\n        \"\"\"Creates a WSGI environment from the given values (see\n        :func:`werkzeug.test.EnvironBuilder` for more information, this\n        function accepts the same arguments).\n        \"\"\"\n        from flask.testing import make_test_environ_builder\n        builder = make_test_environ_builder(self, *args, **kwargs)\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(self, environ, start_response):\n        \"\"\"The actual WSGI application.  This is not implemented in\n        `__call__` so that middlewares can be applied without losing a\n        reference to the class.  So instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n           The behavior of the before and after request callbacks was changed\n           under error conditions and a new callback was added that will\n           always execute at the end of the request, independent on if an\n           error occurred or not.  See :ref:`callbacks-and-errors`.\n\n        :param environ: a WSGI environment\n        :param start_response: a callable accepting a status code,\n                               a list of headers and an optional\n                               exception context to start the response\n        \"\"\"\n        ctx = self.request_context(environ)\n        ctx.push()\n        error = None\n        try:\n            try:\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.make_response(self.handle_exception(e))\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            ctx.auto_pop(error)\n\n    @property\n    def modules(self):\n        from warnings import warn\n        warn(DeprecationWarning('Flask.modules is deprecated, use '\n                                'Flask.blueprints instead'), stacklevel=2)\n        return self.blueprints\n\n    def __call__(self, environ, start_response):\n        \"\"\"Shortcut for :attr:`wsgi_app`.\"\"\"\n        return self.wsgi_app(environ, start_response)\n\n    def __repr__(self):\n        return '<%s %r>' % (\n            self.__class__.__name__,\n            self.name,\n        )\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.blueprints\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Blueprints (and currently modules)\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nimport warnings\nfrom flask.testsuite import FlaskTestCase, emits_module_deprecation_warning\nfrom flask._compat import text_type\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_cache_control_header\nfrom jinja2 import TemplateNotFound\n\n\n# import moduleapp here because it uses deprecated features and we don't\n# want to see the warnings\nwarnings.simplefilter('ignore', DeprecationWarning)\nfrom moduleapp import app as moduleapp\nwarnings.simplefilter('default', DeprecationWarning)\n\n\nclass ModuleTestCase(FlaskTestCase):\n\n    @emits_module_deprecation_warning\n    def test_basic_module(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.route('\/')\n        def admin_index():\n            return 'admin index'\n        @admin.route('\/login')\n        def admin_login():\n            return 'admin login'\n        @admin.route('\/logout')\n        def admin_logout():\n            return 'admin logout'\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'the index')\n        self.assert_equal(c.get('\/admin\/').data, b'admin index')\n        self.assert_equal(c.get('\/admin\/login').data, b'admin login')\n        self.assert_equal(c.get('\/admin\/logout').data, b'admin logout')\n\n    @emits_module_deprecation_warning\n    def test_default_endpoint_name(self):\n        app = flask.Flask(__name__)\n        mod = flask.Module(__name__, 'frontend')\n        def index():\n            return 'Awesome'\n        mod.add_url_rule('\/', view_func=index)\n        app.register_module(mod)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'Awesome')\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('frontend.index'), '\/')\n\n    @emits_module_deprecation_warning\n    def test_request_processing(self):\n        catched = []\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.before_request\n        def before_admin_request():\n            catched.append('before-admin')\n        @admin.after_request\n        def after_admin_request(response):\n            catched.append('after-admin')\n            return response\n        @admin.route('\/')\n        def admin_index():\n            return 'the admin'\n        @app.before_request\n        def before_request():\n            catched.append('before-app')\n        @app.after_request\n        def after_request(response):\n            catched.append('after-app')\n            return response\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/').data, b'the index')\n        self.assert_equal(catched, ['before-app', 'after-app'])\n        del catched[:]\n\n        self.assert_equal(c.get('\/admin\/').data, b'the admin')\n        self.assert_equal(catched, ['before-app', 'before-admin',\n                           'after-admin', 'after-app'])\n\n    @emits_module_deprecation_warning\n    def test_context_processors(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @app.context_processor\n        def inject_all_regular():\n            return {'a': 1}\n        @admin.context_processor\n        def inject_admin():\n            return {'b': 2}\n        @admin.app_context_processor\n        def inject_all_module():\n            return {'c': 3}\n        @app.route('\/')\n        def index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        @admin.route('\/')\n        def admin_index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'13')\n        self.assert_equal(c.get('\/admin\/').data, b'123')\n\n    @emits_module_deprecation_warning\n    def test_late_binding(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.route('\/')\n        def index():\n            return '42'\n        app.register_module(admin, url_prefix='\/admin')\n        self.assert_equal(app.test_client().get('\/admin\/').data, b'42')\n\n    @emits_module_deprecation_warning\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.app_errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @admin.app_errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @admin.route('\/')\n        def index():\n            flask.abort(404)\n        @admin.route('\/error')\n        def error():\n            1 \/\/ 0\n        app.register_module(admin)\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, b'not found')\n        rv = c.get('\/error')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_equal(b'internal server error', rv.data)\n\n    def test_templates_and_static(self):\n        app = moduleapp\n        app.testing = True\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), b'Admin File')\n        rv.close()\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), b'\/* nested file *\/')\n        rv.close()\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_true(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_safe_access(self):\n        app = moduleapp\n\n        with app.test_request_context():\n            f = app.view_functions['admin.static']\n\n            try:\n                f('\/etc\/passwd')\n            except NotFound:\n                pass\n            else:\n                self.assert_true(0, 'expected exception')\n            try:\n                f('..\/__init__.py')\n            except NotFound:\n                pass\n            else:\n                self.assert_true(0, 'expected exception')\n\n            # testcase for a security issue that may exist on windows systems\n            import os\n            import ntpath\n            old_path = os.path\n            os.path = ntpath\n            try:\n                try:\n                    f('..\\\\__init__.py')\n                except NotFound:\n                    pass\n                else:\n                    self.assert_true(0, 'expected exception')\n            finally:\n                os.path = old_path\n\n    @emits_module_deprecation_warning\n    def test_endpoint_decorator(self):\n        from werkzeug.routing import Submount, Rule\n        from flask import Module\n\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n        module = Module(__name__, __name__)\n\n        @module.endpoint('bar')\n        def bar():\n            return 'bar'\n\n        @module.endpoint('index')\n        def index():\n            return 'index'\n\n        app.register_module(module)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, b'index')\n        self.assert_equal(c.get('\/foo\/bar').data, b'bar')\n\n\nclass BlueprintTestCase(FlaskTestCase):\n\n    def test_blueprint_specific_error_handling(self):\n        frontend = flask.Blueprint('frontend', __name__)\n        backend = flask.Blueprint('backend', __name__)\n        sideend = flask.Blueprint('sideend', __name__)\n\n        @frontend.errorhandler(403)\n        def frontend_forbidden(e):\n            return 'frontend says no', 403\n\n        @frontend.route('\/frontend-no')\n        def frontend_no():\n            flask.abort(403)\n\n        @backend.errorhandler(403)\n        def backend_forbidden(e):\n            return 'backend says no', 403\n\n        @backend.route('\/backend-no')\n        def backend_no():\n            flask.abort(403)\n\n        @sideend.route('\/what-is-a-sideend')\n        def sideend_no():\n            flask.abort(403)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n        app.register_blueprint(sideend)\n\n        @app.errorhandler(403)\n        def app_forbidden(e):\n            return 'application itself says no', 403\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/frontend-no').data, b'frontend says no')\n        self.assert_equal(c.get('\/backend-no').data, b'backend says no')\n        self.assert_equal(c.get('\/what-is-a-sideend').data, b'application itself says no')\n\n    def test_blueprint_url_definitions(self):\n        bp = flask.Blueprint('test', __name__)\n\n        @bp.route('\/foo', defaults={'baz': 42})\n        def foo(bar, baz):\n            return '%s\/%d' % (bar, baz)\n\n        @bp.route('\/bar')\n        def bar(bar):\n            return text_type(bar)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/1', url_defaults={'bar': 23})\n        app.register_blueprint(bp, url_prefix='\/2', url_defaults={'bar': 19})\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/1\/foo').data, b'23\/42')\n        self.assert_equal(c.get('\/2\/foo').data, b'19\/42')\n        self.assert_equal(c.get('\/1\/bar').data, b'23')\n        self.assert_equal(c.get('\/2\/bar').data, b'19')\n\n    def test_blueprint_url_processors(self):\n        bp = flask.Blueprint('frontend', __name__, url_prefix='\/<lang_code>')\n\n        @bp.url_defaults\n        def add_language_code(endpoint, values):\n            values.setdefault('lang_code', flask.g.lang_code)\n\n        @bp.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop('lang_code')\n\n        @bp.route('\/')\n        def index():\n            return flask.url_for('.about')\n\n        @bp.route('\/about')\n        def about():\n            return flask.url_for('.index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/de\/').data, b'\/de\/about')\n        self.assert_equal(c.get('\/de\/about').data, b'\/de\/')\n\n    def test_templates_and_static(self):\n        from blueprintapp import app\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), b'Admin File')\n        rv.close()\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), b'\/* nested file *\/')\n        rv.close()\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            expected_max_age = 3600\n            if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == expected_max_age:\n                expected_max_age = 7200\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = expected_max_age\n            rv = c.get('\/admin\/static\/css\/test.css')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, expected_max_age)\n            rv.close()\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_true(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_default_static_cache_timeout(self):\n        app = flask.Flask(__name__)\n        class MyBlueprint(flask.Blueprint):\n            def get_send_file_max_age(self, filename):\n                return 100\n\n        blueprint = MyBlueprint('blueprint', __name__, static_folder='static')\n        app.register_blueprint(blueprint)\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            with app.test_request_context():\n                unexpected_max_age = 3600\n                if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == unexpected_max_age:\n                    unexpected_max_age = 7200\n                app.config['SEND_FILE_MAX_AGE_DEFAULT'] = unexpected_max_age\n                rv = blueprint.send_static_file('index.html')\n                cc = parse_cache_control_header(rv.headers['Cache-Control'])\n                self.assert_equal(cc.max_age, 100)\n                rv.close()\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n    def test_templates_list(self):\n        from blueprintapp import app\n        templates = sorted(app.jinja_env.list_templates())\n        self.assert_equal(templates, ['admin\/index.html',\n                                     'frontend\/index.html'])\n\n    def test_dotted_names(self):\n        frontend = flask.Blueprint('myapp.frontend', __name__)\n        backend = flask.Blueprint('myapp.backend', __name__)\n\n        @frontend.route('\/fe')\n        def frontend_index():\n            return flask.url_for('myapp.backend.backend_index')\n\n        @frontend.route('\/fe2')\n        def frontend_page2():\n            return flask.url_for('.frontend_index')\n\n        @backend.route('\/be')\n        def backend_index():\n            return flask.url_for('myapp.frontend.frontend_index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/fe').data.strip(), b'\/be')\n        self.assert_equal(c.get('\/fe2').data.strip(), b'\/fe')\n        self.assert_equal(c.get('\/be').data.strip(), b'\/fe')\n\n    def test_dotted_names_from_app(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        test = flask.Blueprint('test', __name__)\n\n        @app.route('\/')\n        def app_index():\n            return flask.url_for('test.index')\n\n        @test.route('\/test\/')\n        def index():\n            return flask.url_for('app_index')\n\n        app.register_blueprint(test)\n\n        with app.test_client() as c:\n            rv = c.get('\/')\n            self.assert_equal(rv.data, b'\/test\/')\n\n    def test_empty_url_defaults(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/', defaults={'page': 1})\n        @bp.route('\/page\/<int:page>')\n        def something(page):\n            return str(page)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'1')\n        self.assert_equal(c.get('\/page\/2').data, b'2')\n\n    def test_route_decorator_custom_endpoint(self):\n\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar', endpoint='bar')\n        def foo_bar():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/123', endpoint='123')\n        def foo_bar_foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/foo')\n        def bar_foo():\n            return flask.request.endpoint\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        @app.route('\/')\n        def index():\n            return flask.request.endpoint\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/').data, b'index')\n        self.assertEqual(c.get('\/py\/foo').data, b'bp.foo')\n        self.assertEqual(c.get('\/py\/bar').data, b'bp.bar')\n        self.assertEqual(c.get('\/py\/bar\/123').data, b'bp.123')\n        self.assertEqual(c.get('\/py\/bar\/foo').data, b'bp.bar_foo')\n\n    def test_route_decorator_custom_endpoint_with_dots(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        try:\n            @bp.route('\/bar', endpoint='bar.bar')\n            def foo_bar():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        try:\n            @bp.route('\/bar\/123', endpoint='bar.123')\n            def foo_bar_foo():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        def foo_foo_foo():\n            pass\n\n        self.assertRaises(\n            AssertionError,\n            lambda: bp.add_url_rule(\n                '\/bar\/123', endpoint='bar.123', view_func=foo_foo_foo\n            )\n        )\n\n        self.assertRaises(\n            AssertionError,\n            bp.route('\/bar\/123', endpoint='bar.123'),\n            lambda: None\n        )\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/py\/foo').data, b'bp.foo')\n        # The rule's didn't actually made it through\n        rv = c.get('\/py\/bar')\n        assert rv.status_code == 404\n        rv = c.get('\/py\/bar\/123')\n        assert rv.status_code == 404\n\n    def test_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_add_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('strrev')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_add_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'strrev')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_filter_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def super_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(super_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('super_reverse')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'super_reverse')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('is_boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['is_boolean'](False))\n\n    def test_add_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('is_boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['is_boolean'](False))\n\n    def test_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_template_test_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(BlueprintTestCase))\n    suite.addTest(unittest.makeSuite(ModuleTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.wrappers\n    ~~~~~~~~~~~~~~\n\n    Implements the WSGI wrappers (request and response).\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom werkzeug.wrappers import Request as RequestBase, Response as ResponseBase\nfrom werkzeug.exceptions import BadRequest\n\nfrom .debughelpers import attach_enctype_error_multidict\nfrom . import json\nfrom .globals import _request_ctx_stack\n\n\n_missing = object()\n\n\ndef _get_data(req, cache):\n    getter = getattr(req, 'get_data', None)\n    if getter is not None:\n        return getter(cache=cache)\n    return req.data\n\n\nclass Request(RequestBase):\n    \"\"\"The request object used by default in Flask.  Remembers the\n    matched endpoint and view arguments.\n\n    It is what ends up as :class:`~flask.request`.  If you want to replace\n    the request object used you can subclass this and set\n    :attr:`~flask.Flask.request_class` to your subclass.\n\n    The request object is a :class:`~werkzeug.wrappers.Request` subclass and\n    provides all of the attributes Werkzeug defines plus a few Flask\n    specific ones.\n    \"\"\"\n\n    #: the internal URL rule that matched the request.  This can be\n    #: useful to inspect which methods are allowed for the URL from\n    #: a before\/after handler (``request.url_rule.methods``) etc.\n    #:\n    #: .. versionadded:: 0.6\n    url_rule = None\n\n    #: a dict of view arguments that matched the request.  If an exception\n    #: happened when matching, this will be `None`.\n    view_args = None\n\n    #: if matching the URL failed, this is the exception that will be\n    #: raised \/ was raised as part of the request handling.  This is\n    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n    #: something similar.\n    routing_exception = None\n\n    # switched by the request context until 1.0 to opt in deprecated\n    # module functionality\n    _is_old_module = False\n\n    @property\n    def max_content_length(self):\n        \"\"\"Read-only view of the `MAX_CONTENT_LENGTH` config key.\"\"\"\n        ctx = _request_ctx_stack.top\n        if ctx is not None:\n            return ctx.app.config['MAX_CONTENT_LENGTH']\n\n    @property\n    def endpoint(self):\n        \"\"\"The endpoint that matched the request.  This in combination with\n        :attr:`view_args` can be used to reconstruct the same or a\n        modified URL.  If an exception happened when matching, this will\n        be `None`.\n        \"\"\"\n        if self.url_rule is not None:\n            return self.url_rule.endpoint\n\n    @property\n    def module(self):\n        \"\"\"The name of the current module if the request was dispatched\n        to an actual module.  This is deprecated functionality, use blueprints\n        instead.\n        \"\"\"\n        from warnings import warn\n        warn(DeprecationWarning('modules were deprecated in favor of '\n                                'blueprints.  Use request.blueprint '\n                                'instead.'), stacklevel=2)\n        if self._is_old_module:\n            return self.blueprint\n\n    @property\n    def blueprint(self):\n        \"\"\"The name of the current blueprint\"\"\"\n        if self.url_rule and '.' in self.url_rule.endpoint:\n            return self.url_rule.endpoint.rsplit('.', 1)[0]\n\n    @property\n    def json(self):\n        \"\"\"If the mimetype is `application\/json` this will contain the\n        parsed JSON data.  Otherwise this will be `None`.\n\n        The :meth:`get_json` method should be used instead.\n        \"\"\"\n        # XXX: deprecate property\n        return self.get_json()\n\n    def get_json(self, force=False, silent=False, cache=True):\n        \"\"\"Parses the incoming JSON request data and returns it.  If\n        parsing fails the :meth:`on_json_loading_failed` method on the\n        request object will be invoked.  By default this function will\n        only load the json data if the mimetype is ``application\/json``\n        but this can be overriden by the `force` parameter.\n\n        :param force: if set to `True` the mimetype is ignored.\n        :param silent: if set to `False` this method will fail silently\n                       and return `False`.\n        :param cache: if set to `True` the parsed JSON data is remembered\n                      on the request.\n        \"\"\"\n        rv = getattr(self, '_cached_json', _missing)\n        if rv is not _missing:\n            return rv\n\n        if self.mimetype != 'application\/json' and not force:\n            return None\n\n        # We accept a request charset against the specification as\n        # certain clients have been using this in the past.  This\n        # fits our general approach of being nice in what we accept\n        # and strict in what we send out.\n        request_charset = self.mimetype_params.get('charset')\n        try:\n            data = _get_data(self, cache)\n            if request_charset is not None:\n                rv = json.loads(data, encoding=request_charset)\n            else:\n                rv = json.loads(data)\n        except ValueError as e:\n            if silent:\n                rv = None\n            else:\n                rv = self.on_json_loading_failed(e)\n        if cache:\n            self._cached_json = rv\n        return rv\n\n    def on_json_loading_failed(self, e):\n        \"\"\"Called if decoding of the JSON data failed.  The return value of\n        this method is used by :meth:`get_json` when an error occurred.  The\n        default implementation just raises a :class:`BadRequest` exception.\n\n        .. versionchanged:: 0.10\n           Removed buggy previous behavior of generating a random JSON\n           response.  If you want that behavior back you can trivially\n           add it by subclassing.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        raise BadRequest()\n\n    def _load_form_data(self):\n        RequestBase._load_form_data(self)\n\n        # in debug mode we're replacing the files multidict with an ad-hoc\n        # subclass that raises a different error for key errors.\n        ctx = _request_ctx_stack.top\n        if ctx is not None and ctx.app.debug and \\\n           self.mimetype != 'multipart\/form-data' and not self.files:\n            attach_enctype_error_multidict(self)\n\n\nclass Response(ResponseBase):\n    \"\"\"The response object that is used by default in Flask.  Works like the\n    response object from Werkzeug but is set to have an HTML mimetype by\n    default.  Quite often you don't have to create this object yourself because\n    :meth:`~flask.Flask.make_response` will take care of that for you.\n\n    If you want to replace the response object used you can subclass this and\n    set :attr:`~flask.Flask.response_class` to your subclass.\n    \"\"\"\n    default_mimetype = 'text\/html'\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.blueprints\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Blueprints (and currently modules)\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nimport warnings\nfrom flask.testsuite import FlaskTestCase, emits_module_deprecation_warning\nfrom flask._compat import text_type\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_cache_control_header\nfrom jinja2 import TemplateNotFound\n\n\n# import moduleapp here because it uses deprecated features and we don't\n# want to see the warnings\nwarnings.simplefilter('ignore', DeprecationWarning)\nfrom moduleapp import app as moduleapp\nwarnings.simplefilter('default', DeprecationWarning)\n\n\nclass ModuleTestCase(FlaskTestCase):\n\n    @emits_module_deprecation_warning\n    def test_basic_module(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.route('\/')\n        def admin_index():\n            return 'admin index'\n        @admin.route('\/login')\n        def admin_login():\n            return 'admin login'\n        @admin.route('\/logout')\n        def admin_logout():\n            return 'admin logout'\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'the index')\n        self.assert_equal(c.get('\/admin\/').data, b'admin index')\n        self.assert_equal(c.get('\/admin\/login').data, b'admin login')\n        self.assert_equal(c.get('\/admin\/logout').data, b'admin logout')\n\n    @emits_module_deprecation_warning\n    def test_default_endpoint_name(self):\n        app = flask.Flask(__name__)\n        mod = flask.Module(__name__, 'frontend')\n        def index():\n            return 'Awesome'\n        mod.add_url_rule('\/', view_func=index)\n        app.register_module(mod)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'Awesome')\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('frontend.index'), '\/')\n\n    @emits_module_deprecation_warning\n    def test_request_processing(self):\n        catched = []\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.before_request\n        def before_admin_request():\n            catched.append('before-admin')\n        @admin.after_request\n        def after_admin_request(response):\n            catched.append('after-admin')\n            return response\n        @admin.route('\/')\n        def admin_index():\n            return 'the admin'\n        @app.before_request\n        def before_request():\n            catched.append('before-app')\n        @app.after_request\n        def after_request(response):\n            catched.append('after-app')\n            return response\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/').data, b'the index')\n        self.assert_equal(catched, ['before-app', 'after-app'])\n        del catched[:]\n\n        self.assert_equal(c.get('\/admin\/').data, b'the admin')\n        self.assert_equal(catched, ['before-app', 'before-admin',\n                           'after-admin', 'after-app'])\n\n    @emits_module_deprecation_warning\n    def test_context_processors(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @app.context_processor\n        def inject_all_regular():\n            return {'a': 1}\n        @admin.context_processor\n        def inject_admin():\n            return {'b': 2}\n        @admin.app_context_processor\n        def inject_all_module():\n            return {'c': 3}\n        @app.route('\/')\n        def index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        @admin.route('\/')\n        def admin_index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'13')\n        self.assert_equal(c.get('\/admin\/').data, b'123')\n\n    @emits_module_deprecation_warning\n    def test_late_binding(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.route('\/')\n        def index():\n            return '42'\n        app.register_module(admin, url_prefix='\/admin')\n        self.assert_equal(app.test_client().get('\/admin\/').data, b'42')\n\n    @emits_module_deprecation_warning\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.app_errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @admin.app_errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @admin.route('\/')\n        def index():\n            flask.abort(404)\n        @admin.route('\/error')\n        def error():\n            1 \/\/ 0\n        app.register_module(admin)\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, b'not found')\n        rv = c.get('\/error')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_equal(b'internal server error', rv.data)\n\n    def test_templates_and_static(self):\n        app = moduleapp\n        app.testing = True\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), b'Admin File')\n        rv.close()\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), b'\/* nested file *\/')\n        rv.close()\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_true(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_safe_access(self):\n        app = moduleapp\n\n        with app.test_request_context():\n            f = app.view_functions['admin.static']\n\n            try:\n                f('\/etc\/passwd')\n            except NotFound:\n                pass\n            else:\n                self.assert_true(0, 'expected exception')\n            try:\n                f('..\/__init__.py')\n            except NotFound:\n                pass\n            else:\n                self.assert_true(0, 'expected exception')\n\n            # testcase for a security issue that may exist on windows systems\n            import os\n            import ntpath\n            old_path = os.path\n            os.path = ntpath\n            try:\n                try:\n                    f('..\\\\__init__.py')\n                except NotFound:\n                    pass\n                else:\n                    self.assert_true(0, 'expected exception')\n            finally:\n                os.path = old_path\n\n    @emits_module_deprecation_warning\n    def test_endpoint_decorator(self):\n        from werkzeug.routing import Submount, Rule\n        from flask import Module\n\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n        module = Module(__name__, __name__)\n\n        @module.endpoint('bar')\n        def bar():\n            return 'bar'\n\n        @module.endpoint('index')\n        def index():\n            return 'index'\n\n        app.register_module(module)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, b'index')\n        self.assert_equal(c.get('\/foo\/bar').data, b'bar')\n\n\nclass BlueprintTestCase(FlaskTestCase):\n\n    def test_blueprint_specific_error_handling(self):\n        frontend = flask.Blueprint('frontend', __name__)\n        backend = flask.Blueprint('backend', __name__)\n        sideend = flask.Blueprint('sideend', __name__)\n\n        @frontend.errorhandler(403)\n        def frontend_forbidden(e):\n            return 'frontend says no', 403\n\n        @frontend.route('\/frontend-no')\n        def frontend_no():\n            flask.abort(403)\n\n        @backend.errorhandler(403)\n        def backend_forbidden(e):\n            return 'backend says no', 403\n\n        @backend.route('\/backend-no')\n        def backend_no():\n            flask.abort(403)\n\n        @sideend.route('\/what-is-a-sideend')\n        def sideend_no():\n            flask.abort(403)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n        app.register_blueprint(sideend)\n\n        @app.errorhandler(403)\n        def app_forbidden(e):\n            return 'application itself says no', 403\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/frontend-no').data, b'frontend says no')\n        self.assert_equal(c.get('\/backend-no').data, b'backend says no')\n        self.assert_equal(c.get('\/what-is-a-sideend').data, b'application itself says no')\n\n    def test_blueprint_url_definitions(self):\n        bp = flask.Blueprint('test', __name__)\n\n        @bp.route('\/foo', defaults={'baz': 42})\n        def foo(bar, baz):\n            return '%s\/%d' % (bar, baz)\n\n        @bp.route('\/bar')\n        def bar(bar):\n            return text_type(bar)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/1', url_defaults={'bar': 23})\n        app.register_blueprint(bp, url_prefix='\/2', url_defaults={'bar': 19})\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/1\/foo').data, b'23\/42')\n        self.assert_equal(c.get('\/2\/foo').data, b'19\/42')\n        self.assert_equal(c.get('\/1\/bar').data, b'23')\n        self.assert_equal(c.get('\/2\/bar').data, b'19')\n\n    def test_blueprint_url_processors(self):\n        bp = flask.Blueprint('frontend', __name__, url_prefix='\/<lang_code>')\n\n        @bp.url_defaults\n        def add_language_code(endpoint, values):\n            values.setdefault('lang_code', flask.g.lang_code)\n\n        @bp.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop('lang_code')\n\n        @bp.route('\/')\n        def index():\n            return flask.url_for('.about')\n\n        @bp.route('\/about')\n        def about():\n            return flask.url_for('.index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/de\/').data, b'\/de\/about')\n        self.assert_equal(c.get('\/de\/about').data, b'\/de\/')\n\n    def test_templates_and_static(self):\n        from blueprintapp import app\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), b'Admin File')\n        rv.close()\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), b'\/* nested file *\/')\n        rv.close()\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            expected_max_age = 3600\n            if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == expected_max_age:\n                expected_max_age = 7200\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = expected_max_age\n            rv = c.get('\/admin\/static\/css\/test.css')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, expected_max_age)\n            rv.close()\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_true(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_default_static_cache_timeout(self):\n        app = flask.Flask(__name__)\n        class MyBlueprint(flask.Blueprint):\n            def get_send_file_max_age(self, filename):\n                return 100\n\n        blueprint = MyBlueprint('blueprint', __name__, static_folder='static')\n        app.register_blueprint(blueprint)\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            with app.test_request_context():\n                unexpected_max_age = 3600\n                if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == unexpected_max_age:\n                    unexpected_max_age = 7200\n                app.config['SEND_FILE_MAX_AGE_DEFAULT'] = unexpected_max_age\n                rv = blueprint.send_static_file('index.html')\n                cc = parse_cache_control_header(rv.headers['Cache-Control'])\n                self.assert_equal(cc.max_age, 100)\n                rv.close()\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n    def test_templates_list(self):\n        from blueprintapp import app\n        templates = sorted(app.jinja_env.list_templates())\n        self.assert_equal(templates, ['admin\/index.html',\n                                     'frontend\/index.html'])\n\n    def test_dotted_names(self):\n        frontend = flask.Blueprint('myapp.frontend', __name__)\n        backend = flask.Blueprint('myapp.backend', __name__)\n\n        @frontend.route('\/fe')\n        def frontend_index():\n            return flask.url_for('myapp.backend.backend_index')\n\n        @frontend.route('\/fe2')\n        def frontend_page2():\n            return flask.url_for('.frontend_index')\n\n        @backend.route('\/be')\n        def backend_index():\n            return flask.url_for('myapp.frontend.frontend_index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/fe').data.strip(), b'\/be')\n        self.assert_equal(c.get('\/fe2').data.strip(), b'\/fe')\n        self.assert_equal(c.get('\/be').data.strip(), b'\/fe')\n\n    def test_dotted_names_from_app(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        test = flask.Blueprint('test', __name__)\n\n        @app.route('\/')\n        def app_index():\n            return flask.url_for('test.index')\n\n        @test.route('\/test\/')\n        def index():\n            return flask.url_for('app_index')\n\n        app.register_blueprint(test)\n\n        with app.test_client() as c:\n            rv = c.get('\/')\n            self.assert_equal(rv.data, b'\/test\/')\n\n    def test_empty_url_defaults(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/', defaults={'page': 1})\n        @bp.route('\/page\/<int:page>')\n        def something(page):\n            return str(page)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'1')\n        self.assert_equal(c.get('\/page\/2').data, b'2')\n\n    def test_route_decorator_custom_endpoint(self):\n\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar', endpoint='bar')\n        def foo_bar():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/123', endpoint='123')\n        def foo_bar_foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/foo')\n        def bar_foo():\n            return flask.request.endpoint\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        @app.route('\/')\n        def index():\n            return flask.request.endpoint\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/').data, b'index')\n        self.assertEqual(c.get('\/py\/foo').data, b'bp.foo')\n        self.assertEqual(c.get('\/py\/bar').data, b'bp.bar')\n        self.assertEqual(c.get('\/py\/bar\/123').data, b'bp.123')\n        self.assertEqual(c.get('\/py\/bar\/foo').data, b'bp.bar_foo')\n\n    def test_route_decorator_custom_endpoint_with_dots(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        try:\n            @bp.route('\/bar', endpoint='bar.bar')\n            def foo_bar():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        try:\n            @bp.route('\/bar\/123', endpoint='bar.123')\n            def foo_bar_foo():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        def foo_foo_foo():\n            pass\n\n        self.assertRaises(\n            AssertionError,\n            lambda: bp.add_url_rule(\n                '\/bar\/123', endpoint='bar.123', view_func=foo_foo_foo\n            )\n        )\n\n        self.assertRaises(\n            AssertionError,\n            bp.route('\/bar\/123', endpoint='bar.123'),\n            lambda: None\n        )\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/py\/foo').data, b'bp.foo')\n        # The rule's didn't actually made it through\n        rv = c.get('\/py\/bar')\n        assert rv.status_code == 404\n        rv = c.get('\/py\/bar\/123')\n        assert rv.status_code == 404\n\n    def test_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_add_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('strrev')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_add_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'strrev')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_filter_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def super_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(super_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('super_reverse')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'super_reverse')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('is_boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['is_boolean'](False))\n\n    def test_add_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('is_boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['is_boolean'](False))\n\n    def test_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_template_test_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(BlueprintTestCase))\n    suite.addTest(unittest.makeSuite(ModuleTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.config\n    ~~~~~~~~~~~~~~~~~~~~~~\n\n    Configuration and instances.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nimport flask\nimport pkgutil\nimport unittest\nfrom contextlib import contextmanager\nfrom flask.testsuite import FlaskTestCase\nfrom flask._compat import PY2\n\n\n# config keys used for the ConfigTestCase\nTEST_KEY = 'foo'\nSECRET_KEY = 'devkey'\n\n\nclass ConfigTestCase(FlaskTestCase):\n\n    def common_object_test(self, app):\n        self.assert_equal(app.secret_key, 'devkey')\n        self.assert_equal(app.config['TEST_KEY'], 'foo')\n        self.assert_not_in('ConfigTestCase', app.config)\n\n    def test_config_from_file(self):\n        app = flask.Flask(__name__)\n        app.config.from_pyfile(__file__.rsplit('.', 1)[0] + '.py')\n        self.common_object_test(app)\n\n    def test_config_from_object(self):\n        app = flask.Flask(__name__)\n        app.config.from_object(__name__)\n        self.common_object_test(app)\n\n    def test_config_from_class(self):\n        class Base(object):\n            TEST_KEY = 'foo'\n        class Test(Base):\n            SECRET_KEY = 'devkey'\n        app = flask.Flask(__name__)\n        app.config.from_object(Test)\n        self.common_object_test(app)\n\n    def test_config_from_envvar(self):\n        env = os.environ\n        try:\n            os.environ = {}\n            app = flask.Flask(__name__)\n            try:\n                app.config.from_envvar('FOO_SETTINGS')\n            except RuntimeError as e:\n                self.assert_true(\"'FOO_SETTINGS' is not set\" in str(e))\n            else:\n                self.assert_true(0, 'expected exception')\n            self.assert_false(app.config.from_envvar('FOO_SETTINGS', silent=True))\n\n            os.environ = {'FOO_SETTINGS': __file__.rsplit('.', 1)[0] + '.py'}\n            self.assert_true(app.config.from_envvar('FOO_SETTINGS'))\n            self.common_object_test(app)\n        finally:\n            os.environ = env\n\n    def test_config_from_envvar_missing(self):\n        env = os.environ\n        try:\n            os.environ = {'FOO_SETTINGS': 'missing.cfg'}\n            try:\n                app = flask.Flask(__name__)\n                app.config.from_envvar('FOO_SETTINGS')\n            except IOError as e:\n                msg = str(e)\n                self.assert_true(msg.startswith('[Errno 2] Unable to load configuration '\n                                            'file (No such file or directory):'))\n                self.assert_true(msg.endswith(\"missing.cfg'\"))\n            else:\n                self.fail('expected IOError')\n            self.assertFalse(app.config.from_envvar('FOO_SETTINGS', silent=True))\n        finally:\n            os.environ = env\n\n    def test_config_missing(self):\n        app = flask.Flask(__name__)\n        try:\n            app.config.from_pyfile('missing.cfg')\n        except IOError as e:\n            msg = str(e)\n            self.assert_true(msg.startswith('[Errno 2] Unable to load configuration '\n                                        'file (No such file or directory):'))\n            self.assert_true(msg.endswith(\"missing.cfg'\"))\n        else:\n            self.assert_true(0, 'expected config')\n        self.assert_false(app.config.from_pyfile('missing.cfg', silent=True))\n\n    def test_session_lifetime(self):\n        app = flask.Flask(__name__)\n        app.config['PERMANENT_SESSION_LIFETIME'] = 42\n        self.assert_equal(app.permanent_session_lifetime.seconds, 42)\n\n\nclass LimitedLoaderMockWrapper(object):\n    def __init__(self, loader):\n        self.loader = loader\n\n    def __getattr__(self, name):\n        if name in ('archive', 'get_filename'):\n            msg = 'Mocking a loader which does not have `%s.`' % name\n            raise AttributeError(msg)\n        return getattr(self.loader, name)\n\n\n@contextmanager\ndef patch_pkgutil_get_loader(wrapper_class=LimitedLoaderMockWrapper):\n    \"\"\"Patch pkgutil.get_loader to give loader without get_filename or archive.\n\n    This provides for tests where a system has custom loaders, e.g. Google App\n    Engine's HardenedModulesHook, which have neither the `get_filename` method\n    nor the `archive` attribute.\n    \"\"\"\n    old_get_loader = pkgutil.get_loader\n    def get_loader(*args, **kwargs):\n        return wrapper_class(old_get_loader(*args, **kwargs))\n    try:\n        pkgutil.get_loader = get_loader\n        yield\n    finally:\n        pkgutil.get_loader = old_get_loader\n\n\nclass InstanceTestCase(FlaskTestCase):\n\n    def test_explicit_instance_paths(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        try:\n            flask.Flask(__name__, instance_path='instance')\n        except ValueError as e:\n            self.assert_in('must be absolute', str(e))\n        else:\n            self.fail('Expected value error')\n\n        app = flask.Flask(__name__, instance_path=here)\n        self.assert_equal(app.instance_path, here)\n\n    def test_main_module_paths(self):\n        # Test an app with '__main__' as the import name, uses cwd.\n        from main_app import app\n        here = os.path.abspath(os.getcwd())\n        self.assert_equal(app.instance_path, os.path.join(here, 'instance'))\n        if 'main_app' in sys.modules:\n            del sys.modules['main_app']\n\n    def test_uninstalled_module_paths(self):\n        from config_module_app import app\n        here = os.path.abspath(os.path.dirname(__file__))\n        self.assert_equal(app.instance_path, os.path.join(here, 'test_apps', 'instance'))\n\n    def test_uninstalled_package_paths(self):\n        from config_package_app import app\n        here = os.path.abspath(os.path.dirname(__file__))\n        self.assert_equal(app.instance_path, os.path.join(here, 'test_apps', 'instance'))\n\n    def test_installed_module_paths(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        site_packages = os.path.join(expected_prefix, 'lib', 'python2.5', 'site-packages')\n        sys.path.append(site_packages)\n        try:\n            import site_app\n            self.assert_equal(site_app.app.instance_path,\n                              os.path.join(expected_prefix, 'var',\n                                           'site_app-instance'))\n        finally:\n            sys.prefix = real_prefix\n            sys.path.remove(site_packages)\n            if 'site_app' in sys.modules:\n                del sys.modules['site_app']\n\n    def test_installed_module_paths_with_limited_loader(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        site_packages = os.path.join(expected_prefix, 'lib', 'python2.5', 'site-packages')\n        sys.path.append(site_packages)\n        with patch_pkgutil_get_loader():\n            try:\n                import site_app\n                self.assert_equal(site_app.app.instance_path,\n                                  os.path.join(expected_prefix, 'var',\n                                               'site_app-instance'))\n            finally:\n                sys.prefix = real_prefix\n                sys.path.remove(site_packages)\n                if 'site_app' in sys.modules:\n                    del sys.modules['site_app']\n\n    def test_installed_package_paths(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        installed_path = os.path.join(expected_prefix, 'path')\n        sys.path.append(installed_path)\n        try:\n            import installed_package\n            self.assert_equal(installed_package.app.instance_path,\n                              os.path.join(expected_prefix, 'var',\n                                           'installed_package-instance'))\n        finally:\n            sys.prefix = real_prefix\n            sys.path.remove(installed_path)\n            if 'installed_package' in sys.modules:\n                del sys.modules['installed_package']\n\n    def test_installed_package_paths_with_limited_loader(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        installed_path = os.path.join(expected_prefix, 'path')\n        sys.path.append(installed_path)\n        with patch_pkgutil_get_loader():\n            try:\n                import installed_package\n                self.assert_equal(installed_package.app.instance_path,\n                                  os.path.join(expected_prefix, 'var',\n                                               'installed_package-instance'))\n            finally:\n                sys.prefix = real_prefix\n                sys.path.remove(installed_path)\n                if 'installed_package' in sys.modules:\n                    del sys.modules['installed_package']\n\n    def test_prefix_package_paths(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        site_packages = os.path.join(expected_prefix, 'lib', 'python2.5', 'site-packages')\n        sys.path.append(site_packages)\n        try:\n            import site_package\n            self.assert_equal(site_package.app.instance_path,\n                              os.path.join(expected_prefix, 'var',\n                                           'site_package-instance'))\n        finally:\n            sys.prefix = real_prefix\n            sys.path.remove(site_packages)\n            if 'site_package' in sys.modules:\n                del sys.modules['site_package']\n\n    def test_prefix_package_paths_with_limited_loader(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        site_packages = os.path.join(expected_prefix, 'lib', 'python2.5', 'site-packages')\n        sys.path.append(site_packages)\n        with patch_pkgutil_get_loader():\n            try:\n                import site_package\n                self.assert_equal(site_package.app.instance_path,\n                                  os.path.join(expected_prefix, 'var',\n                                               'site_package-instance'))\n            finally:\n                sys.prefix = real_prefix\n                sys.path.remove(site_packages)\n                if 'site_package' in sys.modules:\n                    del sys.modules['site_package']\n\n    def test_egg_installed_paths(self):\n        here = os.path.abspath(os.path.dirname(__file__))\n        expected_prefix = os.path.join(here, 'test_apps')\n        real_prefix, sys.prefix = sys.prefix, expected_prefix\n        site_packages = os.path.join(expected_prefix, 'lib', 'python2.5', 'site-packages')\n        egg_path = os.path.join(site_packages, 'SiteEgg.egg')\n        sys.path.append(site_packages)\n        sys.path.append(egg_path)\n        try:\n            import site_egg # in SiteEgg.egg\n            self.assert_equal(site_egg.app.instance_path,\n                              os.path.join(expected_prefix, 'var',\n                                           'site_egg-instance'))\n        finally:\n            sys.prefix = real_prefix\n            sys.path.remove(site_packages)\n            sys.path.remove(egg_path)\n            if 'site_egg' in sys.modules:\n                del sys.modules['site_egg']\n\n    if PY2:\n        def test_meta_path_loader_without_is_package(self):\n            class Loader(object):\n                def find_module(self, name):\n                    return self\n            sys.meta_path.append(Loader())\n            try:\n                with self.assert_raises(AttributeError):\n                    flask.Flask(__name__)\n            finally:\n                sys.meta_path.pop()\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(ConfigTestCase))\n    suite.addTest(unittest.makeSuite(InstanceTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.deprecations\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Tests deprecation support.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nfrom flask.testsuite import FlaskTestCase, catch_warnings\n\n\nclass DeprecationsTestCase(FlaskTestCase):\n    \"\"\"not used currently\"\"\"\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(DeprecationsTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.helpers\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Various helpers.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport flask\nimport unittest\nfrom logging import StreamHandler\nfrom flask.testsuite import FlaskTestCase, catch_warnings, catch_stderr\nfrom werkzeug.http import parse_cache_control_header, parse_options_header\nfrom flask._compat import StringIO, text_type\n\n\ndef has_encoding(name):\n    try:\n        import codecs\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n\n\nclass JSONTestCase(FlaskTestCase):\n\n    def test_json_bad_requests(self):\n        app = flask.Flask(__name__)\n        @app.route('\/json', methods=['POST'])\n        def return_json():\n            return flask.jsonify(foo=text_type(flask.request.get_json()))\n        c = app.test_client()\n        rv = c.post('\/json', data='malformed', content_type='application\/json')\n        self.assert_equal(rv.status_code, 400)\n\n    def test_json_body_encoding(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            return flask.request.get_json()\n\n        c = app.test_client()\n        resp = c.get('\/', data=u'\"H\u00e4llo W\u00f6rld\"'.encode('iso-8859-15'),\n                     content_type='application\/json; charset=iso-8859-15')\n        self.assert_equal(resp.data, u'H\u00e4llo W\u00f6rld'.encode('utf-8'))\n\n    def test_jsonify(self):\n        d = dict(a=23, b=42, c=[1, 2, 3])\n        app = flask.Flask(__name__)\n        @app.route('\/kw')\n        def return_kwargs():\n            return flask.jsonify(**d)\n        @app.route('\/dict')\n        def return_dict():\n            return flask.jsonify(d)\n        c = app.test_client()\n        for url in '\/kw', '\/dict':\n            rv = c.get(url)\n            self.assert_equal(rv.mimetype, 'application\/json')\n            self.assert_equal(flask.json.loads(rv.data), d)\n\n    def test_json_as_unicode(self):\n        app = flask.Flask(__name__)\n\n        app.config['JSON_AS_ASCII'] = True\n        with app.app_context():\n            rv = flask.json.dumps(u'\\N{SNOWMAN}')\n            self.assert_equal(rv, '\"\\\\u2603\"')\n\n        app.config['JSON_AS_ASCII'] = False\n        with app.app_context():\n            rv = flask.json.dumps(u'\\N{SNOWMAN}')\n            self.assert_equal(rv, u'\"\\u2603\"')\n\n    def test_json_attr(self):\n        app = flask.Flask(__name__)\n        @app.route('\/add', methods=['POST'])\n        def add():\n            json = flask.request.get_json()\n            return text_type(json['a'] + json['b'])\n        c = app.test_client()\n        rv = c.post('\/add', data=flask.json.dumps({'a': 1, 'b': 2}),\n                            content_type='application\/json')\n        self.assert_equal(rv.data, b'3')\n\n    def test_template_escaping(self):\n        app = flask.Flask(__name__)\n        render = flask.render_template_string\n        with app.test_request_context():\n            rv = flask.json.htmlsafe_dumps('<\/script>')\n            self.assert_equal(rv, u'\"\\\\u003c\/script\\\\u003e\"')\n            self.assert_equal(type(rv), text_type)\n            rv = render('{{ \"<\/script>\"|tojson }}')\n            self.assert_equal(rv, '\"\\\\u003c\/script\\\\u003e\"')\n            rv = render('{{ \"<\\0\/script>\"|tojson }}')\n            self.assert_equal(rv, '\"\\\\u003c\\\\u0000\/script\\\\u003e\"')\n            rv = render('{{ \"<!--<script>\"|tojson }}')\n            self.assert_equal(rv, '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"')\n            rv = render('{{ \"&\"|tojson }}')\n            self.assert_equal(rv, '\"\\\\u0026\"')\n            rv = render('{{ \"\\'\"|tojson }}')\n            self.assert_equal(rv, '\"\\\\u0027\"')\n            rv = render(\"<a ng-data='{{ data|tojson }}'><\/a>\",\n                data={'x': [\"foo\", \"bar\", \"baz'\"]})\n            self.assert_equal(rv,\n                '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'><\/a>')\n\n    def test_json_customization(self):\n        class X(object):\n            def __init__(self, val):\n                self.val = val\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return '<%d>' % o.val\n                return flask.json.JSONEncoder.default(self, o)\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault('object_hook', self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n            def object_hook(self, obj):\n                if len(obj) == 1 and '_foo' in obj:\n                    return X(obj['_foo'])\n                return obj\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n        @app.route('\/', methods=['POST'])\n        def index():\n            return flask.json.dumps(flask.request.get_json()['x'])\n        c = app.test_client()\n        rv = c.post('\/', data=flask.json.dumps({\n            'x': {'_foo': 42}\n        }), content_type='application\/json')\n        self.assertEqual(rv.data, b'\"<42>\"')\n\n    def test_modified_url_encoding(self):\n        class ModifiedRequest(flask.Request):\n            url_charset = 'euc-kr'\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.request_class = ModifiedRequest\n        app.url_map.charset = 'euc-kr'\n\n        @app.route('\/')\n        def index():\n            return flask.request.args['foo']\n\n        rv = app.test_client().get(u'\/?foo=\uc815\uc0c1\ucc98\ub9ac'.encode('euc-kr'))\n        self.assert_equal(rv.status_code, 200)\n        self.assert_equal(rv.data, u'\uc815\uc0c1\ucc98\ub9ac'.encode('utf-8'))\n\n    if not has_encoding('euc-kr'):\n        test_modified_url_encoding = None\n\n    def test_json_key_sorting(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        self.assert_equal(app.config['JSON_SORT_KEYS'], True)\n        d = dict.fromkeys(range(20), 'foo')\n\n        @app.route('\/')\n        def index():\n            return flask.jsonify(values=d)\n\n        c = app.test_client()\n        rv = c.get('\/')\n        lines = [x.strip() for x in rv.data.strip().decode('utf-8').splitlines()]\n        self.assert_equal(lines, [\n            '{',\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\"',\n            '}',\n            '}'\n        ])\n\n\nclass SendfileTestCase(FlaskTestCase):\n\n    def test_send_file_regular(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.send_file('static\/index.html')\n            self.assert_true(rv.direct_passthrough)\n            self.assert_equal(rv.mimetype, 'text\/html')\n            with app.open_resource('static\/index.html') as f:\n                rv.direct_passthrough = False\n                self.assert_equal(rv.data, f.read())\n            rv.close()\n\n    def test_send_file_xsendfile(self):\n        app = flask.Flask(__name__)\n        app.use_x_sendfile = True\n        with app.test_request_context():\n            rv = flask.send_file('static\/index.html')\n            self.assert_true(rv.direct_passthrough)\n            self.assert_in('x-sendfile', rv.headers)\n            self.assert_equal(rv.headers['x-sendfile'],\n                os.path.join(app.root_path, 'static\/index.html'))\n            self.assert_equal(rv.mimetype, 'text\/html')\n            rv.close()\n\n    def test_send_file_object(self):\n        app = flask.Flask(__name__)\n        with catch_warnings() as captured:\n            with app.test_request_context():\n                f = open(os.path.join(app.root_path, 'static\/index.html'))\n                rv = flask.send_file(f)\n                rv.direct_passthrough = False\n                with app.open_resource('static\/index.html') as f:\n                    self.assert_equal(rv.data, f.read())\n                self.assert_equal(rv.mimetype, 'text\/html')\n                rv.close()\n            # mimetypes + etag\n            self.assert_equal(len(captured), 2)\n\n        app.use_x_sendfile = True\n        with catch_warnings() as captured:\n            with app.test_request_context():\n                f = open(os.path.join(app.root_path, 'static\/index.html'))\n                rv = flask.send_file(f)\n                self.assert_equal(rv.mimetype, 'text\/html')\n                self.assert_in('x-sendfile', rv.headers)\n                self.assert_equal(rv.headers['x-sendfile'],\n                    os.path.join(app.root_path, 'static\/index.html'))\n                rv.close()\n            # mimetypes + etag\n            self.assert_equal(len(captured), 2)\n\n        app.use_x_sendfile = False\n        with app.test_request_context():\n            with catch_warnings() as captured:\n                f = StringIO('Test')\n                rv = flask.send_file(f)\n                rv.direct_passthrough = False\n                self.assert_equal(rv.data, b'Test')\n                self.assert_equal(rv.mimetype, 'application\/octet-stream')\n                rv.close()\n            # etags\n            self.assert_equal(len(captured), 1)\n            with catch_warnings() as captured:\n                f = StringIO('Test')\n                rv = flask.send_file(f, mimetype='text\/plain')\n                rv.direct_passthrough = False\n                self.assert_equal(rv.data, b'Test')\n                self.assert_equal(rv.mimetype, 'text\/plain')\n                rv.close()\n            # etags\n            self.assert_equal(len(captured), 1)\n\n        app.use_x_sendfile = True\n        with catch_warnings() as captured:\n            with app.test_request_context():\n                f = StringIO('Test')\n                rv = flask.send_file(f)\n                self.assert_not_in('x-sendfile', rv.headers)\n                rv.close()\n            # etags\n            self.assert_equal(len(captured), 1)\n\n    def test_attachment(self):\n        app = flask.Flask(__name__)\n        with catch_warnings() as captured:\n            with app.test_request_context():\n                f = open(os.path.join(app.root_path, 'static\/index.html'))\n                rv = flask.send_file(f, as_attachment=True)\n                value, options = parse_options_header(rv.headers['Content-Disposition'])\n                self.assert_equal(value, 'attachment')\n                rv.close()\n            # mimetypes + etag\n            self.assert_equal(len(captured), 2)\n\n        with app.test_request_context():\n            self.assert_equal(options['filename'], 'index.html')\n            rv = flask.send_file('static\/index.html', as_attachment=True)\n            value, options = parse_options_header(rv.headers['Content-Disposition'])\n            self.assert_equal(value, 'attachment')\n            self.assert_equal(options['filename'], 'index.html')\n            rv.close()\n\n        with app.test_request_context():\n            rv = flask.send_file(StringIO('Test'), as_attachment=True,\n                                 attachment_filename='index.txt',\n                                 add_etags=False)\n            self.assert_equal(rv.mimetype, 'text\/plain')\n            value, options = parse_options_header(rv.headers['Content-Disposition'])\n            self.assert_equal(value, 'attachment')\n            self.assert_equal(options['filename'], 'index.txt')\n            rv.close()\n\n    def test_static_file(self):\n        app = flask.Flask(__name__)\n        # default cache timeout is 12 hours\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 12 * 60 * 60)\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 12 * 60 * 60)\n            rv.close()\n        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 3600\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 3600)\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 3600)\n            rv.close()\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 10)\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, 10)\n            rv.close()\n\n\nclass LoggingTestCase(FlaskTestCase):\n\n    def test_logger_cache(self):\n        app = flask.Flask(__name__)\n        logger1 = app.logger\n        self.assert_true(app.logger is logger1)\n        self.assert_equal(logger1.name, __name__)\n        app.logger_name = __name__ + '\/test_logger_cache'\n        self.assert_true(app.logger is not logger1)\n\n    def test_debug_log(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        @app.route('\/')\n        def index():\n            app.logger.warning('the standard library is dead')\n            app.logger.debug('this is a debug statement')\n            return ''\n\n        @app.route('\/exc')\n        def exc():\n            1 \/\/ 0\n\n        with app.test_client() as c:\n            with catch_stderr() as err:\n                c.get('\/')\n                out = err.getvalue()\n                self.assert_in('WARNING in helpers [', out)\n                self.assert_in(os.path.basename(__file__.rsplit('.', 1)[0] + '.py'), out)\n                self.assert_in('the standard library is dead', out)\n                self.assert_in('this is a debug statement', out)\n\n            with catch_stderr() as err:\n                try:\n                    c.get('\/exc')\n                except ZeroDivisionError:\n                    pass\n                else:\n                    self.assert_true(False, 'debug log ate the exception')\n\n    def test_debug_log_override(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        app.logger_name = 'flask_tests\/test_debug_log_override'\n        app.logger.level = 10\n        self.assert_equal(app.logger.level, 10)\n\n    def test_exception_logging(self):\n        out = StringIO()\n        app = flask.Flask(__name__)\n        app.logger_name = 'flask_tests\/test_exception_logging'\n        app.logger.addHandler(StreamHandler(out))\n\n        @app.route('\/')\n        def index():\n            1 \/\/ 0\n\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_in(b'Internal Server Error', rv.data)\n\n        err = out.getvalue()\n        self.assert_in('Exception on \/ [GET]', err)\n        self.assert_in('Traceback (most recent call last):', err)\n        self.assert_in('1 \/\/ 0', err)\n        self.assert_in('ZeroDivisionError:', err)\n\n    def test_processor_exceptions(self):\n        app = flask.Flask(__name__)\n        @app.before_request\n        def before_request():\n            if trigger == 'before':\n                1 \/\/ 0\n        @app.after_request\n        def after_request(response):\n            if trigger == 'after':\n                1 \/\/ 0\n            return response\n        @app.route('\/')\n        def index():\n            return 'Foo'\n        @app.errorhandler(500)\n        def internal_server_error(e):\n            return 'Hello Server Error', 500\n        for trigger in 'before', 'after':\n            rv = app.test_client().get('\/')\n            self.assert_equal(rv.status_code, 500)\n            self.assert_equal(rv.data, b'Hello Server Error')\n\n    def test_url_for_with_anchor(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('index', _anchor='x y'),\n                              '\/#x%20y')\n\n    def test_url_for_with_scheme(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('index',\n                                            _external=True,\n                                            _scheme='https'),\n                              'https:\/\/localhost\/')\n\n    def test_url_for_with_scheme_not_external(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            self.assert_raises(ValueError,\n                               flask.url_for,\n                               'index',\n                               _scheme='https')\n\n    def test_url_with_method(self):\n        from flask.views import MethodView\n        app = flask.Flask(__name__)\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return 'List'\n                return 'Get %d' % id\n            def post(self):\n                return 'Create'\n        myview = MyView.as_view('myview')\n        app.add_url_rule('\/myview\/', methods=['GET'],\n                         view_func=myview)\n        app.add_url_rule('\/myview\/<int:id>', methods=['GET'],\n                         view_func=myview)\n        app.add_url_rule('\/myview\/create', methods=['POST'],\n                         view_func=myview)\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('myview', _method='GET'),\n                              '\/myview\/')\n            self.assert_equal(flask.url_for('myview', id=42, _method='GET'),\n                              '\/myview\/42')\n            self.assert_equal(flask.url_for('myview', _method='POST'),\n                              '\/myview\/create')\n\n\nclass NoImportsTestCase(FlaskTestCase):\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self):\n        try:\n            flask.Flask('importerror')\n        except NotImplementedError:\n            self.fail('Flask(import_name) is importing import_name.')\n\n\nclass StreamingTestCase(FlaskTestCase):\n\n    def test_streaming_with_context(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(flask.stream_with_context(generate()))\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        self.assertEqual(rv.data, b'Hello World!')\n\n    def test_streaming_with_context_as_decorator(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            @flask.stream_with_context\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(generate())\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        self.assertEqual(rv.data, b'Hello World!')\n\n    def test_streaming_with_context_and_custom_close(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        called = []\n        class Wrapper(object):\n            def __init__(self, gen):\n                self._gen = gen\n            def __iter__(self):\n                return self\n            def close(self):\n                called.append(42)\n            def __next__(self):\n                return next(self._gen)\n            next = __next__\n        @app.route('\/')\n        def index():\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(flask.stream_with_context(\n                Wrapper(generate())))\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        self.assertEqual(rv.data, b'Hello World!')\n        self.assertEqual(called, [42])\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    if flask.json_available:\n        suite.addTest(unittest.makeSuite(JSONTestCase))\n    suite.addTest(unittest.makeSuite(SendfileTestCase))\n    suite.addTest(unittest.makeSuite(LoggingTestCase))\n    suite.addTest(unittest.makeSuite(NoImportsTestCase))\n    suite.addTest(unittest.makeSuite(StreamingTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.regression\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Tests regressions.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport gc\nimport sys\nimport flask\nimport threading\nimport unittest\nfrom werkzeug.exceptions import NotFound\nfrom flask.testsuite import FlaskTestCase\n\n\n_gc_lock = threading.Lock()\n\n\nclass _NoLeakAsserter(object):\n\n    def __init__(self, testcase):\n        self.testcase = testcase\n\n    def __enter__(self):\n        gc.disable()\n        _gc_lock.acquire()\n        loc = flask._request_ctx_stack._local\n\n        # Force Python to track this dictionary at all times.\n        # This is necessary since Python only starts tracking\n        # dicts if they contain mutable objects.  It's a horrible,\n        # horrible hack but makes this kinda testable.\n        loc.__storage__['FOOO'] = [1, 2, 3]\n\n        gc.collect()\n        self.old_objects = len(gc.get_objects())\n\n    def __exit__(self, exc_type, exc_value, tb):\n        if not hasattr(sys, 'getrefcount'):\n            gc.collect()\n        new_objects = len(gc.get_objects())\n        if new_objects > self.old_objects:\n            self.testcase.fail('Example code leaked')\n        _gc_lock.release()\n        gc.enable()\n\n\nclass MemoryTestCase(FlaskTestCase):\n\n    def assert_no_leak(self):\n        return _NoLeakAsserter(self)\n\n    def test_memory_consumption(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('simple_template.html', whiskey=42)\n\n        def fire():\n            with app.test_client() as c:\n                rv = c.get('\/')\n                self.assert_equal(rv.status_code, 200)\n                self.assert_equal(rv.data, b'<h1>42<\/h1>')\n\n        # Trigger caches\n        fire()\n\n        # This test only works on CPython 2.7.\n        if sys.version_info >= (2, 7) and \\\n                not hasattr(sys, 'pypy_translation_info'):\n            with self.assert_no_leak():\n                for x in range(10):\n                    fire()\n\n    def test_safe_join_toplevel_pardir(self):\n        from flask.helpers import safe_join\n        with self.assert_raises(NotFound):\n            safe_join('\/foo', '..')\n\n\nclass ExceptionTestCase(FlaskTestCase):\n\n    def test_aborting(self):\n        class Foo(Exception):\n            whatever = 42\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.errorhandler(Foo)\n        def handle_foo(e):\n            return str(e.whatever)\n        @app.route('\/')\n        def index():\n            raise flask.abort(flask.redirect(flask.url_for('test')))\n        @app.route('\/test')\n        def test():\n            raise Foo()\n\n        with app.test_client() as c:\n            rv = c.get('\/')\n            self.assertEqual(rv.headers['Location'], 'http:\/\/localhost\/test')\n            rv = c.get('\/test')\n            self.assertEqual(rv.data, b'42')\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    if os.environ.get('RUN_FLASK_MEMORY_TESTS') == '1':\n        suite.addTest(unittest.makeSuite(MemoryTestCase))\n    suite.addTest(unittest.makeSuite(ExceptionTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.reqctx\n    ~~~~~~~~~~~~~~~~~~~~~~\n\n    Tests the request context.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\ntry:\n    from greenlet import greenlet\nexcept ImportError:\n    greenlet = None\nfrom flask.testsuite import FlaskTestCase\n\n\nclass RequestContextTestCase(FlaskTestCase):\n\n    def test_teardown_on_pop(self):\n        buffer = []\n        app = flask.Flask(__name__)\n        @app.teardown_request\n        def end_of_request(exception):\n            buffer.append(exception)\n\n        ctx = app.test_request_context()\n        ctx.push()\n        self.assert_equal(buffer, [])\n        ctx.pop()\n        self.assert_equal(buffer, [None])\n\n    def test_teardown_with_previous_exception(self):\n        buffer = []\n        app = flask.Flask(__name__)\n        @app.teardown_request\n        def end_of_request(exception):\n            buffer.append(exception)\n\n        try:\n            raise Exception('dummy')\n        except Exception:\n            pass\n\n        with app.test_request_context():\n            self.assert_equal(buffer, [])\n        self.assert_equal(buffer, [None])\n\n    def test_proper_test_request_context(self):\n        app = flask.Flask(__name__)\n        app.config.update(\n            SERVER_NAME='localhost.localdomain:5000'\n        )\n\n        @app.route('\/')\n        def index():\n            return None\n\n        @app.route('\/', subdomain='foo')\n        def sub():\n            return None\n\n        with app.test_request_context('\/'):\n            self.assert_equal(flask.url_for('index', _external=True), 'http:\/\/localhost.localdomain:5000\/')\n\n        with app.test_request_context('\/'):\n            self.assert_equal(flask.url_for('sub', _external=True), 'http:\/\/foo.localhost.localdomain:5000\/')\n\n        try:\n            with app.test_request_context('\/', environ_overrides={'HTTP_HOST': 'localhost'}):\n                pass\n        except Exception as e:\n            self.assert_true(isinstance(e, ValueError))\n            self.assert_equal(str(e), \"the server name provided \" +\n                    \"('localhost.localdomain:5000') does not match the \" + \\\n                    \"server name from the WSGI environment ('localhost')\")\n\n        try:\n            app.config.update(SERVER_NAME='localhost')\n            with app.test_request_context('\/', environ_overrides={'SERVER_NAME': 'localhost'}):\n                pass\n        except ValueError as e:\n            raise ValueError(\n                \"No ValueError exception should have been raised \\\"%s\\\"\" % e\n            )\n\n        try:\n            app.config.update(SERVER_NAME='localhost:80')\n            with app.test_request_context('\/', environ_overrides={'SERVER_NAME': 'localhost:80'}):\n                pass\n        except ValueError as e:\n            raise ValueError(\n                \"No ValueError exception should have been raised \\\"%s\\\"\" % e\n            )\n\n    def test_context_binding(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return 'Hello %s!' % flask.request.args['name']\n        @app.route('\/meh')\n        def meh():\n            return flask.request.url\n\n        with app.test_request_context('\/?name=World'):\n            self.assert_equal(index(), 'Hello World!')\n        with app.test_request_context('\/meh'):\n            self.assert_equal(meh(), 'http:\/\/localhost\/meh')\n        self.assert_true(flask._request_ctx_stack.top is None)\n\n    def test_context_test(self):\n        app = flask.Flask(__name__)\n        self.assert_false(flask.request)\n        self.assert_false(flask.has_request_context())\n        ctx = app.test_request_context()\n        ctx.push()\n        try:\n            self.assert_true(flask.request)\n            self.assert_true(flask.has_request_context())\n        finally:\n            ctx.pop()\n\n    def test_manual_context_binding(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return 'Hello %s!' % flask.request.args['name']\n\n        ctx = app.test_request_context('\/?name=World')\n        ctx.push()\n        self.assert_equal(index(), 'Hello World!')\n        ctx.pop()\n        try:\n            index()\n        except RuntimeError:\n            pass\n        else:\n            self.assert_true(0, 'expected runtime error')\n\n    def test_greenlet_context_copying(self):\n        app = flask.Flask(__name__)\n        greenlets = []\n\n        @app.route('\/')\n        def index():\n            reqctx = flask._request_ctx_stack.top.copy()\n            def g():\n                self.assert_false(flask.request)\n                self.assert_false(flask.current_app)\n                with reqctx:\n                    self.assert_true(flask.request)\n                    self.assert_equal(flask.current_app, app)\n                    self.assert_equal(flask.request.path, '\/')\n                    self.assert_equal(flask.request.args['foo'], 'bar')\n                self.assert_false(flask.request)\n                return 42\n            greenlets.append(greenlet(g))\n            return 'Hello World!'\n\n        rv = app.test_client().get('\/?foo=bar')\n        self.assert_equal(rv.data, b'Hello World!')\n\n        result = greenlets[0].run()\n        self.assert_equal(result, 42)\n\n    def test_greenlet_context_copying_api(self):\n        app = flask.Flask(__name__)\n        greenlets = []\n\n        @app.route('\/')\n        def index():\n            reqctx = flask._request_ctx_stack.top.copy()\n            @flask.copy_current_request_context\n            def g():\n                self.assert_true(flask.request)\n                self.assert_equal(flask.current_app, app)\n                self.assert_equal(flask.request.path, '\/')\n                self.assert_equal(flask.request.args['foo'], 'bar')\n                return 42\n            greenlets.append(greenlet(g))\n            return 'Hello World!'\n\n        rv = app.test_client().get('\/?foo=bar')\n        self.assert_equal(rv.data, b'Hello World!')\n\n        result = greenlets[0].run()\n        self.assert_equal(result, 42)\n\n    # Disable test if we don't have greenlets available\n    if greenlet is None:\n        test_greenlet_context_copying = None\n        test_greenlet_context_copying_api = None\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(RequestContextTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.signals\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Signalling.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nfrom flask.testsuite import FlaskTestCase\n\n\nclass SignalsTestCase(FlaskTestCase):\n\n    def test_template_rendered(self):\n        app = flask.Flask(__name__)\n\n        @app.route('\/')\n        def index():\n            return flask.render_template('simple_template.html', whiskey=42)\n\n        recorded = []\n        def record(sender, template, context):\n            recorded.append((template, context))\n\n        flask.template_rendered.connect(record, app)\n        try:\n            app.test_client().get('\/')\n            self.assert_equal(len(recorded), 1)\n            template, context = recorded[0]\n            self.assert_equal(template.name, 'simple_template.html')\n            self.assert_equal(context['whiskey'], 42)\n        finally:\n            flask.template_rendered.disconnect(record, app)\n\n    def test_request_signals(self):\n        app = flask.Flask(__name__)\n        calls = []\n\n        def before_request_signal(sender):\n            calls.append('before-signal')\n\n        def after_request_signal(sender, response):\n            self.assert_equal(response.data, b'stuff')\n            calls.append('after-signal')\n\n        @app.before_request\n        def before_request_handler():\n            calls.append('before-handler')\n\n        @app.after_request\n        def after_request_handler(response):\n            calls.append('after-handler')\n            response.data = 'stuff'\n            return response\n\n        @app.route('\/')\n        def index():\n            calls.append('handler')\n            return 'ignored anyway'\n\n        flask.request_started.connect(before_request_signal, app)\n        flask.request_finished.connect(after_request_signal, app)\n\n        try:\n            rv = app.test_client().get('\/')\n            self.assert_equal(rv.data, b'stuff')\n\n            self.assert_equal(calls, ['before-signal', 'before-handler',\n                             'handler', 'after-handler',\n                             'after-signal'])\n        finally:\n            flask.request_started.disconnect(before_request_signal, app)\n            flask.request_finished.disconnect(after_request_signal, app)\n\n    def test_request_exception_signal(self):\n        app = flask.Flask(__name__)\n        recorded = []\n\n        @app.route('\/')\n        def index():\n            1 \/\/ 0\n\n        def record(sender, exception):\n            recorded.append(exception)\n\n        flask.got_request_exception.connect(record, app)\n        try:\n            self.assert_equal(app.test_client().get('\/').status_code, 500)\n            self.assert_equal(len(recorded), 1)\n            self.assert_true(isinstance(recorded[0], ZeroDivisionError))\n        finally:\n            flask.got_request_exception.disconnect(record, app)\n\n    def test_appcontext_signals(self):\n        app = flask.Flask(__name__)\n        recorded = []\n        def record_push(sender, **kwargs):\n            recorded.append('push')\n        def record_pop(sender, **kwargs):\n            recorded.append('pop')\n\n        @app.route('\/')\n        def index():\n            return 'Hello'\n\n        flask.appcontext_pushed.connect(record_push, app)\n        flask.appcontext_popped.connect(record_pop, app)\n        try:\n            with app.test_client() as c:\n                rv = c.get('\/')\n                self.assert_equal(rv.data, b'Hello')\n                self.assert_equal(recorded, ['push'])\n            self.assert_equal(recorded, ['push', 'pop'])\n        finally:\n            flask.appcontext_pushed.disconnect(record_push, app)\n            flask.appcontext_popped.disconnect(record_pop, app)\n\n    def test_flash_signal(self):\n        app = flask.Flask(__name__)\n        app.config['SECRET_KEY'] = 'secret'\n\n        @app.route('\/')\n        def index():\n            flask.flash('This is a flash message', category='notice')\n            return flask.redirect('\/other')\n\n        recorded = []\n        def record(sender, message, category):\n            recorded.append((message, category))\n\n        flask.message_flashed.connect(record, app)\n        try:\n            client = app.test_client()\n            with client.session_transaction():\n                client.get('\/')\n                self.assert_equal(len(recorded), 1)\n                message, category = recorded[0]\n                self.assert_equal(message, 'This is a flash message')\n                self.assert_equal(category, 'notice')\n        finally:\n            flask.message_flashed.disconnect(record, app)\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    if flask.signals_available:\n        suite.addTest(unittest.makeSuite(SignalsTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.subclassing\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Test that certain behavior of flask can be customized by\n    subclasses.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport flask\nimport unittest\nfrom logging import StreamHandler\nfrom flask.testsuite import FlaskTestCase\nfrom flask._compat import StringIO\n\n\nclass FlaskSubclassingTestCase(FlaskTestCase):\n\n    def test_suppressed_exception_logging(self):\n        class SuppressedFlask(flask.Flask):\n            def log_exception(self, exc_info):\n                pass\n\n        out = StringIO()\n        app = SuppressedFlask(__name__)\n        app.logger_name = 'flask_tests\/test_suppressed_exception_logging'\n        app.logger.addHandler(StreamHandler(out))\n\n        @app.route('\/')\n        def index():\n            1 \/\/ 0\n\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_in(b'Internal Server Error', rv.data)\n\n        err = out.getvalue()\n        self.assert_equal(err, '')\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(FlaskSubclassingTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.templating\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nfrom flask.testsuite import FlaskTestCase\n\n\nclass TemplatingTestCase(FlaskTestCase):\n\n    def test_context_processing(self):\n        app = flask.Flask(__name__)\n        @app.context_processor\n        def context_processor():\n            return {'injected_value': 42}\n        @app.route('\/')\n        def index():\n            return flask.render_template('context_template.html', value=23)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'<p>23|42')\n\n    def test_original_win(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template_string('{{ config }}', config=42)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'42')\n\n    def test_request_less_rendering(self):\n        app = flask.Flask(__name__)\n        app.config['WORLD_NAME'] = 'Special World'\n        @app.context_processor\n        def context_processor():\n            return dict(foo=42)\n\n        with app.app_context():\n            rv = flask.render_template_string('Hello {{ config.WORLD_NAME }} '\n                                              '{{ foo }}')\n            self.assert_equal(rv, 'Hello Special World 42')\n\n    def test_standard_context(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'development key'\n        @app.route('\/')\n        def index():\n            flask.g.foo = 23\n            flask.session['test'] = 'aha'\n            return flask.render_template_string('''\n                {{ request.args.foo }}\n                {{ g.foo }}\n                {{ config.DEBUG }}\n                {{ session.test }}\n            ''')\n        rv = app.test_client().get('\/?foo=42')\n        self.assert_equal(rv.data.split(), [b'42', b'23', b'False', b'aha'])\n\n    def test_escaping(self):\n        text = '<p>Hello World!'\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('escaping_template.html', text=text,\n                                         html=flask.Markup(text))\n        lines = app.test_client().get('\/').data.splitlines()\n        self.assert_equal(lines, [\n            b'&lt;p&gt;Hello World!',\n            b'<p>Hello World!',\n            b'<p>Hello World!',\n            b'<p>Hello World!',\n            b'&lt;p&gt;Hello World!',\n            b'<p>Hello World!'\n        ])\n\n    def test_no_escaping(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            self.assert_equal(flask.render_template_string('{{ foo }}',\n                              foo='<test>'), '<test>')\n            self.assert_equal(flask.render_template('mail.txt', foo='<test>'),\n                              '<test> Mail')\n\n    def test_macros(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            macro = flask.get_template_attribute('_macro.html', 'hello')\n            self.assert_equal(macro('World'), 'Hello World!')\n\n    def test_template_filter(self):\n        app = flask.Flask(__name__)\n        @app.template_filter()\n        def my_reverse(s):\n            return s[::-1]\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_add_template_filter(self):\n        app = flask.Flask(__name__)\n        def my_reverse(s):\n            return s[::-1]\n        app.add_template_filter(my_reverse)\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_template_filter_with_name(self):\n        app = flask.Flask(__name__)\n        @app.template_filter('strrev')\n        def my_reverse(s):\n            return s[::-1]\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_add_template_filter_with_name(self):\n        app = flask.Flask(__name__)\n        def my_reverse(s):\n            return s[::-1]\n        app.add_template_filter(my_reverse, 'strrev')\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_template_filter_with_template(self):\n        app = flask.Flask(__name__)\n        @app.template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_template(self):\n        app = flask.Flask(__name__)\n        def super_reverse(s):\n            return s[::-1]\n        app.add_template_filter(super_reverse)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_filter_with_name_and_template(self):\n        app = flask.Flask(__name__)\n        @app.template_filter('super_reverse')\n        def my_reverse(s):\n            return s[::-1]\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_name_and_template(self):\n        app = flask.Flask(__name__)\n        def my_reverse(s):\n            return s[::-1]\n        app.add_template_filter(my_reverse, 'super_reverse')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_test(self):\n        app = flask.Flask(__name__)\n        @app.template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test(self):\n        app = flask.Flask(__name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        app.add_template_test(boolean)\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_name(self):\n        app = flask.Flask(__name__)\n        @app.template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test_with_name(self):\n        app = flask.Flask(__name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app.add_template_test(is_boolean, 'boolean')\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_template(self):\n        app = flask.Flask(__name__)\n        @app.template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_template(self):\n        app = flask.Flask(__name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        app.add_template_test(boolean)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_template_test_with_name_and_template(self):\n        app = flask.Flask(__name__)\n        @app.template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_name_and_template(self):\n        app = flask.Flask(__name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app.add_template_test(is_boolean, 'boolean')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_global(self):\n        app = flask.Flask(__name__)\n        @app.template_global()\n        def get_stuff():\n            return 42\n        self.assert_in('get_stuff', app.jinja_env.globals.keys())\n        self.assert_equal(app.jinja_env.globals['get_stuff'], get_stuff)\n        self.assert_true(app.jinja_env.globals['get_stuff'](), 42)\n        with app.app_context():\n            rv = flask.render_template_string('{{ get_stuff() }}')\n            self.assert_equal(rv, '42')\n\n    def test_custom_template_loader(self):\n        class MyFlask(flask.Flask):\n            def create_global_jinja_loader(self):\n                from jinja2 import DictLoader\n                return DictLoader({'index.html': 'Hello Custom World!'})\n        app = MyFlask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('index.html')\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Hello Custom World!')\n\n    def test_iterable_loader(self):\n        app = flask.Flask(__name__)\n        @app.context_processor\n        def context_processor():\n            return {'whiskey': 'Jameson'}\n        @app.route('\/')\n        def index():\n            return flask.render_template(\n                ['no_template.xml', # should skip this one\n                'simple_template.html', # should render this\n                'context_template.html'],\n                value=23)\n\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'<h1>Jameson<\/h1>')\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(TemplatingTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.testing\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Test client and more.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nfrom flask.testsuite import FlaskTestCase\nfrom flask._compat import text_type\n\n\nclass TestToolsTestCase(FlaskTestCase):\n\n    def test_environ_defaults_from_config(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.config['SERVER_NAME'] = 'example.com:1234'\n        app.config['APPLICATION_ROOT'] = '\/foo'\n        @app.route('\/')\n        def index():\n            return flask.request.url\n\n        ctx = app.test_request_context()\n        self.assert_equal(ctx.request.url, 'http:\/\/example.com:1234\/foo\/')\n        with app.test_client() as c:\n            rv = c.get('\/')\n            self.assert_equal(rv.data, b'http:\/\/example.com:1234\/foo\/')\n\n    def test_environ_defaults(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            return flask.request.url\n\n        ctx = app.test_request_context()\n        self.assert_equal(ctx.request.url, 'http:\/\/localhost\/')\n        with app.test_client() as c:\n            rv = c.get('\/')\n            self.assert_equal(rv.data, b'http:\/\/localhost\/')\n\n    def test_redirect_keep_session(self):\n        app = flask.Flask(__name__)\n        app.secret_key = 'testing'\n\n        @app.route('\/', methods=['GET', 'POST'])\n        def index():\n            if flask.request.method == 'POST':\n                return flask.redirect('\/getsession')\n            flask.session['data'] = 'foo'\n            return 'index'\n\n        @app.route('\/getsession')\n        def get_session():\n            return flask.session.get('data', '<missing>')\n\n        with app.test_client() as c:\n            rv = c.get('\/getsession')\n            assert rv.data == b'<missing>'\n\n            rv = c.get('\/')\n            assert rv.data == b'index'\n            assert flask.session.get('data') == 'foo'\n            rv = c.post('\/', data={}, follow_redirects=True)\n            assert rv.data == b'foo'\n\n            # This support requires a new Werkzeug version\n            if not hasattr(c, 'redirect_client'):\n                assert flask.session.get('data') == 'foo'\n\n            rv = c.get('\/getsession')\n            assert rv.data == b'foo'\n\n    def test_session_transactions(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.secret_key = 'testing'\n\n        @app.route('\/')\n        def index():\n            return text_type(flask.session['foo'])\n\n        with app.test_client() as c:\n            with c.session_transaction() as sess:\n                self.assert_equal(len(sess), 0)\n                sess['foo'] = [42]\n                self.assert_equal(len(sess), 1)\n            rv = c.get('\/')\n            self.assert_equal(rv.data, b'[42]')\n            with c.session_transaction() as sess:\n                self.assert_equal(len(sess), 1)\n                self.assert_equal(sess['foo'], [42])\n\n    def test_session_transactions_no_null_sessions(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n\n        with app.test_client() as c:\n            try:\n                with c.session_transaction() as sess:\n                    pass\n            except RuntimeError as e:\n                self.assert_in('Session backend did not open a session', str(e))\n            else:\n                self.fail('Expected runtime error')\n\n    def test_session_transactions_keep_context(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.secret_key = 'testing'\n\n        with app.test_client() as c:\n            rv = c.get('\/')\n            req = flask.request._get_current_object()\n            self.assert_true(req is not None)\n            with c.session_transaction():\n                self.assert_true(req is flask.request._get_current_object())\n\n    def test_session_transaction_needs_cookies(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        c = app.test_client(use_cookies=False)\n        try:\n            with c.session_transaction() as s:\n                pass\n        except RuntimeError as e:\n            self.assert_in('cookies', str(e))\n        else:\n            self.fail('Expected runtime error')\n\n    def test_test_client_context_binding(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            flask.g.value = 42\n            return 'Hello World!'\n\n        @app.route('\/other')\n        def other():\n            1 \/\/ 0\n\n        with app.test_client() as c:\n            resp = c.get('\/')\n            self.assert_equal(flask.g.value, 42)\n            self.assert_equal(resp.data, b'Hello World!')\n            self.assert_equal(resp.status_code, 200)\n\n            resp = c.get('\/other')\n            self.assert_false(hasattr(flask.g, 'value'))\n            self.assert_in(b'Internal Server Error', resp.data)\n            self.assert_equal(resp.status_code, 500)\n            flask.g.value = 23\n\n        try:\n            flask.g.value\n        except (AttributeError, RuntimeError):\n            pass\n        else:\n            raise AssertionError('some kind of exception expected')\n\n    def test_reuse_client(self):\n        app = flask.Flask(__name__)\n        c = app.test_client()\n\n        with c:\n            self.assert_equal(c.get('\/').status_code, 404)\n\n        with c:\n            self.assert_equal(c.get('\/').status_code, 404)\n\n    def test_test_client_calls_teardown_handlers(self):\n        app = flask.Flask(__name__)\n        called = []\n        @app.teardown_request\n        def remember(error):\n            called.append(error)\n\n        with app.test_client() as c:\n            self.assert_equal(called, [])\n            c.get('\/')\n            self.assert_equal(called, [])\n        self.assert_equal(called, [None])\n\n        del called[:]\n        with app.test_client() as c:\n            self.assert_equal(called, [])\n            c.get('\/')\n            self.assert_equal(called, [])\n            c.get('\/')\n            self.assert_equal(called, [None])\n        self.assert_equal(called, [None, None])\n\n\nclass SubdomainTestCase(FlaskTestCase):\n\n    def setUp(self):\n        self.app = flask.Flask(__name__)\n        self.app.config['SERVER_NAME'] = 'example.com'\n        self.client = self.app.test_client()\n\n        self._ctx = self.app.test_request_context()\n        self._ctx.push()\n\n    def tearDown(self):\n        if self._ctx is not None:\n            self._ctx.pop()\n\n    def test_subdomain(self):\n        @self.app.route('\/', subdomain='<company_id>')\n        def view(company_id):\n            return company_id\n\n        url = flask.url_for('view', company_id='xxx')\n        response = self.client.get(url)\n\n        self.assert_equal(200, response.status_code)\n        self.assert_equal(b'xxx', response.data)\n\n\n    def test_nosubdomain(self):\n        @self.app.route('\/<company_id>')\n        def view(company_id):\n            return company_id\n\n        url = flask.url_for('view', company_id='xxx')\n        response = self.client.get(url)\n\n        self.assert_equal(200, response.status_code)\n        self.assert_equal(b'xxx', response.data)\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(TestToolsTestCase))\n    suite.addTest(unittest.makeSuite(SubdomainTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, _app_ctx_stack\n\n# configuration\nDATABASE = '\/tmp\/flaskr.db'\nDEBUG = True\nSECRET_KEY = 'development key'\nUSERNAME = 'admin'\nPASSWORD = 'default'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef init_db():\n    \"\"\"Creates the database tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        sqlite_db.row_factory = sqlite3.Row\n        top.sqlite_db = sqlite_db\n\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db_connection(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n                 [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\nif __name__ == '__main__':\n    init_db()\n    app.run()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2014\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.views\n    ~~~~~~~~~~~~~~~~~~~~~\n\n    Pluggable views.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport flask.views\nimport unittest\nfrom flask.testsuite import FlaskTestCase\nfrom werkzeug.http import parse_set_header\n\nclass ViewTestCase(FlaskTestCase):\n\n    def common_test(self, app):\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/').data, b'GET')\n        self.assert_equal(c.post('\/').data, b'POST')\n        self.assert_equal(c.put('\/').status_code, 405)\n        meths = parse_set_header(c.open('\/', method='OPTIONS').headers['Allow'])\n        self.assert_equal(sorted(meths), ['GET', 'HEAD', 'OPTIONS', 'POST'])\n\n    def test_basic_view(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.View):\n            methods = ['GET', 'POST']\n            def dispatch_request(self):\n                return flask.request.method\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n        self.common_test(app)\n\n    def test_method_based_view(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.MethodView):\n            def get(self):\n                return 'GET'\n            def post(self):\n                return 'POST'\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n        self.common_test(app)\n\n    def test_view_patching(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.MethodView):\n            def get(self):\n                1 \/\/ 0\n            def post(self):\n                1 \/\/ 0\n\n        class Other(Index):\n            def get(self):\n                return 'GET'\n            def post(self):\n                return 'POST'\n\n        view = Index.as_view('index')\n        view.view_class = Other\n        app.add_url_rule('\/', view_func=view)\n        self.common_test(app)\n\n    def test_view_inheritance(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.MethodView):\n            def get(self):\n                return 'GET'\n            def post(self):\n                return 'POST'\n\n        class BetterIndex(Index):\n            def delete(self):\n                return 'DELETE'\n\n        app.add_url_rule('\/', view_func=BetterIndex.as_view('index'))\n        c = app.test_client()\n\n        meths = parse_set_header(c.open('\/', method='OPTIONS').headers['Allow'])\n        self.assert_equal(sorted(meths), ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST'])\n\n    def test_view_decorators(self):\n        app = flask.Flask(__name__)\n\n        def add_x_parachute(f):\n            def new_function(*args, **kwargs):\n                resp = flask.make_response(f(*args, **kwargs))\n                resp.headers['X-Parachute'] = 'awesome'\n                return resp\n            return new_function\n\n        class Index(flask.views.View):\n            decorators = [add_x_parachute]\n            def dispatch_request(self):\n                return 'Awesome'\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.headers['X-Parachute'], 'awesome')\n        self.assert_equal(rv.data, b'Awesome')\n\n    def test_implicit_head(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.MethodView):\n            def get(self):\n                return flask.Response('Blub', headers={\n                    'X-Method': flask.request.method\n                })\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Blub')\n        self.assert_equal(rv.headers['X-Method'], 'GET')\n        rv = c.head('\/')\n        self.assert_equal(rv.data, b'')\n        self.assert_equal(rv.headers['X-Method'], 'HEAD')\n\n    def test_explicit_head(self):\n        app = flask.Flask(__name__)\n\n        class Index(flask.views.MethodView):\n            def get(self):\n                return 'GET'\n            def head(self):\n                return flask.Response('', headers={'X-Method': 'HEAD'})\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'GET')\n        rv = c.head('\/')\n        self.assert_equal(rv.data, b'')\n        self.assert_equal(rv.headers['X-Method'], 'HEAD')\n\n    def test_endpoint_override(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        class Index(flask.views.View):\n            methods = ['GET', 'POST']\n            def dispatch_request(self):\n                return flask.request.method\n\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n        with self.assert_raises(AssertionError):\n            app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n        # But these tests should still pass. We just log a warning.\n        self.common_test(app)\n\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(ViewTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Fixed flask tests\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr Tests\n    ~~~~~~~~~~~~\n\n    Tests the Flaskr application.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport os\nimport flaskr\nimport unittest\nimport tempfile\n\n\nclass FlaskrTestCase(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Before each test, set up a blank database\"\"\"\n        self.db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()\n        flaskr.app.config['TESTING'] = True\n        self.app = flaskr.app.test_client()\n        with flaskr.app.app_context():\n            flaskr.init_db()\n\n    def tearDown(self):\n        \"\"\"Get rid of the database again after each test.\"\"\"\n        os.close(self.db_fd)\n        os.unlink(flaskr.app.config['DATABASE'])\n\n    def login(self, username, password):\n        return self.app.post('\/login', data=dict(\n            username=username,\n            password=password\n        ), follow_redirects=True)\n\n    def logout(self):\n        return self.app.get('\/logout', follow_redirects=True)\n\n    # testing functions\n\n    def test_empty_db(self):\n        \"\"\"Start with a blank database.\"\"\"\n        rv = self.app.get('\/')\n        assert b'No entries here so far' in rv.data\n\n    def test_login_logout(self):\n        \"\"\"Make sure login and logout works\"\"\"\n        rv = self.login(flaskr.app.config['USERNAME'],\n                        flaskr.app.config['PASSWORD'])\n        assert b'You were logged in' in rv.data\n        rv = self.logout()\n        assert b'You were logged out' in rv.data\n        rv = self.login(flaskr.app.config['USERNAME'] + 'x',\n                        flaskr.app.config['PASSWORD'])\n        assert b'Invalid username' in rv.data\n        rv = self.login(flaskr.app.config['USERNAME'],\n                        flaskr.app.config['PASSWORD'] + 'x')\n        assert b'Invalid password' in rv.data\n\n    def test_messages(self):\n        \"\"\"Test that messages work\"\"\"\n        self.login(flaskr.app.config['USERNAME'],\n                   flaskr.app.config['PASSWORD'])\n        rv = self.app.post('\/add', data=dict(\n            title='<Hello>',\n            text='<strong>HTML<\/strong> allowed here'\n        ), follow_redirects=True)\n        assert b'No entries here so far' not in rv.data\n        assert b'&lt;Hello&gt;' in rv.data\n        assert b'<strong>HTML<\/strong> allowed here' in rv.data\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit\n    ~~~~~~~~\n\n    A microblogging application written with Flask and sqlite3.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport time\nfrom sqlite3 import dbapi2 as sqlite3\nfrom hashlib import md5\nfrom datetime import datetime\nfrom flask import Flask, request, session, url_for, redirect, \\\n     render_template, abort, g, flash, _app_ctx_stack\nfrom werkzeug import check_password_hash, generate_password_hash\n\n\n# configuration\nDATABASE = '\/tmp\/minitwit.db'\nPER_PAGE = 30\nDEBUG = True\nSECRET_KEY = 'development key'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('MINITWIT_SETTINGS', silent=True)\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        top.sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        top.sqlite_db.row_factory = sqlite3.Row\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_database(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef query_db(query, args=(), one=False):\n    \"\"\"Queries the database and returns a list of dictionaries.\"\"\"\n    cur = get_db().execute(query, args)\n    rv = cur.fetchall()\n    return (rv[0] if rv else None) if one else rv\n\n\ndef get_user_id(username):\n    \"\"\"Convenience method to look up the id for a username.\"\"\"\n    rv = query_db('select user_id from user where username = ?',\n                  [username], one=True)\n    return rv[0] if rv else None\n\n\ndef format_datetime(timestamp):\n    \"\"\"Format a timestamp for display.\"\"\"\n    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')\n\n\ndef gravatar_url(email, size=80):\n    \"\"\"Return the gravatar image for the given email address.\"\"\"\n    return 'http:\/\/www.gravatar.com\/avatar\/%s?d=identicon&s=%d' % \\\n        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)\n\n\n@app.before_request\ndef before_request():\n    g.user = None\n    if 'user_id' in session:\n        g.user = query_db('select * from user where user_id = ?',\n                          [session['user_id']], one=True)\n\n\n@app.route('\/')\ndef timeline():\n    \"\"\"Shows a users timeline or if no user is logged in it will\n    redirect to the public timeline.  This timeline shows the user's\n    messages as well as all the messages of followed users.\n    \"\"\"\n    if not g.user:\n        return redirect(url_for('public_timeline'))\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id and (\n            user.user_id = ? or\n            user.user_id in (select whom_id from follower\n                                    where who_id = ?))\n        order by message.pub_date desc limit ?''',\n        [session['user_id'], session['user_id'], PER_PAGE]))\n\n\n@app.route('\/public')\ndef public_timeline():\n    \"\"\"Displays the latest messages of all users.\"\"\"\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id\n        order by message.pub_date desc limit ?''', [PER_PAGE]))\n\n\n@app.route('\/<username>')\ndef user_timeline(username):\n    \"\"\"Display's a users tweets.\"\"\"\n    profile_user = query_db('select * from user where username = ?',\n                            [username], one=True)\n    if profile_user is None:\n        abort(404)\n    followed = False\n    if g.user:\n        followed = query_db('''select 1 from follower where\n            follower.who_id = ? and follower.whom_id = ?''',\n            [session['user_id'], profile_user['user_id']],\n            one=True) is not None\n    return render_template('timeline.html', messages=query_db('''\n            select message.*, user.* from message, user where\n            user.user_id = message.author_id and user.user_id = ?\n            order by message.pub_date desc limit ?''',\n            [profile_user['user_id'], PER_PAGE]), followed=followed,\n            profile_user=profile_user)\n\n\n@app.route('\/<username>\/follow')\ndef follow_user(username):\n    \"\"\"Adds the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    db = get_db()\n    db.execute('insert into follower (who_id, whom_id) values (?, ?)',\n              [session['user_id'], whom_id])\n    db.commit()\n    flash('You are now following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/<username>\/unfollow')\ndef unfollow_user(username):\n    \"\"\"Removes the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    db = get_db()\n    db.execute('delete from follower where who_id=? and whom_id=?',\n              [session['user_id'], whom_id])\n    db.commit()\n    flash('You are no longer following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/add_message', methods=['POST'])\ndef add_message():\n    \"\"\"Registers a new message for the user.\"\"\"\n    if 'user_id' not in session:\n        abort(401)\n    if request.form['text']:\n        db = get_db()\n        db.execute('''insert into message (author_id, text, pub_date)\n          values (?, ?, ?)''', (session['user_id'], request.form['text'],\n                                int(time.time())))\n        db.commit()\n        flash('Your message was recorded')\n    return redirect(url_for('timeline'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    \"\"\"Logs the user in.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        user = query_db('''select * from user where\n            username = ?''', [request.form['username']], one=True)\n        if user is None:\n            error = 'Invalid username'\n        elif not check_password_hash(user['pw_hash'],\n                                     request.form['password']):\n            error = 'Invalid password'\n        else:\n            flash('You were logged in')\n            session['user_id'] = user['user_id']\n            return redirect(url_for('timeline'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/register', methods=['GET', 'POST'])\ndef register():\n    \"\"\"Registers the user.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        if not request.form['username']:\n            error = 'You have to enter a username'\n        elif not request.form['email'] or \\\n                '@' not in request.form['email']:\n            error = 'You have to enter a valid email address'\n        elif not request.form['password']:\n            error = 'You have to enter a password'\n        elif request.form['password'] != request.form['password2']:\n            error = 'The two passwords do not match'\n        elif get_user_id(request.form['username']) is not None:\n            error = 'The username is already taken'\n        else:\n            db = get_db()\n            db.execute('''insert into user (\n              username, email, pw_hash) values (?, ?, ?)''',\n              [request.form['username'], request.form['email'],\n               generate_password_hash(request.form['password'])])\n            db.commit()\n            flash('You were successfully registered and can login now')\n            return redirect(url_for('login'))\n    return render_template('register.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    \"\"\"Logs the user out.\"\"\"\n    flash('You were logged out')\n    session.pop('user_id', None)\n    return redirect(url_for('public_timeline'))\n\n\n# add some filters to jinja\napp.jinja_env.filters['datetimeformat'] = format_datetime\napp.jinja_env.filters['gravatar'] = gravatar_url\n\n\"\"\"\nGenerate tests which test: Fixed flask tests\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit Tests\n    ~~~~~~~~~~~~~~\n\n    Tests the MiniTwit application.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport os\nimport minitwit\nimport unittest\nimport tempfile\n\n\nclass MiniTwitTestCase(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Before each test, set up a blank database\"\"\"\n        self.db_fd, minitwit.app.config['DATABASE'] = tempfile.mkstemp()\n        self.app = minitwit.app.test_client()\n        with minitwit.app.app_context():\n            minitwit.init_db()\n\n    def tearDown(self):\n        \"\"\"Get rid of the database again after each test.\"\"\"\n        os.close(self.db_fd)\n        os.unlink(minitwit.app.config['DATABASE'])\n\n    # helper functions\n\n    def register(self, username, password, password2=None, email=None):\n        \"\"\"Helper function to register a user\"\"\"\n        if password2 is None:\n            password2 = password\n        if email is None:\n            email = username + '@example.com'\n        return self.app.post('\/register', data={\n            'username':     username,\n            'password':     password,\n            'password2':    password2,\n            'email':        email,\n        }, follow_redirects=True)\n\n    def login(self, username, password):\n        \"\"\"Helper function to login\"\"\"\n        return self.app.post('\/login', data={\n            'username': username,\n            'password': password\n        }, follow_redirects=True)\n\n    def register_and_login(self, username, password):\n        \"\"\"Registers and logs in in one go\"\"\"\n        self.register(username, password)\n        return self.login(username, password)\n\n    def logout(self):\n        \"\"\"Helper function to logout\"\"\"\n        return self.app.get('\/logout', follow_redirects=True)\n\n    def add_message(self, text):\n        \"\"\"Records a message\"\"\"\n        rv = self.app.post('\/add_message', data={'text': text},\n                                    follow_redirects=True)\n        if text:\n            assert b'Your message was recorded' in rv.data\n        return rv\n\n    # testing functions\n\n    def test_register(self):\n        \"\"\"Make sure registering works\"\"\"\n        rv = self.register('user1', 'default')\n        assert b'You were successfully registered ' \\\n               b'and can login now' in rv.data\n        rv = self.register('user1', 'default')\n        assert b'The username is already taken' in rv.data\n        rv = self.register('', 'default')\n        assert b'You have to enter a username' in rv.data\n        rv = self.register('meh', '')\n        assert b'You have to enter a password' in rv.data\n        rv = self.register('meh', 'x', 'y')\n        assert b'The two passwords do not match' in rv.data\n        rv = self.register('meh', 'foo', email='broken')\n        assert b'You have to enter a valid email address' in rv.data\n\n    def test_login_logout(self):\n        \"\"\"Make sure logging in and logging out works\"\"\"\n        rv = self.register_and_login('user1', 'default')\n        assert b'You were logged in' in rv.data\n        rv = self.logout()\n        assert b'You were logged out' in rv.data\n        rv = self.login('user1', 'wrongpassword')\n        assert b'Invalid password' in rv.data\n        rv = self.login('user2', 'wrongpassword')\n        assert b'Invalid username' in rv.data\n\n    def test_message_recording(self):\n        \"\"\"Check if adding messages works\"\"\"\n        self.register_and_login('foo', 'default')\n        self.add_message('test message 1')\n        self.add_message('<test message 2>')\n        rv = self.app.get('\/')\n        assert b'test message 1' in rv.data\n        assert b'&lt;test message 2&gt;' in rv.data\n\n    def test_timelines(self):\n        \"\"\"Make sure that timelines work\"\"\"\n        self.register_and_login('foo', 'default')\n        self.add_message('the message by foo')\n        self.logout()\n        self.register_and_login('bar', 'default')\n        self.add_message('the message by bar')\n        rv = self.app.get('\/public')\n        assert b'the message by foo' in rv.data\n        assert b'the message by bar' in rv.data\n\n        # bar's timeline should just show bar's message\n        rv = self.app.get('\/')\n        assert b'the message by foo' not in rv.data\n        assert b'the message by bar' in rv.data\n\n        # now let's follow foo\n        rv = self.app.get('\/foo\/follow', follow_redirects=True)\n        assert b'You are now following &#34;foo&#34;' in rv.data\n\n        # we should now see foo's message\n        rv = self.app.get('\/')\n        assert b'the message by foo' in rv.data\n        assert b'the message by bar' in rv.data\n\n        # but on the user's page we only want the user's message\n        rv = self.app.get('\/bar')\n        assert b'the message by foo' not in rv.data\n        assert b'the message by bar' in rv.data\n        rv = self.app.get('\/foo')\n        assert b'the message by foo' in rv.data\n        assert b'the message by bar' not in rv.data\n\n        # now unfollow and check if that worked\n        rv = self.app.get('\/foo\/unfollow', follow_redirects=True)\n        assert b'You are no longer following &#34;foo&#34;' in rv.data\n        rv = self.app.get('\/')\n        assert b'the message by foo' not in rv.data\n        assert b'the message by bar' in rv.data\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.app\n    ~~~~~~~~~\n\n    This module implements the central WSGI application object.\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nfrom threading import Lock\nfrom datetime import timedelta\nfrom itertools import chain\nfrom functools import update_wrapper\n\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.routing import Map, Rule, RequestRedirect, BuildError\nfrom werkzeug.exceptions import HTTPException, InternalServerError, \\\n     MethodNotAllowed, BadRequest\n\nfrom .helpers import _PackageBoundObject, url_for, get_flashed_messages, \\\n     locked_cached_property, _endpoint_from_view_func, find_package\nfrom . import json, cli\nfrom .wrappers import Request, Response\nfrom .config import ConfigAttribute, Config\nfrom .ctx import RequestContext, AppContext, _AppCtxGlobals\nfrom .globals import _request_ctx_stack, request, session, g\nfrom .sessions import SecureCookieSessionInterface\nfrom .module import blueprint_is_module\nfrom .templating import DispatchingJinjaLoader, Environment, \\\n     _default_template_ctx_processor\nfrom .signals import request_started, request_finished, got_request_exception, \\\n     request_tearing_down, appcontext_tearing_down\nfrom ._compat import reraise, string_types, text_type, integer_types\n\n# a lock used for logger initialization\n_logger_lock = Lock()\n\n\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\n\n\ndef setupmethod(f):\n    \"\"\"Wraps a method so that it performs a check in debug mode if the\n    first request was already handled.\n    \"\"\"\n    def wrapper_func(self, *args, **kwargs):\n        if self.debug and self._got_first_request:\n            raise AssertionError('A setup function was called after the '\n                'first request was handled.  This usually indicates a bug '\n                'in the application where a module was not imported '\n                'and decorators or other functionality was called too late.\\n'\n                'To fix this make sure to import all your view modules, '\n                'database models and everything related at a central place '\n                'before the application starts serving requests.')\n        return f(self, *args, **kwargs)\n    return update_wrapper(wrapper_func, f)\n\n\nclass Flask(_PackageBoundObject):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an `__init__.py` file inside) or a standard module (just a `.py` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the `__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the file system, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in `yourapplication\/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 1.0\n       The `root_path` parameter was added.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: the folder with static files that should be served\n                          at `static_url_path`.  Defaults to the ``'static'``\n                          folder in the root path of the application.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to `True` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    :param root_path: Flask by default will automatically calculate the path\n                      to the root of the application.  In certain situations\n                      this cannot be achieved (for instance if the package\n                      is a Python 3 namespace package) and needs to be\n                      manually defined.\n    \"\"\"\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class = Response\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on expected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is now application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    # Backwards compatibility support\n    def _get_request_globals_class(self):\n        return self.app_ctx_globals_class\n    def _set_request_globals_class(self, value):\n        from warnings import warn\n        warn(DeprecationWarning('request_globals_class attribute is now '\n                                'called app_ctx_globals_class'))\n        self.app_ctx_globals_class = value\n    request_globals_class = property(_get_request_globals_class,\n                                     _set_request_globals_class)\n    del _get_request_globals_class, _set_request_globals_class\n\n    #: The class that is used for the ``config`` attribute of this app.\n    #: Defaults to :class:`~flask.Config`.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Default values for certain config options.\n    #: 2. Access to config values through attributes in addition to keys.\n    #:\n    #: .. versionadded:: 1.0\n    config_class = Config\n\n    #: The debug flag.  Set this to `True` to enable debugging of the\n    #: application.  In debug mode the debugger will kick in when an unhandled\n    #: exception occurs and the integrated server will automatically reload\n    #: the application if changes in the code are detected.\n    #:\n    #: This attribute can also be configured from the config with the `DEBUG`\n    #: configuration key.  Defaults to `False`.\n    debug = ConfigAttribute('DEBUG')\n\n    #: The testing flag.  Set this to `True` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate unittest helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `TESTING` configuration key.  Defaults to `False`.\n    testing = ConfigAttribute('TESTING')\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and other things.  Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `SECRET_KEY` configuration key.  Defaults to `None`.\n    secret_key = ConfigAttribute('SECRET_KEY')\n\n    #: The secure cookie uses this for the name of the session cookie.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `SESSION_COOKIE_NAME` configuration key.  Defaults to ``'session'``\n    session_cookie_name = ConfigAttribute('SESSION_COOKIE_NAME')\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `PERMANENT_SESSION_LIFETIME` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute('PERMANENT_SESSION_LIFETIME',\n        get_converter=_make_timedelta)\n\n    #: Enable this if you want to use the X-Sendfile feature.  Keep in\n    #: mind that the server has to support this.  This only affects files\n    #: sent with the :func:`send_file` method.\n    #:\n    #: .. versionadded:: 0.2\n    #:\n    #: This attribute can also be configured from the config with the\n    #: `USE_X_SENDFILE` configuration key.  Defaults to `False`.\n    use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')\n\n    #: The name of the logger to use.  By default the logger name is the\n    #: package name passed to the constructor.\n    #:\n    #: .. versionadded:: 0.4\n    logger_name = ConfigAttribute('LOGGER_NAME')\n\n    #: Enable the deprecated module support?  This is active by default\n    #: in 0.7 but will be changed to False in 0.8.  With Flask 1.0 modules\n    #: will be removed in favor of Blueprints\n    enable_modules = True\n\n    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_encoder = json.JSONEncoder\n\n    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_decoder = json.JSONDecoder\n\n    #: Options that are passed directly to the Jinja2 environment.\n    jinja_options = ImmutableDict(\n        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']\n    )\n\n    #: Default configuration parameters.\n    default_config = ImmutableDict({\n        'DEBUG':                                False,\n        'TESTING':                              False,\n        'PROPAGATE_EXCEPTIONS':                 None,\n        'PRESERVE_CONTEXT_ON_EXCEPTION':        None,\n        'SECRET_KEY':                           None,\n        'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n        'USE_X_SENDFILE':                       False,\n        'LOGGER_NAME':                          None,\n        'LOGGER_HANDLER_POLICY':               'always',\n        'SERVER_NAME':                          None,\n        'APPLICATION_ROOT':                     None,\n        'SESSION_COOKIE_NAME':                  'session',\n        'SESSION_COOKIE_DOMAIN':                None,\n        'SESSION_COOKIE_PATH':                  None,\n        'SESSION_COOKIE_HTTPONLY':              True,\n        'SESSION_COOKIE_SECURE':                False,\n        'SESSION_REFRESH_EACH_REQUEST':         True,\n        'MAX_CONTENT_LENGTH':                   None,\n        'SEND_FILE_MAX_AGE_DEFAULT':            12 * 60 * 60, # 12 hours\n        'TRAP_BAD_REQUEST_ERRORS':              False,\n        'TRAP_HTTP_EXCEPTIONS':                 False,\n        'PREFERRED_URL_SCHEME':                 'http',\n        'JSON_AS_ASCII':                        True,\n        'JSON_SORT_KEYS':                       True,\n        'JSONIFY_PRETTYPRINT_REGULAR':          True,\n        'TEMPLATES_AUTO_RELOAD':                True,\n    })\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: the test client that is used with when `test_client` is used.\n    #:\n    #: .. versionadded:: 0.7\n    test_client_class = None\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface = SecureCookieSessionInterface()\n\n    def __init__(self, import_name, static_path=None, static_url_path=None,\n                 static_folder='static', template_folder='templates',\n                 instance_path=None, instance_relative_config=False,\n                 root_path=None):\n        _PackageBoundObject.__init__(self, import_name,\n                                     template_folder=template_folder,\n                                     root_path=root_path)\n        if static_path is not None:\n            from warnings import warn\n            warn(DeprecationWarning('static_path is now called '\n                                    'static_url_path'), stacklevel=2)\n            static_url_path = static_path\n\n        if static_url_path is not None:\n            self.static_url_path = static_url_path\n        if static_folder is not None:\n            self.static_folder = static_folder\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError('If an instance path is provided it must be '\n                             'absolute.  A relative path was given instead.')\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        # Prepare the deferred setup of the logger.\n        self._logger = None\n        self.logger_name = self.import_name\n\n        #: A dictionary of all view functions registered.  The keys will\n        #: be function names which are also used to generate URLs and\n        #: the values are the function objects themselves.\n        #: To register a view function, use the :meth:`route` decorator.\n        self.view_functions = {}\n\n        # support for the now deprecated `error_handlers` attribute.  The\n        # :attr:`error_handler_spec` shall be used now.\n        self._error_handlers = {}\n\n        #: A dictionary of all registered error handlers.  The key is `None`\n        #: for error handlers active on the application, otherwise the key is\n        #: the name of the blueprint.  Each key points to another dictionary\n        #: where the key is the status code of the http exception.  The\n        #: special key `None` points to a list of tuples where the first item\n        #: is the class for the instance check and the second the error handler\n        #: function.\n        #:\n        #: To register a error handler, use the :meth:`errorhandler`\n        #: decorator.\n        self.error_handler_spec = {None: self._error_handlers}\n\n        #: A list of functions that are called when :meth:`url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n        #: is called with `error`, `endpoint` and `values`.  If a function\n        #: returns `None` or raises a `BuildError` the next function is\n        #: tried.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers = []\n\n        #: A dictionary with lists of functions that should be called at the\n        #: beginning of the request.  The key of the dictionary is the name of\n        #: the blueprint this function is active for, `None` for all requests.\n        #: This can for example be used to open database connections or\n        #: getting hold of the currently logged in user.  To register a\n        #: function here, use the :meth:`before_request` decorator.\n        self.before_request_funcs = {}\n\n        #: A lists of functions that should be called at the beginning of the\n        #: first request to this instance.  To register a function here, use\n        #: the :meth:`before_first_request` decorator.\n        #:\n        #: .. versionadded:: 0.8\n        self.before_first_request_funcs = []\n\n        #: A dictionary with lists of functions that should be called after\n        #: each request.  The key of the dictionary is the name of the blueprint\n        #: this function is active for, `None` for all requests.  This can for\n        #: example be used to open database connections or getting hold of the\n        #: currently logged in user.  To register a function here, use the\n        #: :meth:`after_request` decorator.\n        self.after_request_funcs = {}\n\n        #: A dictionary with lists of functions that are called after\n        #: each request, even if an exception has occurred. The key of the\n        #: dictionary is the name of the blueprint this function is active for,\n        #: `None` for all requests. These functions are not allowed to modify\n        #: the request, and their return values are ignored. If an exception\n        #: occurred while processing the request, it gets passed to each\n        #: teardown_request function. To register a function here, use the\n        #: :meth:`teardown_request` decorator.\n        #:\n        #: .. versionadded:: 0.7\n        self.teardown_request_funcs = {}\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs = []\n\n        #: A dictionary with lists of functions that can be used as URL\n        #: value processor functions.  Whenever a URL is built these functions\n        #: are called to modify the dictionary of values in place.  The key\n        #: `None` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #:\n        #: .. versionadded:: 0.7\n        self.url_value_preprocessors = {}\n\n        #: A dictionary with lists of functions that can be used as URL value\n        #: preprocessors.  The key `None` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #: of URL values before they are used as the keyword arguments of the\n        #: view function.  For each function registered this one should also\n        #: provide a :meth:`url_defaults` function that adds the parameters\n        #: automatically again that were removed that way.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_default_functions = {}\n\n        #: A dictionary with list of functions that are called without argument\n        #: to populate the template context.  The key of the dictionary is the\n        #: name of the blueprint this function is active for, `None` for all\n        #: requests.  Each returns a dictionary that the template context is\n        #: updated with.  To register a function here, use the\n        #: :meth:`context_processor` decorator.\n        self.template_context_processors = {\n            None: [_default_template_ctx_processor]\n        }\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 1.0\n        self.shell_context_processors = []\n\n        #: all the attached blueprints in a dictionary by name.  Blueprints\n        #: can be attached multiple times so this dictionary does not tell\n        #: you how often they got attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.  For backwards compatibility extensions should register\n        #: themselves like this::\n        #:\n        #:      if not hasattr(app, 'extensions'):\n        #:          app.extensions = {}\n        #:      app.extensions['extensionname'] = SomeObject()\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(BaseConverter.to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = Map()\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n\n        # register the static folder for the application.  Do that even\n        # if the folder does not exist.  First of all it might be created\n        # while the server is running (usually happens during development)\n        # but also because google appengine stores static files somewhere\n        # else when mapped with the .yml file.\n        if self.has_static_folder:\n            self.add_url_rule(self.static_url_path + '\/<path:filename>',\n                              endpoint='static',\n                              view_func=self.send_static_file)\n\n        #: The click command line context for this application.  Commands\n        #: registered here show up in the ``flask`` command once the\n        #: application has been discovered.  The default commands are\n        #: provided by Flask itself and can be overridden.\n        #:\n        #: This is an instance of a :class:`click.Group` object.\n        self.cli = cli.AppGroup(self)\n\n    def _get_error_handlers(self):\n        from warnings import warn\n        warn(DeprecationWarning('error_handlers is deprecated, use the '\n            'new error_handler_spec attribute instead.'), stacklevel=1)\n        return self._error_handlers\n    def _set_error_handlers(self, value):\n        self._error_handlers = value\n        self.error_handler_spec[None] = value\n    error_handlers = property(_get_error_handlers, _set_error_handlers)\n    del _get_error_handlers, _set_error_handlers\n\n    @locked_cached_property\n    def name(self):\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == '__main__':\n            fn = getattr(sys.modules['__main__'], '__file__', None)\n            if fn is None:\n                return '__main__'\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @property\n    def propagate_exceptions(self):\n        \"\"\"Returns the value of the `PROPAGATE_EXCEPTIONS` configuration\n        value in case it's set, otherwise a sensible default is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PROPAGATE_EXCEPTIONS']\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n\n    @property\n    def preserve_context_on_exception(self):\n        \"\"\"Returns the value of the `PRESERVE_CONTEXT_ON_EXCEPTION`\n        configuration value in case it's set, otherwise a sensible default\n        is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PRESERVE_CONTEXT_ON_EXCEPTION']\n        if rv is not None:\n            return rv\n        return self.debug\n\n    @property\n    def logger(self):\n        \"\"\"A :class:`logging.Logger` object for this application.  The\n        default configuration is to log to stderr if the application is\n        in debug mode.  This logger can be used to (surprise) log messages.\n        Here some examples::\n\n            app.logger.debug('A value for debugging')\n            app.logger.warning('A warning occurred (%d apples)', 42)\n            app.logger.error('An error occurred')\n\n        .. versionadded:: 0.3\n        \"\"\"\n        if self._logger and self._logger.name == self.logger_name:\n            return self._logger\n        with _logger_lock:\n            if self._logger and self._logger.name == self.logger_name:\n                return self._logger\n            from flask.logging import create_logger\n            self._logger = rv = create_logger(self)\n            return rv\n\n    @locked_cached_property\n    def jinja_env(self):\n        \"\"\"The Jinja2 environment used to load templates.\"\"\"\n        return self.create_jinja_environment()\n\n    @property\n    def got_first_request(self):\n        \"\"\"This attribute is set to `True` if the application started\n        handling the first request.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        return self._got_first_request\n\n    def make_config(self, instance_relative=False):\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        return self.config_class(root_path, self.default_config)\n\n    def auto_find_instance_path(self):\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, 'instance')\n        return os.path.join(prefix, 'var', self.name + '-instance')\n\n    def open_instance_resource(self, resource, mode='rb'):\n        \"\"\"Opens a resource from the application's instance folder\n        (:attr:`instance_path`).  Otherwise works like\n        :meth:`open_resource`.  Instance resources can also be opened for\n        writing.\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        :param mode: resource file opening mode, default is 'rb'.\n        \"\"\"\n        return open(os.path.join(self.instance_path, resource), mode)\n\n    def create_jinja_environment(self):\n        \"\"\"Creates the Jinja2 environment based on :attr:`jinja_options`\n        and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds\n        the Jinja2 globals and filters after initialization.  Override\n        this function to customize the behavior.\n\n        .. versionadded:: 0.5\n        .. versionchanged:: 1.0\n           ``Environment.auto_reload`` set in accordance with\n           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n        \"\"\"\n        options = dict(self.jinja_options)\n        if 'autoescape' not in options:\n            options['autoescape'] = self.select_jinja_autoescape\n        if 'auto_reload' not in options:\n            options['auto_reload'] = self.debug \\\n                or self.config['TEMPLATES_AUTO_RELOAD']\n        rv = Environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g\n        )\n        rv.filters['tojson'] = json.tojson_filter\n        return rv\n\n    def create_global_jinja_loader(self):\n        \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n\n    def init_jinja_globals(self):\n        \"\"\"Deprecated.  Used to initialize the Jinja2 globals.\n\n        .. versionadded:: 0.5\n        .. versionchanged:: 0.7\n           This method is deprecated with 0.7.  Override\n           :meth:`create_jinja_environment` instead.\n        \"\"\"\n\n    def select_jinja_autoescape(self, filename):\n        \"\"\"Returns `True` if autoescaping should be active for the given\n        template name.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return False\n        return filename.endswith(('.html', '.htm', '.xml', '.xhtml'))\n\n    def update_template_context(self, context):\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        # make sure the original values win.  This makes it possible to\n        # easier add new variables in context processors without breaking\n        # existing views.\n        context.update(orig_ctx)\n\n    def make_shell_context(self):\n        \"\"\"Returns the shell context for an interactive shell for this\n        application.  This runs all the registered shell context\n        processors.\n\n        .. versionadded:: 1.0\n        \"\"\"\n        rv = {'app': self, 'g': g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n\n    def run(self, host=None, port=None, debug=None, **options):\n        \"\"\"Runs the application on a local development server.  If the\n        :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        It is not recommended to use this function for development with\n        automatic reloading as this is badly supported.  Instead you should\n        be using the ``flask`` command line script's ``runserver``\n        support.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to `True` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        .. versionchanged:: 0.10\n           The default port is now picked from the ``SERVER_NAME`` variable.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n                     have the server available externally as well. Defaults to\n                     ``'127.0.0.1'``.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n                     port defined in the ``SERVER_NAME`` config variable if\n                     present.\n        :param debug: if given, enable or disable debug mode.\n                      See :attr:`debug`.\n        :param options: the options to be forwarded to the underlying\n                        Werkzeug server.  See\n                        :func:`werkzeug.serving.run_simple` for more\n                        information.\n        \"\"\"\n        from werkzeug.serving import run_simple\n        if host is None:\n            host = '127.0.0.1'\n        if port is None:\n            server_name = self.config['SERVER_NAME']\n            if server_name and ':' in server_name:\n                port = int(server_name.rsplit(':', 1)[1])\n            else:\n                port = 5000\n        if debug is not None:\n            self.debug = bool(debug)\n        options.setdefault('use_reloader', self.debug)\n        options.setdefault('use_debugger', self.debug)\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # resetted normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False\n\n    def test_client(self, use_cookies=True):\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :ref:`testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a `with` block to defer the closing down\n        of the context until the end of the `with` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('\/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for `with` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from flask.testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies)\n\n    def open_session(self, request):\n        \"\"\"Creates or opens a new session.  Default implementation stores all\n        session data in a signed cookie.  This requires that the\n        :attr:`secret_key` is set.  Instead of overriding this method\n        we recommend replacing the :class:`session_interface`.\n\n        :param request: an instance of :attr:`request_class`.\n        \"\"\"\n        return self.session_interface.open_session(self, request)\n\n    def save_session(self, session, response):\n        \"\"\"Saves the session if it needs updates.  For the default\n        implementation, check :meth:`open_session`.  Instead of overriding this\n        method we recommend replacing the :class:`session_interface`.\n\n        :param session: the session to be saved (a\n                        :class:`~werkzeug.contrib.securecookie.SecureCookie`\n                        object)\n        :param response: an instance of :attr:`response_class`\n        \"\"\"\n        return self.session_interface.save_session(self, session, response)\n\n    def make_null_session(self):\n        \"\"\"Creates a new instance of a missing session.  Instead of overriding\n        this method we recommend replacing the :class:`session_interface`.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return self.session_interface.make_null_session(self)\n\n    def register_module(self, module, **options):\n        \"\"\"Registers a module with this application.  The keyword arguments\n        of this function are the same as the ones for the constructor of the\n        :class:`Module` class and will override the values of the module if\n        provided.\n\n        .. versionchanged:: 0.7\n           The module system was deprecated in favor for the blueprint\n           system.\n        \"\"\"\n        assert blueprint_is_module(module), 'register_module requires ' \\\n            'actual module objects.  Please upgrade to blueprints though.'\n        if not self.enable_modules:\n            raise RuntimeError('Module support was disabled but code '\n                'attempted to register a module named %r' % module)\n        else:\n            from warnings import warn\n            warn(DeprecationWarning('Modules are deprecated.  Upgrade to '\n                'using blueprints.  Have a look into the documentation for '\n                'more information.  If this module was registered by a '\n                'Flask-Extension upgrade the extension or contact the author '\n                'of that extension instead.  (Registered %r)' % module),\n                stacklevel=2)\n\n        self.register_blueprint(module, **options)\n\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        \"\"\"Registers a blueprint on the application.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, \\\n                'A blueprint\\'s name collision occurred between %r and ' \\\n                '%r.  Both share the same name \"%s\".  Blueprints that ' \\\n                'are created on the fly need unique names.' % \\\n                (blueprint, self.blueprints[blueprint.name], blueprint.name)\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n\n    @setupmethod\n    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n        \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n        decorator.  If a view_func is provided it will be registered with the\n        endpoint.\n\n        Basically this example::\n\n            @app.route('\/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('\/', 'index', index)\n\n        If the view_func is not provided you will need to connect the endpoint\n        to a view function like so::\n\n            app.view_functions['index'] = index\n\n        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n        to customize the behavior via subclassing you only need to change\n        this method.\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        .. versionchanged:: 0.2\n           `view_func` parameter added.\n\n        .. versionchanged:: 0.6\n           `OPTIONS` is added automatically as method.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (`GET`, `POST` etc.).  By default a rule\n                        just listens for `GET` (and implicitly `HEAD`).\n                        Starting with Flask 0.6, `OPTIONS` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options['endpoint'] = endpoint\n        methods = options.pop('methods', None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only `GET` as default.\n        if methods is None:\n            methods = getattr(view_func, 'methods', None) or ('GET',)\n        if isinstance(methods, string_types):\n            raise TypeError('Allowed methods have to be iterables of strings, '\n                            'for example: @app.route(..., methods=[\"POST\"])')\n        methods = set(methods)\n\n        # Methods that should always be added\n        required_methods = set(getattr(view_func, 'required_methods', ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        provide_automatic_options = getattr(view_func,\n            'provide_automatic_options', None)\n\n        if provide_automatic_options is None:\n            if 'OPTIONS' not in methods:\n                provide_automatic_options = True\n                required_methods.add('OPTIONS')\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError('View function mapping is overwriting an '\n                                     'existing endpoint function: %s' % endpoint)\n            self.view_functions[endpoint] = view_func\n\n    def route(self, rule, **options):\n        \"\"\"A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as :meth:`add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('\/')\n            def index():\n                return 'Hello World'\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (`GET`, `POST` etc.).  By default a rule\n                        just listens for `GET` (and implicitly `HEAD`).\n                        Starting with Flask 0.6, `OPTIONS` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        def decorator(f):\n            endpoint = options.pop('endpoint', None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n        return decorator\n\n    @setupmethod\n    def endpoint(self, endpoint):\n        \"\"\"A decorator to register a function as an endpoint.\n        Example::\n\n            @app.endpoint('example.endpoint')\n            def example():\n                return \"example\"\n\n        :param endpoint: the name of the endpoint\n        \"\"\"\n        def decorator(f):\n            self.view_functions[endpoint] = f\n            return f\n        return decorator\n\n    @setupmethod\n    def errorhandler(self, code_or_exception):\n        \"\"\"A decorator that is used to register a function give a given\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        You can also register a function as error handler without using\n        the :meth:`errorhandler` decorator.  The following example is\n        equivalent to the one above::\n\n            def page_not_found(error):\n                return 'This page does not exist', 404\n            app.error_handler_spec[None][404] = page_not_found\n\n        Setting error handlers via assignments to :attr:`error_handler_spec`\n        however is discouraged as it requires fiddling with nested dictionaries\n        and the special case for arbitrary exception types.\n\n        The first `None` refers to the active blueprint.  If the error\n        handler should be application wide `None` shall be used.\n\n        .. versionadded:: 0.7\n            Use :meth:`register_error_handler` instead of modifying\n            :attr:`error_handler_spec` directly, for application wide error\n            handlers.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code: the code as integer for the handler\n        \"\"\"\n        def decorator(f):\n            self._register_error_handler(None, code_or_exception, f)\n            return f\n        return decorator\n\n    def register_error_handler(self, code_or_exception, f):\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._register_error_handler(None, code_or_exception, f)\n\n    @setupmethod\n    def _register_error_handler(self, key, code_or_exception, f):\n        if isinstance(code_or_exception, HTTPException):\n            code_or_exception = code_or_exception.code\n        if isinstance(code_or_exception, integer_types):\n            assert code_or_exception != 500 or key is None, \\\n                'It is currently not possible to register a 500 internal ' \\\n                'server error on a per-blueprint level.'\n            self.error_handler_spec.setdefault(key, {})[code_or_exception] = f\n        else:\n            self.error_handler_spec.setdefault(key, {}).setdefault(None, []) \\\n                .append((code_or_exception, f))\n\n    @setupmethod\n    def template_filter(self, name=None):\n        \"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        \"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f\n\n    @setupmethod\n    def template_test(self, name=None):\n        \"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        \"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f\n\n    @setupmethod\n    def template_global(self, name=None):\n        \"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        \"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f\n\n    @setupmethod\n    def before_request(self, f):\n        \"\"\"Registers a function to run before each request.\"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def before_first_request(self, f):\n        \"\"\"Registers a function to be run before the first request to this\n        instance of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.before_first_request_funcs.append(f)\n        return f\n\n    @setupmethod\n    def after_request(self, f):\n        \"\"\"Register a function to be run after each request.\n\n        Your function must take one parameter, an instance of\n        :attr:`response_class` and return a new response object or the\n        same (see :meth:`process_response`).\n\n        As of Flask 0.7 this function might not be executed at the end of the\n        request in case an unhandled exception occurred.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_request(self, f):\n        \"\"\"Register a function to be run at the end of each request,\n        regardless of whether there was an exception or not.  These functions\n        are executed when the request context is popped, even if not an\n        actual request was performed.\n\n        Example::\n\n            ctx = app.test_request_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the request context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Generally teardown functions must take every necessary step to avoid\n        that they will fail.  If they do execute code that might fail they\n        will have to surround the execution of these code by try\/except\n        statements and log occurring errors.\n\n        When a teardown function was called because of a exception it will\n        be passed an error object.\n\n        .. admonition:: Debug Note\n\n           In debug mode Flask will not tear down a request on an exception\n           immediately.  Instead if will keep it alive so that the interactive\n           debugger can still access it.  This behavior can be controlled\n           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_appcontext(self, f):\n        \"\"\"Registers a function to be called when the application context\n        ends.  These functions are typically also called when the request\n        context is popped.\n\n        Example::\n\n            ctx = app.app_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the app context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Since a request context typically also manages an application\n        context it would also be called when you pop a request context.\n\n        When a teardown function was called because of an exception it will\n        be passed an error object.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n\n    @setupmethod\n    def context_processor(self, f):\n        \"\"\"Registers a template context processor function.\"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n\n    @setupmethod\n    def shell_context_processor(self, f):\n        \"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 1.0\n        \"\"\"\n        self.shell_context_processors.append(f)\n        return f\n\n    @setupmethod\n    def url_value_preprocessor(self, f):\n        \"\"\"Registers a function as URL value preprocessor for all view\n        functions of the application.  It's called before the view functions\n        are called and can modify the url values provided.\n        \"\"\"\n        self.url_value_preprocessors.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def url_defaults(self, f):\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n        \"\"\"\n        self.url_default_functions.setdefault(None, []).append(f)\n        return f\n\n    def handle_http_exception(self, e):\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        handlers = self.error_handler_spec.get(request.blueprint)\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n        if handlers and e.code in handlers:\n            handler = handlers[e.code]\n        else:\n            handler = self.error_handler_spec[None].get(e.code)\n        if handler is None:\n            return e\n        return handler(e)\n\n    def trap_http_exception(self, e):\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return `False` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to `True`.  It\n        also returns `True` if ``TRAP_HTTP_EXCEPTIONS`` is set to `True`.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns `True` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config['TRAP_HTTP_EXCEPTIONS']:\n            return True\n        if self.config['TRAP_BAD_REQUEST_ERRORS']:\n            return isinstance(e, BadRequest)\n        return False\n\n    def handle_user_exception(self, e):\n        \"\"\"This method is called whenever an exception occurs that should be\n        handled.  A special case are\n        :class:`~werkzeug.exception.HTTPException`\\s which are forwarded by\n        this function to the :meth:`handle_http_exception` method.  This\n        function will either return a response value or reraise the\n        exception with the same traceback.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        assert exc_value is e\n\n        # ensure not to trash sys.exc_info() at that point in case someone\n        # wants the traceback preserved in handle_http_exception.  Of course\n        # we cannot prevent users from trashing it themselves in a custom\n        # trap_http_exception method so that's their fault then.\n\n        blueprint_handlers = ()\n        handlers = self.error_handler_spec.get(request.blueprint)\n        if handlers is not None:\n            blueprint_handlers = handlers.get(None, ())\n        app_handlers = self.error_handler_spec[None].get(None, ())\n        for typecheck, handler in chain(blueprint_handlers, app_handlers):\n            if isinstance(e, typecheck):\n                return handler(e)\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        reraise(exc_type, exc_value, tb)\n\n    def handle_exception(self, e):\n        \"\"\"Default exception handling that kicks in when an exception\n        occurs that is not caught.  In debug mode the exception will\n        be re-raised immediately, otherwise it is logged and the handler\n        for a 500 internal server error is used.  If no such handler\n        exists, a default 500 internal server error message is displayed.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n\n        got_request_exception.send(self, exception=e)\n        handler = self.error_handler_spec[None].get(500)\n\n        if self.propagate_exceptions:\n            # if we want to repropagate the exception, we can attempt to\n            # raise it with the whole traceback in case we can do that\n            # (the function was actually called from the except part)\n            # otherwise, we just raise the error again\n            if exc_value is e:\n                reraise(exc_type, exc_value, tb)\n            else:\n                raise e\n\n        self.log_exception((exc_type, exc_value, tb))\n        if handler is None:\n            return InternalServerError()\n        return handler(e)\n\n    def log_exception(self, exc_info):\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error('Exception on %s [%s]' % (\n            request.path,\n            request.method\n        ), exc_info=exc_info)\n\n    def raise_routing_exception(self, request):\n        \"\"\"Exceptions that are recording during routing are reraised with\n        this method.  During debug we are not reraising redirect requests\n        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n        a different error instead to help debug situations.\n\n        :internal:\n        \"\"\"\n        if not self.debug \\\n           or not isinstance(request.routing_exception, RequestRedirect) \\\n           or request.method in ('GET', 'HEAD', 'OPTIONS'):\n            raise request.routing_exception\n\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n\n    def dispatch_request(self):\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if getattr(rule, 'provide_automatic_options', False) \\\n           and req.method == 'OPTIONS':\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        return self.view_functions[rule.endpoint](**req.view_args)\n\n    def full_dispatch_request(self):\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        response = self.make_response(rv)\n        response = self.process_response(response)\n        request_finished.send(self, response=response)\n        return response\n\n    def try_trigger_before_first_request_functions(self):\n        \"\"\"Called before each request and will ensure that it triggers\n        the :attr:`before_first_request_funcs` and only exactly once per\n        application instance (which means process usually).\n\n        :internal:\n        \"\"\"\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n\n    def make_default_options_response(self):\n        \"\"\"This method is called to create the default `OPTIONS` response.\n        This can be changed through subclassing to change the default\n        behavior of `OPTIONS` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        adapter = _request_ctx_stack.top.url_adapter\n        if hasattr(adapter, 'allowed_methods'):\n            methods = adapter.allowed_methods()\n        else:\n            # fallback for Werkzeug < 0.7\n            methods = []\n            try:\n                adapter.match(method='--')\n            except MethodNotAllowed as e:\n                methods = e.valid_methods\n            except HTTPException as e:\n                pass\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n\n    def should_ignore_error(self, error):\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns `True` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False\n\n    def make_response(self, rv):\n        \"\"\"Converts the return value from a view function to a real\n        response object that is an instance of :attr:`response_class`.\n\n        The following types are allowed for `rv`:\n\n        .. tabularcolumns:: |p{3.5cm}|p{9.5cm}|\n\n        ======================= ===========================================\n        :attr:`response_class`  the object is returned unchanged\n        :class:`str`            a response object is created with the\n                                string as body\n        :class:`unicode`        a response object is created with the\n                                string encoded to utf-8 as body\n        a WSGI function         the function is called as WSGI application\n                                and buffered as response object\n        :class:`tuple`          A tuple in the form ``(response, status,\n                                headers)`` or ``(response, headers)``\n                                where `response` is any of the\n                                types defined here, `status` is a string\n                                or an integer and `headers` is a list or\n                                a dictionary with header values.\n        ======================= ===========================================\n\n        :param rv: the return value from the view function\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n        status_or_headers = headers = None\n        if isinstance(rv, tuple):\n            rv, status_or_headers, headers = rv + (None,) * (3 - len(rv))\n\n        if rv is None:\n            raise ValueError('View function did not return a response')\n\n        if isinstance(status_or_headers, (dict, list)):\n            headers, status_or_headers = status_or_headers, None\n\n        if not isinstance(rv, self.response_class):\n            # When we create a response object directly, we let the constructor\n            # set the headers and status.  We do this because there can be\n            # some extra logic involved when creating these objects with\n            # specific values (like default content type selection).\n            if isinstance(rv, (text_type, bytes, bytearray)):\n                rv = self.response_class(rv, headers=headers,\n                                         status=status_or_headers)\n                headers = status_or_headers = None\n            else:\n                rv = self.response_class.force_type(rv, request.environ)\n\n        if status_or_headers is not None:\n            if isinstance(status_or_headers, string_types):\n                rv.status = status_or_headers\n            else:\n                rv.status_code = status_or_headers\n        if headers:\n            rv.headers.extend(headers)\n\n        return rv\n\n    def create_url_adapter(self, request):\n        \"\"\"Creates a URL adapter for the given request.  The URL adapter\n        is created at a point where the request context is not yet set up\n        so the request is passed explicitly.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n           This can now also be called without a request object when the\n           URL adapter is created for the application context.\n        \"\"\"\n        if request is not None:\n            return self.url_map.bind_to_environ(request.environ,\n                server_name=self.config['SERVER_NAME'])\n        # We need at the very least the server name to be set for this\n        # to work.\n        if self.config['SERVER_NAME'] is not None:\n            return self.url_map.bind(\n                self.config['SERVER_NAME'],\n                script_name=self.config['APPLICATION_ROOT'] or '\/',\n                url_scheme=self.config['PREFERRED_URL_SCHEME'])\n\n    def inject_url_defaults(self, endpoint, values):\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        funcs = self.url_default_functions.get(None, ())\n        if '.' in endpoint:\n            bp = endpoint.rsplit('.', 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n\n    def handle_url_build_error(self, error, endpoint, values):\n        \"\"\"Handle :class:`~werkzeug.routing.BuildError` on :meth:`url_for`.\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n                if rv is not None:\n                    return rv\n            except BuildError as error:\n                pass\n\n        # At this point we want to reraise the exception.  If the error is\n        # still the same one we can reraise it with the original traceback,\n        # otherwise we raise it from here.\n        if error is exc_value:\n            reraise(exc_type, exc_value, tb)\n        raise error\n\n    def preprocess_request(self):\n        \"\"\"Called before the actual request dispatching and will\n        call every as :meth:`before_request` decorated function.\n        If any of these function returns a value it's handled as\n        if it was the return value from the view and further\n        request handling is stopped.\n\n        This also triggers the :meth:`url_value_processor` functions before\n        the actual :meth:`before_request` functions are called.\n        \"\"\"\n        bp = _request_ctx_stack.top.request.blueprint\n\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n\n    def process_response(self, response):\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.save_session(ctx.session, response)\n        return response\n\n    def do_teardown_request(self, exc=None):\n        \"\"\"Called after the actual request dispatching and will\n        call every as :meth:`teardown_request` decorated function.  This is\n        not actually called by the :class:`Flask` object itself but is always\n        triggered when the request context is popped.  That way we have a\n        tighter control over certain resources under testing environments.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.  Previously this was always using the\n           current exception information.\n        \"\"\"\n        if exc is None:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n\n    def do_teardown_appcontext(self, exc=None):\n        \"\"\"Called when an application context is popped.  This works pretty\n        much the same as :meth:`do_teardown_request` but for the application\n        context.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is None:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n\n    def app_context(self):\n        \"\"\"Binds the application only.  For as long as the application is bound\n        to the current context the :data:`flask.current_app` points to that\n        application.  An application context is automatically created when a\n        request context is pushed if necessary.\n\n        Example usage::\n\n            with app.app_context():\n                ...\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ):\n        \"\"\"Creates a :class:`~flask.ctx.RequestContext` from the given\n        environment and binds it to the current context.  This must be used in\n        combination with the `with` statement because the request is only bound\n        to the current context for the duration of the `with` block.\n\n        Example usage::\n\n            with app.request_context(environ):\n                do_something_with(request)\n\n        The object returned can also be used without the `with` statement\n        which is useful for working in the shell.  The example above is\n        doing exactly the same as this code::\n\n            ctx = app.request_context(environ)\n            ctx.push()\n            try:\n                do_something_with(request)\n            finally:\n                ctx.pop()\n\n        .. versionchanged:: 0.3\n           Added support for non-with statement usage and `with` statement\n           is now passed the ctx object.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args, **kwargs):\n        \"\"\"Creates a WSGI environment from the given values (see\n        :class:`werkzeug.test.EnvironBuilder` for more information, this\n        function accepts the same arguments).\n        \"\"\"\n        from flask.testing import make_test_environ_builder\n        builder = make_test_environ_builder(self, *args, **kwargs)\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(self, environ, start_response):\n        \"\"\"The actual WSGI application.  This is not implemented in\n        `__call__` so that middlewares can be applied without losing a\n        reference to the class.  So instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n           The behavior of the before and after request callbacks was changed\n           under error conditions and a new callback was added that will\n           always execute at the end of the request, independent on if an\n           error occurred or not.  See :ref:`callbacks-and-errors`.\n\n        :param environ: a WSGI environment\n        :param start_response: a callable accepting a status code,\n                               a list of headers and an optional\n                               exception context to start the response\n        \"\"\"\n        ctx = self.request_context(environ)\n        ctx.push()\n        error = None\n        try:\n            try:\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.make_response(self.handle_exception(e))\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            ctx.auto_pop(error)\n\n    @property\n    def modules(self):\n        from warnings import warn\n        warn(DeprecationWarning('Flask.modules is deprecated, use '\n                                'Flask.blueprints instead'), stacklevel=2)\n        return self.blueprints\n\n    def __call__(self, environ, start_response):\n        \"\"\"Shortcut for :attr:`wsgi_app`.\"\"\"\n        return self.wsgi_app(environ, start_response)\n\n    def __repr__(self):\n        return '<%s %r>' % (\n            self.__class__.__name__,\n            self.name,\n        )\n\n\"\"\"\nGenerate tests which test: Always log now, even if debug is off.\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    flask.testsuite.blueprints\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Blueprints (and currently modules)\n\n    :copyright: (c) 2014 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\nimport unittest\nimport warnings\nfrom flask.testsuite import FlaskTestCase, emits_module_deprecation_warning\nfrom flask._compat import text_type\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_cache_control_header\nfrom jinja2 import TemplateNotFound\n\n\n# import moduleapp here because it uses deprecated features and we don't\n# want to see the warnings\nwarnings.simplefilter('ignore', DeprecationWarning)\nfrom moduleapp import app as moduleapp\nwarnings.simplefilter('default', DeprecationWarning)\n\n\nclass ModuleTestCase(FlaskTestCase):\n\n    @emits_module_deprecation_warning\n    def test_basic_module(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.route('\/')\n        def admin_index():\n            return 'admin index'\n        @admin.route('\/login')\n        def admin_login():\n            return 'admin login'\n        @admin.route('\/logout')\n        def admin_logout():\n            return 'admin logout'\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'the index')\n        self.assert_equal(c.get('\/admin\/').data, b'admin index')\n        self.assert_equal(c.get('\/admin\/login').data, b'admin login')\n        self.assert_equal(c.get('\/admin\/logout').data, b'admin logout')\n\n    @emits_module_deprecation_warning\n    def test_default_endpoint_name(self):\n        app = flask.Flask(__name__)\n        mod = flask.Module(__name__, 'frontend')\n        def index():\n            return 'Awesome'\n        mod.add_url_rule('\/', view_func=index)\n        app.register_module(mod)\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'Awesome')\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('frontend.index'), '\/')\n\n    @emits_module_deprecation_warning\n    def test_request_processing(self):\n        catched = []\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @admin.before_request\n        def before_admin_request():\n            catched.append('before-admin')\n        @admin.after_request\n        def after_admin_request(response):\n            catched.append('after-admin')\n            return response\n        @admin.route('\/')\n        def admin_index():\n            return 'the admin'\n        @app.before_request\n        def before_request():\n            catched.append('before-app')\n        @app.after_request\n        def after_request(response):\n            catched.append('after-app')\n            return response\n        @app.route('\/')\n        def index():\n            return 'the index'\n        app.register_module(admin)\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/').data, b'the index')\n        self.assert_equal(catched, ['before-app', 'after-app'])\n        del catched[:]\n\n        self.assert_equal(c.get('\/admin\/').data, b'the admin')\n        self.assert_equal(catched, ['before-app', 'before-admin',\n                           'after-admin', 'after-app'])\n\n    @emits_module_deprecation_warning\n    def test_context_processors(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin', url_prefix='\/admin')\n        @app.context_processor\n        def inject_all_regular():\n            return {'a': 1}\n        @admin.context_processor\n        def inject_admin():\n            return {'b': 2}\n        @admin.app_context_processor\n        def inject_all_module():\n            return {'c': 3}\n        @app.route('\/')\n        def index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        @admin.route('\/')\n        def admin_index():\n            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n        app.register_module(admin)\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'13')\n        self.assert_equal(c.get('\/admin\/').data, b'123')\n\n    @emits_module_deprecation_warning\n    def test_late_binding(self):\n        app = flask.Flask(__name__)\n        admin = flask.Module(__name__, 'admin')\n        @admin.route('\/')\n        def index():\n            return '42'\n        app.register_module(admin, url_prefix='\/admin')\n        self.assert_equal(app.test_client().get('\/admin\/').data, b'42')\n\n    @emits_module_deprecation_warning\n    def test_error_handling(self):\n        app = flask.Flask(__name__)\n        app.config['LOGGER_HANDLER_POLICY'] = 'never'\n        admin = flask.Module(__name__, 'admin')\n        @admin.app_errorhandler(404)\n        def not_found(e):\n            return 'not found', 404\n        @admin.app_errorhandler(500)\n        def internal_server_error(e):\n            return 'internal server error', 500\n        @admin.route('\/')\n        def index():\n            flask.abort(404)\n        @admin.route('\/error')\n        def error():\n            1 \/\/ 0\n        app.register_module(admin)\n        c = app.test_client()\n        rv = c.get('\/')\n        self.assert_equal(rv.status_code, 404)\n        self.assert_equal(rv.data, b'not found')\n        rv = c.get('\/error')\n        self.assert_equal(rv.status_code, 500)\n        self.assert_equal(b'internal server error', rv.data)\n\n    def test_templates_and_static(self):\n        app = moduleapp\n        app.testing = True\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), b'Admin File')\n        rv.close()\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), b'\/* nested file *\/')\n        rv.close()\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_true(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_safe_access(self):\n        app = moduleapp\n\n        with app.test_request_context():\n            f = app.view_functions['admin.static']\n\n            try:\n                f('\/etc\/passwd')\n            except NotFound:\n                pass\n            else:\n                self.assert_true(0, 'expected exception')\n            try:\n                f('..\/__init__.py')\n            except NotFound:\n                pass\n            else:\n                self.assert_true(0, 'expected exception')\n\n            # testcase for a security issue that may exist on windows systems\n            import os\n            import ntpath\n            old_path = os.path\n            os.path = ntpath\n            try:\n                try:\n                    f('..\\\\__init__.py')\n                except NotFound:\n                    pass\n                else:\n                    self.assert_true(0, 'expected exception')\n            finally:\n                os.path = old_path\n\n    @emits_module_deprecation_warning\n    def test_endpoint_decorator(self):\n        from werkzeug.routing import Submount, Rule\n        from flask import Module\n\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.url_map.add(Submount('\/foo', [\n            Rule('\/bar', endpoint='bar'),\n            Rule('\/', endpoint='index')\n        ]))\n        module = Module(__name__, __name__)\n\n        @module.endpoint('bar')\n        def bar():\n            return 'bar'\n\n        @module.endpoint('index')\n        def index():\n            return 'index'\n\n        app.register_module(module)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/foo\/').data, b'index')\n        self.assert_equal(c.get('\/foo\/bar').data, b'bar')\n\n\nclass BlueprintTestCase(FlaskTestCase):\n\n    def test_blueprint_specific_error_handling(self):\n        frontend = flask.Blueprint('frontend', __name__)\n        backend = flask.Blueprint('backend', __name__)\n        sideend = flask.Blueprint('sideend', __name__)\n\n        @frontend.errorhandler(403)\n        def frontend_forbidden(e):\n            return 'frontend says no', 403\n\n        @frontend.route('\/frontend-no')\n        def frontend_no():\n            flask.abort(403)\n\n        @backend.errorhandler(403)\n        def backend_forbidden(e):\n            return 'backend says no', 403\n\n        @backend.route('\/backend-no')\n        def backend_no():\n            flask.abort(403)\n\n        @sideend.route('\/what-is-a-sideend')\n        def sideend_no():\n            flask.abort(403)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n        app.register_blueprint(sideend)\n\n        @app.errorhandler(403)\n        def app_forbidden(e):\n            return 'application itself says no', 403\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/frontend-no').data, b'frontend says no')\n        self.assert_equal(c.get('\/backend-no').data, b'backend says no')\n        self.assert_equal(c.get('\/what-is-a-sideend').data, b'application itself says no')\n\n    def test_blueprint_specific_user_error_handling(self):\n        class MyDecoratorException(Exception):\n            pass\n        class MyFunctionException(Exception):\n            pass\n\n        blue = flask.Blueprint('blue', __name__)\n\n        @blue.errorhandler(MyDecoratorException)\n        def my_decorator_exception_handler(e):\n            self.assert_true(isinstance(e, MyDecoratorException))\n            return 'boom'\n\n        def my_function_exception_handler(e):\n            self.assert_true(isinstance(e, MyFunctionException))\n            return 'bam'\n        blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n        @blue.route('\/decorator')\n        def blue_deco_test():\n            raise MyDecoratorException()\n        @blue.route('\/function')\n        def blue_func_test():\n            raise MyFunctionException()\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(blue)\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/decorator').data, b'boom')\n        self.assert_equal(c.get('\/function').data, b'bam')\n\n    def test_blueprint_url_definitions(self):\n        bp = flask.Blueprint('test', __name__)\n\n        @bp.route('\/foo', defaults={'baz': 42})\n        def foo(bar, baz):\n            return '%s\/%d' % (bar, baz)\n\n        @bp.route('\/bar')\n        def bar(bar):\n            return text_type(bar)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/1', url_defaults={'bar': 23})\n        app.register_blueprint(bp, url_prefix='\/2', url_defaults={'bar': 19})\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/1\/foo').data, b'23\/42')\n        self.assert_equal(c.get('\/2\/foo').data, b'19\/42')\n        self.assert_equal(c.get('\/1\/bar').data, b'23')\n        self.assert_equal(c.get('\/2\/bar').data, b'19')\n\n    def test_blueprint_url_processors(self):\n        bp = flask.Blueprint('frontend', __name__, url_prefix='\/<lang_code>')\n\n        @bp.url_defaults\n        def add_language_code(endpoint, values):\n            values.setdefault('lang_code', flask.g.lang_code)\n\n        @bp.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop('lang_code')\n\n        @bp.route('\/')\n        def index():\n            return flask.url_for('.about')\n\n        @bp.route('\/about')\n        def about():\n            return flask.url_for('.index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n\n        self.assert_equal(c.get('\/de\/').data, b'\/de\/about')\n        self.assert_equal(c.get('\/de\/about').data, b'\/de\/')\n\n    def test_templates_and_static(self):\n        from blueprintapp import app\n        c = app.test_client()\n\n        rv = c.get('\/')\n        self.assert_equal(rv.data, b'Hello from the Frontend')\n        rv = c.get('\/admin\/')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/index2')\n        self.assert_equal(rv.data, b'Hello from the Admin')\n        rv = c.get('\/admin\/static\/test.txt')\n        self.assert_equal(rv.data.strip(), b'Admin File')\n        rv.close()\n        rv = c.get('\/admin\/static\/css\/test.css')\n        self.assert_equal(rv.data.strip(), b'\/* nested file *\/')\n        rv.close()\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            expected_max_age = 3600\n            if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == expected_max_age:\n                expected_max_age = 7200\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = expected_max_age\n            rv = c.get('\/admin\/static\/css\/test.css')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            self.assert_equal(cc.max_age, expected_max_age)\n            rv.close()\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n        with app.test_request_context():\n            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),\n                              '\/admin\/static\/test.txt')\n\n        with app.test_request_context():\n            try:\n                flask.render_template('missing.html')\n            except TemplateNotFound as e:\n                self.assert_equal(e.name, 'missing.html')\n            else:\n                self.assert_true(0, 'expected exception')\n\n        with flask.Flask(__name__).test_request_context():\n            self.assert_equal(flask.render_template('nested\/nested.txt'), 'I\\'m nested')\n\n    def test_default_static_cache_timeout(self):\n        app = flask.Flask(__name__)\n        class MyBlueprint(flask.Blueprint):\n            def get_send_file_max_age(self, filename):\n                return 100\n\n        blueprint = MyBlueprint('blueprint', __name__, static_folder='static')\n        app.register_blueprint(blueprint)\n\n        # try\/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n        try:\n            with app.test_request_context():\n                unexpected_max_age = 3600\n                if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == unexpected_max_age:\n                    unexpected_max_age = 7200\n                app.config['SEND_FILE_MAX_AGE_DEFAULT'] = unexpected_max_age\n                rv = blueprint.send_static_file('index.html')\n                cc = parse_cache_control_header(rv.headers['Cache-Control'])\n                self.assert_equal(cc.max_age, 100)\n                rv.close()\n        finally:\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n    def test_templates_list(self):\n        from blueprintapp import app\n        templates = sorted(app.jinja_env.list_templates())\n        self.assert_equal(templates, ['admin\/index.html',\n                                     'frontend\/index.html'])\n\n    def test_dotted_names(self):\n        frontend = flask.Blueprint('myapp.frontend', __name__)\n        backend = flask.Blueprint('myapp.backend', __name__)\n\n        @frontend.route('\/fe')\n        def frontend_index():\n            return flask.url_for('myapp.backend.backend_index')\n\n        @frontend.route('\/fe2')\n        def frontend_page2():\n            return flask.url_for('.frontend_index')\n\n        @backend.route('\/be')\n        def backend_index():\n            return flask.url_for('myapp.frontend.frontend_index')\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/fe').data.strip(), b'\/be')\n        self.assert_equal(c.get('\/fe2').data.strip(), b'\/fe')\n        self.assert_equal(c.get('\/be').data.strip(), b'\/fe')\n\n    def test_dotted_names_from_app(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        test = flask.Blueprint('test', __name__)\n\n        @app.route('\/')\n        def app_index():\n            return flask.url_for('test.index')\n\n        @test.route('\/test\/')\n        def index():\n            return flask.url_for('app_index')\n\n        app.register_blueprint(test)\n\n        with app.test_client() as c:\n            rv = c.get('\/')\n            self.assert_equal(rv.data, b'\/test\/')\n\n    def test_empty_url_defaults(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/', defaults={'page': 1})\n        @bp.route('\/page\/<int:page>')\n        def something(page):\n            return str(page)\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp)\n\n        c = app.test_client()\n        self.assert_equal(c.get('\/').data, b'1')\n        self.assert_equal(c.get('\/page\/2').data, b'2')\n\n    def test_route_decorator_custom_endpoint(self):\n\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar', endpoint='bar')\n        def foo_bar():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/123', endpoint='123')\n        def foo_bar_foo():\n            return flask.request.endpoint\n\n        @bp.route('\/bar\/foo')\n        def bar_foo():\n            return flask.request.endpoint\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        @app.route('\/')\n        def index():\n            return flask.request.endpoint\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/').data, b'index')\n        self.assertEqual(c.get('\/py\/foo').data, b'bp.foo')\n        self.assertEqual(c.get('\/py\/bar').data, b'bp.bar')\n        self.assertEqual(c.get('\/py\/bar\/123').data, b'bp.123')\n        self.assertEqual(c.get('\/py\/bar\/foo').data, b'bp.bar_foo')\n\n    def test_route_decorator_custom_endpoint_with_dots(self):\n        bp = flask.Blueprint('bp', __name__)\n\n        @bp.route('\/foo')\n        def foo():\n            return flask.request.endpoint\n\n        try:\n            @bp.route('\/bar', endpoint='bar.bar')\n            def foo_bar():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        try:\n            @bp.route('\/bar\/123', endpoint='bar.123')\n            def foo_bar_foo():\n                return flask.request.endpoint\n        except AssertionError:\n            pass\n        else:\n            raise AssertionError('expected AssertionError not raised')\n\n        def foo_foo_foo():\n            pass\n\n        self.assertRaises(\n            AssertionError,\n            lambda: bp.add_url_rule(\n                '\/bar\/123', endpoint='bar.123', view_func=foo_foo_foo\n            )\n        )\n\n        self.assertRaises(\n            AssertionError,\n            bp.route('\/bar\/123', endpoint='bar.123'),\n            lambda: None\n        )\n\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n\n        c = app.test_client()\n        self.assertEqual(c.get('\/py\/foo').data, b'bp.foo')\n        # The rule's didn't actually made it through\n        rv = c.get('\/py\/bar')\n        assert rv.status_code == 404\n        rv = c.get('\/py\/bar\/123')\n        assert rv.status_code == 404\n\n    def test_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_add_template_filter(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('my_reverse', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')\n\n    def test_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('strrev')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_add_template_filter_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'strrev')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('strrev', app.jinja_env.filters.keys())\n        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)\n        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')\n\n    def test_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_filter_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def super_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(super_reverse)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_filter('super_reverse')\n        def my_reverse(s):\n            return s[::-1]\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_add_template_filter_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def my_reverse(s):\n            return s[::-1]\n        bp.add_app_template_filter(my_reverse, 'super_reverse')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_filter.html', value='abcd')\n        rv = app.test_client().get('\/')\n        self.assert_equal(rv.data, b'dcba')\n\n    def test_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('is_boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['is_boolean'](False))\n\n    def test_add_template_test(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('is_boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['is_boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['is_boolean'](False))\n\n    def test_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_add_template_test_with_name(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        self.assert_in('boolean', app.jinja_env.tests.keys())\n        self.assert_equal(app.jinja_env.tests['boolean'], is_boolean)\n        self.assert_true(app.jinja_env.tests['boolean'](False))\n\n    def test_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_template_test_after_route_with_template(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n        app.register_blueprint(bp, url_prefix='\/py')\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(boolean)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        @bp.app_template_test('boolean')\n        def is_boolean(value):\n            return isinstance(value, bool)\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\n    def test_add_template_test_with_name_and_template(self):\n        bp = flask.Blueprint('bp', __name__)\n        def is_boolean(value):\n            return isinstance(value, bool)\n        bp.add_app_template_test(is_boolean, 'boolean')\n        app = flask.Flask(__name__)\n        app.register_blueprint(bp, url_prefix='\/py')\n        @app.route('\/')\n        def index():\n            return flask.render_template('template_test.html', value=False)\n        rv = app.test_client().get('\/')\n        self.assert_in(b'Success!', rv.data)\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(BlueprintTestCase))\n    suite.addTest(unittest.makeSuite(ModuleTestCase))\n    return suite\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr Tests\n    ~~~~~~~~~~~~\n\n    Tests the Flaskr application.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport os\nimport flaskr\nimport tempfile\n\n\n@pytest.fixture\ndef client(request):\n    db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()\n    flaskr.app.config['TESTING'] = True\n    client = flaskr.app.test_client()\n    with flaskr.app.app_context():\n        flaskr.init_db()\n\n    def teardown():\n        os.close(db_fd)\n        os.unlink(flaskr.app.config['DATABASE'])\n    request.addfinalizer(teardown)\n\n    return client\n\n\ndef login(client, username, password):\n    return client.post('\/login', data=dict(\n        username=username,\n        password=password\n    ), follow_redirects=True)\n\n\ndef logout(client):\n    return client.get('\/logout', follow_redirects=True)\n\n\ndef test_empty_db(client):\n    \"\"\"Start with a blank database.\"\"\"\n    rv = client.get('\/')\n    assert b'No entries here so far' in rv.data\n\n\ndef test_login_logout(client):\n    \"\"\"Make sure login and logout works\"\"\"\n    rv = login(client, flaskr.app.config['USERNAME'],\n               flaskr.app.config['PASSWORD'])\n    assert b'You were logged in' in rv.data\n    rv = logout(client)\n    assert b'You were logged out' in rv.data\n    rv = login(client, flaskr.app.config['USERNAME'] + 'x',\n               flaskr.app.config['PASSWORD'])\n    assert b'Invalid username' in rv.data\n    rv = login(client, flaskr.app.config['USERNAME'],\n               flaskr.app.config['PASSWORD'] + 'x')\n    assert b'Invalid password' in rv.data\n\n\ndef test_messages(client):\n    \"\"\"Test that messages work\"\"\"\n    login(client, flaskr.app.config['USERNAME'],\n          flaskr.app.config['PASSWORD'])\n    rv = client.post('\/add', data=dict(\n        title='<Hello>',\n        text='<strong>HTML<\/strong> allowed here'\n    ), follow_redirects=True)\n    assert b'No entries here so far' not in rv.data\n    assert b'&lt;Hello&gt;' in rv.data\n    assert b'<strong>HTML<\/strong> allowed here' in rv.data\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit\n    ~~~~~~~~\n\n    A microblogging application written with Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport time\nfrom sqlite3 import dbapi2 as sqlite3\nfrom hashlib import md5\nfrom datetime import datetime\nfrom flask import Flask, request, session, url_for, redirect, \\\n     render_template, abort, g, flash, _app_ctx_stack\nfrom werkzeug import check_password_hash, generate_password_hash\n\n\n# configuration\nDATABASE = '\/tmp\/minitwit.db'\nPER_PAGE = 30\nDEBUG = True\nSECRET_KEY = 'development key'\n\n# create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar('MINITWIT_SETTINGS', silent=True)\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        top.sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        top.sqlite_db.row_factory = sqlite3.Row\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_database(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef query_db(query, args=(), one=False):\n    \"\"\"Queries the database and returns a list of dictionaries.\"\"\"\n    cur = get_db().execute(query, args)\n    rv = cur.fetchall()\n    return (rv[0] if rv else None) if one else rv\n\n\ndef get_user_id(username):\n    \"\"\"Convenience method to look up the id for a username.\"\"\"\n    rv = query_db('select user_id from user where username = ?',\n                  [username], one=True)\n    return rv[0] if rv else None\n\n\ndef format_datetime(timestamp):\n    \"\"\"Format a timestamp for display.\"\"\"\n    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')\n\n\ndef gravatar_url(email, size=80):\n    \"\"\"Return the gravatar image for the given email address.\"\"\"\n    return 'http:\/\/www.gravatar.com\/avatar\/%s?d=identicon&s=%d' % \\\n        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)\n\n\n@app.before_request\ndef before_request():\n    g.user = None\n    if 'user_id' in session:\n        g.user = query_db('select * from user where user_id = ?',\n                          [session['user_id']], one=True)\n\n\n@app.route('\/')\ndef timeline():\n    \"\"\"Shows a users timeline or if no user is logged in it will\n    redirect to the public timeline.  This timeline shows the user's\n    messages as well as all the messages of followed users.\n    \"\"\"\n    if not g.user:\n        return redirect(url_for('public_timeline'))\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id and (\n            user.user_id = ? or\n            user.user_id in (select whom_id from follower\n                                    where who_id = ?))\n        order by message.pub_date desc limit ?''',\n        [session['user_id'], session['user_id'], PER_PAGE]))\n\n\n@app.route('\/public')\ndef public_timeline():\n    \"\"\"Displays the latest messages of all users.\"\"\"\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id\n        order by message.pub_date desc limit ?''', [PER_PAGE]))\n\n\n@app.route('\/<username>')\ndef user_timeline(username):\n    \"\"\"Display's a users tweets.\"\"\"\n    profile_user = query_db('select * from user where username = ?',\n                            [username], one=True)\n    if profile_user is None:\n        abort(404)\n    followed = False\n    if g.user:\n        followed = query_db('''select 1 from follower where\n            follower.who_id = ? and follower.whom_id = ?''',\n            [session['user_id'], profile_user['user_id']],\n            one=True) is not None\n    return render_template('timeline.html', messages=query_db('''\n            select message.*, user.* from message, user where\n            user.user_id = message.author_id and user.user_id = ?\n            order by message.pub_date desc limit ?''',\n            [profile_user['user_id'], PER_PAGE]), followed=followed,\n            profile_user=profile_user)\n\n\n@app.route('\/<username>\/follow')\ndef follow_user(username):\n    \"\"\"Adds the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    db = get_db()\n    db.execute('insert into follower (who_id, whom_id) values (?, ?)',\n              [session['user_id'], whom_id])\n    db.commit()\n    flash('You are now following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/<username>\/unfollow')\ndef unfollow_user(username):\n    \"\"\"Removes the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    db = get_db()\n    db.execute('delete from follower where who_id=? and whom_id=?',\n              [session['user_id'], whom_id])\n    db.commit()\n    flash('You are no longer following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/add_message', methods=['POST'])\ndef add_message():\n    \"\"\"Registers a new message for the user.\"\"\"\n    if 'user_id' not in session:\n        abort(401)\n    if request.form['text']:\n        db = get_db()\n        db.execute('''insert into message (author_id, text, pub_date)\n          values (?, ?, ?)''', (session['user_id'], request.form['text'],\n                                int(time.time())))\n        db.commit()\n        flash('Your message was recorded')\n    return redirect(url_for('timeline'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    \"\"\"Logs the user in.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        user = query_db('''select * from user where\n            username = ?''', [request.form['username']], one=True)\n        if user is None:\n            error = 'Invalid username'\n        elif not check_password_hash(user['pw_hash'],\n                                     request.form['password']):\n            error = 'Invalid password'\n        else:\n            flash('You were logged in')\n            session['user_id'] = user['user_id']\n            return redirect(url_for('timeline'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/register', methods=['GET', 'POST'])\ndef register():\n    \"\"\"Registers the user.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        if not request.form['username']:\n            error = 'You have to enter a username'\n        elif not request.form['email'] or \\\n                '@' not in request.form['email']:\n            error = 'You have to enter a valid email address'\n        elif not request.form['password']:\n            error = 'You have to enter a password'\n        elif request.form['password'] != request.form['password2']:\n            error = 'The two passwords do not match'\n        elif get_user_id(request.form['username']) is not None:\n            error = 'The username is already taken'\n        else:\n            db = get_db()\n            db.execute('''insert into user (\n              username, email, pw_hash) values (?, ?, ?)''',\n              [request.form['username'], request.form['email'],\n               generate_password_hash(request.form['password'])])\n            db.commit()\n            flash('You were successfully registered and can login now')\n            return redirect(url_for('login'))\n    return render_template('register.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    \"\"\"Logs the user out.\"\"\"\n    flash('You were logged out')\n    session.pop('user_id', None)\n    return redirect(url_for('public_timeline'))\n\n\n# add some filters to jinja\napp.jinja_env.filters['datetimeformat'] = format_datetime\napp.jinja_env.filters['gravatar'] = gravatar_url\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit Tests\n    ~~~~~~~~~~~~~~\n\n    Tests the MiniTwit application.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport os\nimport minitwit\nimport tempfile\nimport pytest\n\n\n@pytest.fixture\ndef client(request):\n    db_fd, minitwit.app.config['DATABASE'] = tempfile.mkstemp()\n    client = minitwit.app.test_client()\n    with minitwit.app.app_context():\n        minitwit.init_db()\n\n    def teardown():\n        \"\"\"Get rid of the database again after each test.\"\"\"\n        os.close(db_fd)\n        os.unlink(minitwit.app.config['DATABASE'])\n    request.addfinalizer(teardown)\n    return client\n\n\ndef register(client, username, password, password2=None, email=None):\n    \"\"\"Helper function to register a user\"\"\"\n    if password2 is None:\n        password2 = password\n    if email is None:\n        email = username + '@example.com'\n    return client.post('\/register', data={\n        'username':     username,\n        'password':     password,\n        'password2':    password2,\n        'email':        email,\n    }, follow_redirects=True)\n\n\ndef login(client, username, password):\n    \"\"\"Helper function to login\"\"\"\n    return client.post('\/login', data={\n        'username': username,\n        'password': password\n    }, follow_redirects=True)\n\n\ndef register_and_login(client, username, password):\n    \"\"\"Registers and logs in in one go\"\"\"\n    register(client, username, password)\n    return login(client, username, password)\n\n\ndef logout(client):\n    \"\"\"Helper function to logout\"\"\"\n    return client.get('\/logout', follow_redirects=True)\n\n\ndef add_message(client, text):\n    \"\"\"Records a message\"\"\"\n    rv = client.post('\/add_message', data={'text': text},\n                     follow_redirects=True)\n    if text:\n        assert b'Your message was recorded' in rv.data\n    return rv\n\n\ndef test_register(client):\n    \"\"\"Make sure registering works\"\"\"\n    rv = register(client, 'user1', 'default')\n    assert b'You were successfully registered ' \\\n           b'and can login now' in rv.data\n    rv = register(client, 'user1', 'default')\n    assert b'The username is already taken' in rv.data\n    rv = register(client, '', 'default')\n    assert b'You have to enter a username' in rv.data\n    rv = register(client, 'meh', '')\n    assert b'You have to enter a password' in rv.data\n    rv = register(client, 'meh', 'x', 'y')\n    assert b'The two passwords do not match' in rv.data\n    rv = register(client, 'meh', 'foo', email='broken')\n    assert b'You have to enter a valid email address' in rv.data\n\n\ndef test_login_logout(client):\n    \"\"\"Make sure logging in and logging out works\"\"\"\n    rv = register_and_login(client, 'user1', 'default')\n    assert b'You were logged in' in rv.data\n    rv = logout(client)\n    assert b'You were logged out' in rv.data\n    rv = login(client, 'user1', 'wrongpassword')\n    assert b'Invalid password' in rv.data\n    rv = login(client, 'user2', 'wrongpassword')\n    assert b'Invalid username' in rv.data\n\n\ndef test_message_recording(client):\n    \"\"\"Check if adding messages works\"\"\"\n    register_and_login(client, 'foo', 'default')\n    add_message(client, 'test message 1')\n    add_message(client, '<test message 2>')\n    rv = client.get('\/')\n    assert b'test message 1' in rv.data\n    assert b'&lt;test message 2&gt;' in rv.data\n\n\ndef test_timelines(client):\n    \"\"\"Make sure that timelines work\"\"\"\n    register_and_login(client, 'foo', 'default')\n    add_message(client, 'the message by foo')\n    logout(client)\n    register_and_login(client, 'bar', 'default')\n    add_message(client, 'the message by bar')\n    rv = client.get('\/public')\n    assert b'the message by foo' in rv.data\n    assert b'the message by bar' in rv.data\n\n    # bar's timeline should just show bar's message\n    rv = client.get('\/')\n    assert b'the message by foo' not in rv.data\n    assert b'the message by bar' in rv.data\n\n    # now let's follow foo\n    rv = client.get('\/foo\/follow', follow_redirects=True)\n    assert b'You are now following &#34;foo&#34;' in rv.data\n\n    # we should now see foo's message\n    rv = client.get('\/')\n    assert b'the message by foo' in rv.data\n    assert b'the message by bar' in rv.data\n\n    # but on the user's page we only want the user's message\n    rv = client.get('\/bar')\n    assert b'the message by foo' not in rv.data\n    assert b'the message by bar' in rv.data\n    rv = client.get('\/foo')\n    assert b'the message by foo' in rv.data\n    assert b'the message by bar' not in rv.data\n\n    # now unfollow and check if that worked\n    rv = client.get('\/foo\/unfollow', follow_redirects=True)\n    assert b'You are no longer following &#34;foo&#34;' in rv.data\n    rv = client.get('\/')\n    assert b'the message by foo' not in rv.data\n    assert b'the message by bar' in rv.data\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.conftest\n    ~~~~~~~~~~~~~~\n\n    :copyright: (c) 2015 by the Flask Team, see AUTHORS for more details.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport flask\nimport os\nimport sys\nimport pkgutil\nimport pytest\nimport textwrap\n\n\n@pytest.fixture\ndef test_apps(monkeypatch):\n    monkeypatch.syspath_prepend(\n        os.path.abspath(os.path.join(\n            os.path.dirname(__file__), 'test_apps'))\n    )\n\n@pytest.fixture(autouse=True)\ndef leak_detector(request):\n    def ensure_clean_request_context():\n        # make sure we're not leaking a request context since we are\n        # testing flask internally in debug mode in a few cases\n        leaks = []\n        while flask._request_ctx_stack.top is not None:\n            leaks.append(flask._request_ctx_stack.pop())\n        assert leaks == []\n    request.addfinalizer(ensure_clean_request_context)\n\n\n@pytest.fixture(params=(True, False))\ndef limit_loader(request, monkeypatch):\n    \"\"\"Patch pkgutil.get_loader to give loader without get_filename or archive.\n\n    This provides for tests where a system has custom loaders, e.g. Google App\n    Engine's HardenedModulesHook, which have neither the `get_filename` method\n    nor the `archive` attribute.\n\n    This fixture will run the testcase twice, once with and once without the\n    limitation\/mock.\n    \"\"\"\n    if not request.param:\n        return\n\n    class LimitedLoader(object):\n        def __init__(self, loader):\n            self.loader = loader\n\n        def __getattr__(self, name):\n            if name in ('archive', 'get_filename'):\n                msg = 'Mocking a loader which does not have `%s.`' % name\n                raise AttributeError(msg)\n            return getattr(self.loader, name)\n\n    old_get_loader = pkgutil.get_loader\n\n    def get_loader(*args, **kwargs):\n        return LimitedLoader(old_get_loader(*args, **kwargs))\n    monkeypatch.setattr(pkgutil, 'get_loader', get_loader)\n\n\n@pytest.fixture\ndef modules_tmpdir(tmpdir, monkeypatch):\n    '''A tmpdir added to sys.path'''\n    rv = tmpdir.mkdir('modules_tmpdir')\n    monkeypatch.syspath_prepend(str(rv))\n    return rv\n\n\n@pytest.fixture\ndef modules_tmpdir_prefix(modules_tmpdir, monkeypatch):\n    monkeypatch.setattr(sys, 'prefix', str(modules_tmpdir))\n    return modules_tmpdir\n\n\n@pytest.fixture\ndef site_packages(modules_tmpdir, monkeypatch):\n    '''Create a fake site-packages'''\n    rv = modules_tmpdir \\\n        .mkdir('lib')\\\n        .mkdir('python{x[0]}.{x[1]}'.format(x=sys.version_info))\\\n        .mkdir('site-packages')\n    monkeypatch.syspath_prepend(str(rv))\n    return rv\n\n\n@pytest.fixture\ndef install_egg(modules_tmpdir, monkeypatch):\n    '''Generate egg from package name inside base and put the egg into\n    sys.path'''\n    def inner(name, base=modules_tmpdir):\n        if not isinstance(name, str):\n            raise ValueError(name)\n        base.join(name).ensure_dir()\n        base.join(name).join('__init__.py').ensure()\n\n        egg_setup = base.join('setup.py')\n        egg_setup.write(textwrap.dedent(\"\"\"\n        from setuptools import setup\n        setup(name='{0}',\n              version='1.0',\n              packages=['site_egg'],\n              zip_safe=True)\n        \"\"\".format(name)))\n\n        import subprocess\n        subprocess.check_call(\n            [sys.executable, 'setup.py', 'bdist_egg'],\n            cwd=str(modules_tmpdir)\n        )\n        egg_path, = modules_tmpdir.join('dist\/').listdir()\n        monkeypatch.syspath_prepend(str(egg_path))\n        return egg_path\n    return inner\n\n\n@pytest.fixture\ndef purge_module(request):\n    def inner(name):\n        request.addfinalizer(lambda: sys.modules.pop(name, None))\n    return inner\n\n\n@pytest.fixture\ndef catch_deprecation_warnings():\n    import warnings\n    warnings.simplefilter('default', category=DeprecationWarning)\n    return lambda: warnings.catch_warnings(record=True)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.appctx\n    ~~~~~~~~~~~~\n\n    Tests the application context.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\n\n\ndef test_basic_url_generation():\n    app = flask.Flask(__name__)\n    app.config['SERVER_NAME'] = 'localhost'\n    app.config['PREFERRED_URL_SCHEME'] = 'https'\n\n    @app.route('\/')\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for('index')\n        assert rv == 'https:\/\/localhost\/'\n\ndef test_url_generation_requires_server_name():\n    app = flask.Flask(__name__)\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for('index')\n\ndef test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        flask.url_for('index')\n\ndef test_request_context_means_app_context():\n    app = flask.Flask(__name__)\n    with app.test_request_context():\n        assert flask.current_app._get_current_object() == app\n    assert flask._app_ctx_stack.top is None\n\ndef test_app_context_provides_current_app():\n    app = flask.Flask(__name__)\n    with app.app_context():\n        assert flask.current_app._get_current_object() == app\n    assert flask._app_ctx_stack.top is None\n\ndef test_app_tearing_down():\n    cleanup_stuff = []\n    app = flask.Flask(__name__)\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\ndef test_app_tearing_down_with_previous_exception():\n    cleanup_stuff = []\n    app = flask.Flask(__name__)\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception('dummy')\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\ndef test_custom_app_ctx_globals_class():\n    class CustomRequestGlobals(object):\n        def __init__(self):\n            self.spam = 'eggs'\n    app = flask.Flask(__name__)\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string('{{ g.spam }}') == 'eggs'\n\ndef test_context_refcounts():\n    called = []\n    app = flask.Flask(__name__)\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append('request')\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append('app')\n    @app.route('\/')\n    def index():\n        with flask._app_ctx_stack.top:\n            with flask._request_ctx_stack.top:\n                pass\n        env = flask._request_ctx_stack.top.request.environ\n        assert env['werkzeug.request'] is not None\n        return u''\n    c = app.test_client()\n    res = c.get('\/')\n    assert res.status_code == 200\n    assert res.data == b''\n    assert called == ['request', 'app']\n"}
{"prompt":"Python3\n#!\/usr\/bin\/env python\n# -*- coding: utf-8 -*-\n\"\"\"\n    make-release\n    ~~~~~~~~~~~~\n\n    Helper script that performs a release.  Does pretty much everything\n    automatically for us.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport sys\nimport os\nimport re\nfrom datetime import datetime, date\nfrom subprocess import Popen, PIPE\n\n_date_clean_re = re.compile(r'(\\d+)(st|nd|rd|th)')\n\n\ndef parse_changelog():\n    with open('CHANGES') as f:\n        lineiter = iter(f)\n        for line in lineiter:\n            match = re.search('^Version\\s+(.*)', line.strip())\n            if match is None:\n                continue\n            version = match.group(1).strip()\n            if lineiter.next().count('-') != len(match.group(0)):\n                continue\n            while 1:\n                change_info = lineiter.next().strip()\n                if change_info:\n                    break\n\n            match = re.search(r'released on (\\w+\\s+\\d+\\w+\\s+\\d+)'\n                              r'(?:, codename (.*))?(?i)', change_info)\n            if match is None:\n                continue\n\n            datestr, codename = match.groups()\n            return version, parse_date(datestr), codename\n\n\ndef bump_version(version):\n    try:\n        parts = map(int, version.split('.'))\n    except ValueError:\n        fail('Current version is not numeric')\n    parts[-1] += 1\n    return '.'.join(map(str, parts))\n\n\ndef parse_date(string):\n    string = _date_clean_re.sub(r'\\1', string)\n    return datetime.strptime(string, '%B %d %Y')\n\n\ndef set_filename_version(filename, version_number, pattern):\n    changed = []\n\n    def inject_version(match):\n        before, old, after = match.groups()\n        changed.append(True)\n        return before + version_number + after\n    with open(filename) as f:\n        contents = re.sub(r\"^(\\s*%s\\s*=\\s*')(.+?)(')(?sm)\" % pattern,\n                          inject_version, f.read())\n\n    if not changed:\n        fail('Could not find %s in %s', pattern, filename)\n\n    with open(filename, 'w') as f:\n        f.write(contents)\n\n\ndef set_init_version(version):\n    info('Setting __init__.py version to %s', version)\n    set_filename_version('flask\/__init__.py', version, '__version__')\n\n\ndef set_setup_version(version):\n    info('Setting setup.py version to %s', version)\n    set_filename_version('setup.py', version, 'version')\n\n\ndef build_and_upload():\n    Popen([sys.executable, 'setup.py', 'release', 'sdist', 'upload']).wait()\n\n\ndef fail(message, *args):\n    print >> sys.stderr, 'Error:', message % args\n    sys.exit(1)\n\n\ndef info(message, *args):\n    print >> sys.stderr, message % args\n\n\ndef get_git_tags():\n    return set(Popen(['git', 'tag'], stdout=PIPE).communicate()[0].splitlines())\n\n\ndef git_is_clean():\n    return Popen(['git', 'diff', '--quiet']).wait() == 0\n\n\ndef make_git_commit(message, *args):\n    message = message % args\n    Popen(['git', 'commit', '-am', message]).wait()\n\n\ndef make_git_tag(tag):\n    info('Tagging \"%s\"', tag)\n    Popen(['git', 'tag', tag]).wait()\n\n\ndef main():\n    os.chdir(os.path.join(os.path.dirname(__file__), '..'))\n\n    rv = parse_changelog()\n    if rv is None:\n        fail('Could not parse changelog')\n\n    version, release_date, codename = rv\n    dev_version = bump_version(version) + '-dev'\n\n    info('Releasing %s (codename %s, release date %s)',\n         version, codename, release_date.strftime('%d\/%m\/%Y'))\n    tags = get_git_tags()\n\n    if version in tags:\n        fail('Version \"%s\" is already tagged', version)\n    if release_date.date() != date.today():\n        fail('Release date is not today (%s != %s)',\n             release_date.date(), date.today())\n\n    if not git_is_clean():\n        fail('You have uncommitted changes in git')\n\n    set_init_version(version)\n    set_setup_version(version)\n    make_git_commit('Bump version number to %s', version)\n    make_git_tag(version)\n    build_and_upload()\n    set_init_version(dev_version)\n    set_setup_version(dev_version)\n\n\nif __name__ == '__main__':\n    main()\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.basic\n    ~~~~~~~~~~~~~~~~~~~~~\n\n    The basic functionality.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport re\nimport uuid\nimport time\nimport flask\nimport pickle\nfrom datetime import datetime\nfrom threading import Thread\nfrom flask._compat import text_type\nfrom werkzeug.exceptions import BadRequest, NotFound, Forbidden\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\nimport werkzeug.serving\n\n\ndef test_options_work():\n    app = flask.Flask(__name__)\n\n    @app.route('\/', methods=['GET', 'POST'])\n    def index():\n        return 'Hello World'\n    rv = app.test_client().open('\/', method='OPTIONS')\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']\n    assert rv.data == b''\n\n\ndef test_options_on_multiple_rules():\n    app = flask.Flask(__name__)\n\n    @app.route('\/', methods=['GET', 'POST'])\n    def index():\n        return 'Hello World'\n\n    @app.route('\/', methods=['PUT'])\n    def index_put():\n        return 'Aha!'\n    rv = app.test_client().open('\/', method='OPTIONS')\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n\ndef test_options_handling_disabled():\n    app = flask.Flask(__name__)\n\n    def index():\n        return 'Hello World!'\n    index.provide_automatic_options = False\n    app.route('\/')(index)\n    rv = app.test_client().open('\/', method='OPTIONS')\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return 'Hello World!'\n    index2.provide_automatic_options = True\n    app.route('\/', methods=['OPTIONS'])(index2)\n    rv = app.test_client().open('\/', method='OPTIONS')\n    assert sorted(rv.allow) == ['OPTIONS']\n\n\ndef test_request_dispatching():\n    app = flask.Flask(__name__)\n\n    @app.route('\/')\n    def index():\n        return flask.request.method\n\n    @app.route('\/more', methods=['GET', 'POST'])\n    def more():\n        return flask.request.method\n\n    c = app.test_client()\n    assert c.get('\/').data == b'GET'\n    rv = c.post('\/')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']\n    rv = c.head('\/')\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert c.post('\/more').data == b'POST'\n    assert c.get('\/more').data == b'GET'\n    rv = c.delete('\/more')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']\n\n\ndef test_disallow_string_for_allowed_methods():\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        @app.route('\/', methods='GET POST')\n        def index():\n            return \"Hey\"\n\n\ndef test_url_mapping():\n    app = flask.Flask(__name__)\n\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n\n    app.add_url_rule('\/', 'index', index)\n    app.add_url_rule('\/more', 'more', more, methods=['GET', 'POST'])\n\n    # Issue 1288: Test that automatic options are not added when non-uppercase 'options' in methods\n    app.add_url_rule('\/options', 'options', options, methods=['options'])\n\n    c = app.test_client()\n    assert c.get('\/').data == b'GET'\n    rv = c.post('\/')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']\n    rv = c.head('\/')\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert c.post('\/more').data == b'POST'\n    assert c.get('\/more').data == b'GET'\n    rv = c.delete('\/more')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']\n    rv = c.open('\/options', method='OPTIONS')\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")\n\n\ndef test_werkzeug_routing():\n    from werkzeug.routing import Submount, Rule\n    app = flask.Flask(__name__)\n    app.url_map.add(Submount('\/foo', [\n        Rule('\/bar', endpoint='bar'),\n        Rule('\/', endpoint='index')\n    ]))\n\n    def bar():\n        return 'bar'\n\n    def index():\n        return 'index'\n    app.view_functions['bar'] = bar\n    app.view_functions['index'] = index\n\n    c = app.test_client()\n    assert c.get('\/foo\/').data == b'index'\n    assert c.get('\/foo\/bar').data == b'bar'\n\n\ndef test_endpoint_decorator():\n    from werkzeug.routing import Submount, Rule\n    app = flask.Flask(__name__)\n    app.url_map.add(Submount('\/foo', [\n        Rule('\/bar', endpoint='bar'),\n        Rule('\/', endpoint='index')\n    ]))\n\n    @app.endpoint('bar')\n    def bar():\n        return 'bar'\n\n    @app.endpoint('index')\n    def index():\n        return 'index'\n\n    c = app.test_client()\n    assert c.get('\/foo\/').data == b'index'\n    assert c.get('\/foo\/bar').data == b'bar'\n\n\ndef test_session():\n    app = flask.Flask(__name__)\n    app.secret_key = 'testkey'\n\n    @app.route('\/set', methods=['POST'])\n    def set():\n        flask.session['value'] = flask.request.form['value']\n        return 'value set'\n\n    @app.route('\/get')\n    def get():\n        return flask.session['value']\n\n    c = app.test_client()\n    assert c.post('\/set', data={'value': '42'}).data == b'value set'\n    assert c.get('\/get').data == b'42'\n\n\ndef test_session_using_server_name():\n    app = flask.Flask(__name__)\n    app.config.update(\n        SECRET_KEY='foo',\n        SERVER_NAME='example.com'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n    rv = app.test_client().get('\/', 'http:\/\/example.com\/')\n    assert 'domain=.example.com' in rv.headers['set-cookie'].lower()\n    assert 'httponly' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_server_name_and_port():\n    app = flask.Flask(__name__)\n    app.config.update(\n        SECRET_KEY='foo',\n        SERVER_NAME='example.com:8080'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n    rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/')\n    assert 'domain=.example.com' in rv.headers['set-cookie'].lower()\n    assert 'httponly' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_server_name_port_and_path():\n    app = flask.Flask(__name__)\n    app.config.update(\n        SECRET_KEY='foo',\n        SERVER_NAME='example.com:8080',\n        APPLICATION_ROOT='\/foo'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n    rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/foo')\n    assert 'domain=example.com' in rv.headers['set-cookie'].lower()\n    assert 'path=\/foo' in rv.headers['set-cookie'].lower()\n    assert 'httponly' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_application_root():\n    class PrefixPathMiddleware(object):\n\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ['SCRIPT_NAME'] = self.prefix\n            return self.app(environ, start_response)\n\n    app = flask.Flask(__name__)\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, '\/bar')\n    app.config.update(\n        SECRET_KEY='foo',\n        APPLICATION_ROOT='\/bar'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n    rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/')\n    assert 'path=\/bar' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_session_settings():\n    app = flask.Flask(__name__)\n    app.config.update(\n        SECRET_KEY='foo',\n        SERVER_NAME='www.example.com:8080',\n        APPLICATION_ROOT='\/test',\n        SESSION_COOKIE_DOMAIN='.example.com',\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_PATH='\/'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n    rv = app.test_client().get('\/', 'http:\/\/www.example.com:8080\/test\/')\n    cookie = rv.headers['set-cookie'].lower()\n    assert 'domain=.example.com' in cookie\n    assert 'path=\/' in cookie\n    assert 'secure' in cookie\n    assert 'httponly' not in cookie\n\n\ndef test_missing_session():\n    app = flask.Flask(__name__)\n\n    def expect_exception(f, *args, **kwargs):\n        try:\n            f(*args, **kwargs)\n        except RuntimeError as e:\n            assert e.args and 'session is unavailable' in e.args[0]\n        else:\n            assert False, 'expected exception'\n    with app.test_request_context():\n        assert flask.session.get('missing_key') is None\n        expect_exception(flask.session.__setitem__, 'foo', 42)\n        expect_exception(flask.session.pop, 'foo')\n\n\ndef test_session_expiration():\n    permanent = True\n    app = flask.Flask(__name__)\n    app.secret_key = 'testkey'\n\n    @app.route('\/')\n    def index():\n        flask.session['test'] = 42\n        flask.session.permanent = permanent\n        return ''\n\n    @app.route('\/test')\n    def test():\n        return text_type(flask.session.permanent)\n\n    client = app.test_client()\n    rv = client.get('\/')\n    assert 'set-cookie' in rv.headers\n    match = re.search(r'\\bexpires=([^;]+)(?i)', rv.headers['set-cookie'])\n    expires = parse_date(match.group())\n    expected = datetime.utcnow() + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get('\/test')\n    assert rv.data == b'True'\n\n    permanent = False\n    rv = app.test_client().get('\/')\n    assert 'set-cookie' in rv.headers\n    match = re.search(r'\\bexpires=([^;]+)', rv.headers['set-cookie'])\n    assert match is None\n\n\ndef test_session_stored_last():\n    app = flask.Flask(__name__)\n    app.secret_key = 'development-key'\n    app.testing = True\n\n    @app.after_request\n    def modify_session(response):\n        flask.session['foo'] = 42\n        return response\n\n    @app.route('\/')\n    def dump_session_contents():\n        return repr(flask.session.get('foo'))\n\n    c = app.test_client()\n    assert c.get('\/').data == b'None'\n    assert c.get('\/').data == b'42'\n\n\ndef test_session_special_types():\n    app = flask.Flask(__name__)\n    app.secret_key = 'development-key'\n    app.testing = True\n    now = datetime.utcnow().replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.after_request\n    def modify_session(response):\n        flask.session['m'] = flask.Markup('Hello!')\n        flask.session['u'] = the_uuid\n        flask.session['dt'] = now\n        flask.session['b'] = b'\\xff'\n        flask.session['t'] = (1, 2, 3)\n        return response\n\n    @app.route('\/')\n    def dump_session_contents():\n        return pickle.dumps(dict(flask.session))\n\n    c = app.test_client()\n    c.get('\/')\n    rv = pickle.loads(c.get('\/').data)\n    assert rv['m'] == flask.Markup('Hello!')\n    assert type(rv['m']) == flask.Markup\n    assert rv['dt'] == now\n    assert rv['u'] == the_uuid\n    assert rv['b'] == b'\\xff'\n    assert type(rv['b']) == bytes\n    assert rv['t'] == (1, 2, 3)\n\n\ndef test_session_cookie_setting():\n    app = flask.Flask(__name__)\n    app.testing = True\n    app.secret_key = 'dev key'\n    is_permanent = True\n\n    @app.route('\/bump')\n    def bump():\n        rv = flask.session['foo'] = flask.session.get('foo', 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route('\/read')\n    def read():\n        return str(flask.session.get('foo', 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get('\/bump').data == b'1'\n            assert c.get('\/bump').data == b'2'\n            assert c.get('\/bump').data == b'3'\n\n            rv = c.get('\/read')\n            set_cookie = rv.headers.get('set-cookie')\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b'3'\n\n    is_permanent = True\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = False\n    run_test(expect_header=False)\n\n\ndef test_flashes():\n    app = flask.Flask(__name__)\n    app.secret_key = 'testkey'\n\n    with app.test_request_context():\n        assert not flask.session.modified\n        flask.flash('Zap')\n        flask.session.modified = False\n        flask.flash('Zip')\n        assert flask.session.modified\n        assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']\n\n\ndef test_extended_flashing():\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    app = flask.Flask(__name__)\n    app.secret_key = 'testkey'\n    app.testing = True\n\n    @app.route('\/')\n    def index():\n        flask.flash(u'Hello World')\n        flask.flash(u'Hello World', 'error')\n        flask.flash(flask.Markup(u'<em>Testing<\/em>'), 'warning')\n        return ''\n\n    @app.route('\/test\/')\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            u'Hello World',\n            u'Hello World',\n            flask.Markup(u'<em>Testing<\/em>')\n        ]\n        return ''\n\n    @app.route('\/test_with_categories\/')\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            ('message', u'Hello World'),\n            ('error', u'Hello World'),\n            ('warning', flask.Markup(u'<em>Testing<\/em>'))\n        ]\n        return ''\n\n    @app.route('\/test_filter\/')\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=['message'], with_categories=True)\n        assert list(messages) == [('message', u'Hello World')]\n        return ''\n\n    @app.route('\/test_filters\/')\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=['message', 'warning'], with_categories=True)\n        assert list(messages) == [\n            ('message', u'Hello World'),\n            ('warning', flask.Markup(u'<em>Testing<\/em>'))\n        ]\n        return ''\n\n    @app.route('\/test_filters_without_returning_categories\/')\n    def test_filters2():\n        messages = flask.get_flashed_messages(\n            category_filter=['message', 'warning'])\n        assert len(messages) == 2\n        assert messages[0] == u'Hello World'\n        assert messages[1] == flask.Markup(u'<em>Testing<\/em>')\n        return ''\n\n    # Create new test client on each test to clean flashed messages.\n\n    c = app.test_client()\n    c.get('\/')\n    c.get('\/test\/')\n\n    c = app.test_client()\n    c.get('\/')\n    c.get('\/test_with_categories\/')\n\n    c = app.test_client()\n    c.get('\/')\n    c.get('\/test_filter\/')\n\n    c = app.test_client()\n    c.get('\/')\n    c.get('\/test_filters\/')\n\n    c = app.test_client()\n    c.get('\/')\n    c.get('\/test_filters_without_returning_categories\/')\n\n\ndef test_request_processing():\n    app = flask.Flask(__name__)\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append('before')\n\n    @app.after_request\n    def after_request(response):\n        response.data += b'|after'\n        evts.append('after')\n        return response\n\n    @app.route('\/')\n    def index():\n        assert 'before' in evts\n        assert 'after' not in evts\n        return 'request'\n    assert 'after' not in evts\n    rv = app.test_client().get('\/').data\n    assert 'after' in evts\n    assert rv == b'request|after'\n\n\ndef test_after_request_processing():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route('\/')\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers['X-Foo'] = 'a header'\n            return response\n        return 'Test'\n    c = app.test_client()\n    resp = c.get('\/')\n    assert resp.status_code == 200\n    assert resp.headers['X-Foo'] == 'a header'\n\n\ndef test_teardown_request_handler():\n    called = []\n    app = flask.Flask(__name__)\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route('\/')\n    def root():\n        return \"Response\"\n    rv = app.test_client().get('\/')\n    assert rv.status_code == 200\n    assert b'Response' in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_debug_mode():\n    called = []\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route('\/')\n    def root():\n        return \"Response\"\n    rv = app.test_client().get('\/')\n    assert rv.status_code == 200\n    assert b'Response' in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_error():\n    called = []\n    app = flask.Flask(__name__)\n    app.config['LOGGER_HANDLER_POLICY'] = 'never'\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except:\n            pass\n\n    @app.route('\/')\n    def fails():\n        1 \/\/ 0\n    rv = app.test_client().get('\/')\n    assert rv.status_code == 500\n    assert b'Internal Server Error' in rv.data\n    assert len(called) == 2\n\n\ndef test_before_after_request_order():\n    called = []\n    app = flask.Flask(__name__)\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route('\/')\n    def index():\n        return '42'\n    rv = app.test_client().get('\/')\n    assert rv.data == b'42'\n    assert called == [1, 2, 3, 4, 5, 6]\n\n\ndef test_error_handling():\n    app = flask.Flask(__name__)\n    app.config['LOGGER_HANDLER_POLICY'] = 'never'\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return 'not found', 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return 'internal server error', 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return 'forbidden', 403\n\n    @app.route('\/')\n    def index():\n        flask.abort(404)\n\n    @app.route('\/error')\n    def error():\n        1 \/\/ 0\n\n    @app.route('\/forbidden')\n    def error2():\n        flask.abort(403)\n    c = app.test_client()\n    rv = c.get('\/')\n    assert rv.status_code == 404\n    assert rv.data == b'not found'\n    rv = c.get('\/error')\n    assert rv.status_code == 500\n    assert b'internal server error' == rv.data\n    rv = c.get('\/forbidden')\n    assert rv.status_code == 403\n    assert b'forbidden' == rv.data\n\n\ndef test_before_request_and_routing_errors():\n    app = flask.Flask(__name__)\n\n    @app.before_request\n    def attach_something():\n        flask.g.something = 'value'\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n    rv = app.test_client().get('\/')\n    assert rv.status_code == 404\n    assert rv.data == b'value'\n\n\ndef test_user_error_handling():\n    class MyException(Exception):\n        pass\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return '42'\n\n    @app.route('\/')\n    def index():\n        raise MyException()\n\n    c = app.test_client()\n    assert c.get('\/').data == b'42'\n\n\ndef test_http_error_subclass_handling():\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return 'banana'\n\n    @app.errorhandler(403)\n    def handle_forbidden_subclass(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return 'apple'\n\n    @app.route('\/1')\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route('\/2')\n    def index2():\n        flask.abort(403)\n\n    @app.route('\/3')\n    def index3():\n        raise Forbidden()\n\n    c = app.test_client()\n    assert c.get('\/1').data == b'banana'\n    assert c.get('\/2').data == b'apple'\n    assert c.get('\/3').data == b'apple'\n\n\ndef test_trapping_of_bad_request_key_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route('\/fail')\n    def fail():\n        flask.request.form['missing_key']\n    c = app.test_client()\n    assert c.get('\/fail').status_code == 400\n\n    app.config['TRAP_BAD_REQUEST_ERRORS'] = True\n    c = app.test_client()\n    try:\n        c.get('\/fail')\n    except KeyError as e:\n        assert isinstance(e, BadRequest)\n    else:\n        assert False, 'Expected exception'\n\n\ndef test_trapping_of_all_http_exceptions():\n    app = flask.Flask(__name__)\n    app.testing = True\n    app.config['TRAP_HTTP_EXCEPTIONS'] = True\n\n    @app.route('\/fail')\n    def fail():\n        flask.abort(404)\n\n    c = app.test_client()\n    with pytest.raises(NotFound):\n        c.get('\/fail')\n\n\ndef test_enctype_debug_helper():\n    from flask.debughelpers import DebugFilesKeyError\n    app = flask.Flask(__name__)\n    app.debug = True\n\n    @app.route('\/fail', methods=['POST'])\n    def index():\n        return flask.request.files['foo'].filename\n\n    # with statement is important because we leave an exception on the\n    # stack otherwise and we want to ensure that this is not the case\n    # to not negatively affect other tests.\n    with app.test_client() as c:\n        try:\n            c.post('\/fail', data={'foo': 'index.txt'})\n        except DebugFilesKeyError as e:\n            assert 'no file contents were transmitted' in str(e)\n            assert 'This was submitted: \"index.txt\"' in str(e)\n        else:\n            assert False, 'Expected exception'\n\n\ndef test_response_creation():\n    app = flask.Flask(__name__)\n\n    @app.route('\/unicode')\n    def from_unicode():\n        return u'H\u00e4llo W\u00f6rld'\n\n    @app.route('\/string')\n    def from_string():\n        return u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n\n    @app.route('\/args')\n    def from_tuple():\n        return 'Meh', 400, {\n            'X-Foo': 'Testing',\n            'Content-Type': 'text\/plain; charset=utf-8'\n        }\n\n    @app.route('\/two_args')\n    def from_two_args_tuple():\n        return 'Hello', {\n            'X-Foo': 'Test',\n            'Content-Type': 'text\/plain; charset=utf-8'\n        }\n\n    @app.route('\/args_status')\n    def from_status_tuple():\n        return 'Hi, status!', 400\n\n    @app.route('\/args_header')\n    def from_response_instance_status_tuple():\n        return flask.Response('Hello world', 404), {\n            \"X-Foo\": \"Bar\",\n            \"X-Bar\": \"Foo\"\n        }\n\n    c = app.test_client()\n    assert c.get('\/unicode').data == u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n    assert c.get('\/string').data == u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n    rv = c.get('\/args')\n    assert rv.data == b'Meh'\n    assert rv.headers['X-Foo'] == 'Testing'\n    assert rv.status_code == 400\n    assert rv.mimetype == 'text\/plain'\n    rv2 = c.get('\/two_args')\n    assert rv2.data == b'Hello'\n    assert rv2.headers['X-Foo'] == 'Test'\n    assert rv2.status_code == 200\n    assert rv2.mimetype == 'text\/plain'\n    rv3 = c.get('\/args_status')\n    assert rv3.data == b'Hi, status!'\n    assert rv3.status_code == 400\n    assert rv3.mimetype == 'text\/html'\n    rv4 = c.get('\/args_header')\n    assert rv4.data == b'Hello world'\n    assert rv4.headers['X-Foo'] == 'Bar'\n    assert rv4.headers['X-Bar'] == 'Foo'\n    assert rv4.status_code == 404\n\n\ndef test_make_response():\n    app = flask.Flask(__name__)\n    with app.test_request_context():\n        rv = flask.make_response()\n        assert rv.status_code == 200\n        assert rv.data == b''\n        assert rv.mimetype == 'text\/html'\n\n        rv = flask.make_response('Awesome')\n        assert rv.status_code == 200\n        assert rv.data == b'Awesome'\n        assert rv.mimetype == 'text\/html'\n\n        rv = flask.make_response('W00t', 404)\n        assert rv.status_code == 404\n        assert rv.data == b'W00t'\n        assert rv.mimetype == 'text\/html'\n\n\ndef test_make_response_with_response_instance():\n    app = flask.Flask(__name__)\n    with app.test_request_context():\n        rv = flask.make_response(\n            flask.jsonify({'msg': 'W00t'}), 400)\n        assert rv.status_code == 400\n        assert rv.data == b'{\\n  \"msg\": \"W00t\"\\n}\\n'\n        assert rv.mimetype == 'application\/json'\n\n        rv = flask.make_response(\n            flask.Response(''), 400)\n        assert rv.status_code == 400\n        assert rv.data == b''\n        assert rv.mimetype == 'text\/html'\n\n        rv = flask.make_response(\n            flask.Response('', headers={'Content-Type': 'text\/html'}),\n            400, [('X-Foo', 'bar')])\n        assert rv.status_code == 400\n        assert rv.headers['Content-Type'] == 'text\/html'\n        assert rv.headers['X-Foo'] == 'bar'\n\n\ndef test_jsonify_no_prettyprint():\n    app = flask.Flask(__name__)\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": False})\n    with app.test_request_context():\n        compressed_msg = b'{\"msg\":{\"submsg\":\"W00t\"},\"msg2\":\"foobar\"}\\n'\n        uncompressed_msg = {\n            \"msg\": {\n                \"submsg\": \"W00t\"\n            },\n            \"msg2\": \"foobar\"\n            }\n\n        rv = flask.make_response(\n            flask.jsonify(uncompressed_msg), 200)\n        assert rv.data == compressed_msg\n\n\ndef test_jsonify_prettyprint():\n    app = flask.Flask(__name__)\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": True})\n    with app.test_request_context():\n        compressed_msg = {\"msg\":{\"submsg\":\"W00t\"},\"msg2\":\"foobar\"}\n        pretty_response =\\\n            b'{\\n  \"msg\": {\\n    \"submsg\": \"W00t\"\\n  }, \\n  \"msg2\": \"foobar\"\\n}\\n'\n\n        rv = flask.make_response(\n            flask.jsonify(compressed_msg), 200)\n        assert rv.data == pretty_response\n\n\ndef test_url_generation():\n    app = flask.Flask(__name__)\n\n    @app.route('\/hello\/<name>', methods=['POST'])\n    def hello():\n        pass\n    with app.test_request_context():\n        assert flask.url_for('hello', name='test x') == '\/hello\/test%20x'\n        assert flask.url_for('hello', name='test x', _external=True) == \\\n            'http:\/\/localhost\/hello\/test%20x'\n\n\ndef test_build_error_handler():\n    app = flask.Flask(__name__)\n\n    # Test base case, a URL which results in a BuildError.\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, 'spam')\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for('spam')\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError('Test case where BuildError is not current.')\n    except RuntimeError:\n        pytest.raises(\n            BuildError, app.handle_url_build_error, error, 'spam', {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return '\/test_handler\/'\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for('spam') == '\/test_handler\/'\n\n\ndef test_custom_converters():\n    from werkzeug.routing import BaseConverter\n\n    class ListConverter(BaseConverter):\n\n        def to_python(self, value):\n            return value.split(',')\n\n        def to_url(self, value):\n            base_to_url = super(ListConverter, self).to_url\n            return ','.join(base_to_url(x) for x in value)\n    app = flask.Flask(__name__)\n    app.url_map.converters['list'] = ListConverter\n\n    @app.route('\/<list:args>')\n    def index(args):\n        return '|'.join(args)\n    c = app.test_client()\n    assert c.get('\/1,2,3').data == b'1|2|3'\n\n\ndef test_static_files():\n    app = flask.Flask(__name__)\n    app.testing = True\n    rv = app.test_client().get('\/static\/index.html')\n    assert rv.status_code == 200\n    assert rv.data.strip() == b'<h1>Hello World!<\/h1>'\n    with app.test_request_context():\n        assert flask.url_for('static', filename='index.html') == \\\n            '\/static\/index.html'\n    rv.close()\n\n\ndef test_none_response():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route('\/')\n    def test():\n        return None\n    try:\n        app.test_client().get('\/')\n    except ValueError as e:\n        assert str(e) == 'View function did not return a response'\n        pass\n    else:\n        assert \"Expected ValueError\"\n\n\ndef test_request_locals():\n    assert repr(flask.g) == '<LocalProxy unbound>'\n    assert not flask.g\n\n\ndef test_test_app_proper_environ():\n    app = flask.Flask(__name__)\n    app.config.update(\n        SERVER_NAME='localhost.localdomain:5000'\n    )\n\n    @app.route('\/')\n    def index():\n        return 'Foo'\n\n    @app.route('\/', subdomain='foo')\n    def subdomain():\n        return 'Foo SubDomain'\n\n    rv = app.test_client().get('\/')\n    assert rv.data == b'Foo'\n\n    rv = app.test_client().get('\/', 'http:\/\/localhost.localdomain:5000')\n    assert rv.data == b'Foo'\n\n    rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain:5000')\n    assert rv.data == b'Foo'\n\n    app.config.update(SERVER_NAME='localhost.localdomain')\n    rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain')\n    assert rv.data == b'Foo'\n\n    try:\n        app.config.update(SERVER_NAME='localhost.localdomain:443')\n        rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain')\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain:443') does not match the \"\n            \"server name from the WSGI environment ('localhost.localdomain')\"\n        )\n\n    try:\n        app.config.update(SERVER_NAME='localhost.localdomain')\n        rv = app.test_client().get('\/', 'http:\/\/foo.localhost')\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain') does not match the \"\n            \"server name from the WSGI environment ('foo.localhost')\"\n        )\n\n    rv = app.test_client().get('\/', 'http:\/\/foo.localhost.localdomain')\n    assert rv.data == b'Foo SubDomain'\n\n\ndef test_exception_propagation():\n    def apprunner(configkey):\n        app = flask.Flask(__name__)\n        app.config['LOGGER_HANDLER_POLICY'] = 'never'\n\n        @app.route('\/')\n        def index():\n            1 \/\/ 0\n        c = app.test_client()\n        if config_key is not None:\n            app.config[config_key] = True\n            try:\n                c.get('\/')\n            except Exception:\n                pass\n            else:\n                assert False, 'expected exception'\n        else:\n            assert c.get('\/').status_code == 500\n\n    # we have to run this test in an isolated thread because if the\n    # debug flag is set to true and an exception happens the context is\n    # not torn down.  This causes other tests that run after this fail\n    # when they expect no exception on the stack.\n    for config_key in 'TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', None:\n        t = Thread(target=apprunner, args=(config_key,))\n        t.start()\n        t.join()\n\n\ndef test_max_content_length():\n    app = flask.Flask(__name__)\n    app.config['MAX_CONTENT_LENGTH'] = 64\n\n    @app.before_request\n    def always_first():\n        flask.request.form['myfile']\n        assert False\n\n    @app.route('\/accept', methods=['POST'])\n    def accept_file():\n        flask.request.form['myfile']\n        assert False\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return '42'\n\n    c = app.test_client()\n    rv = c.post('\/accept', data={'myfile': 'foo' * 100})\n    assert rv.data == b'42'\n\n\ndef test_url_processors():\n    app = flask.Flask(__name__)\n\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and \\\n           app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n            values.setdefault('lang_code', flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop('lang_code', None)\n\n    @app.route('\/<lang_code>\/')\n    def index():\n        return flask.url_for('about')\n\n    @app.route('\/<lang_code>\/about')\n    def about():\n        return flask.url_for('something_else')\n\n    @app.route('\/foo')\n    def something_else():\n        return flask.url_for('about', lang_code='en')\n\n    c = app.test_client()\n\n    assert c.get('\/de\/').data == b'\/de\/about'\n    assert c.get('\/de\/about').data == b'\/foo'\n    assert c.get('\/foo').data == b'\/en\/about'\n\n\ndef test_inject_blueprint_url_defaults():\n    app = flask.Flask(__name__)\n    bp = flask.Blueprint('foo.bar.baz', __name__,\n                         template_folder='template')\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values['page'] = 'login'\n\n    @bp.route('\/<page>')\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults('foo.bar.baz.view', values)\n    expected = dict(page='login')\n    assert values == expected\n\n    with app.test_request_context('\/somepage'):\n        url = flask.url_for('foo.bar.baz.view')\n    expected = '\/login'\n    assert url == expected\n\n\ndef test_nonascii_pathinfo():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(u'\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442')\n    def index():\n        return 'Hello World!'\n\n    c = app.test_client()\n    rv = c.get(u'\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442')\n    assert rv.data == b'Hello World!'\n\n\ndef test_debug_mode_complains_after_first_request():\n    app = flask.Flask(__name__)\n    app.debug = True\n\n    @app.route('\/')\n    def index():\n        return 'Awesome'\n    assert not app.got_first_request\n    assert app.test_client().get('\/').data == b'Awesome'\n    try:\n        @app.route('\/foo')\n        def broken():\n            return 'Meh'\n    except AssertionError as e:\n        assert 'A setup function was called' in str(e)\n    else:\n        assert False, 'Expected exception'\n\n    app.debug = False\n\n    @app.route('\/foo')\n    def working():\n        return 'Meh'\n    assert app.test_client().get('\/foo').data == b'Meh'\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions():\n    got = []\n    app = flask.Flask(__name__)\n\n    @app.before_first_request\n    def foo():\n        got.append(42)\n    c = app.test_client()\n    c.get('\/')\n    assert got == [42]\n    c.get('\/')\n    assert got == [42]\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions_concurrent():\n    got = []\n    app = flask.Flask(__name__)\n\n    @app.before_first_request\n    def foo():\n        time.sleep(0.2)\n        got.append(42)\n\n    c = app.test_client()\n\n    def get_and_assert():\n        c.get(\"\/\")\n        assert got == [42]\n\n    t = Thread(target=get_and_assert)\n    t.start()\n    get_and_assert()\n    t.join()\n    assert app.got_first_request\n\n\ndef test_routing_redirect_debugging():\n    app = flask.Flask(__name__)\n    app.debug = True\n\n    @app.route('\/foo\/', methods=['GET', 'POST'])\n    def foo():\n        return 'success'\n    with app.test_client() as c:\n        try:\n            c.post('\/foo', data={})\n        except AssertionError as e:\n            assert 'http:\/\/localhost\/foo\/' in str(e)\n            assert ('Make sure to directly send '\n                    'your POST-request to this URL') in str(e)\n        else:\n            assert False, 'Expected exception'\n\n        rv = c.get('\/foo', data={}, follow_redirects=True)\n        assert rv.data == b'success'\n\n    app.debug = False\n    with app.test_client() as c:\n        rv = c.post('\/foo', data={}, follow_redirects=True)\n        assert rv.data == b'success'\n\n\ndef test_route_decorator_custom_endpoint():\n    app = flask.Flask(__name__)\n    app.debug = True\n\n    @app.route('\/foo\/')\n    def foo():\n        return flask.request.endpoint\n\n    @app.route('\/bar\/', endpoint='bar')\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route('\/bar\/123', endpoint='123')\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for('foo') == '\/foo\/'\n        assert flask.url_for('bar') == '\/bar\/'\n        assert flask.url_for('123') == '\/bar\/123'\n\n    c = app.test_client()\n    assert c.get('\/foo\/').data == b'foo'\n    assert c.get('\/bar\/').data == b'bar'\n    assert c.get('\/bar\/123').data == b'123'\n\n\ndef test_preserve_only_once():\n    app = flask.Flask(__name__)\n    app.debug = True\n\n    @app.route('\/fail')\n    def fail_func():\n        1 \/\/ 0\n\n    c = app.test_client()\n    for x in range(3):\n        with pytest.raises(ZeroDivisionError):\n            c.get('\/fail')\n\n    assert flask._request_ctx_stack.top is not None\n    assert flask._app_ctx_stack.top is not None\n    # implicit appctx disappears too\n    flask._request_ctx_stack.top.pop()\n    assert flask._request_ctx_stack.top is None\n    assert flask._app_ctx_stack.top is None\n\n\ndef test_preserve_remembers_exception():\n    app = flask.Flask(__name__)\n    app.debug = True\n    errors = []\n\n    @app.route('\/fail')\n    def fail_func():\n        1 \/\/ 0\n\n    @app.route('\/success')\n    def success_func():\n        return 'Okay'\n\n    @app.teardown_request\n    def teardown_handler(exc):\n        errors.append(exc)\n\n    c = app.test_client()\n\n    # After this failure we did not yet call the teardown handler\n    with pytest.raises(ZeroDivisionError):\n        c.get('\/fail')\n    assert errors == []\n\n    # But this request triggers it, and it's an error\n    c.get('\/success')\n    assert len(errors) == 2\n    assert isinstance(errors[0], ZeroDivisionError)\n\n    # At this point another request does nothing.\n    c.get('\/success')\n    assert len(errors) == 3\n    assert errors[1] is None\n\n\ndef test_get_method_on_g():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    with app.app_context():\n        assert flask.g.get('x') is None\n        assert flask.g.get('x', 11) == 11\n        flask.g.x = 42\n        assert flask.g.get('x') == 42\n        assert flask.g.x == 42\n\n\ndef test_g_iteration_protocol():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    with app.app_context():\n        flask.g.foo = 23\n        flask.g.bar = 42\n        assert 'foo' in flask.g\n        assert 'foos' not in flask.g\n        assert sorted(flask.g) == ['bar', 'foo']\n\n\ndef test_subdomain_basic_support():\n    app = flask.Flask(__name__)\n    app.config['SERVER_NAME'] = 'localhost'\n\n    @app.route('\/')\n    def normal_index():\n        return 'normal index'\n\n    @app.route('\/', subdomain='test')\n    def test_index():\n        return 'test index'\n\n    c = app.test_client()\n    rv = c.get('\/', 'http:\/\/localhost\/')\n    assert rv.data == b'normal index'\n\n    rv = c.get('\/', 'http:\/\/test.localhost\/')\n    assert rv.data == b'test index'\n\n\ndef test_subdomain_matching():\n    app = flask.Flask(__name__)\n    app.config['SERVER_NAME'] = 'localhost'\n\n    @app.route('\/', subdomain='<user>')\n    def index(user):\n        return 'index for %s' % user\n\n    c = app.test_client()\n    rv = c.get('\/', 'http:\/\/mitsuhiko.localhost\/')\n    assert rv.data == b'index for mitsuhiko'\n\n\ndef test_subdomain_matching_with_ports():\n    app = flask.Flask(__name__)\n    app.config['SERVER_NAME'] = 'localhost:3000'\n\n    @app.route('\/', subdomain='<user>')\n    def index(user):\n        return 'index for %s' % user\n\n    c = app.test_client()\n    rv = c.get('\/', 'http:\/\/mitsuhiko.localhost:3000\/')\n    assert rv.data == b'index for mitsuhiko'\n\n\ndef test_multi_route_rules():\n    app = flask.Flask(__name__)\n\n    @app.route('\/')\n    @app.route('\/<test>\/')\n    def index(test='a'):\n        return test\n\n    rv = app.test_client().open('\/')\n    assert rv.data == b'a'\n    rv = app.test_client().open('\/b\/')\n    assert rv.data == b'b'\n\n\ndef test_multi_route_class_views():\n    class View(object):\n\n        def __init__(self, app):\n            app.add_url_rule('\/', 'index', self.index)\n            app.add_url_rule('\/<test>\/', 'index', self.index)\n\n        def index(self, test='a'):\n            return test\n\n    app = flask.Flask(__name__)\n    _ = View(app)\n    rv = app.test_client().open('\/')\n    assert rv.data == b'a'\n    rv = app.test_client().open('\/b\/')\n    assert rv.data == b'b'\n\n\ndef test_run_defaults(monkeypatch):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv['result'] = 'running...'\n\n    app = flask.Flask(__name__)\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n    app.run()\n    assert rv['result'] == 'running...'\n\n\ndef test_run_server_port(monkeypatch):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(hostname, port, application, *args, **kwargs):\n        rv['result'] = 'running on %s:%s ...' % (hostname, port)\n\n    app = flask.Flask(__name__)\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n    hostname, port = 'localhost', 8000\n    app.run(hostname, port, debug=True)\n    assert rv['result'] == 'running on %s:%s ...' % (hostname, port)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.basic\n    ~~~~~~~~~~~~~~~~~~~~~\n\n    The basic functionality.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport re\nimport uuid\nimport time\nimport flask\nimport pickle\nfrom datetime import datetime\nfrom threading import Thread\nfrom flask._compat import text_type\nfrom werkzeug.exceptions import BadRequest, NotFound, Forbidden\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\nimport werkzeug.serving\n\n\ndef test_options_work():\n    app = flask.Flask(__name__)\n\n    @app.route('\/', methods=['GET', 'POST'])\n    def index():\n        return 'Hello World'\n    rv = app.test_client().open('\/', method='OPTIONS')\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']\n    assert rv.data == b''\n\n\ndef test_options_on_multiple_rules():\n    app = flask.Flask(__name__)\n\n    @app.route('\/', methods=['GET', 'POST'])\n    def index():\n        return 'Hello World'\n\n    @app.route('\/', methods=['PUT'])\n    def index_put():\n        return 'Aha!'\n    rv = app.test_client().open('\/', method='OPTIONS')\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n\ndef test_options_handling_disabled():\n    app = flask.Flask(__name__)\n\n    def index():\n        return 'Hello World!'\n    index.provide_automatic_options = False\n    app.route('\/')(index)\n    rv = app.test_client().open('\/', method='OPTIONS')\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return 'Hello World!'\n    index2.provide_automatic_options = True\n    app.route('\/', methods=['OPTIONS'])(index2)\n    rv = app.test_client().open('\/', method='OPTIONS')\n    assert sorted(rv.allow) == ['OPTIONS']\n\n\ndef test_request_dispatching():\n    app = flask.Flask(__name__)\n\n    @app.route('\/')\n    def index():\n        return flask.request.method\n\n    @app.route('\/more', methods=['GET', 'POST'])\n    def more():\n        return flask.request.method\n\n    c = app.test_client()\n    assert c.get('\/').data == b'GET'\n    rv = c.post('\/')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']\n    rv = c.head('\/')\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert c.post('\/more').data == b'POST'\n    assert c.get('\/more').data == b'GET'\n    rv = c.delete('\/more')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']\n\n\ndef test_disallow_string_for_allowed_methods():\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        @app.route('\/', methods='GET POST')\n        def index():\n            return \"Hey\"\n\n\ndef test_url_mapping():\n    app = flask.Flask(__name__)\n\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n\n    app.add_url_rule('\/', 'index', index)\n    app.add_url_rule('\/more', 'more', more, methods=['GET', 'POST'])\n\n    # Issue 1288: Test that automatic options are not added when non-uppercase 'options' in methods\n    app.add_url_rule('\/options', 'options', options, methods=['options'])\n\n    c = app.test_client()\n    assert c.get('\/').data == b'GET'\n    rv = c.post('\/')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']\n    rv = c.head('\/')\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert c.post('\/more').data == b'POST'\n    assert c.get('\/more').data == b'GET'\n    rv = c.delete('\/more')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']\n    rv = c.open('\/options', method='OPTIONS')\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")\n\n\ndef test_werkzeug_routing():\n    from werkzeug.routing import Submount, Rule\n    app = flask.Flask(__name__)\n    app.url_map.add(Submount('\/foo', [\n        Rule('\/bar', endpoint='bar'),\n        Rule('\/', endpoint='index')\n    ]))\n\n    def bar():\n        return 'bar'\n\n    def index():\n        return 'index'\n    app.view_functions['bar'] = bar\n    app.view_functions['index'] = index\n\n    c = app.test_client()\n    assert c.get('\/foo\/').data == b'index'\n    assert c.get('\/foo\/bar').data == b'bar'\n\n\ndef test_endpoint_decorator():\n    from werkzeug.routing import Submount, Rule\n    app = flask.Flask(__name__)\n    app.url_map.add(Submount('\/foo', [\n        Rule('\/bar', endpoint='bar'),\n        Rule('\/', endpoint='index')\n    ]))\n\n    @app.endpoint('bar')\n    def bar():\n        return 'bar'\n\n    @app.endpoint('index')\n    def index():\n        return 'index'\n\n    c = app.test_client()\n    assert c.get('\/foo\/').data == b'index'\n    assert c.get('\/foo\/bar').data == b'bar'\n\n\ndef test_session():\n    app = flask.Flask(__name__)\n    app.secret_key = 'testkey'\n\n    @app.route('\/set', methods=['POST'])\n    def set():\n        flask.session['value'] = flask.request.form['value']\n        return 'value set'\n\n    @app.route('\/get')\n    def get():\n        return flask.session['value']\n\n    c = app.test_client()\n    assert c.post('\/set', data={'value': '42'}).data == b'value set'\n    assert c.get('\/get').data == b'42'\n\n\ndef test_session_using_server_name():\n    app = flask.Flask(__name__)\n    app.config.update(\n        SECRET_KEY='foo',\n        SERVER_NAME='example.com'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n    rv = app.test_client().get('\/', 'http:\/\/example.com\/')\n    assert 'domain=.example.com' in rv.headers['set-cookie'].lower()\n    assert 'httponly' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_server_name_and_port():\n    app = flask.Flask(__name__)\n    app.config.update(\n        SECRET_KEY='foo',\n        SERVER_NAME='example.com:8080'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n    rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/')\n    assert 'domain=.example.com' in rv.headers['set-cookie'].lower()\n    assert 'httponly' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_server_name_port_and_path():\n    app = flask.Flask(__name__)\n    app.config.update(\n        SECRET_KEY='foo',\n        SERVER_NAME='example.com:8080',\n        APPLICATION_ROOT='\/foo'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n    rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/foo')\n    assert 'domain=example.com' in rv.headers['set-cookie'].lower()\n    assert 'path=\/foo' in rv.headers['set-cookie'].lower()\n    assert 'httponly' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_application_root():\n    class PrefixPathMiddleware(object):\n\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ['SCRIPT_NAME'] = self.prefix\n            return self.app(environ, start_response)\n\n    app = flask.Flask(__name__)\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, '\/bar')\n    app.config.update(\n        SECRET_KEY='foo',\n        APPLICATION_ROOT='\/bar'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n    rv = app.test_client().get('\/', 'http:\/\/example.com:8080\/')\n    assert 'path=\/bar' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_session_settings():\n    app = flask.Flask(__name__)\n    app.config.update(\n        SECRET_KEY='foo',\n        SERVER_NAME='www.example.com:8080',\n        APPLICATION_ROOT='\/test',\n        SESSION_COOKIE_DOMAIN='.example.com',\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_PATH='\/'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n    rv = app.test_client().get('\/', 'http:\/\/www.example.com:8080\/test\/')\n    cookie = rv.headers['set-cookie'].lower()\n    assert 'domain=.example.com' in cookie\n    assert 'path=\/' in cookie\n    assert 'secure' in cookie\n    assert 'httponly' not in cookie\n\n\ndef test_missing_session():\n    app = flask.Flask(__name__)\n\n    def expect_exception(f, *args, **kwargs):\n        try:\n            f(*args, **kwargs)\n        except RuntimeError as e:\n            assert e.args and 'session is unavailable' in e.args[0]\n        else:\n            assert False, 'expected exception'\n    with app.test_request_context():\n        assert flask.session.get('missing_key') is None\n        expect_exception(flask.session.__setitem__, 'foo', 42)\n        expect_exception(flask.session.pop, 'foo')\n\n\ndef test_session_expiration():\n    permanent = True\n    app = flask.Flask(__name__)\n    app.secret_key = 'testkey'\n\n    @app.route('\/')\n    def index():\n        flask.session['test'] = 42\n        flask.session.permanent = permanent\n        return ''\n\n    @app.route('\/test')\n    def test():\n        return text_type(flask.session.permanent)\n\n    client = app.test_client()\n    rv = client.get('\/')\n    assert 'set-cookie' in rv.headers\n    match = re.search(r'\\bexpires=([^;]+)(?i)', rv.headers['set-cookie'])\n    expires = parse_date(match.group())\n    expected = datetime.utcnow() + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get('\/test')\n    assert rv.data == b'True'\n\n    permanent = False\n    rv = app.test_client().get('\/')\n    assert 'set-cookie' in rv.headers\n    match = re.search(r'\\bexpires=([^;]+)', rv.headers['set-cookie'])\n    assert match is None\n\n\ndef test_session_stored_last():\n    app = flask.Flask(__name__)\n    app.secret_key = 'development-key'\n    app.testing = True\n\n    @app.after_request\n    def modify_session(response):\n        flask.session['foo'] = 42\n        return response\n\n    @app.route('\/')\n    def dump_session_contents():\n        return repr(flask.session.get('foo'))\n\n    c = app.test_client()\n    assert c.get('\/').data == b'None'\n    assert c.get('\/').data == b'42'\n\n\ndef test_session_special_types():\n    app = flask.Flask(__name__)\n    app.secret_key = 'development-key'\n    app.testing = True\n    now = datetime.utcnow().replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.after_request\n    def modify_session(response):\n        flask.session['m'] = flask.Markup('Hello!')\n        flask.session['u'] = the_uuid\n        flask.session['dt'] = now\n        flask.session['b'] = b'\\xff'\n        flask.session['t'] = (1, 2, 3)\n        return response\n\n    @app.route('\/')\n    def dump_session_contents():\n        return pickle.dumps(dict(flask.session))\n\n    c = app.test_client()\n    c.get('\/')\n    rv = pickle.loads(c.get('\/').data)\n    assert rv['m'] == flask.Markup('Hello!')\n    assert type(rv['m']) == flask.Markup\n    assert rv['dt'] == now\n    assert rv['u'] == the_uuid\n    assert rv['b'] == b'\\xff'\n    assert type(rv['b']) == bytes\n    assert rv['t'] == (1, 2, 3)\n\n\ndef test_session_cookie_setting():\n    app = flask.Flask(__name__)\n    app.testing = True\n    app.secret_key = 'dev key'\n    is_permanent = True\n\n    @app.route('\/bump')\n    def bump():\n        rv = flask.session['foo'] = flask.session.get('foo', 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route('\/read')\n    def read():\n        return str(flask.session.get('foo', 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get('\/bump').data == b'1'\n            assert c.get('\/bump').data == b'2'\n            assert c.get('\/bump').data == b'3'\n\n            rv = c.get('\/read')\n            set_cookie = rv.headers.get('set-cookie')\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b'3'\n\n    is_permanent = True\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = False\n    run_test(expect_header=False)\n\n\ndef test_flashes():\n    app = flask.Flask(__name__)\n    app.secret_key = 'testkey'\n\n    with app.test_request_context():\n        assert not flask.session.modified\n        flask.flash('Zap')\n        flask.session.modified = False\n        flask.flash('Zip')\n        assert flask.session.modified\n        assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']\n\n\ndef test_extended_flashing():\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    app = flask.Flask(__name__)\n    app.secret_key = 'testkey'\n    app.testing = True\n\n    @app.route('\/')\n    def index():\n        flask.flash(u'Hello World')\n        flask.flash(u'Hello World', 'error')\n        flask.flash(flask.Markup(u'<em>Testing<\/em>'), 'warning')\n        return ''\n\n    @app.route('\/test\/')\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            u'Hello World',\n            u'Hello World',\n            flask.Markup(u'<em>Testing<\/em>')\n        ]\n        return ''\n\n    @app.route('\/test_with_categories\/')\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            ('message', u'Hello World'),\n            ('error', u'Hello World'),\n            ('warning', flask.Markup(u'<em>Testing<\/em>'))\n        ]\n        return ''\n\n    @app.route('\/test_filter\/')\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=['message'], with_categories=True)\n        assert list(messages) == [('message', u'Hello World')]\n        return ''\n\n    @app.route('\/test_filters\/')\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=['message', 'warning'], with_categories=True)\n        assert list(messages) == [\n            ('message', u'Hello World'),\n            ('warning', flask.Markup(u'<em>Testing<\/em>'))\n        ]\n        return ''\n\n    @app.route('\/test_filters_without_returning_categories\/')\n    def test_filters2():\n        messages = flask.get_flashed_messages(\n            category_filter=['message', 'warning'])\n        assert len(messages) == 2\n        assert messages[0] == u'Hello World'\n        assert messages[1] == flask.Markup(u'<em>Testing<\/em>')\n        return ''\n\n    # Create new test client on each test to clean flashed messages.\n\n    c = app.test_client()\n    c.get('\/')\n    c.get('\/test\/')\n\n    c = app.test_client()\n    c.get('\/')\n    c.get('\/test_with_categories\/')\n\n    c = app.test_client()\n    c.get('\/')\n    c.get('\/test_filter\/')\n\n    c = app.test_client()\n    c.get('\/')\n    c.get('\/test_filters\/')\n\n    c = app.test_client()\n    c.get('\/')\n    c.get('\/test_filters_without_returning_categories\/')\n\n\ndef test_request_processing():\n    app = flask.Flask(__name__)\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append('before')\n\n    @app.after_request\n    def after_request(response):\n        response.data += b'|after'\n        evts.append('after')\n        return response\n\n    @app.route('\/')\n    def index():\n        assert 'before' in evts\n        assert 'after' not in evts\n        return 'request'\n    assert 'after' not in evts\n    rv = app.test_client().get('\/').data\n    assert 'after' in evts\n    assert rv == b'request|after'\n\n\ndef test_after_request_processing():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route('\/')\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers['X-Foo'] = 'a header'\n            return response\n        return 'Test'\n    c = app.test_client()\n    resp = c.get('\/')\n    assert resp.status_code == 200\n    assert resp.headers['X-Foo'] == 'a header'\n\n\ndef test_teardown_request_handler():\n    called = []\n    app = flask.Flask(__name__)\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route('\/')\n    def root():\n        return \"Response\"\n    rv = app.test_client().get('\/')\n    assert rv.status_code == 200\n    assert b'Response' in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_debug_mode():\n    called = []\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route('\/')\n    def root():\n        return \"Response\"\n    rv = app.test_client().get('\/')\n    assert rv.status_code == 200\n    assert b'Response' in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_error():\n    called = []\n    app = flask.Flask(__name__)\n    app.config['LOGGER_HANDLER_POLICY'] = 'never'\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except:\n            pass\n\n    @app.route('\/')\n    def fails():\n        1 \/\/ 0\n    rv = app.test_client().get('\/')\n    assert rv.status_code == 500\n    assert b'Internal Server Error' in rv.data\n    assert len(called) == 2\n\n\ndef test_before_after_request_order():\n    called = []\n    app = flask.Flask(__name__)\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route('\/')\n    def index():\n        return '42'\n    rv = app.test_client().get('\/')\n    assert rv.data == b'42'\n    assert called == [1, 2, 3, 4, 5, 6]\n\n\ndef test_error_handling():\n    app = flask.Flask(__name__)\n    app.config['LOGGER_HANDLER_POLICY'] = 'never'\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return 'not found', 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return 'internal server error', 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return 'forbidden', 403\n\n    @app.route('\/')\n    def index():\n        flask.abort(404)\n\n    @app.route('\/error')\n    def error():\n        1 \/\/ 0\n\n    @app.route('\/forbidden')\n    def error2():\n        flask.abort(403)\n    c = app.test_client()\n    rv = c.get('\/')\n    assert rv.status_code == 404\n    assert rv.data == b'not found'\n    rv = c.get('\/error')\n    assert rv.status_code == 500\n    assert b'internal server error' == rv.data\n    rv = c.get('\/forbidden')\n    assert rv.status_code == 403\n    assert b'forbidden' == rv.data\n\n\ndef test_before_request_and_routing_errors():\n    app = flask.Flask(__name__)\n\n    @app.before_request\n    def attach_something():\n        flask.g.something = 'value'\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n    rv = app.test_client().get('\/')\n    assert rv.status_code == 404\n    assert rv.data == b'value'\n\n\ndef test_user_error_handling():\n    class MyException(Exception):\n        pass\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return '42'\n\n    @app.route('\/')\n    def index():\n        raise MyException()\n\n    c = app.test_client()\n    assert c.get('\/').data == b'42'\n\n\ndef test_http_error_subclass_handling():\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return 'banana'\n\n    @app.errorhandler(403)\n    def handle_forbidden_subclass(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return 'apple'\n\n    @app.route('\/1')\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route('\/2')\n    def index2():\n        flask.abort(403)\n\n    @app.route('\/3')\n    def index3():\n        raise Forbidden()\n\n    c = app.test_client()\n    assert c.get('\/1').data == b'banana'\n    assert c.get('\/2').data == b'apple'\n    assert c.get('\/3').data == b'apple'\n\n\ndef test_trapping_of_bad_request_key_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route('\/fail')\n    def fail():\n        flask.request.form['missing_key']\n    c = app.test_client()\n    assert c.get('\/fail').status_code == 400\n\n    app.config['TRAP_BAD_REQUEST_ERRORS'] = True\n    c = app.test_client()\n    try:\n        c.get('\/fail')\n    except KeyError as e:\n        assert isinstance(e, BadRequest)\n    else:\n        assert False, 'Expected exception'\n\n\ndef test_trapping_of_all_http_exceptions():\n    app = flask.Flask(__name__)\n    app.testing = True\n    app.config['TRAP_HTTP_EXCEPTIONS'] = True\n\n    @app.route('\/fail')\n    def fail():\n        flask.abort(404)\n\n    c = app.test_client()\n    with pytest.raises(NotFound):\n        c.get('\/fail')\n\n\ndef test_enctype_debug_helper():\n    from flask.debughelpers import DebugFilesKeyError\n    app = flask.Flask(__name__)\n    app.debug = True\n\n    @app.route('\/fail', methods=['POST'])\n    def index():\n        return flask.request.files['foo'].filename\n\n    # with statement is important because we leave an exception on the\n    # stack otherwise and we want to ensure that this is not the case\n    # to not negatively affect other tests.\n    with app.test_client() as c:\n        try:\n            c.post('\/fail', data={'foo': 'index.txt'})\n        except DebugFilesKeyError as e:\n            assert 'no file contents were transmitted' in str(e)\n            assert 'This was submitted: \"index.txt\"' in str(e)\n        else:\n            assert False, 'Expected exception'\n\n\ndef test_response_creation():\n    app = flask.Flask(__name__)\n\n    @app.route('\/unicode')\n    def from_unicode():\n        return u'H\u00e4llo W\u00f6rld'\n\n    @app.route('\/string')\n    def from_string():\n        return u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n\n    @app.route('\/args')\n    def from_tuple():\n        return 'Meh', 400, {\n            'X-Foo': 'Testing',\n            'Content-Type': 'text\/plain; charset=utf-8'\n        }\n\n    @app.route('\/two_args')\n    def from_two_args_tuple():\n        return 'Hello', {\n            'X-Foo': 'Test',\n            'Content-Type': 'text\/plain; charset=utf-8'\n        }\n\n    @app.route('\/args_status')\n    def from_status_tuple():\n        return 'Hi, status!', 400\n\n    @app.route('\/args_header')\n    def from_response_instance_status_tuple():\n        return flask.Response('Hello world', 404), {\n            \"X-Foo\": \"Bar\",\n            \"X-Bar\": \"Foo\"\n        }\n\n    c = app.test_client()\n    assert c.get('\/unicode').data == u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n    assert c.get('\/string').data == u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n    rv = c.get('\/args')\n    assert rv.data == b'Meh'\n    assert rv.headers['X-Foo'] == 'Testing'\n    assert rv.status_code == 400\n    assert rv.mimetype == 'text\/plain'\n    rv2 = c.get('\/two_args')\n    assert rv2.data == b'Hello'\n    assert rv2.headers['X-Foo'] == 'Test'\n    assert rv2.status_code == 200\n    assert rv2.mimetype == 'text\/plain'\n    rv3 = c.get('\/args_status')\n    assert rv3.data == b'Hi, status!'\n    assert rv3.status_code == 400\n    assert rv3.mimetype == 'text\/html'\n    rv4 = c.get('\/args_header')\n    assert rv4.data == b'Hello world'\n    assert rv4.headers['X-Foo'] == 'Bar'\n    assert rv4.headers['X-Bar'] == 'Foo'\n    assert rv4.status_code == 404\n\n\ndef test_make_response():\n    app = flask.Flask(__name__)\n    with app.test_request_context():\n        rv = flask.make_response()\n        assert rv.status_code == 200\n        assert rv.data == b''\n        assert rv.mimetype == 'text\/html'\n\n        rv = flask.make_response('Awesome')\n        assert rv.status_code == 200\n        assert rv.data == b'Awesome'\n        assert rv.mimetype == 'text\/html'\n\n        rv = flask.make_response('W00t', 404)\n        assert rv.status_code == 404\n        assert rv.data == b'W00t'\n        assert rv.mimetype == 'text\/html'\n\n\ndef test_make_response_with_response_instance():\n    app = flask.Flask(__name__)\n    with app.test_request_context():\n        rv = flask.make_response(\n            flask.jsonify({'msg': 'W00t'}), 400)\n        assert rv.status_code == 400\n        assert rv.data == b'{\\n  \"msg\": \"W00t\"\\n}\\n'\n        assert rv.mimetype == 'application\/json'\n\n        rv = flask.make_response(\n            flask.Response(''), 400)\n        assert rv.status_code == 400\n        assert rv.data == b''\n        assert rv.mimetype == 'text\/html'\n\n        rv = flask.make_response(\n            flask.Response('', headers={'Content-Type': 'text\/html'}),\n            400, [('X-Foo', 'bar')])\n        assert rv.status_code == 400\n        assert rv.headers['Content-Type'] == 'text\/html'\n        assert rv.headers['X-Foo'] == 'bar'\n\n\ndef test_jsonify_no_prettyprint():\n    app = flask.Flask(__name__)\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": False})\n    with app.test_request_context():\n        compressed_msg = b'{\"msg\":{\"submsg\":\"W00t\"},\"msg2\":\"foobar\"}\\n'\n        uncompressed_msg = {\n            \"msg\": {\n                \"submsg\": \"W00t\"\n            },\n            \"msg2\": \"foobar\"\n            }\n\n        rv = flask.make_response(\n            flask.jsonify(uncompressed_msg), 200)\n        assert rv.data == compressed_msg\n\n\ndef test_jsonify_prettyprint():\n    app = flask.Flask(__name__)\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": True})\n    with app.test_request_context():\n        compressed_msg = {\"msg\":{\"submsg\":\"W00t\"},\"msg2\":\"foobar\"}\n        pretty_response =\\\n            b'{\\n  \"msg\": {\\n    \"submsg\": \"W00t\"\\n  }, \\n  \"msg2\": \"foobar\"\\n}\\n'\n\n        rv = flask.make_response(\n            flask.jsonify(compressed_msg), 200)\n        assert rv.data == pretty_response\n\n\ndef test_url_generation():\n    app = flask.Flask(__name__)\n\n    @app.route('\/hello\/<name>', methods=['POST'])\n    def hello():\n        pass\n    with app.test_request_context():\n        assert flask.url_for('hello', name='test x') == '\/hello\/test%20x'\n        assert flask.url_for('hello', name='test x', _external=True) == \\\n            'http:\/\/localhost\/hello\/test%20x'\n\n\ndef test_build_error_handler():\n    app = flask.Flask(__name__)\n\n    # Test base case, a URL which results in a BuildError.\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, 'spam')\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for('spam')\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError('Test case where BuildError is not current.')\n    except RuntimeError:\n        pytest.raises(\n            BuildError, app.handle_url_build_error, error, 'spam', {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return '\/test_handler\/'\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for('spam') == '\/test_handler\/'\n\n\ndef test_custom_converters():\n    from werkzeug.routing import BaseConverter\n\n    class ListConverter(BaseConverter):\n\n        def to_python(self, value):\n            return value.split(',')\n\n        def to_url(self, value):\n            base_to_url = super(ListConverter, self).to_url\n            return ','.join(base_to_url(x) for x in value)\n    app = flask.Flask(__name__)\n    app.url_map.converters['list'] = ListConverter\n\n    @app.route('\/<list:args>')\n    def index(args):\n        return '|'.join(args)\n    c = app.test_client()\n    assert c.get('\/1,2,3').data == b'1|2|3'\n\n\ndef test_static_files():\n    app = flask.Flask(__name__)\n    app.testing = True\n    rv = app.test_client().get('\/static\/index.html')\n    assert rv.status_code == 200\n    assert rv.data.strip() == b'<h1>Hello World!<\/h1>'\n    with app.test_request_context():\n        assert flask.url_for('static', filename='index.html') == \\\n            '\/static\/index.html'\n    rv.close()\n\n\ndef test_none_response():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route('\/')\n    def test():\n        return None\n    try:\n        app.test_client().get('\/')\n    except ValueError as e:\n        assert str(e) == 'View function did not return a response'\n        pass\n    else:\n        assert \"Expected ValueError\"\n\n\ndef test_request_locals():\n    assert repr(flask.g) == '<LocalProxy unbound>'\n    assert not flask.g\n\n\ndef test_test_app_proper_environ():\n    app = flask.Flask(__name__)\n    app.config.update(\n        SERVER_NAME='localhost.localdomain:5000'\n    )\n\n    @app.route('\/')\n    def index():\n        return 'Foo'\n\n    @app.route('\/', subdomain='foo')\n    def subdomain():\n        return 'Foo SubDomain'\n\n    rv = app.test_client().get('\/')\n    assert rv.data == b'Foo'\n\n    rv = app.test_client().get('\/', 'http:\/\/localhost.localdomain:5000')\n    assert rv.data == b'Foo'\n\n    rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain:5000')\n    assert rv.data == b'Foo'\n\n    app.config.update(SERVER_NAME='localhost.localdomain')\n    rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain')\n    assert rv.data == b'Foo'\n\n    try:\n        app.config.update(SERVER_NAME='localhost.localdomain:443')\n        rv = app.test_client().get('\/', 'https:\/\/localhost.localdomain')\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain:443') does not match the \"\n            \"server name from the WSGI environment ('localhost.localdomain')\"\n        )\n\n    try:\n        app.config.update(SERVER_NAME='localhost.localdomain')\n        rv = app.test_client().get('\/', 'http:\/\/foo.localhost')\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain') does not match the \"\n            \"server name from the WSGI environment ('foo.localhost')\"\n        )\n\n    rv = app.test_client().get('\/', 'http:\/\/foo.localhost.localdomain')\n    assert rv.data == b'Foo SubDomain'\n\n\ndef test_exception_propagation():\n    def apprunner(configkey):\n        app = flask.Flask(__name__)\n        app.config['LOGGER_HANDLER_POLICY'] = 'never'\n\n        @app.route('\/')\n        def index():\n            1 \/\/ 0\n        c = app.test_client()\n        if config_key is not None:\n            app.config[config_key] = True\n            try:\n                c.get('\/')\n            except Exception:\n                pass\n            else:\n                assert False, 'expected exception'\n        else:\n            assert c.get('\/').status_code == 500\n\n    # we have to run this test in an isolated thread because if the\n    # debug flag is set to true and an exception happens the context is\n    # not torn down.  This causes other tests that run after this fail\n    # when they expect no exception on the stack.\n    for config_key in 'TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', None:\n        t = Thread(target=apprunner, args=(config_key,))\n        t.start()\n        t.join()\n\n\ndef test_max_content_length():\n    app = flask.Flask(__name__)\n    app.config['MAX_CONTENT_LENGTH'] = 64\n\n    @app.before_request\n    def always_first():\n        flask.request.form['myfile']\n        assert False\n\n    @app.route('\/accept', methods=['POST'])\n    def accept_file():\n        flask.request.form['myfile']\n        assert False\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return '42'\n\n    c = app.test_client()\n    rv = c.post('\/accept', data={'myfile': 'foo' * 100})\n    assert rv.data == b'42'\n\n\ndef test_url_processors():\n    app = flask.Flask(__name__)\n\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and \\\n           app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n            values.setdefault('lang_code', flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop('lang_code', None)\n\n    @app.route('\/<lang_code>\/')\n    def index():\n        return flask.url_for('about')\n\n    @app.route('\/<lang_code>\/about')\n    def about():\n        return flask.url_for('something_else')\n\n    @app.route('\/foo')\n    def something_else():\n        return flask.url_for('about', lang_code='en')\n\n    c = app.test_client()\n\n    assert c.get('\/de\/').data == b'\/de\/about'\n    assert c.get('\/de\/about').data == b'\/foo'\n    assert c.get('\/foo').data == b'\/en\/about'\n\n\ndef test_inject_blueprint_url_defaults():\n    app = flask.Flask(__name__)\n    bp = flask.Blueprint('foo.bar.baz', __name__,\n                         template_folder='template')\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values['page'] = 'login'\n\n    @bp.route('\/<page>')\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults('foo.bar.baz.view', values)\n    expected = dict(page='login')\n    assert values == expected\n\n    with app.test_request_context('\/somepage'):\n        url = flask.url_for('foo.bar.baz.view')\n    expected = '\/login'\n    assert url == expected\n\n\ndef test_nonascii_pathinfo():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(u'\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442')\n    def index():\n        return 'Hello World!'\n\n    c = app.test_client()\n    rv = c.get(u'\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442')\n    assert rv.data == b'Hello World!'\n\n\ndef test_debug_mode_complains_after_first_request():\n    app = flask.Flask(__name__)\n    app.debug = True\n\n    @app.route('\/')\n    def index():\n        return 'Awesome'\n    assert not app.got_first_request\n    assert app.test_client().get('\/').data == b'Awesome'\n    try:\n        @app.route('\/foo')\n        def broken():\n            return 'Meh'\n    except AssertionError as e:\n        assert 'A setup function was called' in str(e)\n    else:\n        assert False, 'Expected exception'\n\n    app.debug = False\n\n    @app.route('\/foo')\n    def working():\n        return 'Meh'\n    assert app.test_client().get('\/foo').data == b'Meh'\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions():\n    got = []\n    app = flask.Flask(__name__)\n\n    @app.before_first_request\n    def foo():\n        got.append(42)\n    c = app.test_client()\n    c.get('\/')\n    assert got == [42]\n    c.get('\/')\n    assert got == [42]\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions_concurrent():\n    got = []\n    app = flask.Flask(__name__)\n\n    @app.before_first_request\n    def foo():\n        time.sleep(0.2)\n        got.append(42)\n\n    c = app.test_client()\n\n    def get_and_assert():\n        c.get(\"\/\")\n        assert got == [42]\n\n    t = Thread(target=get_and_assert)\n    t.start()\n    get_and_assert()\n    t.join()\n    assert app.got_first_request\n\n\ndef test_routing_redirect_debugging():\n    app = flask.Flask(__name__)\n    app.debug = True\n\n    @app.route('\/foo\/', methods=['GET', 'POST'])\n    def foo():\n        return 'success'\n    with app.test_client() as c:\n        try:\n            c.post('\/foo', data={})\n        except AssertionError as e:\n            assert 'http:\/\/localhost\/foo\/' in str(e)\n            assert ('Make sure to directly send '\n                    'your POST-request to this URL') in str(e)\n        else:\n            assert False, 'Expected exception'\n\n        rv = c.get('\/foo', data={}, follow_redirects=True)\n        assert rv.data == b'success'\n\n    app.debug = False\n    with app.test_client() as c:\n        rv = c.post('\/foo', data={}, follow_redirects=True)\n        assert rv.data == b'success'\n\n\ndef test_route_decorator_custom_endpoint():\n    app = flask.Flask(__name__)\n    app.debug = True\n\n    @app.route('\/foo\/')\n    def foo():\n        return flask.request.endpoint\n\n    @app.route('\/bar\/', endpoint='bar')\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route('\/bar\/123', endpoint='123')\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for('foo') == '\/foo\/'\n        assert flask.url_for('bar') == '\/bar\/'\n        assert flask.url_for('123') == '\/bar\/123'\n\n    c = app.test_client()\n    assert c.get('\/foo\/').data == b'foo'\n    assert c.get('\/bar\/').data == b'bar'\n    assert c.get('\/bar\/123').data == b'123'\n\n\ndef test_preserve_only_once():\n    app = flask.Flask(__name__)\n    app.debug = True\n\n    @app.route('\/fail')\n    def fail_func():\n        1 \/\/ 0\n\n    c = app.test_client()\n    for x in range(3):\n        with pytest.raises(ZeroDivisionError):\n            c.get('\/fail')\n\n    assert flask._request_ctx_stack.top is not None\n    assert flask._app_ctx_stack.top is not None\n    # implicit appctx disappears too\n    flask._request_ctx_stack.top.pop()\n    assert flask._request_ctx_stack.top is None\n    assert flask._app_ctx_stack.top is None\n\n\ndef test_preserve_remembers_exception():\n    app = flask.Flask(__name__)\n    app.debug = True\n    errors = []\n\n    @app.route('\/fail')\n    def fail_func():\n        1 \/\/ 0\n\n    @app.route('\/success')\n    def success_func():\n        return 'Okay'\n\n    @app.teardown_request\n    def teardown_handler(exc):\n        errors.append(exc)\n\n    c = app.test_client()\n\n    # After this failure we did not yet call the teardown handler\n    with pytest.raises(ZeroDivisionError):\n        c.get('\/fail')\n    assert errors == []\n\n    # But this request triggers it, and it's an error\n    c.get('\/success')\n    assert len(errors) == 2\n    assert isinstance(errors[0], ZeroDivisionError)\n\n    # At this point another request does nothing.\n    c.get('\/success')\n    assert len(errors) == 3\n    assert errors[1] is None\n\n\ndef test_get_method_on_g():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    with app.app_context():\n        assert flask.g.get('x') is None\n        assert flask.g.get('x', 11) == 11\n        flask.g.x = 42\n        assert flask.g.get('x') == 42\n        assert flask.g.x == 42\n\n\ndef test_g_iteration_protocol():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    with app.app_context():\n        flask.g.foo = 23\n        flask.g.bar = 42\n        assert 'foo' in flask.g\n        assert 'foos' not in flask.g\n        assert sorted(flask.g) == ['bar', 'foo']\n\n\ndef test_subdomain_basic_support():\n    app = flask.Flask(__name__)\n    app.config['SERVER_NAME'] = 'localhost'\n\n    @app.route('\/')\n    def normal_index():\n        return 'normal index'\n\n    @app.route('\/', subdomain='test')\n    def test_index():\n        return 'test index'\n\n    c = app.test_client()\n    rv = c.get('\/', 'http:\/\/localhost\/')\n    assert rv.data == b'normal index'\n\n    rv = c.get('\/', 'http:\/\/test.localhost\/')\n    assert rv.data == b'test index'\n\n\ndef test_subdomain_matching():\n    app = flask.Flask(__name__)\n    app.config['SERVER_NAME'] = 'localhost'\n\n    @app.route('\/', subdomain='<user>')\n    def index(user):\n        return 'index for %s' % user\n\n    c = app.test_client()\n    rv = c.get('\/', 'http:\/\/mitsuhiko.localhost\/')\n    assert rv.data == b'index for mitsuhiko'\n\n\ndef test_subdomain_matching_with_ports():\n    app = flask.Flask(__name__)\n    app.config['SERVER_NAME'] = 'localhost:3000'\n\n    @app.route('\/', subdomain='<user>')\n    def index(user):\n        return 'index for %s' % user\n\n    c = app.test_client()\n    rv = c.get('\/', 'http:\/\/mitsuhiko.localhost:3000\/')\n    assert rv.data == b'index for mitsuhiko'\n\n\ndef test_multi_route_rules():\n    app = flask.Flask(__name__)\n\n    @app.route('\/')\n    @app.route('\/<test>\/')\n    def index(test='a'):\n        return test\n\n    rv = app.test_client().open('\/')\n    assert rv.data == b'a'\n    rv = app.test_client().open('\/b\/')\n    assert rv.data == b'b'\n\n\ndef test_multi_route_class_views():\n    class View(object):\n\n        def __init__(self, app):\n            app.add_url_rule('\/', 'index', self.index)\n            app.add_url_rule('\/<test>\/', 'index', self.index)\n\n        def index(self, test='a'):\n            return test\n\n    app = flask.Flask(__name__)\n    _ = View(app)\n    rv = app.test_client().open('\/')\n    assert rv.data == b'a'\n    rv = app.test_client().open('\/b\/')\n    assert rv.data == b'b'\n\n\ndef test_run_defaults(monkeypatch):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv['result'] = 'running...'\n\n    app = flask.Flask(__name__)\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n    app.run()\n    assert rv['result'] == 'running...'\n\n\ndef test_run_server_port(monkeypatch):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(hostname, port, application, *args, **kwargs):\n        rv['result'] = 'running on %s:%s ...' % (hostname, port)\n\n    app = flask.Flask(__name__)\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n    hostname, port = 'localhost', 8000\n    app.run(hostname, port, debug=True)\n    assert rv['result'] == 'running on %s:%s ...' % (hostname, port)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.blueprints\n    ~~~~~~~~~~~~~~~~\n\n    Blueprints (and currently modules)\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\n\nfrom flask._compat import text_type\nfrom werkzeug.http import parse_cache_control_header\nfrom jinja2 import TemplateNotFound\n\n\ndef test_blueprint_specific_error_handling():\n    frontend = flask.Blueprint('frontend', __name__)\n    backend = flask.Blueprint('backend', __name__)\n    sideend = flask.Blueprint('sideend', __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return 'frontend says no', 403\n\n    @frontend.route('\/frontend-no')\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return 'backend says no', 403\n\n    @backend.route('\/backend-no')\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route('\/what-is-a-sideend')\n    def sideend_no():\n        flask.abort(403)\n\n    app = flask.Flask(__name__)\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return 'application itself says no', 403\n\n    c = app.test_client()\n\n    assert c.get('\/frontend-no').data == b'frontend says no'\n    assert c.get('\/backend-no').data == b'backend says no'\n    assert c.get('\/what-is-a-sideend').data == b'application itself says no'\n\ndef test_blueprint_specific_user_error_handling():\n    class MyDecoratorException(Exception):\n        pass\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint('blue', __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return 'boom'\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return 'bam'\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route('\/decorator')\n    def blue_deco_test():\n        raise MyDecoratorException()\n    @blue.route('\/function')\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app = flask.Flask(__name__)\n    app.register_blueprint(blue)\n\n    c = app.test_client()\n\n    assert c.get('\/decorator').data == b'boom'\n    assert c.get('\/function').data == b'bam'\n\ndef test_blueprint_url_definitions():\n    bp = flask.Blueprint('test', __name__)\n\n    @bp.route('\/foo', defaults={'baz': 42})\n    def foo(bar, baz):\n        return '%s\/%d' % (bar, baz)\n\n    @bp.route('\/bar')\n    def bar(bar):\n        return text_type(bar)\n\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/1', url_defaults={'bar': 23})\n    app.register_blueprint(bp, url_prefix='\/2', url_defaults={'bar': 19})\n\n    c = app.test_client()\n    assert c.get('\/1\/foo').data == b'23\/42'\n    assert c.get('\/2\/foo').data == b'19\/42'\n    assert c.get('\/1\/bar').data == b'23'\n    assert c.get('\/2\/bar').data == b'19'\n\ndef test_blueprint_url_processors():\n    bp = flask.Blueprint('frontend', __name__, url_prefix='\/<lang_code>')\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault('lang_code', flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop('lang_code')\n\n    @bp.route('\/')\n    def index():\n        return flask.url_for('.about')\n\n    @bp.route('\/about')\n    def about():\n        return flask.url_for('.index')\n\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp)\n\n    c = app.test_client()\n\n    assert c.get('\/de\/').data == b'\/de\/about'\n    assert c.get('\/de\/about').data == b'\/de\/'\n\ndef test_templates_and_static(test_apps):\n    from blueprintapp import app\n    c = app.test_client()\n\n    rv = c.get('\/')\n    assert rv.data == b'Hello from the Frontend'\n    rv = c.get('\/admin\/')\n    assert rv.data == b'Hello from the Admin'\n    rv = c.get('\/admin\/index2')\n    assert rv.data == b'Hello from the Admin'\n    rv = c.get('\/admin\/static\/test.txt')\n    assert rv.data.strip() == b'Admin File'\n    rv.close()\n    rv = c.get('\/admin\/static\/css\/test.css')\n    assert rv.data.strip() == b'\/* nested file *\/'\n    rv.close()\n\n    # try\/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n    try:\n        expected_max_age = 3600\n        if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == expected_max_age:\n            expected_max_age = 7200\n        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = expected_max_age\n        rv = c.get('\/admin\/static\/css\/test.css')\n        cc = parse_cache_control_header(rv.headers['Cache-Control'])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n    with app.test_request_context():\n        assert flask.url_for('admin.static', filename='test.txt') == '\/admin\/static\/test.txt'\n\n    with app.test_request_context():\n        try:\n            flask.render_template('missing.html')\n        except TemplateNotFound as e:\n            assert e.name == 'missing.html'\n        else:\n            assert 0, 'expected exception'\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template('nested\/nested.txt') == 'I\\'m nested'\n\ndef test_default_static_cache_timeout():\n    app = flask.Flask(__name__)\n    class MyBlueprint(flask.Blueprint):\n        def get_send_file_max_age(self, filename):\n            return 100\n\n    blueprint = MyBlueprint('blueprint', __name__, static_folder='static')\n    app.register_blueprint(blueprint)\n\n    # try\/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n    try:\n        with app.test_request_context():\n            unexpected_max_age = 3600\n            if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == unexpected_max_age:\n                unexpected_max_age = 7200\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = unexpected_max_age\n            rv = blueprint.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\ndef test_templates_list(test_apps):\n    from blueprintapp import app\n    templates = sorted(app.jinja_env.list_templates())\n    assert templates == ['admin\/index.html', 'frontend\/index.html']\n\ndef test_dotted_names():\n    frontend = flask.Blueprint('myapp.frontend', __name__)\n    backend = flask.Blueprint('myapp.backend', __name__)\n\n    @frontend.route('\/fe')\n    def frontend_index():\n        return flask.url_for('myapp.backend.backend_index')\n\n    @frontend.route('\/fe2')\n    def frontend_page2():\n        return flask.url_for('.frontend_index')\n\n    @backend.route('\/be')\n    def backend_index():\n        return flask.url_for('myapp.frontend.frontend_index')\n\n    app = flask.Flask(__name__)\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n\n    c = app.test_client()\n    assert c.get('\/fe').data.strip() == b'\/be'\n    assert c.get('\/fe2').data.strip() == b'\/fe'\n    assert c.get('\/be').data.strip() == b'\/fe'\n\ndef test_dotted_names_from_app():\n    app = flask.Flask(__name__)\n    app.testing = True\n    test = flask.Blueprint('test', __name__)\n\n    @app.route('\/')\n    def app_index():\n        return flask.url_for('test.index')\n\n    @test.route('\/test\/')\n    def index():\n        return flask.url_for('app_index')\n\n    app.register_blueprint(test)\n\n    with app.test_client() as c:\n        rv = c.get('\/')\n        assert rv.data == b'\/test\/'\n\ndef test_empty_url_defaults():\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.route('\/', defaults={'page': 1})\n    @bp.route('\/page\/<int:page>')\n    def something(page):\n        return str(page)\n\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp)\n\n    c = app.test_client()\n    assert c.get('\/').data == b'1'\n    assert c.get('\/page\/2').data == b'2'\n\ndef test_route_decorator_custom_endpoint():\n\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.route('\/foo')\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route('\/bar', endpoint='bar')\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route('\/bar\/123', endpoint='123')\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route('\/bar\/foo')\n    def bar_foo():\n        return flask.request.endpoint\n\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    @app.route('\/')\n    def index():\n        return flask.request.endpoint\n\n    c = app.test_client()\n    assert c.get('\/').data == b'index'\n    assert c.get('\/py\/foo').data == b'bp.foo'\n    assert c.get('\/py\/bar').data == b'bp.bar'\n    assert c.get('\/py\/bar\/123').data == b'bp.123'\n    assert c.get('\/py\/bar\/foo').data == b'bp.bar_foo'\n\ndef test_route_decorator_custom_endpoint_with_dots():\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.route('\/foo')\n    def foo():\n        return flask.request.endpoint\n\n    try:\n        @bp.route('\/bar', endpoint='bar.bar')\n        def foo_bar():\n            return flask.request.endpoint\n    except AssertionError:\n        pass\n    else:\n        raise AssertionError('expected AssertionError not raised')\n\n    try:\n        @bp.route('\/bar\/123', endpoint='bar.123')\n        def foo_bar_foo():\n            return flask.request.endpoint\n    except AssertionError:\n        pass\n    else:\n        raise AssertionError('expected AssertionError not raised')\n\n    def foo_foo_foo():\n        pass\n\n    pytest.raises(\n        AssertionError,\n        lambda: bp.add_url_rule(\n            '\/bar\/123', endpoint='bar.123', view_func=foo_foo_foo\n        )\n    )\n\n    pytest.raises(\n        AssertionError,\n        bp.route('\/bar\/123', endpoint='bar.123'),\n        lambda: None\n    )\n\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    c = app.test_client()\n    assert c.get('\/py\/foo').data == b'bp.foo'\n    # The rule's didn't actually made it through\n    rv = c.get('\/py\/bar')\n    assert rv.status_code == 404\n    rv = c.get('\/py\/bar\/123')\n    assert rv.status_code == 404\n\ndef test_template_filter():\n    bp = flask.Blueprint('bp', __name__)\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\ndef test_add_template_filter():\n    bp = flask.Blueprint('bp', __name__)\n    def my_reverse(s):\n        return s[::-1]\n    bp.add_app_template_filter(my_reverse)\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\ndef test_template_filter_with_name():\n    bp = flask.Blueprint('bp', __name__)\n    @bp.app_template_filter('strrev')\n    def my_reverse(s):\n        return s[::-1]\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\ndef test_add_template_filter_with_name():\n    bp = flask.Blueprint('bp', __name__)\n    def my_reverse(s):\n        return s[::-1]\n    bp.add_app_template_filter(my_reverse, 'strrev')\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\ndef test_template_filter_with_template():\n    bp = flask.Blueprint('bp', __name__)\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_template_filter_after_route_with_template():\n    app = flask.Flask(__name__)\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    bp = flask.Blueprint('bp', __name__)\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n    app.register_blueprint(bp, url_prefix='\/py')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_add_template_filter_with_template():\n    bp = flask.Blueprint('bp', __name__)\n    def super_reverse(s):\n        return s[::-1]\n    bp.add_app_template_filter(super_reverse)\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_template_filter_with_name_and_template():\n    bp = flask.Blueprint('bp', __name__)\n    @bp.app_template_filter('super_reverse')\n    def my_reverse(s):\n        return s[::-1]\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_add_template_filter_with_name_and_template():\n    bp = flask.Blueprint('bp', __name__)\n    def my_reverse(s):\n        return s[::-1]\n    bp.add_app_template_filter(my_reverse, 'super_reverse')\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_template_test():\n    bp = flask.Blueprint('bp', __name__)\n    @bp.app_template_test()\n    def is_boolean(value):\n        return isinstance(value, bool)\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'is_boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['is_boolean'] == is_boolean\n    assert app.jinja_env.tests['is_boolean'](False)\n\ndef test_add_template_test():\n    bp = flask.Blueprint('bp', __name__)\n    def is_boolean(value):\n        return isinstance(value, bool)\n    bp.add_app_template_test(is_boolean)\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'is_boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['is_boolean'] == is_boolean\n    assert app.jinja_env.tests['is_boolean'](False)\n\ndef test_template_test_with_name():\n    bp = flask.Blueprint('bp', __name__)\n    @bp.app_template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\ndef test_add_template_test_with_name():\n    bp = flask.Blueprint('bp', __name__)\n    def is_boolean(value):\n        return isinstance(value, bool)\n    bp.add_app_template_test(is_boolean, 'boolean')\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\ndef test_template_test_with_template():\n    bp = flask.Blueprint('bp', __name__)\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_template_test_after_route_with_template():\n    app = flask.Flask(__name__)\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    bp = flask.Blueprint('bp', __name__)\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n    app.register_blueprint(bp, url_prefix='\/py')\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_add_template_test_with_template():\n    bp = flask.Blueprint('bp', __name__)\n    def boolean(value):\n        return isinstance(value, bool)\n    bp.add_app_template_test(boolean)\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_template_test_with_name_and_template():\n    bp = flask.Blueprint('bp', __name__)\n    @bp.app_template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_add_template_test_with_name_and_template():\n    bp = flask.Blueprint('bp', __name__)\n    def is_boolean(value):\n        return isinstance(value, bool)\n    bp.add_app_template_test(is_boolean, 'boolean')\n    app = flask.Flask(__name__)\n    app.register_blueprint(bp, url_prefix='\/py')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_config\n    ~~~~~~~~~~~~~~~~~\n\n    :copyright: (c) 2015 by the Flask Team, see AUTHORS for more details.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport os\nimport flask\n\n\n# config keys used for the TestConfig\nTEST_KEY = 'foo'\nSECRET_KEY = 'devkey'\n\n\ndef common_object_test(app):\n    assert app.secret_key == 'devkey'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config\n\n\ndef test_config_from_file():\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(__file__.rsplit('.', 1)[0] + '.py')\n    common_object_test(app)\n\n\ndef test_config_from_object():\n    app = flask.Flask(__name__)\n    app.config.from_object(__name__)\n    common_object_test(app)\n\n\ndef test_config_from_json():\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_json(os.path.join(current_dir, 'static', 'config.json'))\n    common_object_test(app)\n\n\ndef test_config_from_mapping():\n    app = flask.Flask(__name__)\n    app.config.from_mapping({\n        'SECRET_KEY': 'devkey',\n        'TEST_KEY': 'foo'\n    })\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([\n        ('SECRET_KEY', 'devkey'),\n        ('TEST_KEY', 'foo')\n    ])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(\n        SECRET_KEY='devkey',\n        TEST_KEY='foo'\n    )\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping(\n            {}, {}\n        )\n\n\ndef test_config_from_class():\n    class Base(object):\n        TEST_KEY = 'foo'\n\n    class Test(Base):\n        SECRET_KEY = 'devkey'\n    app = flask.Flask(__name__)\n    app.config.from_object(Test)\n    common_object_test(app)\n\n\ndef test_config_from_envvar():\n    env = os.environ\n    try:\n        os.environ = {}\n        app = flask.Flask(__name__)\n        try:\n            app.config.from_envvar('FOO_SETTINGS')\n        except RuntimeError as e:\n            assert \"'FOO_SETTINGS' is not set\" in str(e)\n        else:\n            assert 0, 'expected exception'\n        assert not app.config.from_envvar('FOO_SETTINGS', silent=True)\n\n        os.environ = {'FOO_SETTINGS': __file__.rsplit('.', 1)[0] + '.py'}\n        assert app.config.from_envvar('FOO_SETTINGS')\n        common_object_test(app)\n    finally:\n        os.environ = env\n\n\ndef test_config_from_envvar_missing():\n    env = os.environ\n    try:\n        os.environ = {'FOO_SETTINGS': 'missing.cfg'}\n        try:\n            app = flask.Flask(__name__)\n            app.config.from_envvar('FOO_SETTINGS')\n        except IOError as e:\n            msg = str(e)\n            assert msg.startswith('[Errno 2] Unable to load configuration '\n                                  'file (No such file or directory):')\n            assert msg.endswith(\"missing.cfg'\")\n        else:\n            assert False, 'expected IOError'\n        assert not app.config.from_envvar('FOO_SETTINGS', silent=True)\n    finally:\n        os.environ = env\n\n\ndef test_config_missing():\n    app = flask.Flask(__name__)\n    try:\n        app.config.from_pyfile('missing.cfg')\n    except IOError as e:\n        msg = str(e)\n        assert msg.startswith('[Errno 2] Unable to load configuration '\n                              'file (No such file or directory):')\n        assert msg.endswith(\"missing.cfg'\")\n    else:\n        assert 0, 'expected config'\n    assert not app.config.from_pyfile('missing.cfg', silent=True)\n\n\ndef test_config_missing_json():\n    app = flask.Flask(__name__)\n    try:\n        app.config.from_json('missing.json')\n    except IOError as e:\n        msg = str(e)\n        assert msg.startswith('[Errno 2] Unable to load configuration '\n                              'file (No such file or directory):')\n        assert msg.endswith(\"missing.json'\")\n    else:\n        assert 0, 'expected config'\n    assert not app.config.from_json('missing.json', silent=True)\n\n\ndef test_custom_config_class():\n    class Config(flask.Config):\n        pass\n\n    class Flask(flask.Flask):\n        config_class = Config\n    app = Flask(__name__)\n    assert isinstance(app.config, Config)\n    app.config.from_object(__name__)\n    common_object_test(app)\n\n\ndef test_session_lifetime():\n    app = flask.Flask(__name__)\n    app.config['PERMANENT_SESSION_LIFETIME'] = 42\n    assert app.permanent_session_lifetime.seconds == 42\n\n\ndef test_get_namespace():\n    app = flask.Flask(__name__)\n    app.config['FOO_OPTION_1'] = 'foo option 1'\n    app.config['FOO_OPTION_2'] = 'foo option 2'\n    app.config['BAR_STUFF_1'] = 'bar stuff 1'\n    app.config['BAR_STUFF_2'] = 'bar stuff 2'\n    foo_options = app.config.get_namespace('FOO_')\n    assert 2 == len(foo_options)\n    assert 'foo option 1' == foo_options['option_1']\n    assert 'foo option 2' == foo_options['option_2']\n    bar_options = app.config.get_namespace('BAR_', lowercase=False)\n    assert 2 == len(bar_options)\n    assert 'bar stuff 1' == bar_options['STUFF_1']\n    assert 'bar stuff 2' == bar_options['STUFF_2']\n    foo_options = app.config.get_namespace('FOO_', trim_namespace=False)\n    assert 2 == len(foo_options)\n    assert 'foo option 1' == foo_options['foo_option_1']\n    assert 'foo option 2' == foo_options['foo_option_2']\n    bar_options = app.config.get_namespace('BAR_', lowercase=False, trim_namespace=False)\n    assert 2 == len(bar_options)\n    assert 'bar stuff 1' == bar_options['BAR_STUFF_1']\n    assert 'bar stuff 2' == bar_options['BAR_STUFF_2']\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.deprecations\n    ~~~~~~~~~~~~~~~~~~\n\n    Tests deprecation support. Not used currently.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\n\n\nclass TestRequestDeprecation(object):\n\n    def test_request_json(self, catch_deprecation_warnings):\n        \"\"\"Request.json is deprecated\"\"\"\n        app = flask.Flask(__name__)\n        app.testing = True\n\n        @app.route('\/', methods=['POST'])\n        def index():\n            assert flask.request.json == {'spam': 42}\n            print(flask.request.json)\n            return 'OK'\n\n        with catch_deprecation_warnings() as captured:\n            c = app.test_client()\n            c.post('\/', data='{\"spam\": 42}', content_type='application\/json')\n\n        assert len(captured) == 1\n\n    def test_request_module(self, catch_deprecation_warnings):\n        \"\"\"Request.module is deprecated\"\"\"\n        app = flask.Flask(__name__)\n        app.testing = True\n\n        @app.route('\/')\n        def index():\n            assert flask.request.module is None\n            return 'OK'\n\n        with catch_deprecation_warnings() as captured:\n            c = app.test_client()\n            c.get('\/')\n\n        assert len(captured) == 1\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.helpers\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Various helpers.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport os\nimport flask\nfrom logging import StreamHandler\nfrom werkzeug.http import parse_cache_control_header, parse_options_header\nfrom flask._compat import StringIO, text_type\n\n\ndef has_encoding(name):\n    try:\n        import codecs\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n\n\nclass TestJSON(object):\n\n    def test_json_bad_requests(self):\n        app = flask.Flask(__name__)\n        @app.route('\/json', methods=['POST'])\n        def return_json():\n            return flask.jsonify(foo=text_type(flask.request.get_json()))\n        c = app.test_client()\n        rv = c.post('\/json', data='malformed', content_type='application\/json')\n        assert rv.status_code == 400\n\n    def test_json_custom_mimetypes(self):\n        app = flask.Flask(__name__)\n        @app.route('\/json', methods=['POST'])\n        def return_json():\n            return flask.request.get_json()\n        c = app.test_client()\n        rv = c.post('\/json', data='\"foo\"', content_type='application\/x+json')\n        assert rv.data == b'foo'\n\n    def test_json_body_encoding(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            return flask.request.get_json()\n\n        c = app.test_client()\n        resp = c.get('\/', data=u'\"H\u00e4llo W\u00f6rld\"'.encode('iso-8859-15'),\n                     content_type='application\/json; charset=iso-8859-15')\n        assert resp.data == u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n\n    def test_jsonify(self):\n        d = dict(a=23, b=42, c=[1, 2, 3])\n        app = flask.Flask(__name__)\n        @app.route('\/kw')\n        def return_kwargs():\n            return flask.jsonify(**d)\n        @app.route('\/dict')\n        def return_dict():\n            return flask.jsonify(d)\n        c = app.test_client()\n        for url in '\/kw', '\/dict':\n            rv = c.get(url)\n            assert rv.mimetype == 'application\/json'\n            assert flask.json.loads(rv.data) == d\n\n    def test_json_as_unicode(self):\n        app = flask.Flask(__name__)\n\n        app.config['JSON_AS_ASCII'] = True\n        with app.app_context():\n            rv = flask.json.dumps(u'\\N{SNOWMAN}')\n            assert rv == '\"\\\\u2603\"'\n\n        app.config['JSON_AS_ASCII'] = False\n        with app.app_context():\n            rv = flask.json.dumps(u'\\N{SNOWMAN}')\n            assert rv == u'\"\\u2603\"'\n\n    def test_json_attr(self):\n        app = flask.Flask(__name__)\n        @app.route('\/add', methods=['POST'])\n        def add():\n            json = flask.request.get_json()\n            return text_type(json['a'] + json['b'])\n        c = app.test_client()\n        rv = c.post('\/add', data=flask.json.dumps({'a': 1, 'b': 2}),\n                            content_type='application\/json')\n        assert rv.data == b'3'\n\n    def test_template_escaping(self):\n        app = flask.Flask(__name__)\n        render = flask.render_template_string\n        with app.test_request_context():\n            rv = flask.json.htmlsafe_dumps('<\/script>')\n            assert rv == u'\"\\\\u003c\/script\\\\u003e\"'\n            assert type(rv) == text_type\n            rv = render('{{ \"<\/script>\"|tojson }}')\n            assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n            rv = render('{{ \"<\\0\/script>\"|tojson }}')\n            assert rv == '\"\\\\u003c\\\\u0000\/script\\\\u003e\"'\n            rv = render('{{ \"<!--<script>\"|tojson }}')\n            assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n            rv = render('{{ \"&\"|tojson }}')\n            assert rv == '\"\\\\u0026\"'\n            rv = render('{{ \"\\'\"|tojson }}')\n            assert rv == '\"\\\\u0027\"'\n            rv = render(\"<a ng-data='{{ data|tojson }}'><\/a>\",\n                data={'x': [\"foo\", \"bar\", \"baz'\"]})\n            assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'><\/a>'\n\n    def test_json_customization(self):\n        class X(object):\n            def __init__(self, val):\n                self.val = val\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return '<%d>' % o.val\n                return flask.json.JSONEncoder.default(self, o)\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault('object_hook', self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n            def object_hook(self, obj):\n                if len(obj) == 1 and '_foo' in obj:\n                    return X(obj['_foo'])\n                return obj\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n        @app.route('\/', methods=['POST'])\n        def index():\n            return flask.json.dumps(flask.request.get_json()['x'])\n        c = app.test_client()\n        rv = c.post('\/', data=flask.json.dumps({\n            'x': {'_foo': 42}\n        }), content_type='application\/json')\n        assert rv.data == b'\"<42>\"'\n\n    def test_modified_url_encoding(self):\n        class ModifiedRequest(flask.Request):\n            url_charset = 'euc-kr'\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.request_class = ModifiedRequest\n        app.url_map.charset = 'euc-kr'\n\n        @app.route('\/')\n        def index():\n            return flask.request.args['foo']\n\n        rv = app.test_client().get(u'\/?foo=\uc815\uc0c1\ucc98\ub9ac'.encode('euc-kr'))\n        assert rv.status_code == 200\n        assert rv.data == u'\uc815\uc0c1\ucc98\ub9ac'.encode('utf-8')\n\n    if not has_encoding('euc-kr'):\n        test_modified_url_encoding = None\n\n    def test_json_key_sorting(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        assert app.config['JSON_SORT_KEYS'] == True\n        d = dict.fromkeys(range(20), 'foo')\n\n        @app.route('\/')\n        def index():\n            return flask.jsonify(values=d)\n\n        c = app.test_client()\n        rv = c.get('\/')\n        lines = [x.strip() for x in rv.data.strip().decode('utf-8').splitlines()]\n        sorted_by_str = [\n            '{',\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\"',\n            '}',\n            '}'\n        ]\n        sorted_by_int = [\n            '{',\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\"',\n            '}',\n            '}'\n        ]\n\n        try:\n            assert lines == sorted_by_int\n        except AssertionError:\n            assert lines == sorted_by_str\n\nclass TestSendfile(object):\n\n    def test_send_file_regular(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.send_file('static\/index.html')\n            assert rv.direct_passthrough\n            assert rv.mimetype == 'text\/html'\n            with app.open_resource('static\/index.html') as f:\n                rv.direct_passthrough = False\n                assert rv.data == f.read()\n            rv.close()\n\n    def test_send_file_xsendfile(self):\n        app = flask.Flask(__name__)\n        app.use_x_sendfile = True\n        with app.test_request_context():\n            rv = flask.send_file('static\/index.html')\n            assert rv.direct_passthrough\n            assert 'x-sendfile' in rv.headers\n            assert rv.headers['x-sendfile'] == \\\n                os.path.join(app.root_path, 'static\/index.html')\n            assert rv.mimetype == 'text\/html'\n            rv.close()\n\n    def test_send_file_object(self, catch_deprecation_warnings):\n        app = flask.Flask(__name__)\n        with catch_deprecation_warnings() as captured:\n            with app.test_request_context():\n                f = open(os.path.join(app.root_path, 'static\/index.html'), mode='rb')\n                rv = flask.send_file(f)\n                rv.direct_passthrough = False\n                with app.open_resource('static\/index.html') as f:\n                    assert rv.data == f.read()\n                assert rv.mimetype == 'text\/html'\n                rv.close()\n            # mimetypes + etag\n            assert len(captured) == 2\n\n        app.use_x_sendfile = True\n        with catch_deprecation_warnings() as captured:\n            with app.test_request_context():\n                f = open(os.path.join(app.root_path, 'static\/index.html'))\n                rv = flask.send_file(f)\n                assert rv.mimetype == 'text\/html'\n                assert 'x-sendfile' in rv.headers\n                assert rv.headers['x-sendfile'] == \\\n                    os.path.join(app.root_path, 'static\/index.html')\n                rv.close()\n            # mimetypes + etag\n            assert len(captured) == 2\n\n        app.use_x_sendfile = False\n        with app.test_request_context():\n            with catch_deprecation_warnings() as captured:\n                f = StringIO('Test')\n                rv = flask.send_file(f)\n                rv.direct_passthrough = False\n                assert rv.data == b'Test'\n                assert rv.mimetype == 'application\/octet-stream'\n                rv.close()\n            # etags\n            assert len(captured) == 1\n            with catch_deprecation_warnings() as captured:\n                class PyStringIO(object):\n                    def __init__(self, *args, **kwargs):\n                        self._io = StringIO(*args, **kwargs)\n                    def __getattr__(self, name):\n                        return getattr(self._io, name)\n                f = PyStringIO('Test')\n                f.name = 'test.txt'\n                rv = flask.send_file(f)\n                rv.direct_passthrough = False\n                assert rv.data == b'Test'\n                assert rv.mimetype == 'text\/plain'\n                rv.close()\n            # attachment_filename and etags\n            assert len(captured) == 3\n            with catch_deprecation_warnings() as captured:\n                f = StringIO('Test')\n                rv = flask.send_file(f, mimetype='text\/plain')\n                rv.direct_passthrough = False\n                assert rv.data == b'Test'\n                assert rv.mimetype == 'text\/plain'\n                rv.close()\n            # etags\n            assert len(captured) == 1\n\n        app.use_x_sendfile = True\n        with catch_deprecation_warnings() as captured:\n            with app.test_request_context():\n                f = StringIO('Test')\n                rv = flask.send_file(f)\n                assert 'x-sendfile' not in rv.headers\n                rv.close()\n            # etags\n            assert len(captured) == 1\n\n    def test_attachment(self, catch_deprecation_warnings):\n        app = flask.Flask(__name__)\n        with catch_deprecation_warnings() as captured:\n            with app.test_request_context():\n                f = open(os.path.join(app.root_path, 'static\/index.html'))\n                rv = flask.send_file(f, as_attachment=True)\n                value, options = parse_options_header(rv.headers['Content-Disposition'])\n                assert value == 'attachment'\n                rv.close()\n            # mimetypes + etag\n            assert len(captured) == 2\n\n        with app.test_request_context():\n            assert options['filename'] == 'index.html'\n            rv = flask.send_file('static\/index.html', as_attachment=True)\n            value, options = parse_options_header(rv.headers['Content-Disposition'])\n            assert value == 'attachment'\n            assert options['filename'] == 'index.html'\n            rv.close()\n\n        with app.test_request_context():\n            rv = flask.send_file(StringIO('Test'), as_attachment=True,\n                                 attachment_filename='index.txt',\n                                 add_etags=False)\n            assert rv.mimetype == 'text\/plain'\n            value, options = parse_options_header(rv.headers['Content-Disposition'])\n            assert value == 'attachment'\n            assert options['filename'] == 'index.txt'\n            rv.close()\n\n    def test_static_file(self):\n        app = flask.Flask(__name__)\n        # default cache timeout is 12 hours\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 12 * 60 * 60\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 12 * 60 * 60\n            rv.close()\n        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 3600\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 3600\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 3600\n            rv.close()\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 10\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 10\n            rv.close()\n\n    def test_send_from_directory(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.root_path = os.path.join(os.path.dirname(__file__),\n                                     'test_apps', 'subdomaintestmodule')\n        with app.test_request_context():\n            rv = flask.send_from_directory('static', 'hello.txt')\n            rv.direct_passthrough = False\n            assert rv.data.strip() == b'Hello Subdomain'\n            rv.close()\n\n\nclass TestLogging(object):\n\n    def test_logger_cache(self):\n        app = flask.Flask(__name__)\n        logger1 = app.logger\n        assert app.logger is logger1\n        assert logger1.name == __name__\n        app.logger_name = __name__ + '\/test_logger_cache'\n        assert app.logger is not logger1\n\n    def test_debug_log(self, capsys):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        @app.route('\/')\n        def index():\n            app.logger.warning('the standard library is dead')\n            app.logger.debug('this is a debug statement')\n            return ''\n\n        @app.route('\/exc')\n        def exc():\n            1 \/\/ 0\n\n        with app.test_client() as c:\n            c.get('\/')\n            out, err = capsys.readouterr()\n            assert 'WARNING in test_helpers [' in err\n            assert os.path.basename(__file__.rsplit('.', 1)[0] + '.py') in err\n            assert 'the standard library is dead' in err\n            assert 'this is a debug statement' in err\n\n            with pytest.raises(ZeroDivisionError):\n                c.get('\/exc')\n\n    def test_debug_log_override(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        app.logger_name = 'flask_tests\/test_debug_log_override'\n        app.logger.level = 10\n        assert app.logger.level == 10\n\n    def test_exception_logging(self):\n        out = StringIO()\n        app = flask.Flask(__name__)\n        app.config['LOGGER_HANDLER_POLICY'] = 'never'\n        app.logger_name = 'flask_tests\/test_exception_logging'\n        app.logger.addHandler(StreamHandler(out))\n\n        @app.route('\/')\n        def index():\n            1 \/\/ 0\n\n        rv = app.test_client().get('\/')\n        assert rv.status_code == 500\n        assert b'Internal Server Error' in rv.data\n\n        err = out.getvalue()\n        assert 'Exception on \/ [GET]' in err\n        assert 'Traceback (most recent call last):' in err\n        assert '1 \/\/ 0' in err\n        assert 'ZeroDivisionError:' in err\n\n    def test_processor_exceptions(self):\n        app = flask.Flask(__name__)\n        app.config['LOGGER_HANDLER_POLICY'] = 'never'\n        @app.before_request\n        def before_request():\n            if trigger == 'before':\n                1 \/\/ 0\n        @app.after_request\n        def after_request(response):\n            if trigger == 'after':\n                1 \/\/ 0\n            return response\n        @app.route('\/')\n        def index():\n            return 'Foo'\n        @app.errorhandler(500)\n        def internal_server_error(e):\n            return 'Hello Server Error', 500\n        for trigger in 'before', 'after':\n            rv = app.test_client().get('\/')\n            assert rv.status_code == 500\n            assert rv.data == b'Hello Server Error'\n\n    def test_url_for_with_anchor(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            assert flask.url_for('index', _anchor='x y') == '\/#x%20y'\n\n    def test_url_for_with_scheme(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            assert flask.url_for('index', _external=True, _scheme='https') == 'https:\/\/localhost\/'\n\n    def test_url_for_with_scheme_not_external(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            pytest.raises(ValueError,\n                               flask.url_for,\n                               'index',\n                               _scheme='https')\n\n    def test_url_with_method(self):\n        from flask.views import MethodView\n        app = flask.Flask(__name__)\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return 'List'\n                return 'Get %d' % id\n            def post(self):\n                return 'Create'\n        myview = MyView.as_view('myview')\n        app.add_url_rule('\/myview\/', methods=['GET'],\n                         view_func=myview)\n        app.add_url_rule('\/myview\/<int:id>', methods=['GET'],\n                         view_func=myview)\n        app.add_url_rule('\/myview\/create', methods=['POST'],\n                         view_func=myview)\n\n        with app.test_request_context():\n            assert flask.url_for('myview', _method='GET') == '\/myview\/'\n            assert flask.url_for('myview', id=42, _method='GET') == '\/myview\/42'\n            assert flask.url_for('myview', _method='POST') == '\/myview\/create'\n\n\nclass TestNoImports(object):\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self, modules_tmpdir):\n        modules_tmpdir.join('importerror.py').write('raise NotImplementedError()')\n        try:\n            flask.Flask('importerror')\n        except NotImplementedError:\n            assert False, 'Flask(import_name) is importing import_name.'\n\n\nclass TestStreaming(object):\n\n    def test_streaming_with_context(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(flask.stream_with_context(generate()))\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        assert rv.data == b'Hello World!'\n\n    def test_streaming_with_context_as_decorator(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            @flask.stream_with_context\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(generate())\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        assert rv.data == b'Hello World!'\n\n    def test_streaming_with_context_and_custom_close(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        called = []\n        class Wrapper(object):\n            def __init__(self, gen):\n                self._gen = gen\n            def __iter__(self):\n                return self\n            def close(self):\n                called.append(42)\n            def __next__(self):\n                return next(self._gen)\n            next = __next__\n        @app.route('\/')\n        def index():\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(flask.stream_with_context(\n                Wrapper(generate())))\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        assert rv.data == b'Hello World!'\n        assert called == [42]\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_instance\n    ~~~~~~~~~~~~~~~~~~~\n\n    :copyright: (c) 2015 by the Flask Team, see AUTHORS for more details.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport os\nimport sys\n\nimport pytest\nimport flask\nfrom flask._compat import PY2\n\n\ndef test_explicit_instance_paths(modules_tmpdir):\n    with pytest.raises(ValueError) as excinfo:\n        flask.Flask(__name__, instance_path='instance')\n    assert 'must be absolute' in str(excinfo.value)\n\n    app = flask.Flask(__name__, instance_path=str(modules_tmpdir))\n    assert app.instance_path == str(modules_tmpdir)\n\n\ndef test_main_module_paths(modules_tmpdir, purge_module):\n    app = modules_tmpdir.join('main_app.py')\n    app.write('import flask\\n\\napp = flask.Flask(\"__main__\")')\n    purge_module('main_app')\n\n    from main_app import app\n    here = os.path.abspath(os.getcwd())\n    assert app.instance_path == os.path.join(here, 'instance')\n\n\ndef test_uninstalled_module_paths(modules_tmpdir, purge_module):\n    app = modules_tmpdir.join('config_module_app.py').write(\n        'import os\\n'\n        'import flask\\n'\n        'here = os.path.abspath(os.path.dirname(__file__))\\n'\n        'app = flask.Flask(__name__)\\n'\n    )\n    purge_module('config_module_app')\n\n    from config_module_app import app\n    assert app.instance_path == str(modules_tmpdir.join('instance'))\n\n\ndef test_uninstalled_package_paths(modules_tmpdir, purge_module):\n    app = modules_tmpdir.mkdir('config_package_app')\n    init = app.join('__init__.py')\n    init.write(\n        'import os\\n'\n        'import flask\\n'\n        'here = os.path.abspath(os.path.dirname(__file__))\\n'\n        'app = flask.Flask(__name__)\\n'\n    )\n    purge_module('config_package_app')\n\n    from config_package_app import app\n    assert app.instance_path == str(modules_tmpdir.join('instance'))\n\n\ndef test_installed_module_paths(modules_tmpdir, modules_tmpdir_prefix,\n                                purge_module, site_packages, limit_loader):\n    site_packages.join('site_app.py').write(\n        'import flask\\n'\n        'app = flask.Flask(__name__)\\n'\n    )\n    purge_module('site_app')\n\n    from site_app import app\n    assert app.instance_path == \\\n        modules_tmpdir.join('var').join('site_app-instance')\n\n\ndef test_installed_package_paths(limit_loader, modules_tmpdir,\n                                 modules_tmpdir_prefix, purge_module,\n                                 monkeypatch):\n    installed_path = modules_tmpdir.mkdir('path')\n    monkeypatch.syspath_prepend(installed_path)\n\n    app = installed_path.mkdir('installed_package')\n    init = app.join('__init__.py')\n    init.write('import flask\\napp = flask.Flask(__name__)')\n    purge_module('installed_package')\n\n    from installed_package import app\n    assert app.instance_path == \\\n        modules_tmpdir.join('var').join('installed_package-instance')\n\n\ndef test_prefix_package_paths(limit_loader, modules_tmpdir,\n                              modules_tmpdir_prefix, purge_module,\n                              site_packages):\n    app = site_packages.mkdir('site_package')\n    init = app.join('__init__.py')\n    init.write('import flask\\napp = flask.Flask(__name__)')\n    purge_module('site_package')\n\n    import site_package\n    assert site_package.app.instance_path == \\\n        modules_tmpdir.join('var').join('site_package-instance')\n\n\ndef test_egg_installed_paths(install_egg, modules_tmpdir,\n                             modules_tmpdir_prefix):\n    modules_tmpdir.mkdir('site_egg').join('__init__.py').write(\n        'import flask\\n\\napp = flask.Flask(__name__)'\n    )\n    install_egg('site_egg')\n    try:\n        import site_egg\n        assert site_egg.app.instance_path == \\\n            str(modules_tmpdir.join('var\/').join('site_egg-instance'))\n    finally:\n        if 'site_egg' in sys.modules:\n            del sys.modules['site_egg']\n\n\n@pytest.mark.skipif(not PY2, reason='This only works under Python 2.')\ndef test_meta_path_loader_without_is_package(request, modules_tmpdir):\n    app = modules_tmpdir.join('unimportable.py')\n    app.write('import flask\\napp = flask.Flask(__name__)')\n\n    class Loader(object):\n        def find_module(self, name, path=None):\n            return self\n\n    sys.meta_path.append(Loader())\n    request.addfinalizer(sys.meta_path.pop)\n\n    with pytest.raises(AttributeError):\n        import unimportable\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.regression\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Tests regressions.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport os\nimport gc\nimport sys\nimport flask\nimport threading\nfrom werkzeug.exceptions import NotFound\n\n\n_gc_lock = threading.Lock()\n\n\nclass assert_no_leak(object):\n\n    def __enter__(self):\n        gc.disable()\n        _gc_lock.acquire()\n        loc = flask._request_ctx_stack._local\n\n        # Force Python to track this dictionary at all times.\n        # This is necessary since Python only starts tracking\n        # dicts if they contain mutable objects.  It's a horrible,\n        # horrible hack but makes this kinda testable.\n        loc.__storage__['FOOO'] = [1, 2, 3]\n\n        gc.collect()\n        self.old_objects = len(gc.get_objects())\n\n    def __exit__(self, exc_type, exc_value, tb):\n        if not hasattr(sys, 'getrefcount'):\n            gc.collect()\n        new_objects = len(gc.get_objects())\n        if new_objects > self.old_objects:\n            pytest.fail('Example code leaked')\n        _gc_lock.release()\n        gc.enable()\n\n\n# XXX: untitaker: These tests need to be revised. They broke around the time we\n# ported Flask to Python 3.\n@pytest.mark.skipif(os.environ.get('RUN_FLASK_MEMORY_TESTS') != '1',\n                    reason='Turned off due to envvar.')\ndef test_memory_consumption():\n    app = flask.Flask(__name__)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('simple_template.html', whiskey=42)\n\n    def fire():\n        with app.test_client() as c:\n            rv = c.get('\/')\n            assert rv.status_code == 200\n            assert rv.data == b'<h1>42<\/h1>'\n\n    # Trigger caches\n    fire()\n\n    # This test only works on CPython 2.7.\n    if sys.version_info >= (2, 7) and \\\n            not hasattr(sys, 'pypy_translation_info'):\n        with assert_no_leak():\n            for x in range(10):\n                fire()\n\n\ndef test_safe_join_toplevel_pardir():\n    from flask.helpers import safe_join\n    with pytest.raises(NotFound):\n        safe_join('\/foo', '..')\n\n\ndef test_aborting():\n    class Foo(Exception):\n        whatever = 42\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.errorhandler(Foo)\n    def handle_foo(e):\n        return str(e.whatever)\n\n    @app.route('\/')\n    def index():\n        raise flask.abort(flask.redirect(flask.url_for('test')))\n\n    @app.route('\/test')\n    def test():\n        raise Foo()\n\n    with app.test_client() as c:\n        rv = c.get('\/')\n        assert rv.headers['Location'] == 'http:\/\/localhost\/test'\n        rv = c.get('\/test')\n        assert rv.data == b'42'\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.reqctx\n    ~~~~~~~~~~~~\n\n    Tests the request context.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\n\ntry:\n    from greenlet import greenlet\nexcept ImportError:\n    greenlet = None\n\n\ndef test_teardown_on_pop():\n    buffer = []\n    app = flask.Flask(__name__)\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    ctx = app.test_request_context()\n    ctx.push()\n    assert buffer == []\n    ctx.pop()\n    assert buffer == [None]\n\ndef test_teardown_with_previous_exception():\n    buffer = []\n    app = flask.Flask(__name__)\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    try:\n        raise Exception('dummy')\n    except Exception:\n        pass\n\n    with app.test_request_context():\n        assert buffer == []\n    assert buffer == [None]\n\ndef test_proper_test_request_context():\n    app = flask.Flask(__name__)\n    app.config.update(\n        SERVER_NAME='localhost.localdomain:5000'\n    )\n\n    @app.route('\/')\n    def index():\n        return None\n\n    @app.route('\/', subdomain='foo')\n    def sub():\n        return None\n\n    with app.test_request_context('\/'):\n        assert flask.url_for('index', _external=True) == \\\n            'http:\/\/localhost.localdomain:5000\/'\n\n    with app.test_request_context('\/'):\n        assert flask.url_for('sub', _external=True) == \\\n            'http:\/\/foo.localhost.localdomain:5000\/'\n\n    try:\n        with app.test_request_context('\/', environ_overrides={'HTTP_HOST': 'localhost'}):\n            pass\n    except ValueError as e:\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain:5000') does not match the \"\n            \"server name from the WSGI environment ('localhost')\"\n        )\n\n    app.config.update(SERVER_NAME='localhost')\n    with app.test_request_context('\/', environ_overrides={'SERVER_NAME': 'localhost'}):\n        pass\n\n    app.config.update(SERVER_NAME='localhost:80')\n    with app.test_request_context('\/', environ_overrides={'SERVER_NAME': 'localhost:80'}):\n        pass\n\ndef test_context_binding():\n    app = flask.Flask(__name__)\n    @app.route('\/')\n    def index():\n        return 'Hello %s!' % flask.request.args['name']\n    @app.route('\/meh')\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context('\/?name=World'):\n        assert index() == 'Hello World!'\n    with app.test_request_context('\/meh'):\n        assert meh() == 'http:\/\/localhost\/meh'\n    assert flask._request_ctx_stack.top is None\n\ndef test_context_test():\n    app = flask.Flask(__name__)\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\ndef test_manual_context_binding():\n    app = flask.Flask(__name__)\n    @app.route('\/')\n    def index():\n        return 'Hello %s!' % flask.request.args['name']\n\n    ctx = app.test_request_context('\/?name=World')\n    ctx.push()\n    assert index() == 'Hello World!'\n    ctx.pop()\n    try:\n        index()\n    except RuntimeError:\n        pass\n    else:\n        assert 0, 'expected runtime error'\n\n@pytest.mark.skipif(greenlet is None, reason='greenlet not installed')\ndef test_greenlet_context_copying():\n    app = flask.Flask(__name__)\n    greenlets = []\n\n    @app.route('\/')\n    def index():\n        reqctx = flask._request_ctx_stack.top.copy()\n        def g():\n            assert not flask.request\n            assert not flask.current_app\n            with reqctx:\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == '\/'\n                assert flask.request.args['foo'] == 'bar'\n            assert not flask.request\n            return 42\n        greenlets.append(greenlet(g))\n        return 'Hello World!'\n\n    rv = app.test_client().get('\/?foo=bar')\n    assert rv.data == b'Hello World!'\n\n    result = greenlets[0].run()\n    assert result == 42\n\n@pytest.mark.skipif(greenlet is None, reason='greenlet not installed')\ndef test_greenlet_context_copying_api():\n    app = flask.Flask(__name__)\n    greenlets = []\n\n    @app.route('\/')\n    def index():\n        reqctx = flask._request_ctx_stack.top.copy()\n        @flask.copy_current_request_context\n        def g():\n            assert flask.request\n            assert flask.current_app == app\n            assert flask.request.path == '\/'\n            assert flask.request.args['foo'] == 'bar'\n            return 42\n        greenlets.append(greenlet(g))\n        return 'Hello World!'\n\n    rv = app.test_client().get('\/?foo=bar')\n    assert rv.data == b'Hello World!'\n\n    result = greenlets[0].run()\n    assert result == 42\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.signals\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Signalling.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\ntry:\n    import blinker\nexcept ImportError:\n    blinker = None\n\nimport flask\n\n\npytestmark = pytest.mark.skipif(\n    blinker is None,\n    reason='Signals require the blinker library.'\n)\n\ndef test_template_rendered():\n    app = flask.Flask(__name__)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('simple_template.html', whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        recorded.append((template, context))\n\n    flask.template_rendered.connect(record, app)\n    try:\n        app.test_client().get('\/')\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == 'simple_template.html'\n        assert context['whiskey'] == 42\n    finally:\n        flask.template_rendered.disconnect(record, app)\n\ndef test_request_signals():\n    app = flask.Flask(__name__)\n    calls = []\n\n    def before_request_signal(sender):\n        calls.append('before-signal')\n\n    def after_request_signal(sender, response):\n        assert response.data == b'stuff'\n        calls.append('after-signal')\n\n    @app.before_request\n    def before_request_handler():\n        calls.append('before-handler')\n\n    @app.after_request\n    def after_request_handler(response):\n        calls.append('after-handler')\n        response.data = 'stuff'\n        return response\n\n    @app.route('\/')\n    def index():\n        calls.append('handler')\n        return 'ignored anyway'\n\n    flask.request_started.connect(before_request_signal, app)\n    flask.request_finished.connect(after_request_signal, app)\n\n    try:\n        rv = app.test_client().get('\/')\n        assert rv.data == b'stuff'\n\n        assert calls == ['before-signal', 'before-handler', 'handler',\n                         'after-handler', 'after-signal']\n    finally:\n        flask.request_started.disconnect(before_request_signal, app)\n        flask.request_finished.disconnect(after_request_signal, app)\n\ndef test_request_exception_signal():\n    app = flask.Flask(__name__)\n    recorded = []\n\n    @app.route('\/')\n    def index():\n        1 \/\/ 0\n\n    def record(sender, exception):\n        recorded.append(exception)\n\n    flask.got_request_exception.connect(record, app)\n    try:\n        assert app.test_client().get('\/').status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.got_request_exception.disconnect(record, app)\n\ndef test_appcontext_signals():\n    app = flask.Flask(__name__)\n    recorded = []\n\n    def record_push(sender, **kwargs):\n        recorded.append('push')\n\n    def record_pop(sender, **kwargs):\n        recorded.append('pop')\n\n    @app.route('\/')\n    def index():\n        return 'Hello'\n\n    flask.appcontext_pushed.connect(record_push, app)\n    flask.appcontext_popped.connect(record_pop, app)\n    try:\n        with app.test_client() as c:\n            rv = c.get('\/')\n            assert rv.data == b'Hello'\n            assert recorded == ['push']\n        assert recorded == ['push', 'pop']\n    finally:\n        flask.appcontext_pushed.disconnect(record_push, app)\n        flask.appcontext_popped.disconnect(record_pop, app)\n\ndef test_flash_signal():\n    app = flask.Flask(__name__)\n    app.config['SECRET_KEY'] = 'secret'\n\n    @app.route('\/')\n    def index():\n        flask.flash('This is a flash message', category='notice')\n        return flask.redirect('\/other')\n\n    recorded = []\n\n    def record(sender, message, category):\n        recorded.append((message, category))\n\n    flask.message_flashed.connect(record, app)\n    try:\n        client = app.test_client()\n        with client.session_transaction():\n            client.get('\/')\n            assert len(recorded) == 1\n            message, category = recorded[0]\n            assert message == 'This is a flash message'\n            assert category == 'notice'\n    finally:\n        flask.message_flashed.disconnect(record, app)\n\ndef test_appcontext_tearing_down_signal():\n    app = flask.Flask(__name__)\n    recorded = []\n\n    def record_teardown(sender, **kwargs):\n        recorded.append(('tear_down', kwargs))\n\n    @app.route('\/')\n    def index():\n        1 \/\/ 0\n\n    flask.appcontext_tearing_down.connect(record_teardown, app)\n    try:\n        with app.test_client() as c:\n            rv = c.get('\/')\n            assert rv.status_code == 500\n            assert recorded == []\n        assert recorded == [('tear_down', {'exc': None})]\n    finally:\n        flask.appcontext_tearing_down.disconnect(record_teardown, app)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.subclassing\n    ~~~~~~~~~~~~~~~~~\n\n    Test that certain behavior of flask can be customized by\n    subclasses.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport flask\nfrom logging import StreamHandler\n\nfrom flask._compat import StringIO\n\n\ndef test_suppressed_exception_logging():\n    class SuppressedFlask(flask.Flask):\n        def log_exception(self, exc_info):\n            pass\n\n    out = StringIO()\n    app = SuppressedFlask(__name__)\n    app.logger_name = 'flask_tests\/test_suppressed_exception_logging'\n    app.logger.addHandler(StreamHandler(out))\n\n    @app.route('\/')\n    def index():\n        1 \/\/ 0\n\n    rv = app.test_client().get('\/')\n    assert rv.status_code == 500\n    assert b'Internal Server Error' in rv.data\n\n    err = out.getvalue()\n    assert err == ''\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.templating\n    ~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\nimport logging\nfrom jinja2 import TemplateNotFound\n\n\ndef test_context_processing():\n    app = flask.Flask(__name__)\n    @app.context_processor\n    def context_processor():\n        return {'injected_value': 42}\n    @app.route('\/')\n    def index():\n        return flask.render_template('context_template.html', value=23)\n    rv = app.test_client().get('\/')\n    assert rv.data == b'<p>23|42'\n\ndef test_original_win():\n    app = flask.Flask(__name__)\n    @app.route('\/')\n    def index():\n        return flask.render_template_string('{{ config }}', config=42)\n    rv = app.test_client().get('\/')\n    assert rv.data == b'42'\n\ndef test_request_less_rendering():\n    app = flask.Flask(__name__)\n    app.config['WORLD_NAME'] = 'Special World'\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    with app.app_context():\n        rv = flask.render_template_string('Hello {{ config.WORLD_NAME }} '\n                                          '{{ foo }}')\n        assert rv == 'Hello Special World 42'\n\ndef test_standard_context():\n    app = flask.Flask(__name__)\n    app.secret_key = 'development key'\n    @app.route('\/')\n    def index():\n        flask.g.foo = 23\n        flask.session['test'] = 'aha'\n        return flask.render_template_string('''\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        ''')\n    rv = app.test_client().get('\/?foo=42')\n    assert rv.data.split() == [b'42', b'23', b'False', b'aha']\n\ndef test_escaping():\n    text = '<p>Hello World!'\n    app = flask.Flask(__name__)\n    @app.route('\/')\n    def index():\n        return flask.render_template('escaping_template.html', text=text,\n                                     html=flask.Markup(text))\n    lines = app.test_client().get('\/').data.splitlines()\n    assert lines == [\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!'\n    ]\n\ndef test_no_escaping():\n    app = flask.Flask(__name__)\n    with app.test_request_context():\n        assert flask.render_template_string(\n            '{{ foo }}', foo='<test>') == '<test>'\n        assert flask.render_template('mail.txt', foo='<test>') == \\\n            '<test> Mail'\n\ndef test_macros():\n    app = flask.Flask(__name__)\n    with app.test_request_context():\n        macro = flask.get_template_attribute('_macro.html', 'hello')\n        assert macro('World') == 'Hello World!'\n\ndef test_template_filter():\n    app = flask.Flask(__name__)\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\ndef test_add_template_filter():\n    app = flask.Flask(__name__)\n    def my_reverse(s):\n        return s[::-1]\n    app.add_template_filter(my_reverse)\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\ndef test_template_filter_with_name():\n    app = flask.Flask(__name__)\n    @app.template_filter('strrev')\n    def my_reverse(s):\n        return s[::-1]\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\ndef test_add_template_filter_with_name():\n    app = flask.Flask(__name__)\n    def my_reverse(s):\n        return s[::-1]\n    app.add_template_filter(my_reverse, 'strrev')\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\ndef test_template_filter_with_template():\n    app = flask.Flask(__name__)\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_add_template_filter_with_template():\n    app = flask.Flask(__name__)\n    def super_reverse(s):\n        return s[::-1]\n    app.add_template_filter(super_reverse)\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_template_filter_with_name_and_template():\n    app = flask.Flask(__name__)\n    @app.template_filter('super_reverse')\n    def my_reverse(s):\n        return s[::-1]\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_add_template_filter_with_name_and_template():\n    app = flask.Flask(__name__)\n    def my_reverse(s):\n        return s[::-1]\n    app.add_template_filter(my_reverse, 'super_reverse')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_template_test():\n    app = flask.Flask(__name__)\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\ndef test_add_template_test():\n    app = flask.Flask(__name__)\n    def boolean(value):\n        return isinstance(value, bool)\n    app.add_template_test(boolean)\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\ndef test_template_test_with_name():\n    app = flask.Flask(__name__)\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\ndef test_add_template_test_with_name():\n    app = flask.Flask(__name__)\n    def is_boolean(value):\n        return isinstance(value, bool)\n    app.add_template_test(is_boolean, 'boolean')\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\ndef test_template_test_with_template():\n    app = flask.Flask(__name__)\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_add_template_test_with_template():\n    app = flask.Flask(__name__)\n    def boolean(value):\n        return isinstance(value, bool)\n    app.add_template_test(boolean)\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_template_test_with_name_and_template():\n    app = flask.Flask(__name__)\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_add_template_test_with_name_and_template():\n    app = flask.Flask(__name__)\n    def is_boolean(value):\n        return isinstance(value, bool)\n    app.add_template_test(is_boolean, 'boolean')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_add_template_global():\n    app = flask.Flask(__name__)\n    @app.template_global()\n    def get_stuff():\n        return 42\n    assert 'get_stuff' in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals['get_stuff'] == get_stuff\n    assert app.jinja_env.globals['get_stuff'](), 42\n    with app.app_context():\n        rv = flask.render_template_string('{{ get_stuff() }}')\n        assert rv == '42'\n\ndef test_custom_template_loader():\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n            return DictLoader({'index.html': 'Hello Custom World!'})\n    app = MyFlask(__name__)\n    @app.route('\/')\n    def index():\n        return flask.render_template('index.html')\n    c = app.test_client()\n    rv = c.get('\/')\n    assert rv.data == b'Hello Custom World!'\n\ndef test_iterable_loader():\n    app = flask.Flask(__name__)\n    @app.context_processor\n    def context_processor():\n        return {'whiskey': 'Jameson'}\n    @app.route('\/')\n    def index():\n        return flask.render_template(\n            ['no_template.xml',  # should skip this one\n            'simple_template.html',  # should render this\n            'context_template.html'],\n            value=23)\n\n    rv = app.test_client().get('\/')\n    assert rv.data == b'<h1>Jameson<\/h1>'\n\ndef test_templates_auto_reload():\n    # debug is False, config option is None\n    app = flask.Flask(__name__)\n    assert app.debug is False\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.jinja_env.auto_reload is True\n\ndef test_template_loader_debugging(test_apps):\n    from blueprintapp import app\n\n    called = []\n    class _TestHandler(logging.Handler):\n        def handle(x, record):\n            called.append(True)\n            text = str(record.msg)\n            assert '1: trying loader of application \"blueprintapp\"' in text\n            assert ('2: trying loader of blueprint \"admin\" '\n                    '(blueprintapp.apps.admin)') in text\n            assert ('trying loader of blueprint \"frontend\" '\n                    '(blueprintapp.apps.frontend)') in text\n            assert 'Error: the template could not be found' in text\n            assert ('looked up from an endpoint that belongs to '\n                    'the blueprint \"frontend\"') in text\n            assert 'See http:\/\/flask.pocoo.org\/docs\/blueprints\/#templates' in text\n\n    with app.test_client() as c:\n        try:\n            old_load_setting = app.config['EXPLAIN_TEMPLATE_LOADING']\n            old_handlers = app.logger.handlers[:]\n            app.logger.handlers = [_TestHandler()]\n            app.config['EXPLAIN_TEMPLATE_LOADING'] = True\n\n            with pytest.raises(TemplateNotFound) as excinfo:\n                c.get('\/missing')\n\n            assert 'missing_template.html' in str(excinfo.value)\n        finally:\n            app.logger.handlers[:] = old_handlers\n            app.config['EXPLAIN_TEMPLATE_LOADING'] = old_load_setting\n\n    assert len(called) == 1\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.logging\n    ~~~~~~~~~~~~~\n\n    Implements the logging support for Flask.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport sys\n\nfrom werkzeug.local import LocalProxy\nfrom logging import getLogger, StreamHandler, Formatter, getLoggerClass, \\\n     DEBUG, ERROR\nfrom .globals import _request_ctx_stack\n\n\nPROD_LOG_FORMAT = '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\nDEBUG_LOG_FORMAT = (\n    '-' * 80 + '\\n' +\n    '%(levelname)s in %(module)s [%(pathname)s:%(lineno)d]:\\n' +\n    '%(message)s\\n' +\n    '-' * 80\n)\n\n\n@LocalProxy\ndef _proxy_stream():\n    \"\"\"Finds the most appropriate error stream for the application.  If a\n    WSGI request is in flight we log to wsgi.errors, otherwise this resolves\n    to sys.stderr.\n    \"\"\"\n    ctx = _request_ctx_stack.top\n    if ctx is not None:\n        return ctx.request.environ['wsgi.errors']\n    return sys.stderr\n\n\ndef _should_log_for(app, mode):\n    policy = app.config['LOGGER_HANDLER_POLICY']\n    if policy == mode or policy == 'always':\n        return True\n    return False\n\n\ndef create_logger(app):\n    \"\"\"Creates a logger for the given application.  This logger works\n    similar to a regular Python logger but changes the effective logging\n    level based on the application's debug flag.  Furthermore this\n    function also removes all attached handlers in case there was a\n    logger with the log name before.\n    \"\"\"\n    Logger = getLoggerClass()\n\n    class DebugLogger(Logger):\n        def getEffectiveLevel(x):\n            if x.level == 0 and app.debug:\n                return DEBUG\n            return Logger.getEffectiveLevel(x)\n\n    class DebugHandler(StreamHandler):\n        def emit(self, record):\n            if app.debug and _should_log_for(app, 'debug'):\n                StreamHandler.emit(self, record)\n\n    class ProductionHandler(StreamHandler):\n        def emit(self, record):\n            if not app.debug and _should_log_for(app, 'production'):\n                StreamHandler.emit(self, record)\n\n    debug_handler = DebugHandler()\n    debug_handler.setLevel(DEBUG)\n    debug_handler.setFormatter(Formatter(DEBUG_LOG_FORMAT))\n\n    prod_handler = ProductionHandler(_proxy_stream)\n    prod_handler.setLevel(ERROR)\n    prod_handler.setFormatter(Formatter(PROD_LOG_FORMAT))\n\n    logger = getLogger(app.logger_name)\n    # just in case that was not a new logger, get rid of all the handlers\n    # already attached to it.\n    del logger.handlers[:]\n    logger.__class__ = DebugLogger\n    logger.addHandler(debug_handler)\n    logger.addHandler(prod_handler)\n    return logger\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.templating\n    ~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\nimport logging\nfrom jinja2 import TemplateNotFound\n\n\ndef test_context_processing():\n    app = flask.Flask(__name__)\n    @app.context_processor\n    def context_processor():\n        return {'injected_value': 42}\n    @app.route('\/')\n    def index():\n        return flask.render_template('context_template.html', value=23)\n    rv = app.test_client().get('\/')\n    assert rv.data == b'<p>23|42'\n\ndef test_original_win():\n    app = flask.Flask(__name__)\n    @app.route('\/')\n    def index():\n        return flask.render_template_string('{{ config }}', config=42)\n    rv = app.test_client().get('\/')\n    assert rv.data == b'42'\n\ndef test_request_less_rendering():\n    app = flask.Flask(__name__)\n    app.config['WORLD_NAME'] = 'Special World'\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    with app.app_context():\n        rv = flask.render_template_string('Hello {{ config.WORLD_NAME }} '\n                                          '{{ foo }}')\n        assert rv == 'Hello Special World 42'\n\ndef test_standard_context():\n    app = flask.Flask(__name__)\n    app.secret_key = 'development key'\n    @app.route('\/')\n    def index():\n        flask.g.foo = 23\n        flask.session['test'] = 'aha'\n        return flask.render_template_string('''\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        ''')\n    rv = app.test_client().get('\/?foo=42')\n    assert rv.data.split() == [b'42', b'23', b'False', b'aha']\n\ndef test_escaping():\n    text = '<p>Hello World!'\n    app = flask.Flask(__name__)\n    @app.route('\/')\n    def index():\n        return flask.render_template('escaping_template.html', text=text,\n                                     html=flask.Markup(text))\n    lines = app.test_client().get('\/').data.splitlines()\n    assert lines == [\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!'\n    ]\n\ndef test_no_escaping():\n    app = flask.Flask(__name__)\n    with app.test_request_context():\n        assert flask.render_template_string(\n            '{{ foo }}', foo='<test>') == '<test>'\n        assert flask.render_template('mail.txt', foo='<test>') == \\\n            '<test> Mail'\n\ndef test_macros():\n    app = flask.Flask(__name__)\n    with app.test_request_context():\n        macro = flask.get_template_attribute('_macro.html', 'hello')\n        assert macro('World') == 'Hello World!'\n\ndef test_template_filter():\n    app = flask.Flask(__name__)\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\ndef test_add_template_filter():\n    app = flask.Flask(__name__)\n    def my_reverse(s):\n        return s[::-1]\n    app.add_template_filter(my_reverse)\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\ndef test_template_filter_with_name():\n    app = flask.Flask(__name__)\n    @app.template_filter('strrev')\n    def my_reverse(s):\n        return s[::-1]\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\ndef test_add_template_filter_with_name():\n    app = flask.Flask(__name__)\n    def my_reverse(s):\n        return s[::-1]\n    app.add_template_filter(my_reverse, 'strrev')\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\ndef test_template_filter_with_template():\n    app = flask.Flask(__name__)\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_add_template_filter_with_template():\n    app = flask.Flask(__name__)\n    def super_reverse(s):\n        return s[::-1]\n    app.add_template_filter(super_reverse)\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_template_filter_with_name_and_template():\n    app = flask.Flask(__name__)\n    @app.template_filter('super_reverse')\n    def my_reverse(s):\n        return s[::-1]\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_add_template_filter_with_name_and_template():\n    app = flask.Flask(__name__)\n    def my_reverse(s):\n        return s[::-1]\n    app.add_template_filter(my_reverse, 'super_reverse')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n    rv = app.test_client().get('\/')\n    assert rv.data == b'dcba'\n\ndef test_template_test():\n    app = flask.Flask(__name__)\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\ndef test_add_template_test():\n    app = flask.Flask(__name__)\n    def boolean(value):\n        return isinstance(value, bool)\n    app.add_template_test(boolean)\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\ndef test_template_test_with_name():\n    app = flask.Flask(__name__)\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\ndef test_add_template_test_with_name():\n    app = flask.Flask(__name__)\n    def is_boolean(value):\n        return isinstance(value, bool)\n    app.add_template_test(is_boolean, 'boolean')\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\ndef test_template_test_with_template():\n    app = flask.Flask(__name__)\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_add_template_test_with_template():\n    app = flask.Flask(__name__)\n    def boolean(value):\n        return isinstance(value, bool)\n    app.add_template_test(boolean)\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_template_test_with_name_and_template():\n    app = flask.Flask(__name__)\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_add_template_test_with_name_and_template():\n    app = flask.Flask(__name__)\n    def is_boolean(value):\n        return isinstance(value, bool)\n    app.add_template_test(is_boolean, 'boolean')\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n    rv = app.test_client().get('\/')\n    assert b'Success!' in rv.data\n\ndef test_add_template_global():\n    app = flask.Flask(__name__)\n    @app.template_global()\n    def get_stuff():\n        return 42\n    assert 'get_stuff' in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals['get_stuff'] == get_stuff\n    assert app.jinja_env.globals['get_stuff'](), 42\n    with app.app_context():\n        rv = flask.render_template_string('{{ get_stuff() }}')\n        assert rv == '42'\n\ndef test_custom_template_loader():\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n            return DictLoader({'index.html': 'Hello Custom World!'})\n    app = MyFlask(__name__)\n    @app.route('\/')\n    def index():\n        return flask.render_template('index.html')\n    c = app.test_client()\n    rv = c.get('\/')\n    assert rv.data == b'Hello Custom World!'\n\ndef test_iterable_loader():\n    app = flask.Flask(__name__)\n    @app.context_processor\n    def context_processor():\n        return {'whiskey': 'Jameson'}\n    @app.route('\/')\n    def index():\n        return flask.render_template(\n            ['no_template.xml',  # should skip this one\n            'simple_template.html',  # should render this\n            'context_template.html'],\n            value=23)\n\n    rv = app.test_client().get('\/')\n    assert rv.data == b'<h1>Jameson<\/h1>'\n\ndef test_templates_auto_reload():\n    # debug is False, config option is None\n    app = flask.Flask(__name__)\n    assert app.debug is False\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.jinja_env.auto_reload is True\n\ndef test_template_loader_debugging(test_apps):\n    from blueprintapp import app\n\n    called = []\n    class _TestHandler(logging.Handler):\n        def handle(x, record):\n            called.append(True)\n            text = str(record.msg)\n            assert '1: trying loader of application \"blueprintapp\"' in text\n            assert ('2: trying loader of blueprint \"admin\" '\n                    '(blueprintapp.apps.admin)') in text\n            assert ('trying loader of blueprint \"frontend\" '\n                    '(blueprintapp.apps.frontend)') in text\n            assert 'Error: the template could not be found' in text\n            assert ('looked up from an endpoint that belongs to '\n                    'the blueprint \"frontend\"') in text\n            assert 'See http:\/\/flask.pocoo.org\/docs\/blueprints\/#templates' in text\n\n    with app.test_client() as c:\n        try:\n            old_load_setting = app.config['EXPLAIN_TEMPLATE_LOADING']\n            old_handlers = app.logger.handlers[:]\n            app.logger.handlers = [_TestHandler()]\n            app.config['EXPLAIN_TEMPLATE_LOADING'] = True\n\n            with pytest.raises(TemplateNotFound) as excinfo:\n                c.get('\/missing')\n\n            assert 'missing_template.html' in str(excinfo.value)\n        finally:\n            app.logger.handlers[:] = old_handlers\n            app.config['EXPLAIN_TEMPLATE_LOADING'] = old_load_setting\n\n    assert len(called) == 1\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.testing\n    ~~~~~~~~~~~~~\n\n    Test client and more.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport pytest\n\nimport flask\n\nfrom flask._compat import text_type\n\n\ndef test_environ_defaults_from_config():\n    app = flask.Flask(__name__)\n    app.testing = True\n    app.config['SERVER_NAME'] = 'example.com:1234'\n    app.config['APPLICATION_ROOT'] = '\/foo'\n    @app.route('\/')\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == 'http:\/\/example.com:1234\/foo\/'\n    with app.test_client() as c:\n        rv = c.get('\/')\n        assert rv.data == b'http:\/\/example.com:1234\/foo\/'\n\ndef test_environ_defaults():\n    app = flask.Flask(__name__)\n    app.testing = True\n    @app.route('\/')\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == 'http:\/\/localhost\/'\n    with app.test_client() as c:\n        rv = c.get('\/')\n        assert rv.data == b'http:\/\/localhost\/'\n\ndef test_redirect_keep_session():\n    app = flask.Flask(__name__)\n    app.secret_key = 'testing'\n\n    @app.route('\/', methods=['GET', 'POST'])\n    def index():\n        if flask.request.method == 'POST':\n            return flask.redirect('\/getsession')\n        flask.session['data'] = 'foo'\n        return 'index'\n\n    @app.route('\/getsession')\n    def get_session():\n        return flask.session.get('data', '<missing>')\n\n    with app.test_client() as c:\n        rv = c.get('\/getsession')\n        assert rv.data == b'<missing>'\n\n        rv = c.get('\/')\n        assert rv.data == b'index'\n        assert flask.session.get('data') == 'foo'\n        rv = c.post('\/', data={}, follow_redirects=True)\n        assert rv.data == b'foo'\n\n        # This support requires a new Werkzeug version\n        if not hasattr(c, 'redirect_client'):\n            assert flask.session.get('data') == 'foo'\n\n        rv = c.get('\/getsession')\n        assert rv.data == b'foo'\n\ndef test_session_transactions():\n    app = flask.Flask(__name__)\n    app.testing = True\n    app.secret_key = 'testing'\n\n    @app.route('\/')\n    def index():\n        return text_type(flask.session['foo'])\n\n    with app.test_client() as c:\n        with c.session_transaction() as sess:\n            assert len(sess) == 0\n            sess['foo'] = [42]\n            assert len(sess) == 1\n        rv = c.get('\/')\n        assert rv.data == b'[42]'\n        with c.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess['foo'] == [42]\n\ndef test_session_transactions_no_null_sessions():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    with app.test_client() as c:\n        try:\n            with c.session_transaction() as sess:\n                pass\n        except RuntimeError as e:\n            assert 'Session backend did not open a session' in str(e)\n        else:\n            assert False, 'Expected runtime error'\n\ndef test_session_transactions_keep_context():\n    app = flask.Flask(__name__)\n    app.testing = True\n    app.secret_key = 'testing'\n\n    with app.test_client() as c:\n        rv = c.get('\/')\n        req = flask.request._get_current_object()\n        assert req is not None\n        with c.session_transaction():\n            assert req is flask.request._get_current_object()\n\ndef test_session_transaction_needs_cookies():\n    app = flask.Flask(__name__)\n    app.testing = True\n    c = app.test_client(use_cookies=False)\n    try:\n        with c.session_transaction() as s:\n            pass\n    except RuntimeError as e:\n        assert 'cookies' in str(e)\n    else:\n        assert False, 'Expected runtime error'\n\ndef test_test_client_context_binding():\n    app = flask.Flask(__name__)\n    app.config['LOGGER_HANDLER_POLICY'] = 'never'\n    @app.route('\/')\n    def index():\n        flask.g.value = 42\n        return 'Hello World!'\n\n    @app.route('\/other')\n    def other():\n        1 \/\/ 0\n\n    with app.test_client() as c:\n        resp = c.get('\/')\n        assert flask.g.value == 42\n        assert resp.data == b'Hello World!'\n        assert resp.status_code == 200\n\n        resp = c.get('\/other')\n        assert not hasattr(flask.g, 'value')\n        assert b'Internal Server Error' in resp.data\n        assert resp.status_code == 500\n        flask.g.value = 23\n\n    try:\n        flask.g.value\n    except (AttributeError, RuntimeError):\n        pass\n    else:\n        raise AssertionError('some kind of exception expected')\n\ndef test_reuse_client():\n    app = flask.Flask(__name__)\n    c = app.test_client()\n\n    with c:\n        assert c.get('\/').status_code == 404\n\n    with c:\n        assert c.get('\/').status_code == 404\n\ndef test_test_client_calls_teardown_handlers():\n    app = flask.Flask(__name__)\n    called = []\n    @app.teardown_request\n    def remember(error):\n        called.append(error)\n\n    with app.test_client() as c:\n        assert called == []\n        c.get('\/')\n        assert called == []\n    assert called == [None]\n\n    del called[:]\n    with app.test_client() as c:\n        assert called == []\n        c.get('\/')\n        assert called == []\n        c.get('\/')\n        assert called == [None]\n    assert called == [None, None]\n\ndef test_full_url_request():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route('\/action', methods=['POST'])\n    def action():\n        return 'x'\n\n    with app.test_client() as c:\n        rv = c.post('http:\/\/domain.com\/action?vodka=42', data={'gin': 43})\n        assert rv.status_code == 200\n        assert 'gin' in flask.request.form\n        assert 'vodka' in flask.request.args\n\ndef test_subdomain():\n    app = flask.Flask(__name__)\n    app.config['SERVER_NAME'] = 'example.com'\n    @app.route('\/', subdomain='<company_id>')\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for('view', company_id='xxx')\n\n    with app.test_client() as c:\n        response = c.get(url)\n\n    assert 200 == response.status_code\n    assert b'xxx' == response.data\n\ndef test_nosubdomain():\n    app = flask.Flask(__name__)\n    app.config['SERVER_NAME'] = 'example.com'\n    @app.route('\/<company_id>')\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for('view', company_id='xxx')\n\n    with app.test_client() as c:\n        response = c.get(url)\n\n    assert 200 == response.status_code\n    assert b'xxx' == response.data\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Flask, request, session, g, redirect, url_for, abort, \\\n     render_template, flash\n\n\n# create our little application :)\napp = Flask(__name__)\n\n# Load default config and override config from an environment variable\napp.config.update(dict(\n    DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n    DEBUG=True,\n    SECRET_KEY='development key',\n    USERNAME='admin',\n    PASSWORD='default'\n))\napp.config.from_envvar('FLASKR_SETTINGS', silent=True)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_db(error):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    if hasattr(g, 'sqlite_db'):\n        g.sqlite_db.close()\n\n\n@app.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@app.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('show_entries'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('show_entries'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('show_entries'))\n\n\"\"\"\nGenerate tests which test: Happy New Year 2015\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.views\n    ~~~~~~~~~~~\n\n    Pluggable views.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\nimport flask.views\n\nfrom werkzeug.http import parse_set_header\n\ndef common_test(app):\n    c = app.test_client()\n\n    assert c.get('\/').data == b'GET'\n    assert c.post('\/').data == b'POST'\n    assert c.put('\/').status_code == 405\n    meths = parse_set_header(c.open('\/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']\n\ndef test_basic_view():\n    app = flask.Flask(__name__)\n\n    class Index(flask.views.View):\n        methods = ['GET', 'POST']\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n    common_test(app)\n\ndef test_method_based_view():\n    app = flask.Flask(__name__)\n\n    class Index(flask.views.MethodView):\n        def get(self):\n            return 'GET'\n        def post(self):\n            return 'POST'\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n    common_test(app)\n\ndef test_view_patching():\n    app = flask.Flask(__name__)\n\n    class Index(flask.views.MethodView):\n        def get(self):\n            1 \/\/ 0\n        def post(self):\n            1 \/\/ 0\n\n    class Other(Index):\n        def get(self):\n            return 'GET'\n        def post(self):\n            return 'POST'\n\n    view = Index.as_view('index')\n    view.view_class = Other\n    app.add_url_rule('\/', view_func=view)\n    common_test(app)\n\ndef test_view_inheritance():\n    app = flask.Flask(__name__)\n\n    class Index(flask.views.MethodView):\n        def get(self):\n            return 'GET'\n        def post(self):\n            return 'POST'\n\n    class BetterIndex(Index):\n        def delete(self):\n            return 'DELETE'\n\n    app.add_url_rule('\/', view_func=BetterIndex.as_view('index'))\n    c = app.test_client()\n\n    meths = parse_set_header(c.open('\/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST']\n\ndef test_view_decorators():\n    app = flask.Flask(__name__)\n\n    def add_x_parachute(f):\n        def new_function(*args, **kwargs):\n            resp = flask.make_response(f(*args, **kwargs))\n            resp.headers['X-Parachute'] = 'awesome'\n            return resp\n        return new_function\n\n    class Index(flask.views.View):\n        decorators = [add_x_parachute]\n        def dispatch_request(self):\n            return 'Awesome'\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n    c = app.test_client()\n    rv = c.get('\/')\n    assert rv.headers['X-Parachute'] == 'awesome'\n    assert rv.data == b'Awesome'\n\ndef test_implicit_head():\n    app = flask.Flask(__name__)\n\n    class Index(flask.views.MethodView):\n        def get(self):\n            return flask.Response('Blub', headers={\n                'X-Method': flask.request.method\n            })\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n    c = app.test_client()\n    rv = c.get('\/')\n    assert rv.data == b'Blub'\n    assert rv.headers['X-Method'] == 'GET'\n    rv = c.head('\/')\n    assert rv.data == b''\n    assert rv.headers['X-Method'] == 'HEAD'\n\ndef test_explicit_head():\n    app = flask.Flask(__name__)\n\n    class Index(flask.views.MethodView):\n        def get(self):\n            return 'GET'\n        def head(self):\n            return flask.Response('', headers={'X-Method': 'HEAD'})\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n    c = app.test_client()\n    rv = c.get('\/')\n    assert rv.data == b'GET'\n    rv = c.head('\/')\n    assert rv.data == b''\n    assert rv.headers['X-Method'] == 'HEAD'\n\ndef test_endpoint_override():\n    app = flask.Flask(__name__)\n    app.debug = True\n\n    class Index(flask.views.View):\n        methods = ['GET', 'POST']\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n    with pytest.raises(AssertionError):\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n    # But these tests should still pass. We just log a warning.\n    common_test(app)\n"}
{"prompt":"Python3\n# CASE 1 - from flask.ext.foo import bam --> from flask_foo import bam\n# CASE 2 - from flask.ext import foo --> import flask_foo as foo\n\nfrom redbaron import RedBaron\nimport sys\n\n\ndef read_source(input_file):\n    with open(input_file, \"r\") as source_code:\n        red = RedBaron(source_code.read())\n    return red\n\n\ndef write_source(red, input_file):\n    with open(input_file, \"w\") as source_code:\n        source_code.write(red.dumps())\n\n\ndef fix_imports(red):\n    from_imports = red.find_all(\"FromImport\")\n    for x in range(len(from_imports)):\n        values = from_imports[x].value\n        if (values[0].value == 'flask') and (values[1].value == 'ext'):\n            # Case 1\n            if len(from_imports[x].value) == 3:\n                package = values[2].value\n                modules = from_imports[x].modules()\n                r = \"{},\" * len(modules)\n                from_imports[x].replace(\"from flask_%s import %s\"\n                                        % (package, r.format(*modules)[:-1]))\n            # Case 2\n            else:\n                module = from_imports[x].modules()[0]\n                from_imports[x].replace(\"import flask_%s as %s\"\n                                        % (module, module))\n\n    return red\n\n\nif __name__ == \"__main__\":\n    input_file = sys.argv[1]\n    ast = read_source(input_file)\n    new_ast = fix_imports(ast)\n    write_source(new_ast, input_file)\n\n\"\"\"\nGenerate tests which test: Cleanup\n\"\"\"\n","completion":" from flask.ext.foo import \\\n    bam, \\\n    crackle\n\nfrom flask.ext import foo\n\nfrom flask.ext.foo import (bam,\n                           a,\n                           b\n)\n\nimport flask.ext.foo\n\nfrom flask.ext import foo\n\nimport sys\n\ndef migrate(old_file):\n    new_file = open(\"temp.py\", \"w\")\n    for line in old_file:\n        if line[0, 15] is \"from flask.ext\":\n            if line[15] == '.':\n                import_statement = line[16::].split(' ')\n                extension = import_statement[0]\n                line = line. replace(\"flask.ext.\" + extension,\n                                     \"flask_\" + extension)\n            else:\n                pass\n\n        new_file.write(line)\n\n\nif __name__ == \"__main__\":\n    old_file = open(sys.arv[1])\n"}
{"prompt":"Python3\n# Script which modifies source code away from the deprecated \"flask.ext\"\n# format. Does not yet fully support imports in the style:\n#\n# \"import flask.ext.foo\"\n#\n# these are converted to \"import flask_foo\" in the\n# main import statement, but does not handle function calls in the source.\n#\n# Run in the terminal by typing: `python flaskext_migrate.py <source_file.py>`\n#\n# Author: Keyan Pishdadian 2015\n\nfrom redbaron import RedBaron\nimport sys\n\n\ndef read_source(input_file):\n    \"\"\"Parses the input_file into a RedBaron FST.\"\"\"\n    with open(input_file, \"r\") as source_code:\n        red = RedBaron(source_code.read())\n    return red\n\n\ndef write_source(red, input_file):\n    \"\"\"Overwrites the input_file once the FST has been modified.\"\"\"\n    with open(input_file, \"w\") as source_code:\n        source_code.write(red.dumps())\n\n\ndef fix_imports(red):\n    \"\"\"Wrapper which fixes \"from\" style imports and then \"import\" style.\"\"\"\n    red = fix_standard_imports(red)\n    red = fix_from_imports(red)\n    return red\n\n\ndef fix_from_imports(red):\n    \"\"\"\n    Converts \"from\" style imports to not use \"flask.ext\".\n\n    Handles:\n    Case 1: from flask.ext.foo import bam --> from flask_foo import bam\n    Case 2: from flask.ext import foo --> import flask_foo as foo\n    \"\"\"\n    from_imports = red.find_all(\"FromImport\")\n    for x, node in enumerate(from_imports):\n        values = node.value\n        if (values[0].value == 'flask') and (values[1].value == 'ext'):\n            # Case 1\n            if len(node.value) == 3:\n                package = values[2].value\n                modules = node.modules()\n                if len(modules) > 1:\n                    r = \"{},\" * len(modules)\n                    node.replace(\"from flask_%s import %s\"\n                                 % (package, r.format(*modules)[:-1]))\n                else:\n                    name = node.names()[0]\n                    node.replace(\"from flask_%s import %s as %s\"\n                                 % (package, modules.pop(), name))\n            # Case 2\n            else:\n                module = node.modules()[0]\n                node.replace(\"import flask_%s as %s\"\n                             % (module, module))\n    return red\n\n\ndef fix_standard_imports(red):\n    \"\"\"\n    Handles import modification in the form:\n    import flask.ext.foo\" --> import flask_foo\n\n    Does not modify function calls elsewhere in the source outside of the\n    original import statement.\n    \"\"\"\n    imports = red.find_all(\"ImportNode\")\n    for x, node in enumerate(imports):\n        try:\n            if (node.value[0].value == 'flask' and\n               node.value[1].value == 'ext'):\n                package = node.value[2].value\n                name = node.names()[0]\n                imports[x].replace(\"import flask_%s as %s\" % (package, name))\n        except IndexError:\n            pass\n\n    return red\n\n\ndef fix(ast):\n    \"\"\"Wrapper which allows for testing when not running from shell\"\"\"\n    return fix_imports(ast).dumps()\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        sys.exit(\"No filename was included, please try again.\")\n    input_file = sys.argv[1]\n    ast = read_source(input_file)\n    ast = fix_imports(ast)\n    write_source(ast, input_file)\n\n\"\"\"\nGenerate tests which test: Add test for naming module and fix logic to cover\n\"\"\"\n","completion":" # Tester for the flaskext_migrate.py module located in flask\/scripts\/\n#\n# Author: Keyan Pishdadian\nimport sys\nsys.path.append('scripts')\nimport pytest\nfrom redbaron import RedBaron\nimport flaskext_migrate as migrate\n\n\ndef test_simple_from_import():\n    red = RedBaron(\"from flask.ext import foo\")\n    output = migrate.fix(red)\n    assert output == \"import flask_foo as foo\"\n\n\ndef test_from_to_from_import():\n    red = RedBaron(\"from flask.ext.foo import bar\")\n    output = migrate.fix(red)\n    assert output == \"from flask_foo import bar as bar\"\n\n\ndef test_multiple_import():\n    red = RedBaron(\"from flask.ext.foo import bar, foobar, something\")\n    output = migrate.fix(red)\n    assert output == \"from flask_foo import bar,foobar,something\"\n\n\ndef test_multiline_import():\n    red = RedBaron(\"from flask.ext.foo import \\\n                    bar,\\\n                    foobar,\\\n                    something\")\n    output = migrate.fix(red)\n    assert output == \"from flask_foo import bar,foobar,something\"\n\n\ndef test_module_import():\n    red = RedBaron(\"import flask.ext.foo\")\n    output = migrate.fix(red)\n    assert output == \"import flask_foo\"\n\n\ndef test_module_import():\n    red = RedBaron(\"from flask.ext.foo import bar as baz\")\n    output = migrate.fix(red)\n    assert output == \"from flask_foo import bar as baz\"\n"}
{"prompt":"Python3\n# Script which modifies source code away from the deprecated \"flask.ext\"\n# format. Does not yet fully support imports in the style:\n#\n# \"import flask.ext.foo\"\n#\n# these are converted to \"import flask_foo\" in the\n# main import statement, but does not handle function calls in the source.\n#\n# Run in the terminal by typing: `python flaskext_migrate.py <source_file.py>`\n#\n# Author: Keyan Pishdadian 2015\n\nfrom redbaron import RedBaron\nimport sys\n\n\ndef read_source(input_file):\n    \"\"\"Parses the input_file into a RedBaron FST.\"\"\"\n    with open(input_file, \"r\") as source_code:\n        red = RedBaron(source_code.read())\n    return red\n\n\ndef write_source(red, input_file):\n    \"\"\"Overwrites the input_file once the FST has been modified.\"\"\"\n    with open(input_file, \"w\") as source_code:\n        source_code.write(red.dumps())\n\n\ndef fix_imports(red):\n    \"\"\"Wrapper which fixes \"from\" style imports and then \"import\" style.\"\"\"\n    red = fix_standard_imports(red)\n    red = fix_from_imports(red)\n    return red\n\n\ndef fix_from_imports(red):\n    \"\"\"\n    Converts \"from\" style imports to not use \"flask.ext\".\n\n    Handles:\n    Case 1: from flask.ext.foo import bam --> from flask_foo import bam\n    Case 2: from flask.ext import foo --> import flask_foo as foo\n    \"\"\"\n    from_imports = red.find_all(\"FromImport\")\n    for x, node in enumerate(from_imports):\n        values = node.value\n        if (values[0].value == 'flask') and (values[1].value == 'ext'):\n            # Case 1\n            if len(node.value) == 3:\n                package = values[2].value\n                modules = node.modules()\n                module_string = _get_modules(modules)\n                if len(modules) > 1:\n                    node.replace(\"from flask_%s import %s\"\n                                 % (package, module_string))\n                else:\n                    name = node.names()[0]\n                    node.replace(\"from flask_%s import %s as %s\"\n                                 % (package, module_string, name))\n            # Case 2\n            else:\n                module = node.modules()[0]\n                node.replace(\"import flask_%s as %s\"\n                             % (module, module))\n    return red\n\n\ndef fix_standard_imports(red):\n    \"\"\"\n    Handles import modification in the form:\n    import flask.ext.foo\" --> import flask_foo\n\n    Does not modify function calls elsewhere in the source outside of the\n    original import statement.\n    \"\"\"\n    imports = red.find_all(\"ImportNode\")\n    for x, node in enumerate(imports):\n        try:\n            if (node.value[0].value == 'flask' and\n               node.value[1].value == 'ext'):\n                package = node.value[2].value\n                name = node.names()[0]\n                imports[x].replace(\"import flask_%s as %s\" % (package, name))\n        except IndexError:\n            pass\n\n    return red\n\n\ndef _get_modules(module):\n    \"\"\"\n    Takes a list of modules and converts into a string\n\n    The module list can include parens, this function checks each element in\n    the list, if there is a paren then it does not add a comma before the next\n    element. Otherwise a comma and space is added. This is to preserve module\n    imports which are multi-line and\/or occur within parens. While also not\n    affecting imports which are not enclosed.\n    \"\"\"\n    modules_string = [cur + ', ' if cur.isalnum() and next.isalnum()\n                      else cur\n                      for (cur, next) in zip(module, module[1:]+[''])]\n\n    return ''.join(modules_string)\n\n\ndef check_user_input():\n    \"\"\"Exits and gives error message if no argument is passed in the shell.\"\"\"\n    if len(sys.argv) < 2:\n        sys.exit(\"No filename was included, please try again.\")\n\n\ndef fix(ast):\n    \"\"\"Wrapper which allows for testing when not running from shell.\"\"\"\n    return fix_imports(ast).dumps()\n\n\nif __name__ == \"__main__\":\n    check_user_input()\n    input_file = sys.argv[1]\n    ast = read_source(input_file)\n    ast = fix_imports(ast)\n    write_source(ast, input_file)\n\n\"\"\"\nGenerate tests which test: Add a test and cover edge case with parens\n\"\"\"\n","completion":" # Tester for the flaskext_migrate.py module located in flask\/scripts\/\n#\n# Author: Keyan Pishdadian\nimport pytest\nfrom redbaron import RedBaron\nimport flaskext_migrate as migrate\n\n\ndef test_simple_from_import():\n    red = RedBaron(\"from flask.ext import foo\")\n    output = migrate.fix(red)\n    assert output == \"import flask_foo as foo\"\n\n\ndef test_from_to_from_import():\n    red = RedBaron(\"from flask.ext.foo import bar\")\n    output = migrate.fix(red)\n    assert output == \"from flask_foo import bar as bar\"\n\n\ndef test_multiple_import():\n    red = RedBaron(\"from flask.ext.foo import bar, foobar, something\")\n    output = migrate.fix(red)\n    assert output == \"from flask_foo import bar, foobar, something\"\n\n\ndef test_multiline_import():\n    red = RedBaron(\"from flask.ext.foo import \\\n                    bar,\\\n                    foobar,\\\n                    something\")\n    output = migrate.fix(red)\n    assert output == \"from flask_foo import bar, foobar, something\"\n\n\ndef test_module_import():\n    red = RedBaron(\"import flask.ext.foo\")\n    output = migrate.fix(red)\n    assert output == \"import flask_foo\"\n\n\ndef test_module_import():\n    red = RedBaron(\"from flask.ext.foo import bar as baz\")\n    output = migrate.fix(red)\n    assert output == \"from flask_foo import bar as baz\"\n\n\ndef test_parens_import():\n    red = RedBaron(\"from flask.ext.foo import (bar, foo, foobar)\")\n    output = migrate.fix(red)\n    assert output == \"from flask_foo import (bar, foo, foobar)\"\n"}
{"prompt":"Python3\n# Script which modifies source code away from the deprecated \"flask.ext\"\n# format. Does not yet fully support imports in the style:\n#\n# \"import flask.ext.foo\"\n#\n# these are converted to \"import flask_foo\" in the\n# main import statement, but does not handle function calls in the source.\n#\n# Run in the terminal by typing: `python flaskext_migrate.py <source_file.py>`\n#\n# Author: Keyan Pishdadian 2015\n\nfrom redbaron import RedBaron\nimport sys\n\n\ndef read_source(input_file):\n    \"\"\"Parses the input_file into a RedBaron FST.\"\"\"\n    with open(input_file, \"r\") as source_code:\n        red = RedBaron(source_code.read())\n    return red\n\n\ndef write_source(red, input_file):\n    \"\"\"Overwrites the input_file once the FST has been modified.\"\"\"\n    with open(input_file, \"w\") as source_code:\n        source_code.write(red.dumps())\n\n\ndef fix_imports(red):\n    \"\"\"Wrapper which fixes \"from\" style imports and then \"import\" style.\"\"\"\n    red = fix_standard_imports(red)\n    red = fix_from_imports(red)\n    return red\n\n\ndef fix_from_imports(red):\n    \"\"\"\n    Converts \"from\" style imports to not use \"flask.ext\".\n\n    Handles:\n    Case 1: from flask.ext.foo import bam --> from flask_foo import bam\n    Case 2: from flask.ext import foo --> import flask_foo as foo\n    \"\"\"\n    from_imports = red.find_all(\"FromImport\")\n    for x, node in enumerate(from_imports):\n        values = node.value\n        if (values[0].value == 'flask') and (values[1].value == 'ext'):\n            # Case 1\n            if len(node.value) == 3:\n                package = values[2].value\n                modules = node.modules()\n                module_string = _get_modules(modules)\n                if len(modules) > 1:\n                    node.replace(\"from flask_%s import %s\"\n                                 % (package, module_string))\n                else:\n                    name = node.names()[0]\n                    node.replace(\"from flask_%s import %s as %s\"\n                                 % (package, module_string, name))\n            # Case 2\n            else:\n                module = node.modules()[0]\n                node.replace(\"import flask_%s as %s\"\n                             % (module, module))\n    return red\n\n\ndef fix_standard_imports(red):\n    \"\"\"\n    Handles import modification in the form:\n    import flask.ext.foo\" --> import flask_foo\n    \"\"\"\n    imports = red.find_all(\"ImportNode\")\n    for x, node in enumerate(imports):\n        try:\n            if (node.value[0].value[0].value == 'flask' and\n               node.value[0].value[1].value == 'ext'):\n                package = node.value[0].value[2]\n                name = node.names()[0].split('.')[-1]\n                node.replace(\"import flask_%s as %s\" % (package, name))\n        except IndexError:\n            pass\n\n    return red\n\n\ndef _get_modules(module):\n    \"\"\"\n    Takes a list of modules and converts into a string.\n\n    The module list can include parens, this function checks each element in\n    the list, if there is a paren then it does not add a comma before the next\n    element. Otherwise a comma and space is added. This is to preserve module\n    imports which are multi-line and\/or occur within parens. While also not\n    affecting imports which are not enclosed.\n    \"\"\"\n    modules_string = [cur + ', ' if cur.isalnum() and next.isalnum()\n                      else cur\n                      for (cur, next) in zip(module, module[1:]+[''])]\n\n    return ''.join(modules_string)\n\n\ndef fix_function_calls(red):\n    \"\"\"\n    Modifies function calls in the source to reflect import changes.\n\n    Searches the AST for AtomtrailerNodes and replaces them.\n    \"\"\"\n    atoms = red.find_all(\"Atomtrailers\")\n    for x, node in enumerate(atoms):\n        try:\n            if (node.value[0].value == 'flask' and\n               node.value[1].value == 'ext'):\n                node.replace(\"flask_foo%s\" % node.value[3])\n        except IndexError:\n            pass\n\n    return red\n\n\ndef check_user_input():\n    \"\"\"Exits and gives error message if no argument is passed in the shell.\"\"\"\n    if len(sys.argv) < 2:\n        sys.exit(\"No filename was included, please try again.\")\n\n\ndef fix_tester(ast):\n    \"\"\"Wrapper which allows for testing when not running from shell.\"\"\"\n    ast = fix_imports(ast)\n    ast = fix_function_calls(ast)\n    return ast.dumps()\n\n\ndef fix():\n    \"\"\"Wrapper for user argument checking and import fixing.\"\"\"\n    check_user_input()\n    input_file = sys.argv[1]\n    ast = read_source(input_file)\n    ast = fix_imports(ast)\n    ast = fix_function_calls(ast)\n    write_source(ast, input_file)\n\n\nif __name__ == \"__main__\":\n    fix()\n\n\"\"\"\nGenerate tests which test: Add support for function call fixing, add tests\n\nAddresses #1135, some code cleanup and refactoring. Changes wrapper function which handles testing, further modularized code, added test to cover function call fixing, and fixed duplicate test function name.\n\"\"\"\n","completion":" # Tester for the flaskext_migrate.py module located in flask\/scripts\/\n#\n# Author: Keyan Pishdadian\nimport pytest\nfrom redbaron import RedBaron\nimport flaskext_migrate as migrate\n\n\ndef test_simple_from_import():\n    red = RedBaron(\"from flask.ext import foo\")\n    output = migrate.fix_tester(red)\n    assert output == \"import flask_foo as foo\"\n\n\ndef test_from_to_from_import():\n    red = RedBaron(\"from flask.ext.foo import bar\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar as bar\"\n\n\ndef test_multiple_import():\n    red = RedBaron(\"from flask.ext.foo import bar, foobar, something\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar, foobar, something\"\n\n\ndef test_multiline_import():\n    red = RedBaron(\"from flask.ext.foo import \\\n                    bar,\\\n                    foobar,\\\n                    something\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar, foobar, something\"\n\n\ndef test_module_import():\n    red = RedBaron(\"import flask.ext.foo\")\n    output = migrate.fix_tester(red)\n    assert output == \"import flask_foo as foo\"\n\n\ndef test_named_module_import():\n    red = RedBaron(\"import flask.ext.foo as foobar\")\n    output = migrate.fix_tester(red)\n    assert output == \"import flask_foo as foobar\"\n\n\ndef test__named_from_import():\n    red = RedBaron(\"from flask.ext.foo import bar as baz\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar as baz\"\n\n\ndef test_parens_import():\n    red = RedBaron(\"from flask.ext.foo import (bar, foo, foobar)\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import (bar, foo, foobar)\"\n\n\ndef test_function_call_migration():\n    red = RedBaron(\"flask.ext.foo(var)\")\n    output = migrate.fix_tester(red)\n    assert output == \"flask_foo(var)\"\n"}
{"prompt":"Python3\n# Script which modifies source code away from the deprecated \"flask.ext\"\n# format. Does not yet fully support imports in the style:\n#\n# \"import flask.ext.foo\"\n#\n# these are converted to \"import flask_foo\" in the\n# main import statement, but does not handle function calls in the source.\n#\n# Run in the terminal by typing: `python flaskext_migrate.py <source_file.py>`\n#\n# Author: Keyan Pishdadian 2015\n\nfrom redbaron import RedBaron\nimport sys\n\n\ndef read_source(input_file):\n    \"\"\"Parses the input_file into a RedBaron FST.\"\"\"\n    with open(input_file, \"r\") as source_code:\n        red = RedBaron(source_code.read())\n    return red\n\n\ndef write_source(red, input_file):\n    \"\"\"Overwrites the input_file once the FST has been modified.\"\"\"\n    with open(input_file, \"w\") as source_code:\n        source_code.write(red.dumps())\n\n\ndef fix_imports(red):\n    \"\"\"Wrapper which fixes \"from\" style imports and then \"import\" style.\"\"\"\n    red = fix_standard_imports(red)\n    red = fix_from_imports(red)\n    return red\n\n\ndef fix_from_imports(red):\n    \"\"\"\n    Converts \"from\" style imports to not use \"flask.ext\".\n\n    Handles:\n    Case 1: from flask.ext.foo import bam --> from flask_foo import bam\n    Case 2: from flask.ext import foo --> import flask_foo as foo\n    \"\"\"\n    from_imports = red.find_all(\"FromImport\")\n    for x, node in enumerate(from_imports):\n        values = node.value\n        if (values[0].value == 'flask') and (values[1].value == 'ext'):\n            # Case 1\n            if len(node.value) == 3:\n                package = values[2].value\n                modules = node.modules()\n                module_string = _get_modules(modules)\n                if len(modules) > 1:\n                    node.replace(\"from flask_%s import %s\"\n                                 % (package, module_string))\n                else:\n                    name = node.names()[0]\n                    node.replace(\"from flask_%s import %s as %s\"\n                                 % (package, module_string, name))\n            # Case 2\n            else:\n                module = node.modules()[0]\n                node.replace(\"import flask_%s as %s\"\n                             % (module, module))\n    return red\n\n\ndef fix_standard_imports(red):\n    \"\"\"\n    Handles import modification in the form:\n    import flask.ext.foo\" --> import flask_foo\n    \"\"\"\n    imports = red.find_all(\"ImportNode\")\n    for x, node in enumerate(imports):\n        try:\n            if (node.value[0].value[0].value == 'flask' and\n               node.value[0].value[1].value == 'ext'):\n                package = node.value[0].value[2].value\n                name = node.names()[0].split('.')[-1]\n                if name == package:\n                    node.replace(\"import flask_%s\" % (package))\n                else:\n                    node.replace(\"import flask_%s as %s\" % (package, name))\n        except IndexError:\n            pass\n\n    return red\n\n\ndef _get_modules(module):\n    \"\"\"\n    Takes a list of modules and converts into a string.\n\n    The module list can include parens, this function checks each element in\n    the list, if there is a paren then it does not add a comma before the next\n    element. Otherwise a comma and space is added. This is to preserve module\n    imports which are multi-line and\/or occur within parens. While also not\n    affecting imports which are not enclosed.\n    \"\"\"\n    modules_string = [cur + ', ' if cur.isalnum() and next.isalnum()\n                      else cur\n                      for (cur, next) in zip(module, module[1:]+[''])]\n\n    return ''.join(modules_string)\n\n\ndef fix_function_calls(red):\n    \"\"\"\n    Modifies function calls in the source to reflect import changes.\n\n    Searches the AST for AtomtrailerNodes and replaces them.\n    \"\"\"\n    atoms = red.find_all(\"Atomtrailers\")\n    for x, node in enumerate(atoms):\n        try:\n            if (node.value[0].value == 'flask' and\n               node.value[1].value == 'ext'):\n                params = _form_function_call(node)\n                node.replace(\"flask_%s%s\" % (node.value[2], params))\n        except IndexError:\n            pass\n\n    return red\n\n\ndef _form_function_call(node):\n    \"\"\"\n    Reconstructs function call strings when making attribute access calls.\n    \"\"\"\n    node_vals = node.value\n    output = \".\"\n    for x, param in enumerate(node_vals[3::]):\n        if param.dumps()[0] == \"(\":\n            output = output[0:-1] + param.dumps()\n            return output\n        else:\n            output += param.dumps() + \".\"\n\n\ndef check_user_input():\n    \"\"\"Exits and gives error message if no argument is passed in the shell.\"\"\"\n    if len(sys.argv) < 2:\n        sys.exit(\"No filename was included, please try again.\")\n\n\ndef fix_tester(ast):\n    \"\"\"Wrapper which allows for testing when not running from shell.\"\"\"\n    ast = fix_imports(ast)\n    ast = fix_function_calls(ast)\n    return ast.dumps()\n\n\ndef fix():\n    \"\"\"Wrapper for user argument checking and import fixing.\"\"\"\n    check_user_input()\n    input_file = sys.argv[1]\n    ast = read_source(input_file)\n    ast = fix_imports(ast)\n    ast = fix_function_calls(ast)\n    write_source(ast, input_file)\n\n\nif __name__ == \"__main__\":\n    fix()\n\n\"\"\"\nGenerate tests which test: Add test and logic for attribute access calls\n\"\"\"\n","completion":" # Tester for the flaskext_migrate.py module located in flask\/scripts\/\n#\n# Author: Keyan Pishdadian\nimport pytest\nfrom redbaron import RedBaron\nimport flaskext_migrate as migrate\n\n\ndef test_simple_from_import():\n    red = RedBaron(\"from flask.ext import foo\")\n    output = migrate.fix_tester(red)\n    assert output == \"import flask_foo as foo\"\n\n\ndef test_from_to_from_import():\n    red = RedBaron(\"from flask.ext.foo import bar\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar as bar\"\n\n\ndef test_multiple_import():\n    red = RedBaron(\"from flask.ext.foo import bar, foobar, something\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar, foobar, something\"\n\n\ndef test_multiline_import():\n    red = RedBaron(\"from flask.ext.foo import \\\n                    bar,\\\n                    foobar,\\\n                    something\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar, foobar, something\"\n\n\ndef test_module_import():\n    red = RedBaron(\"import flask.ext.foo\")\n    output = migrate.fix_tester(red)\n    assert output == \"import flask_foo\"\n\n\ndef test_named_module_import():\n    red = RedBaron(\"import flask.ext.foo as foobar\")\n    output = migrate.fix_tester(red)\n    assert output == \"import flask_foo as foobar\"\n\n\ndef test__named_from_import():\n    red = RedBaron(\"from flask.ext.foo import bar as baz\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar as baz\"\n\n\ndef test_parens_import():\n    red = RedBaron(\"from flask.ext.foo import (bar, foo, foobar)\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import (bar, foo, foobar)\"\n\n\ndef test_function_call_migration():\n    red = RedBaron(\"flask.ext.foo(var)\")\n    output = migrate.fix_tester(red)\n    assert output == \"flask_foo(var)\"\n\n\ndef test_nested_function_call_migration():\n    red = RedBaron(\"import flask.ext.foo\\n\\n\"\n                   \"flask.ext.foo.bar(var)\")\n    output = migrate.fix_tester(red)\n    assert output == (\"import flask_foo\\n\\n\"\n                      \"flask_foo.bar(var)\")\n"}
{"prompt":"Python3\n# Script which modifies source code away from the deprecated \"flask.ext\"\n# format.\n#\n# Run in the terminal by typing: `python flaskext_migrate.py <source_file.py>`\n#\n# Author: Keyan Pishdadian 2015\n\nfrom redbaron import RedBaron\nimport sys\n\n\ndef read_source(input_file):\n    \"\"\"Parses the input_file into a RedBaron FST.\"\"\"\n    with open(input_file, \"r\") as source_code:\n        red = RedBaron(source_code.read())\n    return red\n\n\ndef write_source(red, input_file):\n    \"\"\"Overwrites the input_file once the FST has been modified.\"\"\"\n    with open(input_file, \"w\") as source_code:\n        source_code.write(red.dumps())\n\n\ndef fix_imports(red):\n    \"\"\"Wrapper which fixes \"from\" style imports and then \"import\" style.\"\"\"\n    red = fix_standard_imports(red)\n    red = fix_from_imports(red)\n    return red\n\n\ndef fix_from_imports(red):\n    \"\"\"\n    Converts \"from\" style imports to not use \"flask.ext\".\n\n    Handles:\n    Case 1: from flask.ext.foo import bam --> from flask_foo import bam\n    Case 2: from flask.ext import foo --> import flask_foo as foo\n    \"\"\"\n    from_imports = red.find_all(\"FromImport\")\n    for x, node in enumerate(from_imports):\n        values = node.value\n        if len(values) < 2:\n            continue\n        if (values[0].value == 'flask') and (values[1].value == 'ext'):\n            # Case 1\n            if len(node.value) == 3:\n                package = values[2].value\n                modules = node.modules()\n                module_string = _get_modules(modules)\n                if len(modules) > 1:\n                    node.replace(\"from flask_%s import %s\"\n                                 % (package, module_string))\n                else:\n                    name = node.names()[0]\n                    node.replace(\"from flask_%s import %s as %s\"\n                                 % (package, module_string, name))\n            # Case 2\n            else:\n                module = node.modules()[0]\n                node.replace(\"import flask_%s as %s\"\n                             % (module, module))\n    return red\n\n\ndef fix_standard_imports(red):\n    \"\"\"\n    Handles import modification in the form:\n    import flask.ext.foo\" --> import flask_foo\n    \"\"\"\n    imports = red.find_all(\"ImportNode\")\n    for x, node in enumerate(imports):\n        try:\n            if (node.value[0].value[0].value == 'flask' and\n               node.value[0].value[1].value == 'ext'):\n                package = node.value[0].value[2].value\n                name = node.names()[0].split('.')[-1]\n                if name == package:\n                    node.replace(\"import flask_%s\" % (package))\n                else:\n                    node.replace(\"import flask_%s as %s\" % (package, name))\n        except IndexError:\n            pass\n\n    return red\n\n\ndef _get_modules(module):\n    \"\"\"\n    Takes a list of modules and converts into a string.\n\n    The module list can include parens, this function checks each element in\n    the list, if there is a paren then it does not add a comma before the next\n    element. Otherwise a comma and space is added. This is to preserve module\n    imports which are multi-line and\/or occur within parens. While also not\n    affecting imports which are not enclosed.\n    \"\"\"\n    modules_string = [cur + ', ' if cur.isalnum() and next.isalnum()\n                      else cur\n                      for (cur, next) in zip(module, module[1:]+[''])]\n\n    return ''.join(modules_string)\n\n\ndef fix_function_calls(red):\n    \"\"\"\n    Modifies function calls in the source to reflect import changes.\n\n    Searches the AST for AtomtrailerNodes and replaces them.\n    \"\"\"\n    atoms = red.find_all(\"Atomtrailers\")\n    for x, node in enumerate(atoms):\n        try:\n            if (node.value[0].value == 'flask' and\n               node.value[1].value == 'ext'):\n                params = _form_function_call(node)\n                node.replace(\"flask_%s%s\" % (node.value[2], params))\n        except IndexError:\n            pass\n\n    return red\n\n\ndef _form_function_call(node):\n    \"\"\"\n    Reconstructs function call strings when making attribute access calls.\n    \"\"\"\n    node_vals = node.value\n    output = \".\"\n    for x, param in enumerate(node_vals[3::]):\n        if param.dumps()[0] == \"(\":\n            output = output[0:-1] + param.dumps()\n            return output\n        else:\n            output += param.dumps() + \".\"\n\n\ndef check_user_input():\n    \"\"\"Exits and gives error message if no argument is passed in the shell.\"\"\"\n    if len(sys.argv) < 2:\n        sys.exit(\"No filename was included, please try again.\")\n\n\ndef fix_tester(ast):\n    \"\"\"Wrapper which allows for testing when not running from shell.\"\"\"\n    ast = fix_imports(ast)\n    ast = fix_function_calls(ast)\n    return ast.dumps()\n\n\ndef fix():\n    \"\"\"Wrapper for user argument checking and import fixing.\"\"\"\n    check_user_input()\n    input_file = sys.argv[1]\n    ast = read_source(input_file)\n    ast = fix_imports(ast)\n    ast = fix_function_calls(ast)\n    write_source(ast, input_file)\n\n\nif __name__ == \"__main__\":\n    fix()\n\n\"\"\"\nGenerate tests which test: Add skip to fix unnoticed bug with good imports\n\nFixes logic so that imports that should not be changed are skipped, which was not happening correctly before.\n\"\"\"\n","completion":" # Tester for the flaskext_migrate.py module located in flask\/scripts\/\n#\n# Author: Keyan Pishdadian\nimport pytest\nfrom redbaron import RedBaron\nimport flaskext_migrate as migrate\n\n\ndef test_simple_from_import():\n    red = RedBaron(\"from flask.ext import foo\")\n    output = migrate.fix_tester(red)\n    assert output == \"import flask_foo as foo\"\n\n\ndef test_from_to_from_import():\n    red = RedBaron(\"from flask.ext.foo import bar\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar as bar\"\n\n\ndef test_multiple_import():\n    red = RedBaron(\"from flask.ext.foo import bar, foobar, something\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar, foobar, something\"\n\n\ndef test_multiline_import():\n    red = RedBaron(\"from flask.ext.foo import \\\n                    bar,\\\n                    foobar,\\\n                    something\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar, foobar, something\"\n\n\ndef test_module_import():\n    red = RedBaron(\"import flask.ext.foo\")\n    output = migrate.fix_tester(red)\n    assert output == \"import flask_foo\"\n\n\ndef test_named_module_import():\n    red = RedBaron(\"import flask.ext.foo as foobar\")\n    output = migrate.fix_tester(red)\n    assert output == \"import flask_foo as foobar\"\n\n\ndef test_named_from_import():\n    red = RedBaron(\"from flask.ext.foo import bar as baz\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import bar as baz\"\n\n\ndef test_parens_import():\n    red = RedBaron(\"from flask.ext.foo import (bar, foo, foobar)\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask_foo import (bar, foo, foobar)\"\n\n\ndef test_function_call_migration():\n    red = RedBaron(\"flask.ext.foo(var)\")\n    output = migrate.fix_tester(red)\n    assert output == \"flask_foo(var)\"\n\n\ndef test_nested_function_call_migration():\n    red = RedBaron(\"import flask.ext.foo\\n\\n\"\n                   \"flask.ext.foo.bar(var)\")\n    output = migrate.fix_tester(red)\n    assert output == (\"import flask_foo\\n\\n\"\n                      \"flask_foo.bar(var)\")\n\n\ndef test_no_change_to_import():\n    red = RedBaron(\"from flask import Flask\")\n    output = migrate.fix_tester(red)\n    assert output == \"from flask import Flask\"\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.cli\n    ~~~~~~~~~\n\n    A simple command line application to run flask apps.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nfrom threading import Lock, Thread\nfrom functools import update_wrapper\n\nimport click\n\nfrom ._compat import iteritems, reraise\nfrom .helpers import get_debug_flag\nfrom . import __version__\n\nclass NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n\n\ndef find_best_app(module):\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in 'app', 'application':\n        app = getattr(module, attr_name, None)\n        if app is not None and isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [v for k, v in iteritems(module.__dict__)\n               if isinstance(v, Flask)]\n\n    if len(matches) == 1:\n        return matches[0]\n    raise NoAppException('Failed to find application in module \"%s\".  Are '\n                         'you sure it contains a Flask application?  Maybe '\n                         'you wrapped it in a WSGI middleware or you are '\n                         'using a factory function.' % module.__name__)\n\n\ndef prepare_exec_for_file(filename):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    module = []\n\n    # Chop off file extensions or package markers\n    if os.path.split(filename)[1] == '__init__.py':\n        filename = os.path.dirname(filename)\n    elif filename.endswith('.py'):\n        filename = filename[:-3]\n    else:\n        raise NoAppException('The file provided (%s) does exist but is not a '\n                             'valid Python file.  This means that it cannot '\n                             'be used as application.  Please change the '\n                             'extension to .py' % filename)\n    filename = os.path.realpath(filename)\n\n    dirpath = filename\n    while 1:\n        dirpath, extra = os.path.split(dirpath)\n        module.append(extra)\n        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n            break\n\n    sys.path.insert(0, dirpath)\n    return '.'.join(module[::-1])\n\n\ndef locate_app(app_id):\n    \"\"\"Attempts to locate the application.\"\"\"\n    __traceback_hide__ = True\n    if ':' in app_id:\n        module, app_obj = app_id.split(':', 1)\n    else:\n        module = app_id\n        app_obj = None\n\n    __import__(module)\n    mod = sys.modules[module]\n    if app_obj is None:\n        app = find_best_app(mod)\n    else:\n        app = getattr(mod, app_obj, None)\n        if app is None:\n            raise RuntimeError('Failed to find application in module \"%s\"'\n                               % module)\n\n    return app\n\n\ndef find_default_import_path():\n    app = os.environ.get('FLASK_APP')\n    if app is None:\n        return\n    if os.path.isfile(app):\n        return prepare_exec_for_file(app)\n    return app\n\n\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n    message = 'Flask %(version)s\\nPython %(python_version)s'\n    click.echo(message % {\n        'version': __version__,\n        'python_version': sys.version,\n    }, color=ctx.color)\n    ctx.exit()\n\nversion_option = click.Option(['--version'],\n                              help='Show the flask version',\n                              expose_value=False,\n                              callback=get_version,\n                              is_flag=True, is_eager=True)\n\nclass DispatchingApp(object):\n    \"\"\"Special application that dispatches to a flask application which\n    is imported by name in a background thread.  If an error happens\n    it is is recorded and shows as part of the WSGI handling which in case\n    of the Werkzeug debugger means that it shows up in the browser.\n    \"\"\"\n\n    def __init__(self, loader, use_eager_loading=False):\n        self.loader = loader\n        self._app = None\n        self._lock = Lock()\n        self._bg_loading_exc_info = None\n        if use_eager_loading:\n            self._load_unlocked()\n        else:\n            self._load_in_background()\n\n    def _load_in_background(self):\n        def _load_app():\n            __traceback_hide__ = True\n            with self._lock:\n                try:\n                    self._load_unlocked()\n                except Exception:\n                    self._bg_loading_exc_info = sys.exc_info()\n        t = Thread(target=_load_app, args=())\n        t.start()\n\n    def _flush_bg_loading_exception(self):\n        __traceback_hide__ = True\n        exc_info = self._bg_loading_exc_info\n        if exc_info is not None:\n            self._bg_loading_exc_info = None\n            reraise(*exc_info)\n\n    def _load_unlocked(self):\n        __traceback_hide__ = True\n        self._app = rv = self.loader()\n        self._bg_loading_exc_info = None\n        return rv\n\n    def __call__(self, environ, start_response):\n        __traceback_hide__ = True\n        if self._app is not None:\n            return self._app(environ, start_response)\n        self._flush_bg_loading_exception()\n        with self._lock:\n            if self._app is not None:\n                rv = self._app\n            else:\n                rv = self._load_unlocked()\n            return rv(environ, start_response)\n\n\nclass ScriptInfo(object):\n    \"\"\"Help object to deal with Flask applications.  This is usually not\n    necessary to interface with as it's used internally in the dispatching\n    to click.  In future versions of Flask this object will most likely play\n    a bigger role.  Typically it's created automatically by the\n    :class:`FlaskGroup` but you can also manually create it and pass it\n    onwards as click object.\n    \"\"\"\n\n    def __init__(self, app_import_path=None, create_app=None):\n        if create_app is None:\n            if app_import_path is None:\n                app_import_path = find_default_import_path()\n            self.app_import_path = app_import_path\n        else:\n            app_import_path = None\n\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data = {}\n        self._loaded_app = None\n\n    def load_app(self):\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        __traceback_hide__ = True\n        if self._loaded_app is not None:\n            return self._loaded_app\n        if self.create_app is not None:\n            rv = self.create_app(self)\n        else:\n            if not self.app_import_path:\n                raise NoAppException(\n                    'Could not locate Flask application. You did not provide '\n                    'the FLASK_APP environment variable.\\n\\nFor more '\n                    'information see '\n                    'http:\/\/flask.pocoo.org\/docs\/latest\/quickstart\/')\n            rv = locate_app(self.app_import_path)\n        debug = get_debug_flag()\n        if debug is not None:\n            rv.debug = debug\n        self._loaded_app = rv\n        return rv\n\n\npass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n\n\ndef with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.  If callbacks are registered directly\n    to the ``app.cli`` object then they are wrapped with this function\n    by default unless it's disabled.\n    \"\"\"\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n            return __ctx.invoke(f, *args, **kwargs)\n    return update_wrapper(decorator, f)\n\n\nclass AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop('with_appcontext', True)\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n        return decorator\n\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault('cls', AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n\n\nclass FlaskGroup(AppGroup):\n    \"\"\"Special subclass of the :class:`AppGroup` group that supports\n    loading more commands from the configured Flask app.  Normally a\n    developer does not have to interface with this class but there are\n    some very advanced use cases for which it makes sense to create an\n    instance of this.\n\n    For information as of why this is useful see :ref:`custom-scripts`.\n\n    :param add_default_commands: if this is True then the default run and\n                                 shell commands wil be added.\n    :param add_version_option: adds the :option:`--version` option.\n    :param create_app: an optional callback that is passed the script info\n                       and returns the loaded app.\n    \"\"\"\n\n    def __init__(self, add_default_commands=True, create_app=None,\n                 add_version_option=True, **extra):\n        params = list(extra.pop('params', None) or ())\n\n        if add_version_option:\n            params.append(version_option)\n\n        AppGroup.__init__(self, params=params, **extra)\n        self.create_app = create_app\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n\n    def _load_plugin_commands(self):\n        if self._loaded_plugin_commands:\n            return\n        try:\n            import pkg_resources\n        except ImportError:\n            self._loaded_plugin_commands = True\n            return\n\n        for ep in pkg_resources.iter_entry_points('flask.commands'):\n            self.add_command(ep.load(), ep.name)\n        self._loaded_plugin_commands = True\n\n    def get_command(self, ctx, name):\n        self._load_plugin_commands()\n\n        # We load built-in commands first as these should always be the\n        # same no matter what the app does.  If the app does want to\n        # override this it needs to make a custom instance of this group\n        # and not attach the default commands.\n        #\n        # This also means that the script stays functional in case the\n        # application completely fails.\n        rv = AppGroup.get_command(self, ctx, name)\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv = info.load_app().cli.get_command(ctx, name)\n            if rv is not None:\n                return rv\n        except NoAppException:\n            pass\n\n    def list_commands(self, ctx):\n        self._load_plugin_commands()\n\n        # The commands available is the list of both the application (if\n        # available) plus the builtin commands.\n        rv = set(click.Group.list_commands(self, ctx))\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except Exception:\n            # Here we intentionally swallow all exceptions as we don't\n            # want the help page to break if the app does not exist.\n            # If someone attempts to use the command we try to create\n            # the app again and this will give us the error.\n            pass\n        return sorted(rv)\n\n    def main(self, *args, **kwargs):\n        obj = kwargs.get('obj')\n        if obj is None:\n            obj = ScriptInfo(create_app=self.create_app)\n        kwargs['obj'] = obj\n        kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n        return AppGroup.main(self, *args, **kwargs)\n\n\n@click.command('run', short_help='Runs a development server.')\n@click.option('--host', '-h', default='127.0.0.1',\n              help='The interface to bind to.')\n@click.option('--port', '-p', default=5000,\n              help='The port to bind to.')\n@click.option('--reload\/--no-reload', default=None,\n              help='Enable or disable the reloader.  By default the reloader '\n              'is active if debug is enabled.')\n@click.option('--debugger\/--no-debugger', default=None,\n              help='Enable or disable the debugger.  By default the debugger '\n              'is active if debug is enabled.')\n@click.option('--eager-loading\/--lazy-loader', default=None,\n              help='Enable or disable eager loading.  By default eager '\n              'loading is enabled if the reloader is disabled.')\n@click.option('--with-threads\/--without-threads', default=False,\n              help='Enable or disable multithreading.')\n@pass_script_info\ndef run_command(info, host, port, reload, debugger, eager_loading,\n                with_threads):\n    \"\"\"Runs a local development server for the Flask application.\n\n    This local server is recommended for development purposes only but it\n    can also be used for simple intranet deployments.  By default it will\n    not support any sort of concurrency at all to simplify debugging.  This\n    can be changed with the --with-threads option which will enable basic\n    multithreading.\n\n    The reloader and debugger are by default enabled if the debug flag of\n    Flask is enabled and disabled otherwise.\n    \"\"\"\n    from werkzeug.serving import run_simple\n\n    debug = get_debug_flag()\n    if reload is None:\n        reload = bool(debug)\n    if debugger is None:\n        debugger = bool(debug)\n    if eager_loading is None:\n        eager_loading = not reload\n\n    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n\n    # Extra startup messages.  This depends a but on Werkzeug internals to\n    # not double execute when the reloader kicks in.\n    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n        # If we have an import path we can print it out now which can help\n        # people understand what's being served.  If we do not have an\n        # import path because the app was loaded through a callback then\n        # we won't print anything.\n        if info.app_import_path is not None:\n            print(' * Serving Flask app \"%s\"' % info.app_import_path)\n        if debug is not None:\n            print(' * Forcing debug mode %s' % (debug and 'on' or 'off'))\n\n    run_simple(host, port, app, use_reloader=reload,\n               use_debugger=debugger, threaded=with_threads,\n               passthrough_errors=True)\n\n\n@click.command('shell', short_help='Runs a shell in the app context.')\n@with_appcontext\ndef shell_command():\n    \"\"\"Runs an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to it's configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configuring the application.\n    \"\"\"\n    import code\n    from flask.globals import _app_ctx_stack\n    app = _app_ctx_stack.top.app\n    banner = 'Python %s on %s\\nApp: %s%s\\nInstance: %s' % (\n        sys.version,\n        sys.platform,\n        app.import_name,\n        app.debug and ' [debug]' or '',\n        app.instance_path,\n    )\n    ctx = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get('PYTHONSTARTUP')\n    if startup and os.path.isfile(startup):\n        with open(startup, 'r') as f:\n            eval(compile(f.read(), startup, 'exec'), ctx)\n\n    ctx.update(app.make_shell_context())\n\n    code.interact(banner=banner, local=ctx)\n\n\n@click.command('routes', short_help='Show routes for the app.')\n@click.option('-r', 'order_by', flag_value='rule', default=True, help='Order by route')\n@click.option('-e', 'order_by', flag_value='endpoint', help='Order by endpoint')\n@click.option('-m', 'order_by', flag_value='methods', help='Order by methods')\n@with_appcontext\ndef routes_command(order_by):\n    \"\"\"Show all routes with endpoints and methods.\"\"\"\n    from flask.globals import _app_ctx_stack\n    app = _app_ctx_stack.top.app\n\n    order_key = lambda rule: getattr(rule, order_by)\n    sorted_rules = sorted(app.url_map.iter_rules(), key=order_key)\n\n    max_rule = max(len(rule.rule) for rule in sorted_rules)\n    max_rule = max(max_rule, len('Route'))\n    max_ep = max(len(rule.endpoint) for rule in sorted_rules)\n    max_ep = max(max_ep, len('Endpoint'))\n    max_meth = max(len(', '.join(rule.methods)) for rule in sorted_rules)\n    max_meth = max(max_meth, len('Methods'))\n\n    columnformat = '{:<%s}  {:<%s}  {:<%s}' % (max_rule, max_ep, max_meth)\n    click.echo(columnformat.format('Route', 'Endpoint', 'Methods'))\n    under_count = max_rule + max_ep + max_meth + 4\n    click.echo('-' * under_count)\n\n    for rule in sorted_rules:\n        methods = ', '.join(rule.methods)\n        click.echo(columnformat.format(rule.rule, rule.endpoint, methods))\n\n\ncli = FlaskGroup(help=\"\"\"\\\nThis shell command acts as general utility script for Flask applications.\n\nIt loads the application configured (either through the FLASK_APP environment\nvariable) and then provides commands either provided by the application or\nFlask itself.\n\nThe most useful commands are the \"run\" and \"shell\" command.\n\nExample usage:\n\n\\b\n  %(prefix)s%(cmd)s FLASK_APP=hello.py\n  %(prefix)s%(cmd)s FLASK_DEBUG=1\n  %(prefix)sflask run\n\"\"\" % {\n    'cmd': os.name == 'posix' and 'export' or 'set',\n    'prefix': os.name == 'posix' and '$ ' or '',\n})\n\n\ndef main(as_module=False):\n    this_module = __package__ + '.cli'\n    args = sys.argv[1:]\n\n    if as_module:\n        if sys.version_info >= (2, 7):\n            name = 'python -m ' + this_module.rsplit('.', 1)[0]\n        else:\n            name = 'python -m ' + this_module\n\n        # This module is always executed as \"python -m flask.run\" and as such\n        # we need to ensure that we restore the actual command line so that\n        # the reloader can properly operate.\n        sys.argv = ['-m', this_module] + sys.argv[1:]\n    else:\n        name = None\n\n    cli.main(args=args, prog_name=name)\n\n\nif __name__ == '__main__':\n    main(as_module=True)\n\n\"\"\"\nGenerate tests which test: Added tests, fixed some minor alignment problems.\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_cli\n    ~~~~~~~~~~~~~~\n\n    :copyright: (c) 2016 by the Flask Team, see AUTHORS for more details.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n#\n# This file was part of Flask-CLI and was modified under the terms its license,\n# the Revised BSD License.\n# Copyright (C) 2015 CERN.\n#\nfrom __future__ import absolute_import, print_function\nimport os\nimport sys\n\nimport click\nimport pytest\nfrom click.testing import CliRunner\nfrom flask import Flask, current_app\n\nfrom flask.cli import cli, AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n    find_best_app, locate_app, with_appcontext, prepare_exec_for_file, \\\n    find_default_import_path\n\n\ndef test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n    assert testapp.cli.name == testapp.name\n\n\ndef test_find_best_app(test_apps):\n    \"\"\"Test of find_best_app.\"\"\"\n    class mod:\n        app = Flask('appname')\n    assert find_best_app(mod) == mod.app\n\n    class mod:\n        application = Flask('appname')\n    assert find_best_app(mod) == mod.application\n\n    class mod:\n        myapp = Flask('appname')\n    assert find_best_app(mod) == mod.myapp\n\n    class mod:\n        myapp = Flask('appname')\n        myapp2 = Flask('appname2')\n\n    pytest.raises(NoAppException, find_best_app, mod)\n\n\ndef test_prepare_exec_for_file(test_apps):\n    \"\"\"Expect the correct path to be set and the correct module name to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect, where\n    the parent directory of given file is added to `sys.path`.\n    \"\"\"\n    realpath = os.path.realpath('\/tmp\/share\/test.py')\n    dirname = os.path.dirname(realpath)\n    assert prepare_exec_for_file('\/tmp\/share\/test.py') == 'test'\n    assert dirname in sys.path\n\n    realpath = os.path.realpath('\/tmp\/share\/__init__.py')\n    dirname = os.path.dirname(os.path.dirname(realpath))\n    assert prepare_exec_for_file('\/tmp\/share\/__init__.py') == 'share'\n    assert dirname in sys.path\n\n    with pytest.raises(NoAppException):\n        prepare_exec_for_file('\/tmp\/share\/test.txt')\n\n\ndef test_locate_app(test_apps):\n    \"\"\"Test of locate_app.\"\"\"\n    assert locate_app(\"cliapp.app\").name == \"testapp\"\n    assert locate_app(\"cliapp.app:testapp\").name == \"testapp\"\n    assert locate_app(\"cliapp.multiapp:app1\").name == \"app1\"\n    pytest.raises(RuntimeError, locate_app, \"cliapp.app:notanapp\")\n\n\ndef test_find_default_import_path(test_apps, monkeypatch, tmpdir):\n    \"\"\"Test of find_default_import_path.\"\"\"\n    monkeypatch.delitem(os.environ, 'FLASK_APP', raising=False)\n    assert find_default_import_path() == None\n    monkeypatch.setitem(os.environ, 'FLASK_APP', 'notanapp')\n    assert find_default_import_path() == 'notanapp'\n    tmpfile = tmpdir.join('testapp.py')\n    tmpfile.write('')\n    monkeypatch.setitem(os.environ, 'FLASK_APP', str(tmpfile))\n    expect_rv = prepare_exec_for_file(str(tmpfile))\n    assert find_default_import_path() == expect_rv\n\n\ndef test_scriptinfo(test_apps):\n    \"\"\"Test of ScriptInfo.\"\"\"\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    assert obj.load_app().name == \"testapp\"\n    assert obj.load_app().name == \"testapp\"\n\n    def create_app(info):\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() == app\n\n\ndef test_with_appcontext():\n    \"\"\"Test of with_appcontext.\"\"\"\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testapp\"))\n\n    runner = CliRunner()\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testapp\\n'\n\n\ndef test_appgroup():\n    \"\"\"Test of with_appcontext.\"\"\"\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command(with_appcontext=True)\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command(with_appcontext=True)\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testappgroup\"))\n\n    runner = CliRunner()\n    result = runner.invoke(cli, ['test'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n    result = runner.invoke(cli, ['subgroup', 'test2'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n\ndef test_flaskgroup():\n    \"\"\"Test FlaskGroup.\"\"\"\n    def create_app(info):\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    runner = CliRunner()\n    result = runner.invoke(cli, ['test'])\n    assert result.exit_code == 0\n    assert result.output == 'flaskgroup\\n'\n\n\nclass TestRoutes:\n    def test_no_route(self, monkeypatch):\n        monkeypatch.setitem(os.environ, 'FLASK_APP', 'cliapp.routesapp:noroute_app')\n        runner = CliRunner()\n        result = runner.invoke(cli, ['routes'], catch_exceptions=False)\n        assert result.exit_code == 0\n        assert result.output == \"\"\"\\\nRoute                    Endpoint  Methods           \n-----------------------------------------------------\n\/static\/<path:filename>  static    HEAD, OPTIONS, GET\n\"\"\"\n\n    def test_simple_route(self, monkeypatch):\n        monkeypatch.setitem(os.environ, 'FLASK_APP', 'cliapp.routesapp:simpleroute_app')\n        runner = CliRunner()\n        result = runner.invoke(cli, ['routes'], catch_exceptions=False)\n        assert result.exit_code == 0\n        assert result.output == \"\"\"\\\nRoute                    Endpoint  Methods           \n-----------------------------------------------------\n\/simpleroute             simple    HEAD, OPTIONS, GET\n\/static\/<path:filename>  static    HEAD, OPTIONS, GET\n\"\"\"\n\n    def test_only_POST_route(self, monkeypatch):\n        monkeypatch.setitem(os.environ, 'FLASK_APP', 'cliapp.routesapp:only_POST_route_app')\n        runner = CliRunner()\n        result = runner.invoke(cli, ['routes'], catch_exceptions=False)\n        assert result.exit_code == 0\n        assert result.output == \"\"\"\\\nRoute                    Endpoint   Methods           \n------------------------------------------------------\n\/only-post               only_post  POST, OPTIONS     \n\/static\/<path:filename>  static     HEAD, OPTIONS, GET\n\"\"\"\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.cli\n    ~~~~~~~~~\n\n    A simple command line application to run flask apps.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nimport traceback\nfrom functools import update_wrapper\nfrom operator import attrgetter\nfrom threading import Lock, Thread\n\nimport click\n\nfrom . import __version__\nfrom ._compat import iteritems, reraise\nfrom .globals import current_app\nfrom .helpers import get_debug_flag\n\n\nclass NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n\n\ndef find_best_app(module):\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in 'app', 'application':\n        app = getattr(module, attr_name, None)\n        if app is not None and isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [v for k, v in iteritems(module.__dict__)\n               if isinstance(v, Flask)]\n\n    if len(matches) == 1:\n        return matches[0]\n    raise NoAppException('Failed to find application in module \"%s\".  Are '\n                         'you sure it contains a Flask application?  Maybe '\n                         'you wrapped it in a WSGI middleware or you are '\n                         'using a factory function.' % module.__name__)\n\n\ndef prepare_exec_for_file(filename):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    module = []\n\n    # Chop off file extensions or package markers\n    if os.path.split(filename)[1] == '__init__.py':\n        filename = os.path.dirname(filename)\n    elif filename.endswith('.py'):\n        filename = filename[:-3]\n    else:\n        raise NoAppException('The file provided (%s) does exist but is not a '\n                             'valid Python file.  This means that it cannot '\n                             'be used as application.  Please change the '\n                             'extension to .py' % filename)\n    filename = os.path.realpath(filename)\n\n    dirpath = filename\n    while 1:\n        dirpath, extra = os.path.split(dirpath)\n        module.append(extra)\n        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n            break\n\n    sys.path.insert(0, dirpath)\n    return '.'.join(module[::-1])\n\n\ndef locate_app(app_id):\n    \"\"\"Attempts to locate the application.\"\"\"\n    __traceback_hide__ = True\n    if ':' in app_id:\n        module, app_obj = app_id.split(':', 1)\n    else:\n        module = app_id\n        app_obj = None\n\n    try:\n        __import__(module)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[-1].tb_next:\n            stack_trace = traceback.format_exc()\n            raise NoAppException('There was an error trying to import'\n                    ' the app (%s):\\n%s' % (module, stack_trace))\n        else:\n            raise NoAppException('The file\/path provided (%s) does not appear'\n                                 ' to exist.  Please verify the path is '\n                                 'correct.  If app is not on PYTHONPATH, '\n                                 'ensure the extension is .py' % module)\n\n    mod = sys.modules[module]\n    if app_obj is None:\n        app = find_best_app(mod)\n    else:\n        app = getattr(mod, app_obj, None)\n        if app is None:\n            raise RuntimeError('Failed to find application in module \"%s\"'\n                               % module)\n\n    return app\n\n\ndef find_default_import_path():\n    app = os.environ.get('FLASK_APP')\n    if app is None:\n        return\n    if os.path.isfile(app):\n        return prepare_exec_for_file(app)\n    return app\n\n\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n    message = 'Flask %(version)s\\nPython %(python_version)s'\n    click.echo(message % {\n        'version': __version__,\n        'python_version': sys.version,\n    }, color=ctx.color)\n    ctx.exit()\n\nversion_option = click.Option(['--version'],\n                              help='Show the flask version',\n                              expose_value=False,\n                              callback=get_version,\n                              is_flag=True, is_eager=True)\n\nclass DispatchingApp(object):\n    \"\"\"Special application that dispatches to a Flask application which\n    is imported by name in a background thread.  If an error happens\n    it is recorded and shown as part of the WSGI handling which in case\n    of the Werkzeug debugger means that it shows up in the browser.\n    \"\"\"\n\n    def __init__(self, loader, use_eager_loading=False):\n        self.loader = loader\n        self._app = None\n        self._lock = Lock()\n        self._bg_loading_exc_info = None\n        if use_eager_loading:\n            self._load_unlocked()\n        else:\n            self._load_in_background()\n\n    def _load_in_background(self):\n        def _load_app():\n            __traceback_hide__ = True\n            with self._lock:\n                try:\n                    self._load_unlocked()\n                except Exception:\n                    self._bg_loading_exc_info = sys.exc_info()\n        t = Thread(target=_load_app, args=())\n        t.start()\n\n    def _flush_bg_loading_exception(self):\n        __traceback_hide__ = True\n        exc_info = self._bg_loading_exc_info\n        if exc_info is not None:\n            self._bg_loading_exc_info = None\n            reraise(*exc_info)\n\n    def _load_unlocked(self):\n        __traceback_hide__ = True\n        self._app = rv = self.loader()\n        self._bg_loading_exc_info = None\n        return rv\n\n    def __call__(self, environ, start_response):\n        __traceback_hide__ = True\n        if self._app is not None:\n            return self._app(environ, start_response)\n        self._flush_bg_loading_exception()\n        with self._lock:\n            if self._app is not None:\n                rv = self._app\n            else:\n                rv = self._load_unlocked()\n            return rv(environ, start_response)\n\n\nclass ScriptInfo(object):\n    \"\"\"Help object to deal with Flask applications.  This is usually not\n    necessary to interface with as it's used internally in the dispatching\n    to click.  In future versions of Flask this object will most likely play\n    a bigger role.  Typically it's created automatically by the\n    :class:`FlaskGroup` but you can also manually create it and pass it\n    onwards as click object.\n    \"\"\"\n\n    def __init__(self, app_import_path=None, create_app=None):\n        if create_app is None:\n            if app_import_path is None:\n                app_import_path = find_default_import_path()\n            self.app_import_path = app_import_path\n        else:\n            app_import_path = None\n\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data = {}\n        self._loaded_app = None\n\n    def load_app(self):\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        __traceback_hide__ = True\n        if self._loaded_app is not None:\n            return self._loaded_app\n        if self.create_app is not None:\n            rv = self.create_app(self)\n        else:\n            if not self.app_import_path:\n                raise NoAppException(\n                    'Could not locate Flask application. You did not provide '\n                    'the FLASK_APP environment variable.\\n\\nFor more '\n                    'information see '\n                    'http:\/\/flask.pocoo.org\/docs\/latest\/quickstart\/')\n            rv = locate_app(self.app_import_path)\n        debug = get_debug_flag()\n        if debug is not None:\n            rv.debug = debug\n        self._loaded_app = rv\n        return rv\n\n\npass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n\n\ndef with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.  If callbacks are registered directly\n    to the ``app.cli`` object then they are wrapped with this function\n    by default unless it's disabled.\n    \"\"\"\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n            return __ctx.invoke(f, *args, **kwargs)\n    return update_wrapper(decorator, f)\n\n\nclass AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop('with_appcontext', True)\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n        return decorator\n\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault('cls', AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n\n\nclass FlaskGroup(AppGroup):\n    \"\"\"Special subclass of the :class:`AppGroup` group that supports\n    loading more commands from the configured Flask app.  Normally a\n    developer does not have to interface with this class but there are\n    some very advanced use cases for which it makes sense to create an\n    instance of this.\n\n    For information as of why this is useful see :ref:`custom-scripts`.\n\n    :param add_default_commands: if this is True then the default run and\n                                 shell commands wil be added.\n    :param add_version_option: adds the ``--version`` option.\n    :param create_app: an optional callback that is passed the script info\n                       and returns the loaded app.\n    \"\"\"\n\n    def __init__(self, add_default_commands=True, create_app=None,\n                 add_version_option=True, **extra):\n        params = list(extra.pop('params', None) or ())\n\n        if add_version_option:\n            params.append(version_option)\n\n        AppGroup.__init__(self, params=params, **extra)\n        self.create_app = create_app\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n\n    def _load_plugin_commands(self):\n        if self._loaded_plugin_commands:\n            return\n        try:\n            import pkg_resources\n        except ImportError:\n            self._loaded_plugin_commands = True\n            return\n\n        for ep in pkg_resources.iter_entry_points('flask.commands'):\n            self.add_command(ep.load(), ep.name)\n        self._loaded_plugin_commands = True\n\n    def get_command(self, ctx, name):\n        self._load_plugin_commands()\n\n        # We load built-in commands first as these should always be the\n        # same no matter what the app does.  If the app does want to\n        # override this it needs to make a custom instance of this group\n        # and not attach the default commands.\n        #\n        # This also means that the script stays functional in case the\n        # application completely fails.\n        rv = AppGroup.get_command(self, ctx, name)\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv = info.load_app().cli.get_command(ctx, name)\n            if rv is not None:\n                return rv\n        except NoAppException:\n            pass\n\n    def list_commands(self, ctx):\n        self._load_plugin_commands()\n\n        # The commands available is the list of both the application (if\n        # available) plus the builtin commands.\n        rv = set(click.Group.list_commands(self, ctx))\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except Exception:\n            # Here we intentionally swallow all exceptions as we don't\n            # want the help page to break if the app does not exist.\n            # If someone attempts to use the command we try to create\n            # the app again and this will give us the error.\n            # However, we will not do so silently because that would confuse\n            # users.\n            traceback.print_exc()\n        return sorted(rv)\n\n    def main(self, *args, **kwargs):\n        obj = kwargs.get('obj')\n        if obj is None:\n            obj = ScriptInfo(create_app=self.create_app)\n        kwargs['obj'] = obj\n        kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n        return AppGroup.main(self, *args, **kwargs)\n\n\n@click.command('run', short_help='Runs a development server.')\n@click.option('--host', '-h', default='127.0.0.1',\n              help='The interface to bind to.')\n@click.option('--port', '-p', default=5000,\n              help='The port to bind to.')\n@click.option('--reload\/--no-reload', default=None,\n              help='Enable or disable the reloader.  By default the reloader '\n              'is active if debug is enabled.')\n@click.option('--debugger\/--no-debugger', default=None,\n              help='Enable or disable the debugger.  By default the debugger '\n              'is active if debug is enabled.')\n@click.option('--eager-loading\/--lazy-loader', default=None,\n              help='Enable or disable eager loading.  By default eager '\n              'loading is enabled if the reloader is disabled.')\n@click.option('--with-threads\/--without-threads', default=False,\n              help='Enable or disable multithreading.')\n@pass_script_info\ndef run_command(info, host, port, reload, debugger, eager_loading,\n                with_threads):\n    \"\"\"Runs a local development server for the Flask application.\n\n    This local server is recommended for development purposes only but it\n    can also be used for simple intranet deployments.  By default it will\n    not support any sort of concurrency at all to simplify debugging.  This\n    can be changed with the --with-threads option which will enable basic\n    multithreading.\n\n    The reloader and debugger are by default enabled if the debug flag of\n    Flask is enabled and disabled otherwise.\n    \"\"\"\n    from werkzeug.serving import run_simple\n\n    # Set a global flag that indicates that we were invoked from the\n    # command line interface provided server command.  This is detected\n    # by Flask.run to make the call into a no-op.  This is necessary to\n    # avoid ugly errors when the script that is loaded here also attempts\n    # to start a server.\n    os.environ['FLASK_RUN_FROM_CLI_SERVER'] = '1'\n\n    debug = get_debug_flag()\n    if reload is None:\n        reload = bool(debug)\n    if debugger is None:\n        debugger = bool(debug)\n    if eager_loading is None:\n        eager_loading = not reload\n\n    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n\n    # Extra startup messages.  This depends a bit on Werkzeug internals to\n    # not double execute when the reloader kicks in.\n    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n        # If we have an import path we can print it out now which can help\n        # people understand what's being served.  If we do not have an\n        # import path because the app was loaded through a callback then\n        # we won't print anything.\n        if info.app_import_path is not None:\n            print(' * Serving Flask app \"%s\"' % info.app_import_path)\n        if debug is not None:\n            print(' * Forcing debug mode %s' % (debug and 'on' or 'off'))\n\n    run_simple(host, port, app, use_reloader=reload,\n               use_debugger=debugger, threaded=with_threads)\n\n\n@click.command('shell', short_help='Runs a shell in the app context.')\n@with_appcontext\ndef shell_command():\n    \"\"\"Runs an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to it's configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configuring the application.\n    \"\"\"\n    import code\n    from flask.globals import _app_ctx_stack\n    app = _app_ctx_stack.top.app\n    banner = 'Python %s on %s\\nApp: %s%s\\nInstance: %s' % (\n        sys.version,\n        sys.platform,\n        app.import_name,\n        app.debug and ' [debug]' or '',\n        app.instance_path,\n    )\n    ctx = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get('PYTHONSTARTUP')\n    if startup and os.path.isfile(startup):\n        with open(startup, 'r') as f:\n            eval(compile(f.read(), startup, 'exec'), ctx)\n\n    ctx.update(app.make_shell_context())\n\n    code.interact(banner=banner, local=ctx)\n\n\n@click.command('routes', short_help='Show the routes for the app.')\n@click.option(\n    '--sort', '-s',\n    type=click.Choice(('endpoint', 'methods', 'rule', 'match')),\n    default='endpoint',\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        'routes when dispatching a request.'\n    )\n)\n@click.option(\n    '--all-methods',\n    is_flag=True,\n    help=\"Show HEAD and OPTIONS methods.\"\n)\n@with_appcontext\ndef routes_command(sort, all_methods):\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    ignored_methods = set(() if all_methods else ('HEAD', 'OPTIONS'))\n\n    if sort in ('endpoint', 'rule'):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == 'methods':\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\n        ', '.join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = ('Endpoint', 'Methods', 'Rule')\n    widths = (\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = '{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}'.format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*('-' * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n\n\ncli = FlaskGroup(help=\"\"\"\\\nThis shell command acts as general utility script for Flask applications.\n\nIt loads the application configured (through the FLASK_APP environment\nvariable) and then provides commands either provided by the application or\nFlask itself.\n\nThe most useful commands are the \"run\" and \"shell\" command.\n\nExample usage:\n\n\\b\n  %(prefix)s%(cmd)s FLASK_APP=hello.py\n  %(prefix)s%(cmd)s FLASK_DEBUG=1\n  %(prefix)sflask run\n\"\"\" % {\n    'cmd': os.name == 'posix' and 'export' or 'set',\n    'prefix': os.name == 'posix' and '$ ' or '',\n})\n\n\ndef main(as_module=False):\n    this_module = __package__ + '.cli'\n    args = sys.argv[1:]\n\n    if as_module:\n        if sys.version_info >= (2, 7):\n            name = 'python -m ' + this_module.rsplit('.', 1)[0]\n        else:\n            name = 'python -m ' + this_module\n\n        # This module is always executed as \"python -m flask.run\" and as such\n        # we need to ensure that we restore the actual command line so that\n        # the reloader can properly operate.\n        sys.argv = ['-m', this_module] + sys.argv[1:]\n    else:\n        name = None\n\n    cli.main(args=args, prog_name=name)\n\n\nif __name__ == '__main__':\n    main(as_module=True)\n\n\"\"\"\nGenerate tests which test: add sort by match order\nsort by endpoint by default\ncombine sort flags\nsort methods\nignore HEAD and OPTIONS methods by default\nrearrange columns\nuse format to build row format string\nrework tests\nadd changelog\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_cli\n    ~~~~~~~~~~~~~~\n\n    :copyright: (c) 2016 by the Flask Team, see AUTHORS for more details.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n#\n# This file was part of Flask-CLI and was modified under the terms its license,\n# the Revised BSD License.\n# Copyright (C) 2015 CERN.\n#\nfrom __future__ import absolute_import, print_function\nimport os\nimport sys\nfrom functools import partial\n\nimport click\nimport pytest\nfrom click.testing import CliRunner\nfrom flask import Flask, current_app\n\nfrom flask.cli import cli, AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n    find_best_app, locate_app, with_appcontext, prepare_exec_for_file, \\\n    find_default_import_path, get_version\n\n\n@pytest.fixture\ndef runner():\n    return CliRunner()\n\n\ndef test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n    assert testapp.cli.name == testapp.name\n\n\ndef test_find_best_app(test_apps):\n    \"\"\"Test if `find_best_app` behaves as expected with different combinations of input.\"\"\"\n    class Module:\n        app = Flask('appname')\n    assert find_best_app(Module) == Module.app\n\n    class Module:\n        application = Flask('appname')\n    assert find_best_app(Module) == Module.application\n\n    class Module:\n        myapp = Flask('appname')\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        pass\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        myapp1 = Flask('appname1')\n        myapp2 = Flask('appname2')\n    pytest.raises(NoAppException, find_best_app, Module)\n\n\ndef test_prepare_exec_for_file(test_apps):\n    \"\"\"Expect the correct path to be set and the correct module name to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect, where\n    the parent directory of given file is added to `sys.path`.\n    \"\"\"\n    realpath = os.path.realpath('\/tmp\/share\/test.py')\n    dirname = os.path.dirname(realpath)\n    assert prepare_exec_for_file('\/tmp\/share\/test.py') == 'test'\n    assert dirname in sys.path\n\n    realpath = os.path.realpath('\/tmp\/share\/__init__.py')\n    dirname = os.path.dirname(os.path.dirname(realpath))\n    assert prepare_exec_for_file('\/tmp\/share\/__init__.py') == 'share'\n    assert dirname in sys.path\n\n    with pytest.raises(NoAppException):\n        prepare_exec_for_file('\/tmp\/share\/test.txt')\n\n\ndef test_locate_app(test_apps):\n    \"\"\"Test of locate_app.\"\"\"\n    assert locate_app(\"cliapp.app\").name == \"testapp\"\n    assert locate_app(\"cliapp.app:testapp\").name == \"testapp\"\n    assert locate_app(\"cliapp.multiapp:app1\").name == \"app1\"\n    pytest.raises(NoAppException, locate_app, \"notanpp.py\")\n    pytest.raises(NoAppException, locate_app, \"cliapp\/app\")\n    pytest.raises(RuntimeError, locate_app, \"cliapp.app:notanapp\")\n    pytest.raises(NoAppException, locate_app, \"cliapp.importerrorapp\")\n\n\ndef test_find_default_import_path(test_apps, monkeypatch, tmpdir):\n    \"\"\"Test of find_default_import_path.\"\"\"\n    monkeypatch.delitem(os.environ, 'FLASK_APP', raising=False)\n    assert find_default_import_path() == None\n    monkeypatch.setitem(os.environ, 'FLASK_APP', 'notanapp')\n    assert find_default_import_path() == 'notanapp'\n    tmpfile = tmpdir.join('testapp.py')\n    tmpfile.write('')\n    monkeypatch.setitem(os.environ, 'FLASK_APP', str(tmpfile))\n    expect_rv = prepare_exec_for_file(str(tmpfile))\n    assert find_default_import_path() == expect_rv\n\n\ndef test_get_version(test_apps, capsys):\n    \"\"\"Test of get_version.\"\"\"\n    from flask import __version__ as flask_ver\n    from sys import version as py_ver\n    class MockCtx(object):\n        resilient_parsing = False\n        color = None\n        def exit(self): return\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert flask_ver in out\n    assert py_ver in out\n\n\ndef test_scriptinfo(test_apps):\n    \"\"\"Test of ScriptInfo.\"\"\"\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    assert obj.load_app().name == \"testapp\"\n    assert obj.load_app().name == \"testapp\"\n\n    def create_app(info):\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() == app\n\n\ndef test_with_appcontext(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testapp\\n'\n\n\ndef test_appgroup(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command(with_appcontext=True)\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command(with_appcontext=True)\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, ['test'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n    result = runner.invoke(cli, ['subgroup', 'test2'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n\ndef test_flaskgroup(runner):\n    \"\"\"Test FlaskGroup.\"\"\"\n    def create_app(info):\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, ['test'])\n    assert result.exit_code == 0\n    assert result.output == 'flaskgroup\\n'\n\n\ndef test_print_exceptions(runner):\n    \"\"\"Print the stacktrace if the CLI.\"\"\"\n    def create_app(info):\n        raise Exception(\"oh no\")\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    result = runner.invoke(cli, ['--help'])\n    assert result.exit_code == 0\n    assert 'Exception: oh no' in result.output\n    assert 'Traceback' in result.output\n\n\nclass TestRoutes:\n    @pytest.fixture\n    def invoke(self, runner):\n        def create_app(info):\n            app = Flask(__name__)\n            app.testing = True\n\n            @app.route('\/get_post\/<int:x>\/<int:y>', methods=['GET', 'POST'])\n            def yyy_get_post(x, y):\n                pass\n\n            @app.route('\/zzz_post', methods=['POST'])\n            def aaa_post():\n                pass\n\n            return app\n\n        cli = FlaskGroup(create_app=create_app)\n        return partial(runner.invoke, cli)\n\n    def expect_order(self, order, output):\n        # skip the header and match the start of each row\n        for expect, line in zip(order, output.splitlines()[2:]):\n            # do this instead of startswith for nicer pytest output\n            assert line[:len(expect)] == expect\n\n    def test_simple(self, invoke):\n        result = invoke(['routes'])\n        assert result.exit_code == 0\n        self.expect_order(\n            ['aaa_post', 'static', 'yyy_get_post'],\n            result.output\n        )\n\n    def test_sort(self, invoke):\n        default_output = invoke(['routes']).output\n        endpoint_output = invoke(['routes', '-s', 'endpoint']).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            ['static', 'yyy_get_post', 'aaa_post'],\n            invoke(['routes', '-s', 'methods']).output\n        )\n        self.expect_order(\n            ['yyy_get_post', 'static', 'aaa_post'],\n            invoke(['routes', '-s', 'rule']).output\n        )\n        self.expect_order(\n            ['aaa_post', 'yyy_get_post', 'static'],\n            invoke(['routes', '-s', 'match']).output\n        )\n\n    def test_all_methods(self, invoke):\n        output = invoke(['routes']).output\n        assert 'GET, HEAD, OPTIONS, POST' not in output\n        output = invoke(['routes', '--all-methods']).output\n        assert 'GET, HEAD, OPTIONS, POST' in output\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.cli\n    ~~~~~~~~~\n\n    A simple command line application to run flask apps.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nimport traceback\nfrom functools import update_wrapper\nfrom operator import attrgetter\nfrom threading import Lock, Thread\n\nimport click\n\nfrom . import __version__\nfrom ._compat import iteritems, reraise\nfrom .globals import current_app\nfrom .helpers import get_debug_flag\n\n\nclass NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n\n\ndef find_best_app(module):\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in 'app', 'application':\n        app = getattr(module, attr_name, None)\n        if app is not None and isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [v for k, v in iteritems(module.__dict__)\n               if isinstance(v, Flask)]\n\n    if len(matches) == 1:\n        return matches[0]\n\n    # Search for app factory callables.\n    for attr_name in 'create_app', 'make_app':\n        app_factory = getattr(module, attr_name, None)\n        if app_factory is not None and callable(app_factory):\n            try:\n                app = app_factory()\n                if app is not None and isinstance(app, Flask):\n                    return app\n            except TypeError:\n                raise NoAppException('Auto-detected \"%s()\" in module \"%s\", '\n                                     'but could not call it without '\n                                     'specifying arguments.'\n                                     % (attr_name, module.__name__))\n\n    raise NoAppException('Failed to find application in module \"%s\".  Are '\n                         'you sure it contains a Flask application?  Maybe '\n                         'you wrapped it in a WSGI middleware or you are '\n                         'using a factory function.' % module.__name__)\n\n\ndef prepare_exec_for_file(filename):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    module = []\n\n    # Chop off file extensions or package markers\n    if os.path.split(filename)[1] == '__init__.py':\n        filename = os.path.dirname(filename)\n    elif filename.endswith('.py'):\n        filename = filename[:-3]\n    else:\n        raise NoAppException('The file provided (%s) does exist but is not a '\n                             'valid Python file.  This means that it cannot '\n                             'be used as application.  Please change the '\n                             'extension to .py' % filename)\n    filename = os.path.realpath(filename)\n\n    dirpath = filename\n    while 1:\n        dirpath, extra = os.path.split(dirpath)\n        module.append(extra)\n        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n            break\n\n    sys.path.insert(0, dirpath)\n    return '.'.join(module[::-1])\n\n\ndef locate_app(app_id):\n    \"\"\"Attempts to locate the application.\"\"\"\n    __traceback_hide__ = True\n    if ':' in app_id:\n        module, app_obj = app_id.split(':', 1)\n    else:\n        module = app_id\n        app_obj = None\n\n    try:\n        __import__(module)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[-1].tb_next:\n            stack_trace = traceback.format_exc()\n            raise NoAppException('There was an error trying to import'\n                    ' the app (%s):\\n%s' % (module, stack_trace))\n        else:\n            raise NoAppException('The file\/path provided (%s) does not appear'\n                                 ' to exist.  Please verify the path is '\n                                 'correct.  If app is not on PYTHONPATH, '\n                                 'ensure the extension is .py' % module)\n\n    mod = sys.modules[module]\n    if app_obj is None:\n        app = find_best_app(mod)\n    else:\n        app = getattr(mod, app_obj, None)\n        if app is None:\n            raise RuntimeError('Failed to find application in module \"%s\"'\n                               % module)\n\n    return app\n\n\ndef find_default_import_path():\n    app = os.environ.get('FLASK_APP')\n    if app is None:\n        return\n    if os.path.isfile(app):\n        return prepare_exec_for_file(app)\n    return app\n\n\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n    message = 'Flask %(version)s\\nPython %(python_version)s'\n    click.echo(message % {\n        'version': __version__,\n        'python_version': sys.version,\n    }, color=ctx.color)\n    ctx.exit()\n\nversion_option = click.Option(['--version'],\n                              help='Show the flask version',\n                              expose_value=False,\n                              callback=get_version,\n                              is_flag=True, is_eager=True)\n\nclass DispatchingApp(object):\n    \"\"\"Special application that dispatches to a Flask application which\n    is imported by name in a background thread.  If an error happens\n    it is recorded and shown as part of the WSGI handling which in case\n    of the Werkzeug debugger means that it shows up in the browser.\n    \"\"\"\n\n    def __init__(self, loader, use_eager_loading=False):\n        self.loader = loader\n        self._app = None\n        self._lock = Lock()\n        self._bg_loading_exc_info = None\n        if use_eager_loading:\n            self._load_unlocked()\n        else:\n            self._load_in_background()\n\n    def _load_in_background(self):\n        def _load_app():\n            __traceback_hide__ = True\n            with self._lock:\n                try:\n                    self._load_unlocked()\n                except Exception:\n                    self._bg_loading_exc_info = sys.exc_info()\n        t = Thread(target=_load_app, args=())\n        t.start()\n\n    def _flush_bg_loading_exception(self):\n        __traceback_hide__ = True\n        exc_info = self._bg_loading_exc_info\n        if exc_info is not None:\n            self._bg_loading_exc_info = None\n            reraise(*exc_info)\n\n    def _load_unlocked(self):\n        __traceback_hide__ = True\n        self._app = rv = self.loader()\n        self._bg_loading_exc_info = None\n        return rv\n\n    def __call__(self, environ, start_response):\n        __traceback_hide__ = True\n        if self._app is not None:\n            return self._app(environ, start_response)\n        self._flush_bg_loading_exception()\n        with self._lock:\n            if self._app is not None:\n                rv = self._app\n            else:\n                rv = self._load_unlocked()\n            return rv(environ, start_response)\n\n\nclass ScriptInfo(object):\n    \"\"\"Help object to deal with Flask applications.  This is usually not\n    necessary to interface with as it's used internally in the dispatching\n    to click.  In future versions of Flask this object will most likely play\n    a bigger role.  Typically it's created automatically by the\n    :class:`FlaskGroup` but you can also manually create it and pass it\n    onwards as click object.\n    \"\"\"\n\n    def __init__(self, app_import_path=None, create_app=None):\n        if create_app is None:\n            if app_import_path is None:\n                app_import_path = find_default_import_path()\n            self.app_import_path = app_import_path\n        else:\n            app_import_path = None\n\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data = {}\n        self._loaded_app = None\n\n    def load_app(self):\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        __traceback_hide__ = True\n        if self._loaded_app is not None:\n            return self._loaded_app\n        if self.create_app is not None:\n            rv = self.create_app(self)\n        else:\n            if not self.app_import_path:\n                raise NoAppException(\n                    'Could not locate Flask application. You did not provide '\n                    'the FLASK_APP environment variable.\\n\\nFor more '\n                    'information see '\n                    'http:\/\/flask.pocoo.org\/docs\/latest\/quickstart\/')\n            rv = locate_app(self.app_import_path)\n        debug = get_debug_flag()\n        if debug is not None:\n            rv.debug = debug\n        self._loaded_app = rv\n        return rv\n\n\npass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n\n\ndef with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.  If callbacks are registered directly\n    to the ``app.cli`` object then they are wrapped with this function\n    by default unless it's disabled.\n    \"\"\"\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n            return __ctx.invoke(f, *args, **kwargs)\n    return update_wrapper(decorator, f)\n\n\nclass AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop('with_appcontext', True)\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n        return decorator\n\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault('cls', AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n\n\nclass FlaskGroup(AppGroup):\n    \"\"\"Special subclass of the :class:`AppGroup` group that supports\n    loading more commands from the configured Flask app.  Normally a\n    developer does not have to interface with this class but there are\n    some very advanced use cases for which it makes sense to create an\n    instance of this.\n\n    For information as of why this is useful see :ref:`custom-scripts`.\n\n    :param add_default_commands: if this is True then the default run and\n                                 shell commands wil be added.\n    :param add_version_option: adds the ``--version`` option.\n    :param create_app: an optional callback that is passed the script info\n                       and returns the loaded app.\n    \"\"\"\n\n    def __init__(self, add_default_commands=True, create_app=None,\n                 add_version_option=True, **extra):\n        params = list(extra.pop('params', None) or ())\n\n        if add_version_option:\n            params.append(version_option)\n\n        AppGroup.__init__(self, params=params, **extra)\n        self.create_app = create_app\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n\n    def _load_plugin_commands(self):\n        if self._loaded_plugin_commands:\n            return\n        try:\n            import pkg_resources\n        except ImportError:\n            self._loaded_plugin_commands = True\n            return\n\n        for ep in pkg_resources.iter_entry_points('flask.commands'):\n            self.add_command(ep.load(), ep.name)\n        self._loaded_plugin_commands = True\n\n    def get_command(self, ctx, name):\n        self._load_plugin_commands()\n\n        # We load built-in commands first as these should always be the\n        # same no matter what the app does.  If the app does want to\n        # override this it needs to make a custom instance of this group\n        # and not attach the default commands.\n        #\n        # This also means that the script stays functional in case the\n        # application completely fails.\n        rv = AppGroup.get_command(self, ctx, name)\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv = info.load_app().cli.get_command(ctx, name)\n            if rv is not None:\n                return rv\n        except NoAppException:\n            pass\n\n    def list_commands(self, ctx):\n        self._load_plugin_commands()\n\n        # The commands available is the list of both the application (if\n        # available) plus the builtin commands.\n        rv = set(click.Group.list_commands(self, ctx))\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except Exception:\n            # Here we intentionally swallow all exceptions as we don't\n            # want the help page to break if the app does not exist.\n            # If someone attempts to use the command we try to create\n            # the app again and this will give us the error.\n            # However, we will not do so silently because that would confuse\n            # users.\n            traceback.print_exc()\n        return sorted(rv)\n\n    def main(self, *args, **kwargs):\n        obj = kwargs.get('obj')\n        if obj is None:\n            obj = ScriptInfo(create_app=self.create_app)\n        kwargs['obj'] = obj\n        kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n        return AppGroup.main(self, *args, **kwargs)\n\n\n@click.command('run', short_help='Runs a development server.')\n@click.option('--host', '-h', default='127.0.0.1',\n              help='The interface to bind to.')\n@click.option('--port', '-p', default=5000,\n              help='The port to bind to.')\n@click.option('--reload\/--no-reload', default=None,\n              help='Enable or disable the reloader.  By default the reloader '\n              'is active if debug is enabled.')\n@click.option('--debugger\/--no-debugger', default=None,\n              help='Enable or disable the debugger.  By default the debugger '\n              'is active if debug is enabled.')\n@click.option('--eager-loading\/--lazy-loader', default=None,\n              help='Enable or disable eager loading.  By default eager '\n              'loading is enabled if the reloader is disabled.')\n@click.option('--with-threads\/--without-threads', default=False,\n              help='Enable or disable multithreading.')\n@pass_script_info\ndef run_command(info, host, port, reload, debugger, eager_loading,\n                with_threads):\n    \"\"\"Runs a local development server for the Flask application.\n\n    This local server is recommended for development purposes only but it\n    can also be used for simple intranet deployments.  By default it will\n    not support any sort of concurrency at all to simplify debugging.  This\n    can be changed with the --with-threads option which will enable basic\n    multithreading.\n\n    The reloader and debugger are by default enabled if the debug flag of\n    Flask is enabled and disabled otherwise.\n    \"\"\"\n    from werkzeug.serving import run_simple\n\n    # Set a global flag that indicates that we were invoked from the\n    # command line interface provided server command.  This is detected\n    # by Flask.run to make the call into a no-op.  This is necessary to\n    # avoid ugly errors when the script that is loaded here also attempts\n    # to start a server.\n    os.environ['FLASK_RUN_FROM_CLI_SERVER'] = '1'\n\n    debug = get_debug_flag()\n    if reload is None:\n        reload = bool(debug)\n    if debugger is None:\n        debugger = bool(debug)\n    if eager_loading is None:\n        eager_loading = not reload\n\n    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n\n    # Extra startup messages.  This depends a bit on Werkzeug internals to\n    # not double execute when the reloader kicks in.\n    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n        # If we have an import path we can print it out now which can help\n        # people understand what's being served.  If we do not have an\n        # import path because the app was loaded through a callback then\n        # we won't print anything.\n        if info.app_import_path is not None:\n            print(' * Serving Flask app \"%s\"' % info.app_import_path)\n        if debug is not None:\n            print(' * Forcing debug mode %s' % (debug and 'on' or 'off'))\n\n    run_simple(host, port, app, use_reloader=reload,\n               use_debugger=debugger, threaded=with_threads)\n\n\n@click.command('shell', short_help='Runs a shell in the app context.')\n@with_appcontext\ndef shell_command():\n    \"\"\"Runs an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to it's configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configuring the application.\n    \"\"\"\n    import code\n    from flask.globals import _app_ctx_stack\n    app = _app_ctx_stack.top.app\n    banner = 'Python %s on %s\\nApp: %s%s\\nInstance: %s' % (\n        sys.version,\n        sys.platform,\n        app.import_name,\n        app.debug and ' [debug]' or '',\n        app.instance_path,\n    )\n    ctx = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get('PYTHONSTARTUP')\n    if startup and os.path.isfile(startup):\n        with open(startup, 'r') as f:\n            eval(compile(f.read(), startup, 'exec'), ctx)\n\n    ctx.update(app.make_shell_context())\n\n    code.interact(banner=banner, local=ctx)\n\n\n@click.command('routes', short_help='Show the routes for the app.')\n@click.option(\n    '--sort', '-s',\n    type=click.Choice(('endpoint', 'methods', 'rule', 'match')),\n    default='endpoint',\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        'routes when dispatching a request.'\n    )\n)\n@click.option(\n    '--all-methods',\n    is_flag=True,\n    help=\"Show HEAD and OPTIONS methods.\"\n)\n@with_appcontext\ndef routes_command(sort, all_methods):\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    ignored_methods = set(() if all_methods else ('HEAD', 'OPTIONS'))\n\n    if sort in ('endpoint', 'rule'):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == 'methods':\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\n        ', '.join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = ('Endpoint', 'Methods', 'Rule')\n    widths = (\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = '{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}'.format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*('-' * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n\n\ncli = FlaskGroup(help=\"\"\"\\\nThis shell command acts as general utility script for Flask applications.\n\nIt loads the application configured (through the FLASK_APP environment\nvariable) and then provides commands either provided by the application or\nFlask itself.\n\nThe most useful commands are the \"run\" and \"shell\" command.\n\nExample usage:\n\n\\b\n  %(prefix)s%(cmd)s FLASK_APP=hello.py\n  %(prefix)s%(cmd)s FLASK_DEBUG=1\n  %(prefix)sflask run\n\"\"\" % {\n    'cmd': os.name == 'posix' and 'export' or 'set',\n    'prefix': os.name == 'posix' and '$ ' or '',\n})\n\n\ndef main(as_module=False):\n    this_module = __package__ + '.cli'\n    args = sys.argv[1:]\n\n    if as_module:\n        if sys.version_info >= (2, 7):\n            name = 'python -m ' + this_module.rsplit('.', 1)[0]\n        else:\n            name = 'python -m ' + this_module\n\n        # This module is always executed as \"python -m flask.run\" and as such\n        # we need to ensure that we restore the actual command line so that\n        # the reloader can properly operate.\n        sys.argv = ['-m', this_module] + sys.argv[1:]\n    else:\n        name = None\n\n    cli.main(args=args, prog_name=name)\n\n\nif __name__ == '__main__':\n    main(as_module=True)\n\n\"\"\"\nGenerate tests which test: Auto-detect create_app and make_app factory functions\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_cli\n    ~~~~~~~~~~~~~~\n\n    :copyright: (c) 2016 by the Flask Team, see AUTHORS for more details.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n#\n# This file was part of Flask-CLI and was modified under the terms its license,\n# the Revised BSD License.\n# Copyright (C) 2015 CERN.\n#\nfrom __future__ import absolute_import, print_function\nimport os\nimport sys\nfrom functools import partial\n\nimport click\nimport pytest\nfrom click.testing import CliRunner\nfrom flask import Flask, current_app\n\nfrom flask.cli import cli, AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n    find_best_app, locate_app, with_appcontext, prepare_exec_for_file, \\\n    find_default_import_path, get_version\n\n\n@pytest.fixture\ndef runner():\n    return CliRunner()\n\n\ndef test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n    assert testapp.cli.name == testapp.name\n\n\ndef test_find_best_app(test_apps):\n    \"\"\"Test if `find_best_app` behaves as expected with different combinations of input.\"\"\"\n    class Module:\n        app = Flask('appname')\n    assert find_best_app(Module) == Module.app\n\n    class Module:\n        application = Flask('appname')\n    assert find_best_app(Module) == Module.application\n\n    class Module:\n        myapp = Flask('appname')\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask('appname')\n    assert isinstance(find_best_app(Module), Flask)\n    assert find_best_app(Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask('appname')\n    assert isinstance(find_best_app(Module), Flask)\n    assert find_best_app(Module).name == 'appname'\n\n    class Module:\n        myapp = Flask('appname1')\n        @staticmethod\n        def create_app():\n            return Flask('appname2')\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        myapp = Flask('appname1')\n        @staticmethod\n        def create_app(foo):\n            return Flask('appname2')\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        pass\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        myapp1 = Flask('appname1')\n        myapp2 = Flask('appname2')\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo):\n            return Flask('appname2')\n    pytest.raises(NoAppException, find_best_app, Module)\n\n\ndef test_prepare_exec_for_file(test_apps):\n    \"\"\"Expect the correct path to be set and the correct module name to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect, where\n    the parent directory of given file is added to `sys.path`.\n    \"\"\"\n    realpath = os.path.realpath('\/tmp\/share\/test.py')\n    dirname = os.path.dirname(realpath)\n    assert prepare_exec_for_file('\/tmp\/share\/test.py') == 'test'\n    assert dirname in sys.path\n\n    realpath = os.path.realpath('\/tmp\/share\/__init__.py')\n    dirname = os.path.dirname(os.path.dirname(realpath))\n    assert prepare_exec_for_file('\/tmp\/share\/__init__.py') == 'share'\n    assert dirname in sys.path\n\n    with pytest.raises(NoAppException):\n        prepare_exec_for_file('\/tmp\/share\/test.txt')\n\n\ndef test_locate_app(test_apps):\n    \"\"\"Test of locate_app.\"\"\"\n    assert locate_app(\"cliapp.app\").name == \"testapp\"\n    assert locate_app(\"cliapp.app:testapp\").name == \"testapp\"\n    assert locate_app(\"cliapp.multiapp:app1\").name == \"app1\"\n    pytest.raises(NoAppException, locate_app, \"notanpp.py\")\n    pytest.raises(NoAppException, locate_app, \"cliapp\/app\")\n    pytest.raises(RuntimeError, locate_app, \"cliapp.app:notanapp\")\n    pytest.raises(NoAppException, locate_app, \"cliapp.importerrorapp\")\n\n\ndef test_find_default_import_path(test_apps, monkeypatch, tmpdir):\n    \"\"\"Test of find_default_import_path.\"\"\"\n    monkeypatch.delitem(os.environ, 'FLASK_APP', raising=False)\n    assert find_default_import_path() == None\n    monkeypatch.setitem(os.environ, 'FLASK_APP', 'notanapp')\n    assert find_default_import_path() == 'notanapp'\n    tmpfile = tmpdir.join('testapp.py')\n    tmpfile.write('')\n    monkeypatch.setitem(os.environ, 'FLASK_APP', str(tmpfile))\n    expect_rv = prepare_exec_for_file(str(tmpfile))\n    assert find_default_import_path() == expect_rv\n\n\ndef test_get_version(test_apps, capsys):\n    \"\"\"Test of get_version.\"\"\"\n    from flask import __version__ as flask_ver\n    from sys import version as py_ver\n    class MockCtx(object):\n        resilient_parsing = False\n        color = None\n        def exit(self): return\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert flask_ver in out\n    assert py_ver in out\n\n\ndef test_scriptinfo(test_apps):\n    \"\"\"Test of ScriptInfo.\"\"\"\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    assert obj.load_app().name == \"testapp\"\n    assert obj.load_app().name == \"testapp\"\n\n    def create_app(info):\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() == app\n\n\ndef test_with_appcontext(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testapp\\n'\n\n\ndef test_appgroup(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command(with_appcontext=True)\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command(with_appcontext=True)\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, ['test'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n    result = runner.invoke(cli, ['subgroup', 'test2'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n\ndef test_flaskgroup(runner):\n    \"\"\"Test FlaskGroup.\"\"\"\n    def create_app(info):\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, ['test'])\n    assert result.exit_code == 0\n    assert result.output == 'flaskgroup\\n'\n\n\ndef test_print_exceptions(runner):\n    \"\"\"Print the stacktrace if the CLI.\"\"\"\n    def create_app(info):\n        raise Exception(\"oh no\")\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    result = runner.invoke(cli, ['--help'])\n    assert result.exit_code == 0\n    assert 'Exception: oh no' in result.output\n    assert 'Traceback' in result.output\n\n\nclass TestRoutes:\n    @pytest.fixture\n    def invoke(self, runner):\n        def create_app(info):\n            app = Flask(__name__)\n            app.testing = True\n\n            @app.route('\/get_post\/<int:x>\/<int:y>', methods=['GET', 'POST'])\n            def yyy_get_post(x, y):\n                pass\n\n            @app.route('\/zzz_post', methods=['POST'])\n            def aaa_post():\n                pass\n\n            return app\n\n        cli = FlaskGroup(create_app=create_app)\n        return partial(runner.invoke, cli)\n\n    def expect_order(self, order, output):\n        # skip the header and match the start of each row\n        for expect, line in zip(order, output.splitlines()[2:]):\n            # do this instead of startswith for nicer pytest output\n            assert line[:len(expect)] == expect\n\n    def test_simple(self, invoke):\n        result = invoke(['routes'])\n        assert result.exit_code == 0\n        self.expect_order(\n            ['aaa_post', 'static', 'yyy_get_post'],\n            result.output\n        )\n\n    def test_sort(self, invoke):\n        default_output = invoke(['routes']).output\n        endpoint_output = invoke(['routes', '-s', 'endpoint']).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            ['static', 'yyy_get_post', 'aaa_post'],\n            invoke(['routes', '-s', 'methods']).output\n        )\n        self.expect_order(\n            ['yyy_get_post', 'static', 'aaa_post'],\n            invoke(['routes', '-s', 'rule']).output\n        )\n        self.expect_order(\n            ['aaa_post', 'yyy_get_post', 'static'],\n            invoke(['routes', '-s', 'match']).output\n        )\n\n    def test_all_methods(self, invoke):\n        output = invoke(['routes']).output\n        assert 'GET, HEAD, OPTIONS, POST' not in output\n        output = invoke(['routes', '--all-methods']).output\n        assert 'GET, HEAD, OPTIONS, POST' in output\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.cli\n    ~~~~~~~~~\n\n    A simple command line application to run flask apps.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nimport traceback\nfrom functools import update_wrapper\nfrom operator import attrgetter\nfrom threading import Lock, Thread\n\nimport click\n\nfrom . import __version__\nfrom ._compat import iteritems, reraise\nfrom .globals import current_app\nfrom .helpers import get_debug_flag\nfrom ._compat import getargspec\n\n\nclass NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n\n\ndef find_best_app(script_info, module):\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in ('app', 'application'):\n        app = getattr(module, attr_name, None)\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [\n        v for k, v in iteritems(module.__dict__) if isinstance(v, Flask)\n    ]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            'Auto-detected multiple Flask applications in module \"{module}\".'\n            ' Use \"FLASK_APP={module}:name\" to specify the correct'\n            ' one.'.format(module=module.__name__)\n        )\n\n    # Search for app factory callables.\n    for attr_name in ('create_app', 'make_app'):\n        app_factory = getattr(module, attr_name, None)\n\n        if callable(app_factory):\n            try:\n                app = check_factory_for_script_info_and_call(app_factory,\n                                                             script_info)\n                if isinstance(app, Flask):\n                    return app\n            except TypeError:\n                raise NoAppException(\n                    'Auto-detected \"{callable}()\" in module \"{module}\", but '\n                    'could not call it without specifying arguments.'.format(\n                        callable=attr_name, module=module.__name__\n                    )\n                )\n\n    raise NoAppException(\n        'Failed to find application in module \"{module}\". Are you sure '\n        'it contains a Flask application? Maybe you wrapped it in a WSGI '\n        'middleware.'.format(module=module.__name__)\n    )\n\n\ndef check_factory_for_script_info_and_call(func, script_info):\n    \"\"\"Given a function this checks if the function has an argument named \n    script_info or just a single argument and calls the function with \n    script_info if so. Otherwise calls the function without any arguments and \n    returns the result.\"\"\"\n    arguments = getargspec(func).args\n    if 'script_info' in arguments:\n        result = func(script_info=script_info)\n    elif len(arguments) == 1:\n        result = func(script_info)\n    else:\n        result = func()\n    return result\n\n\ndef prepare_exec_for_file(filename):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    module = []\n\n    # Chop off file extensions or package markers\n    if os.path.split(filename)[1] == '__init__.py':\n        filename = os.path.dirname(filename)\n    elif filename.endswith('.py'):\n        filename = filename[:-3]\n    else:\n        raise NoAppException('The file provided (%s) does exist but is not a '\n                             'valid Python file.  This means that it cannot '\n                             'be used as application.  Please change the '\n                             'extension to .py' % filename)\n    filename = os.path.realpath(filename)\n\n    dirpath = filename\n    while 1:\n        dirpath, extra = os.path.split(dirpath)\n        module.append(extra)\n        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n            break\n\n    sys.path.insert(0, dirpath)\n    return '.'.join(module[::-1])\n\n\ndef locate_app(script_info, app_id):\n    \"\"\"Attempts to locate the application.\"\"\"\n    __traceback_hide__ = True\n    if ':' in app_id:\n        module, app_obj = app_id.split(':', 1)\n    else:\n        module = app_id\n        app_obj = None\n\n    try:\n        __import__(module)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[-1].tb_next:\n            stack_trace = traceback.format_exc()\n            raise NoAppException('There was an error trying to import'\n                    ' the app (%s):\\n%s' % (module, stack_trace))\n        else:\n            raise NoAppException('The file\/path provided (%s) does not appear'\n                                 ' to exist.  Please verify the path is '\n                                 'correct.  If app is not on PYTHONPATH, '\n                                 'ensure the extension is .py' % module)\n\n    mod = sys.modules[module]\n    if app_obj is None:\n        app = find_best_app(script_info, mod)\n    else:\n        app = getattr(mod, app_obj, None)\n        if app is None:\n            raise RuntimeError('Failed to find application in module \"%s\"'\n                               % module)\n\n    return app\n\n\ndef find_default_import_path():\n    app = os.environ.get('FLASK_APP')\n    if app is None:\n        return\n    if os.path.isfile(app):\n        return prepare_exec_for_file(app)\n    return app\n\n\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n    message = 'Flask %(version)s\\nPython %(python_version)s'\n    click.echo(message % {\n        'version': __version__,\n        'python_version': sys.version,\n    }, color=ctx.color)\n    ctx.exit()\n\nversion_option = click.Option(['--version'],\n                              help='Show the flask version',\n                              expose_value=False,\n                              callback=get_version,\n                              is_flag=True, is_eager=True)\n\nclass DispatchingApp(object):\n    \"\"\"Special application that dispatches to a Flask application which\n    is imported by name in a background thread.  If an error happens\n    it is recorded and shown as part of the WSGI handling which in case\n    of the Werkzeug debugger means that it shows up in the browser.\n    \"\"\"\n\n    def __init__(self, loader, use_eager_loading=False):\n        self.loader = loader\n        self._app = None\n        self._lock = Lock()\n        self._bg_loading_exc_info = None\n        if use_eager_loading:\n            self._load_unlocked()\n        else:\n            self._load_in_background()\n\n    def _load_in_background(self):\n        def _load_app():\n            __traceback_hide__ = True\n            with self._lock:\n                try:\n                    self._load_unlocked()\n                except Exception:\n                    self._bg_loading_exc_info = sys.exc_info()\n        t = Thread(target=_load_app, args=())\n        t.start()\n\n    def _flush_bg_loading_exception(self):\n        __traceback_hide__ = True\n        exc_info = self._bg_loading_exc_info\n        if exc_info is not None:\n            self._bg_loading_exc_info = None\n            reraise(*exc_info)\n\n    def _load_unlocked(self):\n        __traceback_hide__ = True\n        self._app = rv = self.loader()\n        self._bg_loading_exc_info = None\n        return rv\n\n    def __call__(self, environ, start_response):\n        __traceback_hide__ = True\n        if self._app is not None:\n            return self._app(environ, start_response)\n        self._flush_bg_loading_exception()\n        with self._lock:\n            if self._app is not None:\n                rv = self._app\n            else:\n                rv = self._load_unlocked()\n            return rv(environ, start_response)\n\n\nclass ScriptInfo(object):\n    \"\"\"Help object to deal with Flask applications.  This is usually not\n    necessary to interface with as it's used internally in the dispatching\n    to click.  In future versions of Flask this object will most likely play\n    a bigger role.  Typically it's created automatically by the\n    :class:`FlaskGroup` but you can also manually create it and pass it\n    onwards as click object.\n    \"\"\"\n\n    def __init__(self, app_import_path=None, create_app=None):\n        if create_app is None:\n            if app_import_path is None:\n                app_import_path = find_default_import_path()\n            self.app_import_path = app_import_path\n        else:\n            app_import_path = None\n\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data = {}\n        self._loaded_app = None\n\n    def load_app(self):\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        __traceback_hide__ = True\n        if self._loaded_app is not None:\n            return self._loaded_app\n        if self.create_app is not None:\n            rv = check_factory_for_script_info_and_call(self.create_app, self)\n        else:\n            if not self.app_import_path:\n                raise NoAppException(\n                    'Could not locate Flask application. You did not provide '\n                    'the FLASK_APP environment variable.\\n\\nFor more '\n                    'information see '\n                    'http:\/\/flask.pocoo.org\/docs\/latest\/quickstart\/')\n            rv = locate_app(self, self.app_import_path)\n        debug = get_debug_flag()\n        if debug is not None:\n            rv.debug = debug\n        self._loaded_app = rv\n        return rv\n\n\npass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n\n\ndef with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.  If callbacks are registered directly\n    to the ``app.cli`` object then they are wrapped with this function\n    by default unless it's disabled.\n    \"\"\"\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n            return __ctx.invoke(f, *args, **kwargs)\n    return update_wrapper(decorator, f)\n\n\nclass AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop('with_appcontext', True)\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n        return decorator\n\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault('cls', AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n\n\nclass FlaskGroup(AppGroup):\n    \"\"\"Special subclass of the :class:`AppGroup` group that supports\n    loading more commands from the configured Flask app.  Normally a\n    developer does not have to interface with this class but there are\n    some very advanced use cases for which it makes sense to create an\n    instance of this.\n\n    For information as of why this is useful see :ref:`custom-scripts`.\n\n    :param add_default_commands: if this is True then the default run and\n                                 shell commands wil be added.\n    :param add_version_option: adds the ``--version`` option.\n    :param create_app: an optional callback that is passed the script info\n                       and returns the loaded app.\n    \"\"\"\n\n    def __init__(self, add_default_commands=True, create_app=None,\n                 add_version_option=True, **extra):\n        params = list(extra.pop('params', None) or ())\n\n        if add_version_option:\n            params.append(version_option)\n\n        AppGroup.__init__(self, params=params, **extra)\n        self.create_app = create_app\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n\n    def _load_plugin_commands(self):\n        if self._loaded_plugin_commands:\n            return\n        try:\n            import pkg_resources\n        except ImportError:\n            self._loaded_plugin_commands = True\n            return\n\n        for ep in pkg_resources.iter_entry_points('flask.commands'):\n            self.add_command(ep.load(), ep.name)\n        self._loaded_plugin_commands = True\n\n    def get_command(self, ctx, name):\n        self._load_plugin_commands()\n\n        # We load built-in commands first as these should always be the\n        # same no matter what the app does.  If the app does want to\n        # override this it needs to make a custom instance of this group\n        # and not attach the default commands.\n        #\n        # This also means that the script stays functional in case the\n        # application completely fails.\n        rv = AppGroup.get_command(self, ctx, name)\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv = info.load_app().cli.get_command(ctx, name)\n            if rv is not None:\n                return rv\n        except NoAppException:\n            pass\n\n    def list_commands(self, ctx):\n        self._load_plugin_commands()\n\n        # The commands available is the list of both the application (if\n        # available) plus the builtin commands.\n        rv = set(click.Group.list_commands(self, ctx))\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except Exception:\n            # Here we intentionally swallow all exceptions as we don't\n            # want the help page to break if the app does not exist.\n            # If someone attempts to use the command we try to create\n            # the app again and this will give us the error.\n            # However, we will not do so silently because that would confuse\n            # users.\n            traceback.print_exc()\n        return sorted(rv)\n\n    def main(self, *args, **kwargs):\n        obj = kwargs.get('obj')\n        if obj is None:\n            obj = ScriptInfo(create_app=self.create_app)\n        kwargs['obj'] = obj\n        kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n        return AppGroup.main(self, *args, **kwargs)\n\n\n@click.command('run', short_help='Runs a development server.')\n@click.option('--host', '-h', default='127.0.0.1',\n              help='The interface to bind to.')\n@click.option('--port', '-p', default=5000,\n              help='The port to bind to.')\n@click.option('--reload\/--no-reload', default=None,\n              help='Enable or disable the reloader.  By default the reloader '\n              'is active if debug is enabled.')\n@click.option('--debugger\/--no-debugger', default=None,\n              help='Enable or disable the debugger.  By default the debugger '\n              'is active if debug is enabled.')\n@click.option('--eager-loading\/--lazy-loader', default=None,\n              help='Enable or disable eager loading.  By default eager '\n              'loading is enabled if the reloader is disabled.')\n@click.option('--with-threads\/--without-threads', default=False,\n              help='Enable or disable multithreading.')\n@pass_script_info\ndef run_command(info, host, port, reload, debugger, eager_loading,\n                with_threads):\n    \"\"\"Runs a local development server for the Flask application.\n\n    This local server is recommended for development purposes only but it\n    can also be used for simple intranet deployments.  By default it will\n    not support any sort of concurrency at all to simplify debugging.  This\n    can be changed with the --with-threads option which will enable basic\n    multithreading.\n\n    The reloader and debugger are by default enabled if the debug flag of\n    Flask is enabled and disabled otherwise.\n    \"\"\"\n    from werkzeug.serving import run_simple\n\n    # Set a global flag that indicates that we were invoked from the\n    # command line interface provided server command.  This is detected\n    # by Flask.run to make the call into a no-op.  This is necessary to\n    # avoid ugly errors when the script that is loaded here also attempts\n    # to start a server.\n    os.environ['FLASK_RUN_FROM_CLI_SERVER'] = '1'\n\n    debug = get_debug_flag()\n    if reload is None:\n        reload = bool(debug)\n    if debugger is None:\n        debugger = bool(debug)\n    if eager_loading is None:\n        eager_loading = not reload\n\n    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n\n    # Extra startup messages.  This depends a bit on Werkzeug internals to\n    # not double execute when the reloader kicks in.\n    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n        # If we have an import path we can print it out now which can help\n        # people understand what's being served.  If we do not have an\n        # import path because the app was loaded through a callback then\n        # we won't print anything.\n        if info.app_import_path is not None:\n            print(' * Serving Flask app \"%s\"' % info.app_import_path)\n        if debug is not None:\n            print(' * Forcing debug mode %s' % (debug and 'on' or 'off'))\n\n    run_simple(host, port, app, use_reloader=reload,\n               use_debugger=debugger, threaded=with_threads)\n\n\n@click.command('shell', short_help='Runs a shell in the app context.')\n@with_appcontext\ndef shell_command():\n    \"\"\"Runs an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to it's configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configuring the application.\n    \"\"\"\n    import code\n    from flask.globals import _app_ctx_stack\n    app = _app_ctx_stack.top.app\n    banner = 'Python %s on %s\\nApp: %s%s\\nInstance: %s' % (\n        sys.version,\n        sys.platform,\n        app.import_name,\n        app.debug and ' [debug]' or '',\n        app.instance_path,\n    )\n    ctx = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get('PYTHONSTARTUP')\n    if startup and os.path.isfile(startup):\n        with open(startup, 'r') as f:\n            eval(compile(f.read(), startup, 'exec'), ctx)\n\n    ctx.update(app.make_shell_context())\n\n    code.interact(banner=banner, local=ctx)\n\n\n@click.command('routes', short_help='Show the routes for the app.')\n@click.option(\n    '--sort', '-s',\n    type=click.Choice(('endpoint', 'methods', 'rule', 'match')),\n    default='endpoint',\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        'routes when dispatching a request.'\n    )\n)\n@click.option(\n    '--all-methods',\n    is_flag=True,\n    help=\"Show HEAD and OPTIONS methods.\"\n)\n@with_appcontext\ndef routes_command(sort, all_methods):\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    ignored_methods = set(() if all_methods else ('HEAD', 'OPTIONS'))\n\n    if sort in ('endpoint', 'rule'):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == 'methods':\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\n        ', '.join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = ('Endpoint', 'Methods', 'Rule')\n    widths = (\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = '{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}'.format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*('-' * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n\n\ncli = FlaskGroup(help=\"\"\"\\\nThis shell command acts as general utility script for Flask applications.\n\nIt loads the application configured (through the FLASK_APP environment\nvariable) and then provides commands either provided by the application or\nFlask itself.\n\nThe most useful commands are the \"run\" and \"shell\" command.\n\nExample usage:\n\n\\b\n  %(prefix)s%(cmd)s FLASK_APP=hello.py\n  %(prefix)s%(cmd)s FLASK_DEBUG=1\n  %(prefix)sflask run\n\"\"\" % {\n    'cmd': os.name == 'posix' and 'export' or 'set',\n    'prefix': os.name == 'posix' and '$ ' or '',\n})\n\n\ndef main(as_module=False):\n    this_module = __package__ + '.cli'\n    args = sys.argv[1:]\n\n    if as_module:\n        if sys.version_info >= (2, 7):\n            name = 'python -m ' + this_module.rsplit('.', 1)[0]\n        else:\n            name = 'python -m ' + this_module\n\n        # This module is always executed as \"python -m flask.run\" and as such\n        # we need to ensure that we restore the actual command line so that\n        # the reloader can properly operate.\n        sys.argv = ['-m', this_module] + sys.argv[1:]\n    else:\n        name = None\n\n    cli.main(args=args, prog_name=name)\n\n\nif __name__ == '__main__':\n    main(as_module=True)\n\n\"\"\"\nGenerate tests which test: Check if app factory takes script_info argument and call it with(out) script_info as an argument depending on that\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_cli\n    ~~~~~~~~~~~~~~\n\n    :copyright: (c) 2016 by the Flask Team, see AUTHORS for more details.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n#\n# This file was part of Flask-CLI and was modified under the terms its license,\n# the Revised BSD License.\n# Copyright (C) 2015 CERN.\n#\nfrom __future__ import absolute_import, print_function\nimport os\nimport sys\nfrom functools import partial\n\nimport click\nimport pytest\nfrom click.testing import CliRunner\nfrom flask import Flask, current_app\n\nfrom flask.cli import cli, AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n    find_best_app, locate_app, with_appcontext, prepare_exec_for_file, \\\n    find_default_import_path, get_version\n\n\n@pytest.fixture\ndef runner():\n    return CliRunner()\n\n\ndef test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n    assert testapp.cli.name == testapp.name\n\n\ndef test_find_best_app(test_apps):\n    \"\"\"Test if `find_best_app` behaves as expected with different combinations of input.\"\"\"\n    script_info = ScriptInfo()\n    class Module:\n        app = Flask('appname')\n    assert find_best_app(script_info, Module) == Module.app\n\n    class Module:\n        application = Flask('appname')\n    assert find_best_app(script_info, Module) == Module.application\n\n    class Module:\n        myapp = Flask('appname')\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask('appname')\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def create_app(foo):\n            return Flask('appname')\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def create_app(foo=None, script_info=None):\n            return Flask('appname')\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask('appname')\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        myapp = Flask('appname1')\n        @staticmethod\n        def create_app():\n            return Flask('appname2')\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        myapp = Flask('appname1')\n        @staticmethod\n        def create_app():\n            return Flask('appname2')\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        pass\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        myapp1 = Flask('appname1')\n        myapp2 = Flask('appname2')\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask('appname2')\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n\ndef test_prepare_exec_for_file(test_apps):\n    \"\"\"Expect the correct path to be set and the correct module name to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect, where\n    the parent directory of given file is added to `sys.path`.\n    \"\"\"\n    realpath = os.path.realpath('\/tmp\/share\/test.py')\n    dirname = os.path.dirname(realpath)\n    assert prepare_exec_for_file('\/tmp\/share\/test.py') == 'test'\n    assert dirname in sys.path\n\n    realpath = os.path.realpath('\/tmp\/share\/__init__.py')\n    dirname = os.path.dirname(os.path.dirname(realpath))\n    assert prepare_exec_for_file('\/tmp\/share\/__init__.py') == 'share'\n    assert dirname in sys.path\n\n    with pytest.raises(NoAppException):\n        prepare_exec_for_file('\/tmp\/share\/test.txt')\n\n\ndef test_locate_app(test_apps):\n    \"\"\"Test of locate_app.\"\"\"\n    script_info = ScriptInfo()\n    assert locate_app(script_info, \"cliapp.app\").name == \"testapp\"\n    assert locate_app(script_info, \"cliapp.app:testapp\").name == \"testapp\"\n    assert locate_app(script_info, \"cliapp.multiapp:app1\").name == \"app1\"\n    pytest.raises(NoAppException, locate_app,\n                  script_info, \"notanpp.py\")\n    pytest.raises(NoAppException, locate_app,\n                  script_info, \"cliapp\/app\")\n    pytest.raises(RuntimeError, locate_app,\n                  script_info, \"cliapp.app:notanapp\")\n    pytest.raises(NoAppException, locate_app,\n                  script_info, \"cliapp.importerrorapp\")\n\n\ndef test_find_default_import_path(test_apps, monkeypatch, tmpdir):\n    \"\"\"Test of find_default_import_path.\"\"\"\n    monkeypatch.delitem(os.environ, 'FLASK_APP', raising=False)\n    assert find_default_import_path() == None\n    monkeypatch.setitem(os.environ, 'FLASK_APP', 'notanapp')\n    assert find_default_import_path() == 'notanapp'\n    tmpfile = tmpdir.join('testapp.py')\n    tmpfile.write('')\n    monkeypatch.setitem(os.environ, 'FLASK_APP', str(tmpfile))\n    expect_rv = prepare_exec_for_file(str(tmpfile))\n    assert find_default_import_path() == expect_rv\n\n\ndef test_get_version(test_apps, capsys):\n    \"\"\"Test of get_version.\"\"\"\n    from flask import __version__ as flask_ver\n    from sys import version as py_ver\n    class MockCtx(object):\n        resilient_parsing = False\n        color = None\n        def exit(self): return\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert flask_ver in out\n    assert py_ver in out\n\n\ndef test_scriptinfo(test_apps):\n    \"\"\"Test of ScriptInfo.\"\"\"\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    assert obj.load_app().name == \"testapp\"\n    assert obj.load_app().name == \"testapp\"\n\n    def create_app(info):\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() == app\n\n\ndef test_with_appcontext(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testapp\\n'\n\n\ndef test_appgroup(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command(with_appcontext=True)\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command(with_appcontext=True)\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, ['test'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n    result = runner.invoke(cli, ['subgroup', 'test2'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n\ndef test_flaskgroup(runner):\n    \"\"\"Test FlaskGroup.\"\"\"\n    def create_app(info):\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, ['test'])\n    assert result.exit_code == 0\n    assert result.output == 'flaskgroup\\n'\n\n\ndef test_print_exceptions(runner):\n    \"\"\"Print the stacktrace if the CLI.\"\"\"\n    def create_app(info):\n        raise Exception(\"oh no\")\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    result = runner.invoke(cli, ['--help'])\n    assert result.exit_code == 0\n    assert 'Exception: oh no' in result.output\n    assert 'Traceback' in result.output\n\n\nclass TestRoutes:\n    @pytest.fixture\n    def invoke(self, runner):\n        def create_app(info):\n            app = Flask(__name__)\n            app.testing = True\n\n            @app.route('\/get_post\/<int:x>\/<int:y>', methods=['GET', 'POST'])\n            def yyy_get_post(x, y):\n                pass\n\n            @app.route('\/zzz_post', methods=['POST'])\n            def aaa_post():\n                pass\n\n            return app\n\n        cli = FlaskGroup(create_app=create_app)\n        return partial(runner.invoke, cli)\n\n    def expect_order(self, order, output):\n        # skip the header and match the start of each row\n        for expect, line in zip(order, output.splitlines()[2:]):\n            # do this instead of startswith for nicer pytest output\n            assert line[:len(expect)] == expect\n\n    def test_simple(self, invoke):\n        result = invoke(['routes'])\n        assert result.exit_code == 0\n        self.expect_order(\n            ['aaa_post', 'static', 'yyy_get_post'],\n            result.output\n        )\n\n    def test_sort(self, invoke):\n        default_output = invoke(['routes']).output\n        endpoint_output = invoke(['routes', '-s', 'endpoint']).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            ['static', 'yyy_get_post', 'aaa_post'],\n            invoke(['routes', '-s', 'methods']).output\n        )\n        self.expect_order(\n            ['yyy_get_post', 'static', 'aaa_post'],\n            invoke(['routes', '-s', 'rule']).output\n        )\n        self.expect_order(\n            ['aaa_post', 'yyy_get_post', 'static'],\n            invoke(['routes', '-s', 'match']).output\n        )\n\n    def test_all_methods(self, invoke):\n        output = invoke(['routes']).output\n        assert 'GET, HEAD, OPTIONS, POST' not in output\n        output = invoke(['routes', '--all-methods']).output\n        assert 'GET, HEAD, OPTIONS, POST' in output\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.cli\n    ~~~~~~~~~\n\n    A simple command line application to run flask apps.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport ast\nimport inspect\nimport os\nimport re\nimport sys\nimport traceback\nfrom functools import update_wrapper\nfrom operator import attrgetter\nfrom threading import Lock, Thread\n\nimport click\n\nfrom . import __version__\nfrom ._compat import iteritems, reraise\nfrom .globals import current_app\nfrom .helpers import get_debug_flag\nfrom ._compat import getargspec\n\n\nclass NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n\n\ndef find_best_app(script_info, module):\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in ('app', 'application'):\n        app = getattr(module, attr_name, None)\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [\n        v for k, v in iteritems(module.__dict__) if isinstance(v, Flask)\n    ]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            'Auto-detected multiple Flask applications in module \"{module}\".'\n            ' Use \"FLASK_APP={module}:name\" to specify the correct'\n            ' one.'.format(module=module.__name__)\n        )\n\n    # Search for app factory functions.\n    for attr_name in ('create_app', 'make_app'):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = call_factory(app_factory, script_info)\n                if isinstance(app, Flask):\n                    return app\n            except TypeError:\n                raise NoAppException(\n                    'Auto-detected \"{function}()\" in module \"{module}\", but '\n                    'could not call it without specifying arguments.'.format(\n                        function=attr_name, module=module.__name__\n                    )\n                )\n\n    raise NoAppException(\n        'Failed to find application in module \"{module}\". Are you sure '\n        'it contains a Flask application? Maybe you wrapped it in a WSGI '\n        'middleware.'.format(module=module.__name__)\n    )\n\n\ndef call_factory(func, script_info):\n    \"\"\"Checks if the given app factory function has an argument named \n    ``script_info`` or just a single argument and calls the function passing \n    ``script_info`` if so. Otherwise, calls the function without any arguments\n    and returns the result.\n    \"\"\"\n    arguments = getargspec(func).args\n    if 'script_info' in arguments:\n        return func(script_info=script_info)\n    elif len(arguments) == 1:\n        return func(script_info)\n    return func()\n\n\ndef prepare_exec_for_file(filename):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    module = []\n\n    # Chop off file extensions or package markers\n    if os.path.split(filename)[1] == '__init__.py':\n        filename = os.path.dirname(filename)\n    elif filename.endswith('.py'):\n        filename = filename[:-3]\n    else:\n        raise NoAppException('The file provided (%s) does exist but is not a '\n                             'valid Python file.  This means that it cannot '\n                             'be used as application.  Please change the '\n                             'extension to .py' % filename)\n    filename = os.path.realpath(filename)\n\n    dirpath = filename\n    while 1:\n        dirpath, extra = os.path.split(dirpath)\n        module.append(extra)\n        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n            break\n\n    sys.path.insert(0, dirpath)\n    return '.'.join(module[::-1])\n\n\ndef locate_app(script_info, app_id):\n    \"\"\"Attempts to locate the application.\"\"\"\n    __traceback_hide__ = True\n    if ':' in app_id:\n        module, app_obj = app_id.split(':', 1)\n    else:\n        module = app_id\n        app_obj = None\n\n    try:\n        __import__(module)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[-1].tb_next:\n            stack_trace = traceback.format_exc()\n            raise NoAppException('There was an error trying to import'\n                    ' the app (%s):\\n%s' % (module, stack_trace))\n        else:\n            raise NoAppException('The file\/path provided (%s) does not appear'\n                                 ' to exist.  Please verify the path is '\n                                 'correct.  If app is not on PYTHONPATH, '\n                                 'ensure the extension is .py' % module)\n\n    mod = sys.modules[module]\n    if app_obj is None:\n        app = find_best_app(script_info, mod)\n    else:\n        function_regex = r'^([\\w_][\\w_\\d]*)\\((.*)\\)$'\n        match = re.match(function_regex, app_obj)\n        try:\n            if match:\n                function_name = match.group(1)\n                arguments = match.group(2)\n                if arguments:\n                    arguments = ast.literal_eval(\n                        \"({arguments}, )\".format(arguments=arguments))\n                else:\n                    arguments = ()\n                app_factory = getattr(mod, function_name, None)\n                app_factory_arg_names = getargspec(app_factory).args\n                if 'script_info' in app_factory_arg_names:\n                    app = app_factory(*arguments, script_info=script_info)\n                elif arguments:\n                    app = app_factory(*arguments)\n                elif not arguments and len(app_factory_arg_names) == 1:\n                    app = app_factory(script_info)\n                else:\n                    app = app_factory()\n            else:\n                attr = getattr(mod, app_obj, None)\n                if inspect.isfunction(attr):\n                    app = call_factory(attr, script_info)\n                else:\n                    app = attr\n        except TypeError as e:\n            new_error = NoAppException(\n                '{e}\\nThe app factory \"{factory}\" in module \"{module}\" could'\n                ' not be called with the specified arguments (and a'\n                ' script_info argument automatically added if applicable).'\n                ' Did you make sure to use the right number of arguments as'\n                ' well as not using keyword arguments or'\n                ' non-literals?'.format(e=e, factory=app_obj, module=module))\n            reraise(NoAppException, new_error, sys.exc_info()[2])\n        if app is None:\n            raise RuntimeError('Failed to find application in module '\n                               '\"{name}\"'.format(name=module))\n\n    return app\n\n\ndef find_default_import_path():\n    app = os.environ.get('FLASK_APP')\n    if app is None:\n        return\n    if os.path.isfile(app):\n        return prepare_exec_for_file(app)\n    return app\n\n\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n    message = 'Flask %(version)s\\nPython %(python_version)s'\n    click.echo(message % {\n        'version': __version__,\n        'python_version': sys.version,\n    }, color=ctx.color)\n    ctx.exit()\n\nversion_option = click.Option(['--version'],\n                              help='Show the flask version',\n                              expose_value=False,\n                              callback=get_version,\n                              is_flag=True, is_eager=True)\n\nclass DispatchingApp(object):\n    \"\"\"Special application that dispatches to a Flask application which\n    is imported by name in a background thread.  If an error happens\n    it is recorded and shown as part of the WSGI handling which in case\n    of the Werkzeug debugger means that it shows up in the browser.\n    \"\"\"\n\n    def __init__(self, loader, use_eager_loading=False):\n        self.loader = loader\n        self._app = None\n        self._lock = Lock()\n        self._bg_loading_exc_info = None\n        if use_eager_loading:\n            self._load_unlocked()\n        else:\n            self._load_in_background()\n\n    def _load_in_background(self):\n        def _load_app():\n            __traceback_hide__ = True\n            with self._lock:\n                try:\n                    self._load_unlocked()\n                except Exception:\n                    self._bg_loading_exc_info = sys.exc_info()\n        t = Thread(target=_load_app, args=())\n        t.start()\n\n    def _flush_bg_loading_exception(self):\n        __traceback_hide__ = True\n        exc_info = self._bg_loading_exc_info\n        if exc_info is not None:\n            self._bg_loading_exc_info = None\n            reraise(*exc_info)\n\n    def _load_unlocked(self):\n        __traceback_hide__ = True\n        self._app = rv = self.loader()\n        self._bg_loading_exc_info = None\n        return rv\n\n    def __call__(self, environ, start_response):\n        __traceback_hide__ = True\n        if self._app is not None:\n            return self._app(environ, start_response)\n        self._flush_bg_loading_exception()\n        with self._lock:\n            if self._app is not None:\n                rv = self._app\n            else:\n                rv = self._load_unlocked()\n            return rv(environ, start_response)\n\n\nclass ScriptInfo(object):\n    \"\"\"Help object to deal with Flask applications.  This is usually not\n    necessary to interface with as it's used internally in the dispatching\n    to click.  In future versions of Flask this object will most likely play\n    a bigger role.  Typically it's created automatically by the\n    :class:`FlaskGroup` but you can also manually create it and pass it\n    onwards as click object.\n    \"\"\"\n\n    def __init__(self, app_import_path=None, create_app=None):\n        if create_app is None:\n            if app_import_path is None:\n                app_import_path = find_default_import_path()\n            self.app_import_path = app_import_path\n        else:\n            app_import_path = None\n\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data = {}\n        self._loaded_app = None\n\n    def load_app(self):\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        __traceback_hide__ = True\n        if self._loaded_app is not None:\n            return self._loaded_app\n        if self.create_app is not None:\n            rv = call_factory(self.create_app, self)\n        else:\n            if not self.app_import_path:\n                raise NoAppException(\n                    'Could not locate Flask application. You did not provide '\n                    'the FLASK_APP environment variable.\\n\\nFor more '\n                    'information see '\n                    'http:\/\/flask.pocoo.org\/docs\/latest\/quickstart\/')\n            rv = locate_app(self, self.app_import_path)\n        debug = get_debug_flag()\n        if debug is not None:\n            rv.debug = debug\n        self._loaded_app = rv\n        return rv\n\n\npass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n\n\ndef with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.  If callbacks are registered directly\n    to the ``app.cli`` object then they are wrapped with this function\n    by default unless it's disabled.\n    \"\"\"\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n            return __ctx.invoke(f, *args, **kwargs)\n    return update_wrapper(decorator, f)\n\n\nclass AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop('with_appcontext', True)\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n        return decorator\n\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault('cls', AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n\n\nclass FlaskGroup(AppGroup):\n    \"\"\"Special subclass of the :class:`AppGroup` group that supports\n    loading more commands from the configured Flask app.  Normally a\n    developer does not have to interface with this class but there are\n    some very advanced use cases for which it makes sense to create an\n    instance of this.\n\n    For information as of why this is useful see :ref:`custom-scripts`.\n\n    :param add_default_commands: if this is True then the default run and\n                                 shell commands wil be added.\n    :param add_version_option: adds the ``--version`` option.\n    :param create_app: an optional callback that is passed the script info\n                       and returns the loaded app.\n    \"\"\"\n\n    def __init__(self, add_default_commands=True, create_app=None,\n                 add_version_option=True, **extra):\n        params = list(extra.pop('params', None) or ())\n\n        if add_version_option:\n            params.append(version_option)\n\n        AppGroup.__init__(self, params=params, **extra)\n        self.create_app = create_app\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n\n    def _load_plugin_commands(self):\n        if self._loaded_plugin_commands:\n            return\n        try:\n            import pkg_resources\n        except ImportError:\n            self._loaded_plugin_commands = True\n            return\n\n        for ep in pkg_resources.iter_entry_points('flask.commands'):\n            self.add_command(ep.load(), ep.name)\n        self._loaded_plugin_commands = True\n\n    def get_command(self, ctx, name):\n        self._load_plugin_commands()\n\n        # We load built-in commands first as these should always be the\n        # same no matter what the app does.  If the app does want to\n        # override this it needs to make a custom instance of this group\n        # and not attach the default commands.\n        #\n        # This also means that the script stays functional in case the\n        # application completely fails.\n        rv = AppGroup.get_command(self, ctx, name)\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv = info.load_app().cli.get_command(ctx, name)\n            if rv is not None:\n                return rv\n        except NoAppException:\n            pass\n\n    def list_commands(self, ctx):\n        self._load_plugin_commands()\n\n        # The commands available is the list of both the application (if\n        # available) plus the builtin commands.\n        rv = set(click.Group.list_commands(self, ctx))\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except Exception:\n            # Here we intentionally swallow all exceptions as we don't\n            # want the help page to break if the app does not exist.\n            # If someone attempts to use the command we try to create\n            # the app again and this will give us the error.\n            # However, we will not do so silently because that would confuse\n            # users.\n            traceback.print_exc()\n        return sorted(rv)\n\n    def main(self, *args, **kwargs):\n        obj = kwargs.get('obj')\n        if obj is None:\n            obj = ScriptInfo(create_app=self.create_app)\n        kwargs['obj'] = obj\n        kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n        return AppGroup.main(self, *args, **kwargs)\n\n\n@click.command('run', short_help='Runs a development server.')\n@click.option('--host', '-h', default='127.0.0.1',\n              help='The interface to bind to.')\n@click.option('--port', '-p', default=5000,\n              help='The port to bind to.')\n@click.option('--reload\/--no-reload', default=None,\n              help='Enable or disable the reloader.  By default the reloader '\n              'is active if debug is enabled.')\n@click.option('--debugger\/--no-debugger', default=None,\n              help='Enable or disable the debugger.  By default the debugger '\n              'is active if debug is enabled.')\n@click.option('--eager-loading\/--lazy-loader', default=None,\n              help='Enable or disable eager loading.  By default eager '\n              'loading is enabled if the reloader is disabled.')\n@click.option('--with-threads\/--without-threads', default=False,\n              help='Enable or disable multithreading.')\n@pass_script_info\ndef run_command(info, host, port, reload, debugger, eager_loading,\n                with_threads):\n    \"\"\"Runs a local development server for the Flask application.\n\n    This local server is recommended for development purposes only but it\n    can also be used for simple intranet deployments.  By default it will\n    not support any sort of concurrency at all to simplify debugging.  This\n    can be changed with the --with-threads option which will enable basic\n    multithreading.\n\n    The reloader and debugger are by default enabled if the debug flag of\n    Flask is enabled and disabled otherwise.\n    \"\"\"\n    from werkzeug.serving import run_simple\n\n    # Set a global flag that indicates that we were invoked from the\n    # command line interface provided server command.  This is detected\n    # by Flask.run to make the call into a no-op.  This is necessary to\n    # avoid ugly errors when the script that is loaded here also attempts\n    # to start a server.\n    os.environ['FLASK_RUN_FROM_CLI_SERVER'] = '1'\n\n    debug = get_debug_flag()\n    if reload is None:\n        reload = bool(debug)\n    if debugger is None:\n        debugger = bool(debug)\n    if eager_loading is None:\n        eager_loading = not reload\n\n    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n\n    # Extra startup messages.  This depends a bit on Werkzeug internals to\n    # not double execute when the reloader kicks in.\n    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n        # If we have an import path we can print it out now which can help\n        # people understand what's being served.  If we do not have an\n        # import path because the app was loaded through a callback then\n        # we won't print anything.\n        if info.app_import_path is not None:\n            print(' * Serving Flask app \"%s\"' % info.app_import_path)\n        if debug is not None:\n            print(' * Forcing debug mode %s' % (debug and 'on' or 'off'))\n\n    run_simple(host, port, app, use_reloader=reload,\n               use_debugger=debugger, threaded=with_threads)\n\n\n@click.command('shell', short_help='Runs a shell in the app context.')\n@with_appcontext\ndef shell_command():\n    \"\"\"Runs an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to it's configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configuring the application.\n    \"\"\"\n    import code\n    from flask.globals import _app_ctx_stack\n    app = _app_ctx_stack.top.app\n    banner = 'Python %s on %s\\nApp: %s%s\\nInstance: %s' % (\n        sys.version,\n        sys.platform,\n        app.import_name,\n        app.debug and ' [debug]' or '',\n        app.instance_path,\n    )\n    ctx = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get('PYTHONSTARTUP')\n    if startup and os.path.isfile(startup):\n        with open(startup, 'r') as f:\n            eval(compile(f.read(), startup, 'exec'), ctx)\n\n    ctx.update(app.make_shell_context())\n\n    code.interact(banner=banner, local=ctx)\n\n\n@click.command('routes', short_help='Show the routes for the app.')\n@click.option(\n    '--sort', '-s',\n    type=click.Choice(('endpoint', 'methods', 'rule', 'match')),\n    default='endpoint',\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        'routes when dispatching a request.'\n    )\n)\n@click.option(\n    '--all-methods',\n    is_flag=True,\n    help=\"Show HEAD and OPTIONS methods.\"\n)\n@with_appcontext\ndef routes_command(sort, all_methods):\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    ignored_methods = set(() if all_methods else ('HEAD', 'OPTIONS'))\n\n    if sort in ('endpoint', 'rule'):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == 'methods':\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\n        ', '.join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = ('Endpoint', 'Methods', 'Rule')\n    widths = (\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = '{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}'.format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*('-' * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n\n\ncli = FlaskGroup(help=\"\"\"\\\nThis shell command acts as general utility script for Flask applications.\n\nIt loads the application configured (through the FLASK_APP environment\nvariable) and then provides commands either provided by the application or\nFlask itself.\n\nThe most useful commands are the \"run\" and \"shell\" command.\n\nExample usage:\n\n\\b\n  %(prefix)s%(cmd)s FLASK_APP=hello.py\n  %(prefix)s%(cmd)s FLASK_DEBUG=1\n  %(prefix)sflask run\n\"\"\" % {\n    'cmd': os.name == 'posix' and 'export' or 'set',\n    'prefix': os.name == 'posix' and '$ ' or '',\n})\n\n\ndef main(as_module=False):\n    this_module = __package__ + '.cli'\n    args = sys.argv[1:]\n\n    if as_module:\n        if sys.version_info >= (2, 7):\n            name = 'python -m ' + this_module.rsplit('.', 1)[0]\n        else:\n            name = 'python -m ' + this_module\n\n        # This module is always executed as \"python -m flask.run\" and as such\n        # we need to ensure that we restore the actual command line so that\n        # the reloader can properly operate.\n        sys.argv = ['-m', this_module] + sys.argv[1:]\n    else:\n        name = None\n\n    cli.main(args=args, prog_name=name)\n\n\nif __name__ == '__main__':\n    main(as_module=True)\n\n\"\"\"\nGenerate tests which test: Handle app factory with arguments in FLASK_APP\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_cli\n    ~~~~~~~~~~~~~~\n\n    :copyright: (c) 2016 by the Flask Team, see AUTHORS for more details.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n#\n# This file was part of Flask-CLI and was modified under the terms its license,\n# the Revised BSD License.\n# Copyright (C) 2015 CERN.\n#\nfrom __future__ import absolute_import, print_function\nimport os\nimport sys\nfrom functools import partial\n\nimport click\nimport pytest\nfrom click.testing import CliRunner\nfrom flask import Flask, current_app\n\nfrom flask.cli import cli, AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n    find_best_app, locate_app, with_appcontext, prepare_exec_for_file, \\\n    find_default_import_path, get_version\n\n\n@pytest.fixture\ndef runner():\n    return CliRunner()\n\n\ndef test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n    assert testapp.cli.name == testapp.name\n\n\ndef test_find_best_app(test_apps):\n    \"\"\"Test if `find_best_app` behaves as expected with different combinations of input.\"\"\"\n    script_info = ScriptInfo()\n\n    class Module:\n        app = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.app\n\n    class Module:\n        application = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.application\n\n    class Module:\n        myapp = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def create_app(foo):\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def create_app(foo=None, script_info=None):\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        myapp = Flask('appname1')\n\n        @staticmethod\n        def create_app():\n            return Flask('appname2')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        myapp = Flask('appname1')\n\n        @staticmethod\n        def create_app():\n            return Flask('appname2')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        myapp1 = Flask('appname1')\n        myapp2 = Flask('appname2')\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask('appname2')\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n\ndef test_prepare_exec_for_file(test_apps):\n    \"\"\"Expect the correct path to be set and the correct module name to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect, where\n    the parent directory of given file is added to `sys.path`.\n    \"\"\"\n    realpath = os.path.realpath('\/tmp\/share\/test.py')\n    dirname = os.path.dirname(realpath)\n    assert prepare_exec_for_file('\/tmp\/share\/test.py') == 'test'\n    assert dirname in sys.path\n\n    realpath = os.path.realpath('\/tmp\/share\/__init__.py')\n    dirname = os.path.dirname(os.path.dirname(realpath))\n    assert prepare_exec_for_file('\/tmp\/share\/__init__.py') == 'share'\n    assert dirname in sys.path\n\n    with pytest.raises(NoAppException):\n        prepare_exec_for_file('\/tmp\/share\/test.txt')\n\n\ndef test_locate_app(test_apps):\n    \"\"\"Test of locate_app.\"\"\"\n    script_info = ScriptInfo()\n    assert locate_app(script_info, \"cliapp.app\").name == \"testapp\"\n    assert locate_app(script_info, \"cliapp.app:testapp\").name == \"testapp\"\n    assert locate_app(script_info, \"cliapp.factory\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app()\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app2('foo', 'bar')\"\n    ).name == \"create_app2_foo_bar\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app3('baz', 'qux')\"\n    ).name == \"create_app3_baz_qux\"\n    assert locate_app(script_info, \"cliapp.multiapp:app1\").name == \"app1\"\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"notanpp.py\")\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"cliapp\/app\")\n    pytest.raises(\n        RuntimeError, locate_app, script_info, \"cliapp.app:notanapp\")\n    pytest.raises(\n        NoAppException, locate_app,\n        script_info, \"cliapp.factory:create_app2('foo')\")\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"cliapp.importerrorapp\")\n\n\ndef test_find_default_import_path(test_apps, monkeypatch, tmpdir):\n    \"\"\"Test of find_default_import_path.\"\"\"\n    monkeypatch.delitem(os.environ, 'FLASK_APP', raising=False)\n    assert find_default_import_path() == None\n    monkeypatch.setitem(os.environ, 'FLASK_APP', 'notanapp')\n    assert find_default_import_path() == 'notanapp'\n    tmpfile = tmpdir.join('testapp.py')\n    tmpfile.write('')\n    monkeypatch.setitem(os.environ, 'FLASK_APP', str(tmpfile))\n    expect_rv = prepare_exec_for_file(str(tmpfile))\n    assert find_default_import_path() == expect_rv\n\n\ndef test_get_version(test_apps, capsys):\n    \"\"\"Test of get_version.\"\"\"\n    from flask import __version__ as flask_ver\n    from sys import version as py_ver\n\n    class MockCtx(object):\n        resilient_parsing = False\n        color = None\n\n        def exit(self): return\n\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert flask_ver in out\n    assert py_ver in out\n\n\ndef test_scriptinfo(test_apps):\n    \"\"\"Test of ScriptInfo.\"\"\"\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    assert obj.load_app().name == \"testapp\"\n    assert obj.load_app().name == \"testapp\"\n\n    def create_app(info):\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() == app\n\n\ndef test_with_appcontext(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testapp\\n'\n\n\ndef test_appgroup(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command(with_appcontext=True)\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command(with_appcontext=True)\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, ['test'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n    result = runner.invoke(cli, ['subgroup', 'test2'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n\ndef test_flaskgroup(runner):\n    \"\"\"Test FlaskGroup.\"\"\"\n\n    def create_app(info):\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, ['test'])\n    assert result.exit_code == 0\n    assert result.output == 'flaskgroup\\n'\n\n\ndef test_print_exceptions(runner):\n    \"\"\"Print the stacktrace if the CLI.\"\"\"\n\n    def create_app(info):\n        raise Exception(\"oh no\")\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    result = runner.invoke(cli, ['--help'])\n    assert result.exit_code == 0\n    assert 'Exception: oh no' in result.output\n    assert 'Traceback' in result.output\n\n\nclass TestRoutes:\n    @pytest.fixture\n    def invoke(self, runner):\n        def create_app(info):\n            app = Flask(__name__)\n            app.testing = True\n\n            @app.route('\/get_post\/<int:x>\/<int:y>', methods=['GET', 'POST'])\n            def yyy_get_post(x, y):\n                pass\n\n            @app.route('\/zzz_post', methods=['POST'])\n            def aaa_post():\n                pass\n\n            return app\n\n        cli = FlaskGroup(create_app=create_app)\n        return partial(runner.invoke, cli)\n\n    def expect_order(self, order, output):\n        # skip the header and match the start of each row\n        for expect, line in zip(order, output.splitlines()[2:]):\n            # do this instead of startswith for nicer pytest output\n            assert line[:len(expect)] == expect\n\n    def test_simple(self, invoke):\n        result = invoke(['routes'])\n        assert result.exit_code == 0\n        self.expect_order(\n            ['aaa_post', 'static', 'yyy_get_post'],\n            result.output\n        )\n\n    def test_sort(self, invoke):\n        default_output = invoke(['routes']).output\n        endpoint_output = invoke(['routes', '-s', 'endpoint']).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            ['static', 'yyy_get_post', 'aaa_post'],\n            invoke(['routes', '-s', 'methods']).output\n        )\n        self.expect_order(\n            ['yyy_get_post', 'static', 'aaa_post'],\n            invoke(['routes', '-s', 'rule']).output\n        )\n        self.expect_order(\n            ['aaa_post', 'yyy_get_post', 'static'],\n            invoke(['routes', '-s', 'match']).output\n        )\n\n    def test_all_methods(self, invoke):\n        output = invoke(['routes']).output\n        assert 'GET, HEAD, OPTIONS, POST' not in output\n        output = invoke(['routes', '--all-methods']).output\n        assert 'GET, HEAD, OPTIONS, POST' in output\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.cli\n    ~~~~~~~~~\n\n    A simple command line application to run flask apps.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport ast\nimport inspect\nimport os\nimport re\nimport sys\nimport traceback\nfrom functools import update_wrapper\nfrom operator import attrgetter\nfrom threading import Lock, Thread\n\nimport click\n\nfrom . import __version__\nfrom ._compat import iteritems, reraise\nfrom .globals import current_app\nfrom .helpers import get_debug_flag\nfrom ._compat import getargspec\n\n\nclass NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n\n\ndef find_best_app(script_info, module):\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in ('app', 'application'):\n        app = getattr(module, attr_name, None)\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [\n        v for k, v in iteritems(module.__dict__) if isinstance(v, Flask)\n    ]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            'Auto-detected multiple Flask applications in module \"{module}\".'\n            ' Use \"FLASK_APP={module}:name\" to specify the correct'\n            ' one.'.format(module=module.__name__)\n        )\n\n    # Search for app factory functions.\n    for attr_name in ('create_app', 'make_app'):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = call_factory(app_factory, script_info)\n                if isinstance(app, Flask):\n                    return app\n            except TypeError:\n                raise NoAppException(\n                    'Auto-detected \"{function}()\" in module \"{module}\", but '\n                    'could not call it without specifying arguments.'.format(\n                        function=attr_name, module=module.__name__\n                    )\n                )\n\n    raise NoAppException(\n        'Failed to find application in module \"{module}\". Are you sure '\n        'it contains a Flask application? Maybe you wrapped it in a WSGI '\n        'middleware.'.format(module=module.__name__)\n    )\n\n\ndef call_factory(app_factory, script_info, arguments=()):\n    \"\"\"Takes an app factory, a ``script_info` object and  optionally a tuple\n    of arguments. Checks for the existence of a script_info argument and calls\n    the app_factory depending on that and the arguments provided.\n    \"\"\"\n    arg_names = getargspec(app_factory).args\n    if 'script_info' in arg_names:\n        return app_factory(*arguments, script_info=script_info)\n    elif arguments:\n        return app_factory(*arguments)\n    elif not arguments and len(arg_names) == 1:\n        return app_factory(script_info)\n    return app_factory()\n\n\ndef find_app_by_string(string, script_info, module):\n    \"\"\"Checks if the given string is a variable name or a function. If it is \n    a function, it checks for specified arguments and whether it takes \n    a ``script_info`` argument and calls the function with the appropriate \n    arguments. If it is a \"\"\"\n    from . import Flask\n    function_regex = r'^(?P<name>\\w+)(?:\\((?P<args>.*)\\))?$'\n    match = re.match(function_regex, string)\n    if match:\n        name, args = match.groups()\n        try:\n            if args is not None:\n                args = args.rstrip(' ,')\n                if args:\n                    args = ast.literal_eval(\n                        \"({args}, )\".format(args=args))\n                else:\n                    args = ()\n                app_factory = getattr(module, name, None)\n                app = call_factory(app_factory, script_info, args)\n            else:\n                attr = getattr(module, name, None)\n                if inspect.isfunction(attr):\n                    app = call_factory(attr, script_info)\n                else:\n                    app = attr\n\n            if isinstance(app, Flask):\n                return app\n            else:\n                raise RuntimeError('Failed to find application in module '\n                                   '\"{name}\"'.format(name=module))\n        except TypeError as e:\n            new_error = NoAppException(\n                '{e}\\nThe app factory \"{factory}\" in module \"{module}\" could'\n                ' not be called with the specified arguments (and a'\n                ' script_info argument automatically added if applicable).'\n                ' Did you make sure to use the right number of arguments as'\n                ' well as not using keyword arguments or'\n                ' non-literals?'.format(e=e, factory=string, module=module))\n            reraise(NoAppException, new_error, sys.exc_info()[2])\n    else:\n        raise NoAppException(\n            'The provided string \"{string}\" is not a valid variable name'\n            'or function expression.'.format(string=string))\n\n\ndef prepare_exec_for_file(filename):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    module = []\n\n    # Chop off file extensions or package markers\n    if os.path.split(filename)[1] == '__init__.py':\n        filename = os.path.dirname(filename)\n    elif filename.endswith('.py'):\n        filename = filename[:-3]\n    else:\n        raise NoAppException('The file provided (%s) does exist but is not a '\n                             'valid Python file.  This means that it cannot '\n                             'be used as application.  Please change the '\n                             'extension to .py' % filename)\n    filename = os.path.realpath(filename)\n\n    dirpath = filename\n    while 1:\n        dirpath, extra = os.path.split(dirpath)\n        module.append(extra)\n        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n            break\n\n    sys.path.insert(0, dirpath)\n    return '.'.join(module[::-1])\n\n\ndef locate_app(script_info, app_id):\n    \"\"\"Attempts to locate the application.\"\"\"\n    __traceback_hide__ = True\n    if ':' in app_id:\n        module, app_obj = app_id.split(':', 1)\n    else:\n        module = app_id\n        app_obj = None\n\n    try:\n        __import__(module)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[-1].tb_next:\n            stack_trace = traceback.format_exc()\n            raise NoAppException('There was an error trying to import'\n                    ' the app (%s):\\n%s' % (module, stack_trace))\n        else:\n            raise NoAppException('The file\/path provided (%s) does not appear'\n                                 ' to exist.  Please verify the path is '\n                                 'correct.  If app is not on PYTHONPATH, '\n                                 'ensure the extension is .py' % module)\n\n    mod = sys.modules[module]\n    if app_obj is None:\n        return find_best_app(script_info, mod)\n    else:\n        return find_app_by_string(app_obj, script_info, mod)\n\n\ndef find_default_import_path():\n    app = os.environ.get('FLASK_APP')\n    if app is None:\n        return\n    if os.path.isfile(app):\n        return prepare_exec_for_file(app)\n    return app\n\n\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n    message = 'Flask %(version)s\\nPython %(python_version)s'\n    click.echo(message % {\n        'version': __version__,\n        'python_version': sys.version,\n    }, color=ctx.color)\n    ctx.exit()\n\nversion_option = click.Option(['--version'],\n                              help='Show the flask version',\n                              expose_value=False,\n                              callback=get_version,\n                              is_flag=True, is_eager=True)\n\nclass DispatchingApp(object):\n    \"\"\"Special application that dispatches to a Flask application which\n    is imported by name in a background thread.  If an error happens\n    it is recorded and shown as part of the WSGI handling which in case\n    of the Werkzeug debugger means that it shows up in the browser.\n    \"\"\"\n\n    def __init__(self, loader, use_eager_loading=False):\n        self.loader = loader\n        self._app = None\n        self._lock = Lock()\n        self._bg_loading_exc_info = None\n        if use_eager_loading:\n            self._load_unlocked()\n        else:\n            self._load_in_background()\n\n    def _load_in_background(self):\n        def _load_app():\n            __traceback_hide__ = True\n            with self._lock:\n                try:\n                    self._load_unlocked()\n                except Exception:\n                    self._bg_loading_exc_info = sys.exc_info()\n        t = Thread(target=_load_app, args=())\n        t.start()\n\n    def _flush_bg_loading_exception(self):\n        __traceback_hide__ = True\n        exc_info = self._bg_loading_exc_info\n        if exc_info is not None:\n            self._bg_loading_exc_info = None\n            reraise(*exc_info)\n\n    def _load_unlocked(self):\n        __traceback_hide__ = True\n        self._app = rv = self.loader()\n        self._bg_loading_exc_info = None\n        return rv\n\n    def __call__(self, environ, start_response):\n        __traceback_hide__ = True\n        if self._app is not None:\n            return self._app(environ, start_response)\n        self._flush_bg_loading_exception()\n        with self._lock:\n            if self._app is not None:\n                rv = self._app\n            else:\n                rv = self._load_unlocked()\n            return rv(environ, start_response)\n\n\nclass ScriptInfo(object):\n    \"\"\"Help object to deal with Flask applications.  This is usually not\n    necessary to interface with as it's used internally in the dispatching\n    to click.  In future versions of Flask this object will most likely play\n    a bigger role.  Typically it's created automatically by the\n    :class:`FlaskGroup` but you can also manually create it and pass it\n    onwards as click object.\n    \"\"\"\n\n    def __init__(self, app_import_path=None, create_app=None):\n        if create_app is None:\n            if app_import_path is None:\n                app_import_path = find_default_import_path()\n            self.app_import_path = app_import_path\n        else:\n            app_import_path = None\n\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data = {}\n        self._loaded_app = None\n\n    def load_app(self):\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        __traceback_hide__ = True\n        if self._loaded_app is not None:\n            return self._loaded_app\n        if self.create_app is not None:\n            rv = call_factory(self.create_app, self)\n        else:\n            if not self.app_import_path:\n                raise NoAppException(\n                    'Could not locate Flask application. You did not provide '\n                    'the FLASK_APP environment variable.\\n\\nFor more '\n                    'information see '\n                    'http:\/\/flask.pocoo.org\/docs\/latest\/quickstart\/')\n            rv = locate_app(self, self.app_import_path)\n        debug = get_debug_flag()\n        if debug is not None:\n            rv.debug = debug\n        self._loaded_app = rv\n        return rv\n\n\npass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n\n\ndef with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.  If callbacks are registered directly\n    to the ``app.cli`` object then they are wrapped with this function\n    by default unless it's disabled.\n    \"\"\"\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n            return __ctx.invoke(f, *args, **kwargs)\n    return update_wrapper(decorator, f)\n\n\nclass AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop('with_appcontext', True)\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n        return decorator\n\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault('cls', AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n\n\nclass FlaskGroup(AppGroup):\n    \"\"\"Special subclass of the :class:`AppGroup` group that supports\n    loading more commands from the configured Flask app.  Normally a\n    developer does not have to interface with this class but there are\n    some very advanced use cases for which it makes sense to create an\n    instance of this.\n\n    For information as of why this is useful see :ref:`custom-scripts`.\n\n    :param add_default_commands: if this is True then the default run and\n                                 shell commands wil be added.\n    :param add_version_option: adds the ``--version`` option.\n    :param create_app: an optional callback that is passed the script info\n                       and returns the loaded app.\n    \"\"\"\n\n    def __init__(self, add_default_commands=True, create_app=None,\n                 add_version_option=True, **extra):\n        params = list(extra.pop('params', None) or ())\n\n        if add_version_option:\n            params.append(version_option)\n\n        AppGroup.__init__(self, params=params, **extra)\n        self.create_app = create_app\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n\n    def _load_plugin_commands(self):\n        if self._loaded_plugin_commands:\n            return\n        try:\n            import pkg_resources\n        except ImportError:\n            self._loaded_plugin_commands = True\n            return\n\n        for ep in pkg_resources.iter_entry_points('flask.commands'):\n            self.add_command(ep.load(), ep.name)\n        self._loaded_plugin_commands = True\n\n    def get_command(self, ctx, name):\n        self._load_plugin_commands()\n\n        # We load built-in commands first as these should always be the\n        # same no matter what the app does.  If the app does want to\n        # override this it needs to make a custom instance of this group\n        # and not attach the default commands.\n        #\n        # This also means that the script stays functional in case the\n        # application completely fails.\n        rv = AppGroup.get_command(self, ctx, name)\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv = info.load_app().cli.get_command(ctx, name)\n            if rv is not None:\n                return rv\n        except NoAppException:\n            pass\n\n    def list_commands(self, ctx):\n        self._load_plugin_commands()\n\n        # The commands available is the list of both the application (if\n        # available) plus the builtin commands.\n        rv = set(click.Group.list_commands(self, ctx))\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except Exception:\n            # Here we intentionally swallow all exceptions as we don't\n            # want the help page to break if the app does not exist.\n            # If someone attempts to use the command we try to create\n            # the app again and this will give us the error.\n            # However, we will not do so silently because that would confuse\n            # users.\n            traceback.print_exc()\n        return sorted(rv)\n\n    def main(self, *args, **kwargs):\n        obj = kwargs.get('obj')\n        if obj is None:\n            obj = ScriptInfo(create_app=self.create_app)\n        kwargs['obj'] = obj\n        kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n        return AppGroup.main(self, *args, **kwargs)\n\n\n@click.command('run', short_help='Runs a development server.')\n@click.option('--host', '-h', default='127.0.0.1',\n              help='The interface to bind to.')\n@click.option('--port', '-p', default=5000,\n              help='The port to bind to.')\n@click.option('--reload\/--no-reload', default=None,\n              help='Enable or disable the reloader.  By default the reloader '\n              'is active if debug is enabled.')\n@click.option('--debugger\/--no-debugger', default=None,\n              help='Enable or disable the debugger.  By default the debugger '\n              'is active if debug is enabled.')\n@click.option('--eager-loading\/--lazy-loader', default=None,\n              help='Enable or disable eager loading.  By default eager '\n              'loading is enabled if the reloader is disabled.')\n@click.option('--with-threads\/--without-threads', default=False,\n              help='Enable or disable multithreading.')\n@pass_script_info\ndef run_command(info, host, port, reload, debugger, eager_loading,\n                with_threads):\n    \"\"\"Runs a local development server for the Flask application.\n\n    This local server is recommended for development purposes only but it\n    can also be used for simple intranet deployments.  By default it will\n    not support any sort of concurrency at all to simplify debugging.  This\n    can be changed with the --with-threads option which will enable basic\n    multithreading.\n\n    The reloader and debugger are by default enabled if the debug flag of\n    Flask is enabled and disabled otherwise.\n    \"\"\"\n    from werkzeug.serving import run_simple\n\n    # Set a global flag that indicates that we were invoked from the\n    # command line interface provided server command.  This is detected\n    # by Flask.run to make the call into a no-op.  This is necessary to\n    # avoid ugly errors when the script that is loaded here also attempts\n    # to start a server.\n    os.environ['FLASK_RUN_FROM_CLI_SERVER'] = '1'\n\n    debug = get_debug_flag()\n    if reload is None:\n        reload = bool(debug)\n    if debugger is None:\n        debugger = bool(debug)\n    if eager_loading is None:\n        eager_loading = not reload\n\n    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n\n    # Extra startup messages.  This depends a bit on Werkzeug internals to\n    # not double execute when the reloader kicks in.\n    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n        # If we have an import path we can print it out now which can help\n        # people understand what's being served.  If we do not have an\n        # import path because the app was loaded through a callback then\n        # we won't print anything.\n        if info.app_import_path is not None:\n            print(' * Serving Flask app \"%s\"' % info.app_import_path)\n        if debug is not None:\n            print(' * Forcing debug mode %s' % (debug and 'on' or 'off'))\n\n    run_simple(host, port, app, use_reloader=reload,\n               use_debugger=debugger, threaded=with_threads)\n\n\n@click.command('shell', short_help='Runs a shell in the app context.')\n@with_appcontext\ndef shell_command():\n    \"\"\"Runs an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to it's configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configuring the application.\n    \"\"\"\n    import code\n    from flask.globals import _app_ctx_stack\n    app = _app_ctx_stack.top.app\n    banner = 'Python %s on %s\\nApp: %s%s\\nInstance: %s' % (\n        sys.version,\n        sys.platform,\n        app.import_name,\n        app.debug and ' [debug]' or '',\n        app.instance_path,\n    )\n    ctx = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get('PYTHONSTARTUP')\n    if startup and os.path.isfile(startup):\n        with open(startup, 'r') as f:\n            eval(compile(f.read(), startup, 'exec'), ctx)\n\n    ctx.update(app.make_shell_context())\n\n    code.interact(banner=banner, local=ctx)\n\n\n@click.command('routes', short_help='Show the routes for the app.')\n@click.option(\n    '--sort', '-s',\n    type=click.Choice(('endpoint', 'methods', 'rule', 'match')),\n    default='endpoint',\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        'routes when dispatching a request.'\n    )\n)\n@click.option(\n    '--all-methods',\n    is_flag=True,\n    help=\"Show HEAD and OPTIONS methods.\"\n)\n@with_appcontext\ndef routes_command(sort, all_methods):\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    ignored_methods = set(() if all_methods else ('HEAD', 'OPTIONS'))\n\n    if sort in ('endpoint', 'rule'):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == 'methods':\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\n        ', '.join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = ('Endpoint', 'Methods', 'Rule')\n    widths = (\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = '{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}'.format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*('-' * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n\n\ncli = FlaskGroup(help=\"\"\"\\\nThis shell command acts as general utility script for Flask applications.\n\nIt loads the application configured (through the FLASK_APP environment\nvariable) and then provides commands either provided by the application or\nFlask itself.\n\nThe most useful commands are the \"run\" and \"shell\" command.\n\nExample usage:\n\n\\b\n  %(prefix)s%(cmd)s FLASK_APP=hello.py\n  %(prefix)s%(cmd)s FLASK_DEBUG=1\n  %(prefix)sflask run\n\"\"\" % {\n    'cmd': os.name == 'posix' and 'export' or 'set',\n    'prefix': os.name == 'posix' and '$ ' or '',\n})\n\n\ndef main(as_module=False):\n    this_module = __package__ + '.cli'\n    args = sys.argv[1:]\n\n    if as_module:\n        if sys.version_info >= (2, 7):\n            name = 'python -m ' + this_module.rsplit('.', 1)[0]\n        else:\n            name = 'python -m ' + this_module\n\n        # This module is always executed as \"python -m flask.run\" and as such\n        # we need to ensure that we restore the actual command line so that\n        # the reloader can properly operate.\n        sys.argv = ['-m', this_module] + sys.argv[1:]\n    else:\n        name = None\n\n    cli.main(args=args, prog_name=name)\n\n\nif __name__ == '__main__':\n    main(as_module=True)\n\n\"\"\"\nGenerate tests which test: Factor in code review comments and refactor functions to be more naturally split.\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_cli\n    ~~~~~~~~~~~~~~\n\n    :copyright: (c) 2016 by the Flask Team, see AUTHORS for more details.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n#\n# This file was part of Flask-CLI and was modified under the terms its license,\n# the Revised BSD License.\n# Copyright (C) 2015 CERN.\n#\nfrom __future__ import absolute_import, print_function\nimport os\nimport sys\nfrom functools import partial\n\nimport click\nimport pytest\nfrom click.testing import CliRunner\nfrom flask import Flask, current_app\n\nfrom flask.cli import cli, AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n    find_best_app, locate_app, with_appcontext, prepare_exec_for_file, \\\n    find_default_import_path, get_version\n\n\n@pytest.fixture\ndef runner():\n    return CliRunner()\n\n\ndef test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n    assert testapp.cli.name == testapp.name\n\n\ndef test_find_best_app(test_apps):\n    \"\"\"Test if `find_best_app` behaves as expected with different combinations of input.\"\"\"\n    script_info = ScriptInfo()\n\n    class Module:\n        app = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.app\n\n    class Module:\n        application = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.application\n\n    class Module:\n        myapp = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def create_app(foo):\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def create_app(foo=None, script_info=None):\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        myapp = Flask('appname1')\n\n        @staticmethod\n        def create_app():\n            return Flask('appname2')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        myapp = Flask('appname1')\n\n        @staticmethod\n        def create_app():\n            return Flask('appname2')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        myapp1 = Flask('appname1')\n        myapp2 = Flask('appname2')\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask('appname2')\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n\ndef test_prepare_exec_for_file(test_apps):\n    \"\"\"Expect the correct path to be set and the correct module name to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect, where\n    the parent directory of given file is added to `sys.path`.\n    \"\"\"\n    realpath = os.path.realpath('\/tmp\/share\/test.py')\n    dirname = os.path.dirname(realpath)\n    assert prepare_exec_for_file('\/tmp\/share\/test.py') == 'test'\n    assert dirname in sys.path\n\n    realpath = os.path.realpath('\/tmp\/share\/__init__.py')\n    dirname = os.path.dirname(os.path.dirname(realpath))\n    assert prepare_exec_for_file('\/tmp\/share\/__init__.py') == 'share'\n    assert dirname in sys.path\n\n    with pytest.raises(NoAppException):\n        prepare_exec_for_file('\/tmp\/share\/test.txt')\n\n\ndef test_locate_app(test_apps):\n    \"\"\"Test of locate_app.\"\"\"\n    script_info = ScriptInfo()\n    assert locate_app(script_info, \"cliapp.app\").name == \"testapp\"\n    assert locate_app(script_info, \"cliapp.app:testapp\").name == \"testapp\"\n    assert locate_app(script_info, \"cliapp.factory\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app()\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app2('foo', 'bar')\"\n    ).name == \"create_app2_foo_bar\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app2('foo', 'bar', )\"\n    ).name == \"create_app2_foo_bar\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app3('baz', 'qux')\"\n    ).name == \"create_app3_baz_qux\"\n    assert locate_app(script_info, \"cliapp.multiapp:app1\").name == \"app1\"\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"notanpp.py\")\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"cliapp\/app\")\n    pytest.raises(\n        RuntimeError, locate_app, script_info, \"cliapp.app:notanapp\")\n    pytest.raises(\n        NoAppException, locate_app,\n        script_info, \"cliapp.factory:create_app2('foo')\")\n    pytest.raises(\n        NoAppException, locate_app,\n        script_info, \"cliapp.factory:create_app ()\")\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"cliapp.importerrorapp\")\n\n\ndef test_find_default_import_path(test_apps, monkeypatch, tmpdir):\n    \"\"\"Test of find_default_import_path.\"\"\"\n    monkeypatch.delitem(os.environ, 'FLASK_APP', raising=False)\n    assert find_default_import_path() == None\n    monkeypatch.setitem(os.environ, 'FLASK_APP', 'notanapp')\n    assert find_default_import_path() == 'notanapp'\n    tmpfile = tmpdir.join('testapp.py')\n    tmpfile.write('')\n    monkeypatch.setitem(os.environ, 'FLASK_APP', str(tmpfile))\n    expect_rv = prepare_exec_for_file(str(tmpfile))\n    assert find_default_import_path() == expect_rv\n\n\ndef test_get_version(test_apps, capsys):\n    \"\"\"Test of get_version.\"\"\"\n    from flask import __version__ as flask_ver\n    from sys import version as py_ver\n\n    class MockCtx(object):\n        resilient_parsing = False\n        color = None\n\n        def exit(self): return\n\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert flask_ver in out\n    assert py_ver in out\n\n\ndef test_scriptinfo(test_apps):\n    \"\"\"Test of ScriptInfo.\"\"\"\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    assert obj.load_app().name == \"testapp\"\n    assert obj.load_app().name == \"testapp\"\n\n    def create_app(info):\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() == app\n\n\ndef test_with_appcontext(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testapp\\n'\n\n\ndef test_appgroup(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command(with_appcontext=True)\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command(with_appcontext=True)\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, ['test'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n    result = runner.invoke(cli, ['subgroup', 'test2'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n\ndef test_flaskgroup(runner):\n    \"\"\"Test FlaskGroup.\"\"\"\n\n    def create_app(info):\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, ['test'])\n    assert result.exit_code == 0\n    assert result.output == 'flaskgroup\\n'\n\n\ndef test_print_exceptions(runner):\n    \"\"\"Print the stacktrace if the CLI.\"\"\"\n\n    def create_app(info):\n        raise Exception(\"oh no\")\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    result = runner.invoke(cli, ['--help'])\n    assert result.exit_code == 0\n    assert 'Exception: oh no' in result.output\n    assert 'Traceback' in result.output\n\n\nclass TestRoutes:\n    @pytest.fixture\n    def invoke(self, runner):\n        def create_app(info):\n            app = Flask(__name__)\n            app.testing = True\n\n            @app.route('\/get_post\/<int:x>\/<int:y>', methods=['GET', 'POST'])\n            def yyy_get_post(x, y):\n                pass\n\n            @app.route('\/zzz_post', methods=['POST'])\n            def aaa_post():\n                pass\n\n            return app\n\n        cli = FlaskGroup(create_app=create_app)\n        return partial(runner.invoke, cli)\n\n    def expect_order(self, order, output):\n        # skip the header and match the start of each row\n        for expect, line in zip(order, output.splitlines()[2:]):\n            # do this instead of startswith for nicer pytest output\n            assert line[:len(expect)] == expect\n\n    def test_simple(self, invoke):\n        result = invoke(['routes'])\n        assert result.exit_code == 0\n        self.expect_order(\n            ['aaa_post', 'static', 'yyy_get_post'],\n            result.output\n        )\n\n    def test_sort(self, invoke):\n        default_output = invoke(['routes']).output\n        endpoint_output = invoke(['routes', '-s', 'endpoint']).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            ['static', 'yyy_get_post', 'aaa_post'],\n            invoke(['routes', '-s', 'methods']).output\n        )\n        self.expect_order(\n            ['yyy_get_post', 'static', 'aaa_post'],\n            invoke(['routes', '-s', 'rule']).output\n        )\n        self.expect_order(\n            ['aaa_post', 'yyy_get_post', 'static'],\n            invoke(['routes', '-s', 'match']).output\n        )\n\n    def test_all_methods(self, invoke):\n        output = invoke(['routes']).output\n        assert 'GET, HEAD, OPTIONS, POST' not in output\n        output = invoke(['routes', '--all-methods']).output\n        assert 'GET, HEAD, OPTIONS, POST' in output\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.cli\n    ~~~~~~~~~\n\n    A simple command line application to run flask apps.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport ast\nimport inspect\nimport os\nimport re\nimport sys\nimport traceback\nfrom functools import update_wrapper\nfrom operator import attrgetter\nfrom threading import Lock, Thread\n\nimport click\n\nfrom . import __version__\nfrom ._compat import iteritems, reraise\nfrom .globals import current_app\nfrom .helpers import get_debug_flag\nfrom ._compat import getargspec\n\n\nclass NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n\n\ndef find_best_app(script_info, module):\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in ('app', 'application'):\n        app = getattr(module, attr_name, None)\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [\n        v for k, v in iteritems(module.__dict__) if isinstance(v, Flask)\n    ]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            'Auto-detected multiple Flask applications in module \"{module}\".'\n            ' Use \"FLASK_APP={module}:name\" to specify the correct'\n            ' one.'.format(module=module.__name__)\n        )\n\n    # Search for app factory functions.\n    for attr_name in ('create_app', 'make_app'):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = call_factory(app_factory, script_info)\n                if isinstance(app, Flask):\n                    return app\n            except TypeError:\n                raise NoAppException(\n                    'Auto-detected \"{function}()\" in module \"{module}\", but '\n                    'could not call it without specifying arguments.'.format(\n                        function=attr_name, module=module.__name__\n                    )\n                )\n\n    raise NoAppException(\n        'Failed to find application in module \"{module}\". Are you sure '\n        'it contains a Flask application? Maybe you wrapped it in a WSGI '\n        'middleware.'.format(module=module.__name__)\n    )\n\n\ndef call_factory(app_factory, script_info, arguments=()):\n    \"\"\"Takes an app factory, a ``script_info` object and  optionally a tuple\n    of arguments. Checks for the existence of a script_info argument and calls\n    the app_factory depending on that and the arguments provided.\n    \"\"\"\n    args_spec = getargspec(app_factory)\n    arg_names = args_spec.args\n    arg_defaults = args_spec.defaults\n\n    if 'script_info' in arg_names:\n        return app_factory(*arguments, script_info=script_info)\n    elif arguments:\n        return app_factory(*arguments)\n    elif not arguments and len(arg_names) == 1 and arg_defaults is None:\n        return app_factory(script_info)\n    return app_factory()\n\n\ndef find_app_by_string(string, script_info, module):\n    \"\"\"Checks if the given string is a variable name or a function. If it is\n    a function, it checks for specified arguments and whether it takes\n    a ``script_info`` argument and calls the function with the appropriate\n    arguments.\"\"\"\n    from . import Flask\n    function_regex = r'^(?P<name>\\w+)(?:\\((?P<args>.*)\\))?$'\n    match = re.match(function_regex, string)\n    if match:\n        name, args = match.groups()\n        try:\n            if args is not None:\n                args = args.rstrip(' ,')\n                if args:\n                    args = ast.literal_eval(\n                        \"({args}, )\".format(args=args))\n                else:\n                    args = ()\n                app_factory = getattr(module, name, None)\n                app = call_factory(app_factory, script_info, args)\n            else:\n                attr = getattr(module, name, None)\n                if inspect.isfunction(attr):\n                    app = call_factory(attr, script_info)\n                else:\n                    app = attr\n\n            if isinstance(app, Flask):\n                return app\n            else:\n                raise RuntimeError('Failed to find application in module '\n                                   '\"{name}\"'.format(name=module))\n        except TypeError as e:\n            new_error = NoAppException(\n                '{e}\\nThe app factory \"{factory}\" in module \"{module}\" could'\n                ' not be called with the specified arguments (and a'\n                ' script_info argument automatically added if applicable).'\n                ' Did you make sure to use the right number of arguments as'\n                ' well as not using keyword arguments or'\n                ' non-literals?'.format(e=e, factory=string, module=module))\n            reraise(NoAppException, new_error, sys.exc_info()[2])\n    else:\n        raise NoAppException(\n            'The provided string \"{string}\" is not a valid variable name'\n            'or function expression.'.format(string=string))\n\n\ndef prepare_exec_for_file(filename):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    module = []\n\n    # Chop off file extensions or package markers\n    if os.path.split(filename)[1] == '__init__.py':\n        filename = os.path.dirname(filename)\n    elif filename.endswith('.py'):\n        filename = filename[:-3]\n    else:\n        raise NoAppException('The file provided (%s) does exist but is not a '\n                             'valid Python file.  This means that it cannot '\n                             'be used as application.  Please change the '\n                             'extension to .py' % filename)\n    filename = os.path.realpath(filename)\n\n    dirpath = filename\n    while 1:\n        dirpath, extra = os.path.split(dirpath)\n        module.append(extra)\n        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n            break\n\n    if sys.path[0] != dirpath:\n        sys.path.insert(0, dirpath)\n    return '.'.join(module[::-1])\n\n\ndef locate_app(script_info, app_id, raise_if_not_found=True):\n    \"\"\"Attempts to locate the application.\"\"\"\n    __traceback_hide__ = True\n    if ':' in app_id:\n        module, app_obj = app_id.split(':', 1)\n    else:\n        module = app_id\n        app_obj = None\n\n    try:\n        __import__(module)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[-1].tb_next:\n            stack_trace = traceback.format_exc()\n            raise NoAppException('There was an error trying to import'\n                                 ' the app (%s):\\n%s' % (module, stack_trace))\n        elif raise_if_not_found:\n            raise NoAppException('The file\/path provided (%s) does not appear'\n                                 ' to exist.  Please verify the path is '\n                                 'correct.  If app is not on PYTHONPATH, '\n                                 'ensure the extension is .py' % module)\n        else:\n            return\n\n    mod = sys.modules[module]\n    if app_obj is None:\n        return find_best_app(script_info, mod)\n    else:\n        return find_app_by_string(app_obj, script_info, mod)\n\n\ndef find_default_import_path():\n    app = os.environ.get('FLASK_APP')\n    if app is None:\n        return\n    if os.path.isfile(app):\n        return prepare_exec_for_file(app)\n    return app\n\n\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n    message = 'Flask %(version)s\\nPython %(python_version)s'\n    click.echo(message % {\n        'version': __version__,\n        'python_version': sys.version,\n    }, color=ctx.color)\n    ctx.exit()\n\nversion_option = click.Option(['--version'],\n                              help='Show the flask version',\n                              expose_value=False,\n                              callback=get_version,\n                              is_flag=True, is_eager=True)\n\nclass DispatchingApp(object):\n    \"\"\"Special application that dispatches to a Flask application which\n    is imported by name in a background thread.  If an error happens\n    it is recorded and shown as part of the WSGI handling which in case\n    of the Werkzeug debugger means that it shows up in the browser.\n    \"\"\"\n\n    def __init__(self, loader, use_eager_loading=False):\n        self.loader = loader\n        self._app = None\n        self._lock = Lock()\n        self._bg_loading_exc_info = None\n        if use_eager_loading:\n            self._load_unlocked()\n        else:\n            self._load_in_background()\n\n    def _load_in_background(self):\n        def _load_app():\n            __traceback_hide__ = True\n            with self._lock:\n                try:\n                    self._load_unlocked()\n                except Exception:\n                    self._bg_loading_exc_info = sys.exc_info()\n        t = Thread(target=_load_app, args=())\n        t.start()\n\n    def _flush_bg_loading_exception(self):\n        __traceback_hide__ = True\n        exc_info = self._bg_loading_exc_info\n        if exc_info is not None:\n            self._bg_loading_exc_info = None\n            reraise(*exc_info)\n\n    def _load_unlocked(self):\n        __traceback_hide__ = True\n        self._app = rv = self.loader()\n        self._bg_loading_exc_info = None\n        return rv\n\n    def __call__(self, environ, start_response):\n        __traceback_hide__ = True\n        if self._app is not None:\n            return self._app(environ, start_response)\n        self._flush_bg_loading_exception()\n        with self._lock:\n            if self._app is not None:\n                rv = self._app\n            else:\n                rv = self._load_unlocked()\n            return rv(environ, start_response)\n\n\nclass ScriptInfo(object):\n    \"\"\"Help object to deal with Flask applications.  This is usually not\n    necessary to interface with as it's used internally in the dispatching\n    to click.  In future versions of Flask this object will most likely play\n    a bigger role.  Typically it's created automatically by the\n    :class:`FlaskGroup` but you can also manually create it and pass it\n    onwards as click object.\n    \"\"\"\n\n    def __init__(self, app_import_path=None, create_app=None):\n        if create_app is None:\n            if app_import_path is None:\n                app_import_path = find_default_import_path()\n            self.app_import_path = app_import_path\n        else:\n            app_import_path = None\n\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data = {}\n        self._loaded_app = None\n\n    def load_app(self):\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        __traceback_hide__ = True\n\n        if self._loaded_app is not None:\n            return self._loaded_app\n\n        if self.create_app is not None:\n            rv = call_factory(self.create_app, self)\n        else:\n            if self.app_import_path:\n                rv = locate_app(self, self.app_import_path)\n            else:\n                for module in ['wsgi.py', 'app.py']:\n                    import_path = prepare_exec_for_file(module)\n                    rv = locate_app(self, import_path,\n                                    raise_if_not_found=False)\n                    if rv:\n                        break\n            if not rv:\n                raise NoAppException(\n                    'Could not locate Flask application. You did not provide '\n                    'the FLASK_APP environment variable, and a wsgi.py or '\n                    'app.py module was not found in the current directory.\\n\\n'\n                    'For more information see '\n                    'http:\/\/flask.pocoo.org\/docs\/latest\/quickstart\/')\n\n        debug = get_debug_flag()\n\n        if debug is not None:\n            rv._reconfigure_for_run_debug(debug)\n\n        self._loaded_app = rv\n        return rv\n\n\npass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n\n\ndef with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.  If callbacks are registered directly\n    to the ``app.cli`` object then they are wrapped with this function\n    by default unless it's disabled.\n    \"\"\"\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n            return __ctx.invoke(f, *args, **kwargs)\n    return update_wrapper(decorator, f)\n\n\nclass AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop('with_appcontext', True)\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n        return decorator\n\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault('cls', AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n\n\nclass FlaskGroup(AppGroup):\n    \"\"\"Special subclass of the :class:`AppGroup` group that supports\n    loading more commands from the configured Flask app.  Normally a\n    developer does not have to interface with this class but there are\n    some very advanced use cases for which it makes sense to create an\n    instance of this.\n\n    For information as of why this is useful see :ref:`custom-scripts`.\n\n    :param add_default_commands: if this is True then the default run and\n                                 shell commands wil be added.\n    :param add_version_option: adds the ``--version`` option.\n    :param create_app: an optional callback that is passed the script info\n                       and returns the loaded app.\n    \"\"\"\n\n    def __init__(self, add_default_commands=True, create_app=None,\n                 add_version_option=True, **extra):\n        params = list(extra.pop('params', None) or ())\n\n        if add_version_option:\n            params.append(version_option)\n\n        AppGroup.__init__(self, params=params, **extra)\n        self.create_app = create_app\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n\n    def _load_plugin_commands(self):\n        if self._loaded_plugin_commands:\n            return\n        try:\n            import pkg_resources\n        except ImportError:\n            self._loaded_plugin_commands = True\n            return\n\n        for ep in pkg_resources.iter_entry_points('flask.commands'):\n            self.add_command(ep.load(), ep.name)\n        self._loaded_plugin_commands = True\n\n    def get_command(self, ctx, name):\n        self._load_plugin_commands()\n\n        # We load built-in commands first as these should always be the\n        # same no matter what the app does.  If the app does want to\n        # override this it needs to make a custom instance of this group\n        # and not attach the default commands.\n        #\n        # This also means that the script stays functional in case the\n        # application completely fails.\n        rv = AppGroup.get_command(self, ctx, name)\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv = info.load_app().cli.get_command(ctx, name)\n            if rv is not None:\n                return rv\n        except NoAppException:\n            pass\n\n    def list_commands(self, ctx):\n        self._load_plugin_commands()\n\n        # The commands available is the list of both the application (if\n        # available) plus the builtin commands.\n        rv = set(click.Group.list_commands(self, ctx))\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except Exception:\n            # Here we intentionally swallow all exceptions as we don't\n            # want the help page to break if the app does not exist.\n            # If someone attempts to use the command we try to create\n            # the app again and this will give us the error.\n            # However, we will not do so silently because that would confuse\n            # users.\n            traceback.print_exc()\n        return sorted(rv)\n\n    def main(self, *args, **kwargs):\n        obj = kwargs.get('obj')\n        if obj is None:\n            obj = ScriptInfo(create_app=self.create_app)\n        kwargs['obj'] = obj\n        kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n        return AppGroup.main(self, *args, **kwargs)\n\n\n@click.command('run', short_help='Runs a development server.')\n@click.option('--host', '-h', default='127.0.0.1',\n              help='The interface to bind to.')\n@click.option('--port', '-p', default=5000,\n              help='The port to bind to.')\n@click.option('--reload\/--no-reload', default=None,\n              help='Enable or disable the reloader.  By default the reloader '\n              'is active if debug is enabled.')\n@click.option('--debugger\/--no-debugger', default=None,\n              help='Enable or disable the debugger.  By default the debugger '\n              'is active if debug is enabled.')\n@click.option('--eager-loading\/--lazy-loader', default=None,\n              help='Enable or disable eager loading.  By default eager '\n              'loading is enabled if the reloader is disabled.')\n@click.option('--with-threads\/--without-threads', default=False,\n              help='Enable or disable multithreading.')\n@pass_script_info\ndef run_command(info, host, port, reload, debugger, eager_loading,\n                with_threads):\n    \"\"\"Runs a local development server for the Flask application.\n\n    This local server is recommended for development purposes only but it\n    can also be used for simple intranet deployments.  By default it will\n    not support any sort of concurrency at all to simplify debugging.  This\n    can be changed with the --with-threads option which will enable basic\n    multithreading.\n\n    The reloader and debugger are by default enabled if the debug flag of\n    Flask is enabled and disabled otherwise.\n    \"\"\"\n    from werkzeug.serving import run_simple\n\n    # Set a global flag that indicates that we were invoked from the\n    # command line interface provided server command.  This is detected\n    # by Flask.run to make the call into a no-op.  This is necessary to\n    # avoid ugly errors when the script that is loaded here also attempts\n    # to start a server.\n    os.environ['FLASK_RUN_FROM_CLI_SERVER'] = '1'\n\n    debug = get_debug_flag()\n    if reload is None:\n        reload = bool(debug)\n    if debugger is None:\n        debugger = bool(debug)\n    if eager_loading is None:\n        eager_loading = not reload\n\n    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n\n    # Extra startup messages.  This depends a bit on Werkzeug internals to\n    # not double execute when the reloader kicks in.\n    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n        # If we have an import path we can print it out now which can help\n        # people understand what's being served.  If we do not have an\n        # import path because the app was loaded through a callback then\n        # we won't print anything.\n        if info.app_import_path is not None:\n            print(' * Serving Flask app \"%s\"' % info.app_import_path)\n        if debug is not None:\n            print(' * Forcing debug mode %s' % (debug and 'on' or 'off'))\n\n    run_simple(host, port, app, use_reloader=reload,\n               use_debugger=debugger, threaded=with_threads)\n\n\n@click.command('shell', short_help='Runs a shell in the app context.')\n@with_appcontext\ndef shell_command():\n    \"\"\"Runs an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to it's configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configuring the application.\n    \"\"\"\n    import code\n    from flask.globals import _app_ctx_stack\n    app = _app_ctx_stack.top.app\n    banner = 'Python %s on %s\\nApp: %s%s\\nInstance: %s' % (\n        sys.version,\n        sys.platform,\n        app.import_name,\n        app.debug and ' [debug]' or '',\n        app.instance_path,\n    )\n    ctx = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get('PYTHONSTARTUP')\n    if startup and os.path.isfile(startup):\n        with open(startup, 'r') as f:\n            eval(compile(f.read(), startup, 'exec'), ctx)\n\n    ctx.update(app.make_shell_context())\n\n    code.interact(banner=banner, local=ctx)\n\n\n@click.command('routes', short_help='Show the routes for the app.')\n@click.option(\n    '--sort', '-s',\n    type=click.Choice(('endpoint', 'methods', 'rule', 'match')),\n    default='endpoint',\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        'routes when dispatching a request.'\n    )\n)\n@click.option(\n    '--all-methods',\n    is_flag=True,\n    help=\"Show HEAD and OPTIONS methods.\"\n)\n@with_appcontext\ndef routes_command(sort, all_methods):\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    ignored_methods = set(() if all_methods else ('HEAD', 'OPTIONS'))\n\n    if sort in ('endpoint', 'rule'):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == 'methods':\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\n        ', '.join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = ('Endpoint', 'Methods', 'Rule')\n    widths = (\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = '{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}'.format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*('-' * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n\n\ncli = FlaskGroup(help=\"\"\"\\\nThis shell command acts as general utility script for Flask applications.\n\nIt loads the application configured (through the FLASK_APP environment\nvariable) and then provides commands either provided by the application or\nFlask itself.\n\nThe most useful commands are the \"run\" and \"shell\" command.\n\nExample usage:\n\n\\b\n  %(prefix)s%(cmd)s FLASK_APP=hello.py\n  %(prefix)s%(cmd)s FLASK_DEBUG=1\n  %(prefix)sflask run\n\"\"\" % {\n    'cmd': os.name == 'posix' and 'export' or 'set',\n    'prefix': os.name == 'posix' and '$ ' or '',\n})\n\n\ndef main(as_module=False):\n    args = sys.argv[1:]\n\n    if as_module:\n        this_module = 'flask'\n\n        if sys.version_info < (2, 7):\n            this_module += '.cli'\n\n        name = 'python -m ' + this_module\n\n        # Python rewrites \"python -m flask\" to the path to the file in argv.\n        # Restore the original command so that the reloader works.\n        sys.argv = ['-m', this_module] + args\n    else:\n        name = None\n\n    cli.main(args=args, prog_name=name)\n\n\nif __name__ == '__main__':\n    main(as_module=True)\n\n\"\"\"\nGenerate tests which test: Import app from wsgi.py or app.py if FLASK_APP is not defined\n\nFixes #2376\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_cli\n    ~~~~~~~~~~~~~~\n\n    :copyright: (c) 2016 by the Flask Team, see AUTHORS for more details.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n#\n# This file was part of Flask-CLI and was modified under the terms its license,\n# the Revised BSD License.\n# Copyright (C) 2015 CERN.\n#\nfrom __future__ import absolute_import, print_function\nimport os\nimport sys\nfrom functools import partial\n\nimport click\nimport pytest\nfrom click.testing import CliRunner\nfrom flask import Flask, current_app\n\nfrom flask.cli import cli, AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n    find_best_app, locate_app, with_appcontext, prepare_exec_for_file, \\\n    find_default_import_path, get_version\n\n\n@pytest.fixture\ndef runner():\n    return CliRunner()\n\n\ndef test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n    assert testapp.cli.name == testapp.name\n\n\ndef test_find_best_app(test_apps):\n    \"\"\"Test if `find_best_app` behaves as expected with different combinations of input.\"\"\"\n    script_info = ScriptInfo()\n\n    class Module:\n        app = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.app\n\n    class Module:\n        application = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.application\n\n    class Module:\n        myapp = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def create_app(foo):\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def create_app(foo=None, script_info=None):\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        myapp = Flask('appname1')\n\n        @staticmethod\n        def create_app():\n            return Flask('appname2')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        myapp = Flask('appname1')\n\n        @staticmethod\n        def create_app():\n            return Flask('appname2')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        myapp1 = Flask('appname1')\n        myapp2 = Flask('appname2')\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask('appname2')\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n\ndef test_prepare_exec_for_file(test_apps):\n    \"\"\"Expect the correct path to be set and the correct module name to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect, where\n    the parent directory of given file is added to `sys.path`.\n    \"\"\"\n    realpath = os.path.realpath('\/tmp\/share\/test.py')\n    dirname = os.path.dirname(realpath)\n    assert prepare_exec_for_file('\/tmp\/share\/test.py') == 'test'\n    assert dirname in sys.path\n\n    realpath = os.path.realpath('\/tmp\/share\/__init__.py')\n    dirname = os.path.dirname(os.path.dirname(realpath))\n    assert prepare_exec_for_file('\/tmp\/share\/__init__.py') == 'share'\n    assert dirname in sys.path\n\n    with pytest.raises(NoAppException):\n        prepare_exec_for_file('\/tmp\/share\/test.txt')\n\n\ndef test_locate_app(test_apps):\n    \"\"\"Test of locate_app.\"\"\"\n    script_info = ScriptInfo()\n    assert locate_app(script_info, \"cliapp.app\").name == \"testapp\"\n    assert locate_app(script_info, \"cliapp.app:testapp\").name == \"testapp\"\n    assert locate_app(script_info, \"cliapp.factory\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app()\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app2('foo', 'bar')\"\n    ).name == \"create_app2_foo_bar\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app2('foo', 'bar', )\"\n    ).name == \"create_app2_foo_bar\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app3('baz', 'qux')\"\n    ).name == \"create_app3_baz_qux\"\n    assert locate_app(script_info, \"cliapp.multiapp:app1\").name == \"app1\"\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"notanpp.py\")\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"cliapp\/app\")\n    pytest.raises(\n        RuntimeError, locate_app, script_info, \"cliapp.app:notanapp\")\n    pytest.raises(\n        NoAppException, locate_app,\n        script_info, \"cliapp.factory:create_app2('foo')\")\n    pytest.raises(\n        NoAppException, locate_app,\n        script_info, \"cliapp.factory:create_app ()\")\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"cliapp.importerrorapp\")\n    assert locate_app(script_info, \"notanpp.py\",\n                      raise_if_not_found=False) is None\n\n\ndef test_find_default_import_path(test_apps, monkeypatch, tmpdir):\n    \"\"\"Test of find_default_import_path.\"\"\"\n    monkeypatch.delitem(os.environ, 'FLASK_APP', raising=False)\n    assert find_default_import_path() == None\n    monkeypatch.setitem(os.environ, 'FLASK_APP', 'notanapp')\n    assert find_default_import_path() == 'notanapp'\n    tmpfile = tmpdir.join('testapp.py')\n    tmpfile.write('')\n    monkeypatch.setitem(os.environ, 'FLASK_APP', str(tmpfile))\n    expect_rv = prepare_exec_for_file(str(tmpfile))\n    assert find_default_import_path() == expect_rv\n\n\ndef test_get_version(test_apps, capsys):\n    \"\"\"Test of get_version.\"\"\"\n    from flask import __version__ as flask_ver\n    from sys import version as py_ver\n\n    class MockCtx(object):\n        resilient_parsing = False\n        color = None\n\n        def exit(self): return\n\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert flask_ver in out\n    assert py_ver in out\n\n\ndef test_scriptinfo(test_apps, monkeypatch):\n    \"\"\"Test of ScriptInfo.\"\"\"\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    assert obj.load_app().name == \"testapp\"\n    assert obj.load_app().name == \"testapp\"\n\n    def create_app(info):\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() == app\n\n    obj = ScriptInfo()\n    pytest.raises(\n        NoAppException, obj.load_app)\n\n    # import app from wsgi.py in current directory\n    monkeypatch.chdir(os.path.abspath(\n        os.path.join(os.path.dirname(__file__), 'test_apps', 'helloworld')))\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == 'hello'\n\n    # import app from app.py in current directory\n    monkeypatch.chdir(os.path.abspath(\n        os.path.join(os.path.dirname(__file__), 'test_apps', 'cliapp')))\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == 'testapp'\n\n\ndef test_with_appcontext(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testapp\\n'\n\n\ndef test_appgroup(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command(with_appcontext=True)\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command(with_appcontext=True)\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, ['test'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n    result = runner.invoke(cli, ['subgroup', 'test2'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n\ndef test_flaskgroup(runner):\n    \"\"\"Test FlaskGroup.\"\"\"\n\n    def create_app(info):\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, ['test'])\n    assert result.exit_code == 0\n    assert result.output == 'flaskgroup\\n'\n\n\ndef test_print_exceptions(runner):\n    \"\"\"Print the stacktrace if the CLI.\"\"\"\n\n    def create_app(info):\n        raise Exception(\"oh no\")\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    result = runner.invoke(cli, ['--help'])\n    assert result.exit_code == 0\n    assert 'Exception: oh no' in result.output\n    assert 'Traceback' in result.output\n\n\nclass TestRoutes:\n    @pytest.fixture\n    def invoke(self, runner):\n        def create_app(info):\n            app = Flask(__name__)\n            app.testing = True\n\n            @app.route('\/get_post\/<int:x>\/<int:y>', methods=['GET', 'POST'])\n            def yyy_get_post(x, y):\n                pass\n\n            @app.route('\/zzz_post', methods=['POST'])\n            def aaa_post():\n                pass\n\n            return app\n\n        cli = FlaskGroup(create_app=create_app)\n        return partial(runner.invoke, cli)\n\n    def expect_order(self, order, output):\n        # skip the header and match the start of each row\n        for expect, line in zip(order, output.splitlines()[2:]):\n            # do this instead of startswith for nicer pytest output\n            assert line[:len(expect)] == expect\n\n    def test_simple(self, invoke):\n        result = invoke(['routes'])\n        assert result.exit_code == 0\n        self.expect_order(\n            ['aaa_post', 'static', 'yyy_get_post'],\n            result.output\n        )\n\n    def test_sort(self, invoke):\n        default_output = invoke(['routes']).output\n        endpoint_output = invoke(['routes', '-s', 'endpoint']).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            ['static', 'yyy_get_post', 'aaa_post'],\n            invoke(['routes', '-s', 'methods']).output\n        )\n        self.expect_order(\n            ['yyy_get_post', 'static', 'aaa_post'],\n            invoke(['routes', '-s', 'rule']).output\n        )\n        self.expect_order(\n            ['aaa_post', 'yyy_get_post', 'static'],\n            invoke(['routes', '-s', 'match']).output\n        )\n\n    def test_all_methods(self, invoke):\n        output = invoke(['routes']).output\n        assert 'GET, HEAD, OPTIONS, POST' not in output\n        output = invoke(['routes', '--all-methods']).output\n        assert 'GET, HEAD, OPTIONS, POST' in output\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.cli\n    ~~~~~~~~~\n\n    A simple command line application to run flask apps.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport ast\nimport inspect\nimport os\nimport re\nimport sys\nimport traceback\nfrom functools import update_wrapper\nfrom operator import attrgetter\nfrom threading import Lock, Thread\n\nimport click\n\nfrom . import __version__\nfrom ._compat import iteritems, reraise\nfrom .globals import current_app\nfrom .helpers import get_debug_flag\nfrom ._compat import getargspec\n\n\nclass NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n\n\ndef find_best_app(script_info, module):\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in ('app', 'application'):\n        app = getattr(module, attr_name, None)\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [\n        v for k, v in iteritems(module.__dict__) if isinstance(v, Flask)\n    ]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            'Auto-detected multiple Flask applications in module \"{module}\".'\n            ' Use \"FLASK_APP={module}:name\" to specify the correct'\n            ' one.'.format(module=module.__name__)\n        )\n\n    # Search for app factory functions.\n    for attr_name in ('create_app', 'make_app'):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = call_factory(app_factory, script_info)\n                if isinstance(app, Flask):\n                    return app\n            except TypeError:\n                raise NoAppException(\n                    'Auto-detected \"{function}()\" in module \"{module}\", but '\n                    'could not call it without specifying arguments.'.format(\n                        function=attr_name, module=module.__name__\n                    )\n                )\n\n    raise NoAppException(\n        'Failed to find application in module \"{module}\". Are you sure '\n        'it contains a Flask application? Maybe you wrapped it in a WSGI '\n        'middleware.'.format(module=module.__name__)\n    )\n\n\ndef call_factory(app_factory, script_info, arguments=()):\n    \"\"\"Takes an app factory, a ``script_info` object and  optionally a tuple\n    of arguments. Checks for the existence of a script_info argument and calls\n    the app_factory depending on that and the arguments provided.\n    \"\"\"\n    args_spec = getargspec(app_factory)\n    arg_names = args_spec.args\n    arg_defaults = args_spec.defaults\n\n    if 'script_info' in arg_names:\n        return app_factory(*arguments, script_info=script_info)\n    elif arguments:\n        return app_factory(*arguments)\n    elif not arguments and len(arg_names) == 1 and arg_defaults is None:\n        return app_factory(script_info)\n    return app_factory()\n\n\ndef find_app_by_string(string, script_info, module):\n    \"\"\"Checks if the given string is a variable name or a function. If it is\n    a function, it checks for specified arguments and whether it takes\n    a ``script_info`` argument and calls the function with the appropriate\n    arguments.\"\"\"\n    from . import Flask\n    function_regex = r'^(?P<name>\\w+)(?:\\((?P<args>.*)\\))?$'\n    match = re.match(function_regex, string)\n    if match:\n        name, args = match.groups()\n        try:\n            if args is not None:\n                args = args.rstrip(' ,')\n                if args:\n                    args = ast.literal_eval(\n                        \"({args}, )\".format(args=args))\n                else:\n                    args = ()\n                app_factory = getattr(module, name, None)\n                app = call_factory(app_factory, script_info, args)\n            else:\n                attr = getattr(module, name, None)\n                if inspect.isfunction(attr):\n                    app = call_factory(attr, script_info)\n                else:\n                    app = attr\n\n            if isinstance(app, Flask):\n                return app\n            else:\n                raise RuntimeError('Failed to find application in module '\n                                   '\"{name}\"'.format(name=module))\n        except TypeError as e:\n            new_error = NoAppException(\n                '{e}\\nThe app factory \"{factory}\" in module \"{module}\" could'\n                ' not be called with the specified arguments (and a'\n                ' script_info argument automatically added if applicable).'\n                ' Did you make sure to use the right number of arguments as'\n                ' well as not using keyword arguments or'\n                ' non-literals?'.format(e=e, factory=string, module=module))\n            reraise(NoAppException, new_error, sys.exc_info()[2])\n    else:\n        raise NoAppException(\n            'The provided string \"{string}\" is not a valid variable name'\n            'or function expression.'.format(string=string))\n\n\ndef prepare_exec_for_file(filename):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    module = []\n\n    # Chop off file extensions or package markers\n    if os.path.split(filename)[1] == '__init__.py':\n        filename = os.path.dirname(filename)\n    elif filename.endswith('.py'):\n        filename = filename[:-3]\n    else:\n        raise NoAppException('The file provided (%s) does exist but is not a '\n                             'valid Python file.  This means that it cannot '\n                             'be used as application.  Please change the '\n                             'extension to .py' % filename)\n    filename = os.path.realpath(filename)\n\n    dirpath = filename\n    while 1:\n        dirpath, extra = os.path.split(dirpath)\n        module.append(extra)\n        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n            break\n\n    if sys.path[0] != dirpath:\n        sys.path.insert(0, dirpath)\n\n    return '.'.join(module[::-1])\n\n\ndef locate_app(script_info, app_id, raise_if_not_found=True):\n    \"\"\"Attempts to locate the application.\"\"\"\n    __traceback_hide__ = True\n\n    if ':' in app_id:\n        module, app_obj = app_id.split(':', 1)\n    else:\n        module = app_id\n        app_obj = None\n\n    try:\n        __import__(module)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[-1].tb_next:\n            stack_trace = traceback.format_exc()\n            raise NoAppException(\n                'There was an error trying to import the app ({module}):\\n'\n                '{stack_trace}'.format(\n                    module=module, stack_trace=stack_trace\n                )\n            )\n        elif raise_if_not_found:\n            raise NoAppException(\n                'The file\/path provided (%s) does not appear to exist. Please'\n                ' verify the path is correct. If app is not on PYTHONPATH,'\n                ' ensure the extension is .py.'.format(module=module)\n            )\n        else:\n            return\n\n    mod = sys.modules[module]\n\n    if app_obj is None:\n        return find_best_app(script_info, mod)\n    else:\n        return find_app_by_string(app_obj, script_info, mod)\n\n\ndef find_default_import_path():\n    app = os.environ.get('FLASK_APP')\n    if app is None:\n        return\n    if os.path.isfile(app):\n        return prepare_exec_for_file(app)\n    return app\n\n\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n    message = 'Flask %(version)s\\nPython %(python_version)s'\n    click.echo(message % {\n        'version': __version__,\n        'python_version': sys.version,\n    }, color=ctx.color)\n    ctx.exit()\n\nversion_option = click.Option(['--version'],\n                              help='Show the flask version',\n                              expose_value=False,\n                              callback=get_version,\n                              is_flag=True, is_eager=True)\n\nclass DispatchingApp(object):\n    \"\"\"Special application that dispatches to a Flask application which\n    is imported by name in a background thread.  If an error happens\n    it is recorded and shown as part of the WSGI handling which in case\n    of the Werkzeug debugger means that it shows up in the browser.\n    \"\"\"\n\n    def __init__(self, loader, use_eager_loading=False):\n        self.loader = loader\n        self._app = None\n        self._lock = Lock()\n        self._bg_loading_exc_info = None\n        if use_eager_loading:\n            self._load_unlocked()\n        else:\n            self._load_in_background()\n\n    def _load_in_background(self):\n        def _load_app():\n            __traceback_hide__ = True\n            with self._lock:\n                try:\n                    self._load_unlocked()\n                except Exception:\n                    self._bg_loading_exc_info = sys.exc_info()\n        t = Thread(target=_load_app, args=())\n        t.start()\n\n    def _flush_bg_loading_exception(self):\n        __traceback_hide__ = True\n        exc_info = self._bg_loading_exc_info\n        if exc_info is not None:\n            self._bg_loading_exc_info = None\n            reraise(*exc_info)\n\n    def _load_unlocked(self):\n        __traceback_hide__ = True\n        self._app = rv = self.loader()\n        self._bg_loading_exc_info = None\n        return rv\n\n    def __call__(self, environ, start_response):\n        __traceback_hide__ = True\n        if self._app is not None:\n            return self._app(environ, start_response)\n        self._flush_bg_loading_exception()\n        with self._lock:\n            if self._app is not None:\n                rv = self._app\n            else:\n                rv = self._load_unlocked()\n            return rv(environ, start_response)\n\n\nclass ScriptInfo(object):\n    \"\"\"Help object to deal with Flask applications.  This is usually not\n    necessary to interface with as it's used internally in the dispatching\n    to click.  In future versions of Flask this object will most likely play\n    a bigger role.  Typically it's created automatically by the\n    :class:`FlaskGroup` but you can also manually create it and pass it\n    onwards as click object.\n    \"\"\"\n\n    def __init__(self, app_import_path=None, create_app=None):\n        if create_app is None:\n            if app_import_path is None:\n                app_import_path = find_default_import_path()\n            self.app_import_path = app_import_path\n        else:\n            app_import_path = None\n\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data = {}\n        self._loaded_app = None\n\n    def load_app(self):\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        __traceback_hide__ = True\n\n        if self._loaded_app is not None:\n            return self._loaded_app\n\n        if self.create_app is not None:\n            rv = call_factory(self.create_app, self)\n        else:\n            if self.app_import_path:\n                rv = locate_app(self, self.app_import_path)\n            else:\n                for module in ['wsgi.py', 'app.py']:\n                    import_path = prepare_exec_for_file(module)\n                    rv = locate_app(\n                        self, import_path, raise_if_not_found=False\n                    )\n\n                    if rv:\n                        break\n\n            if not rv:\n                raise NoAppException(\n                    'Could not locate Flask application. You did not provide '\n                    'the FLASK_APP environment variable, and a wsgi.py or '\n                    'app.py module was not found in the current directory.\\n\\n'\n                    'For more information see '\n                    'http:\/\/flask.pocoo.org\/docs\/latest\/quickstart\/'\n                )\n\n        debug = get_debug_flag()\n\n        if debug is not None:\n            rv._reconfigure_for_run_debug(debug)\n\n        self._loaded_app = rv\n        return rv\n\n\npass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n\n\ndef with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.  If callbacks are registered directly\n    to the ``app.cli`` object then they are wrapped with this function\n    by default unless it's disabled.\n    \"\"\"\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n            return __ctx.invoke(f, *args, **kwargs)\n    return update_wrapper(decorator, f)\n\n\nclass AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop('with_appcontext', True)\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n        return decorator\n\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault('cls', AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n\n\nclass FlaskGroup(AppGroup):\n    \"\"\"Special subclass of the :class:`AppGroup` group that supports\n    loading more commands from the configured Flask app.  Normally a\n    developer does not have to interface with this class but there are\n    some very advanced use cases for which it makes sense to create an\n    instance of this.\n\n    For information as of why this is useful see :ref:`custom-scripts`.\n\n    :param add_default_commands: if this is True then the default run and\n                                 shell commands wil be added.\n    :param add_version_option: adds the ``--version`` option.\n    :param create_app: an optional callback that is passed the script info\n                       and returns the loaded app.\n    \"\"\"\n\n    def __init__(self, add_default_commands=True, create_app=None,\n                 add_version_option=True, **extra):\n        params = list(extra.pop('params', None) or ())\n\n        if add_version_option:\n            params.append(version_option)\n\n        AppGroup.__init__(self, params=params, **extra)\n        self.create_app = create_app\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n\n    def _load_plugin_commands(self):\n        if self._loaded_plugin_commands:\n            return\n        try:\n            import pkg_resources\n        except ImportError:\n            self._loaded_plugin_commands = True\n            return\n\n        for ep in pkg_resources.iter_entry_points('flask.commands'):\n            self.add_command(ep.load(), ep.name)\n        self._loaded_plugin_commands = True\n\n    def get_command(self, ctx, name):\n        self._load_plugin_commands()\n\n        # We load built-in commands first as these should always be the\n        # same no matter what the app does.  If the app does want to\n        # override this it needs to make a custom instance of this group\n        # and not attach the default commands.\n        #\n        # This also means that the script stays functional in case the\n        # application completely fails.\n        rv = AppGroup.get_command(self, ctx, name)\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv = info.load_app().cli.get_command(ctx, name)\n            if rv is not None:\n                return rv\n        except NoAppException:\n            pass\n\n    def list_commands(self, ctx):\n        self._load_plugin_commands()\n\n        # The commands available is the list of both the application (if\n        # available) plus the builtin commands.\n        rv = set(click.Group.list_commands(self, ctx))\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except Exception:\n            # Here we intentionally swallow all exceptions as we don't\n            # want the help page to break if the app does not exist.\n            # If someone attempts to use the command we try to create\n            # the app again and this will give us the error.\n            # However, we will not do so silently because that would confuse\n            # users.\n            traceback.print_exc()\n        return sorted(rv)\n\n    def main(self, *args, **kwargs):\n        obj = kwargs.get('obj')\n        if obj is None:\n            obj = ScriptInfo(create_app=self.create_app)\n        kwargs['obj'] = obj\n        kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n        return AppGroup.main(self, *args, **kwargs)\n\n\n@click.command('run', short_help='Runs a development server.')\n@click.option('--host', '-h', default='127.0.0.1',\n              help='The interface to bind to.')\n@click.option('--port', '-p', default=5000,\n              help='The port to bind to.')\n@click.option('--reload\/--no-reload', default=None,\n              help='Enable or disable the reloader.  By default the reloader '\n              'is active if debug is enabled.')\n@click.option('--debugger\/--no-debugger', default=None,\n              help='Enable or disable the debugger.  By default the debugger '\n              'is active if debug is enabled.')\n@click.option('--eager-loading\/--lazy-loader', default=None,\n              help='Enable or disable eager loading.  By default eager '\n              'loading is enabled if the reloader is disabled.')\n@click.option('--with-threads\/--without-threads', default=False,\n              help='Enable or disable multithreading.')\n@pass_script_info\ndef run_command(info, host, port, reload, debugger, eager_loading,\n                with_threads):\n    \"\"\"Runs a local development server for the Flask application.\n\n    This local server is recommended for development purposes only but it\n    can also be used for simple intranet deployments.  By default it will\n    not support any sort of concurrency at all to simplify debugging.  This\n    can be changed with the --with-threads option which will enable basic\n    multithreading.\n\n    The reloader and debugger are by default enabled if the debug flag of\n    Flask is enabled and disabled otherwise.\n    \"\"\"\n    from werkzeug.serving import run_simple\n\n    # Set a global flag that indicates that we were invoked from the\n    # command line interface provided server command.  This is detected\n    # by Flask.run to make the call into a no-op.  This is necessary to\n    # avoid ugly errors when the script that is loaded here also attempts\n    # to start a server.\n    os.environ['FLASK_RUN_FROM_CLI_SERVER'] = '1'\n\n    debug = get_debug_flag()\n    if reload is None:\n        reload = bool(debug)\n    if debugger is None:\n        debugger = bool(debug)\n    if eager_loading is None:\n        eager_loading = not reload\n\n    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n\n    # Extra startup messages.  This depends a bit on Werkzeug internals to\n    # not double execute when the reloader kicks in.\n    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n        # If we have an import path we can print it out now which can help\n        # people understand what's being served.  If we do not have an\n        # import path because the app was loaded through a callback then\n        # we won't print anything.\n        if info.app_import_path is not None:\n            print(' * Serving Flask app \"%s\"' % info.app_import_path)\n        if debug is not None:\n            print(' * Forcing debug mode %s' % (debug and 'on' or 'off'))\n\n    run_simple(host, port, app, use_reloader=reload,\n               use_debugger=debugger, threaded=with_threads)\n\n\n@click.command('shell', short_help='Runs a shell in the app context.')\n@with_appcontext\ndef shell_command():\n    \"\"\"Runs an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to it's configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configuring the application.\n    \"\"\"\n    import code\n    from flask.globals import _app_ctx_stack\n    app = _app_ctx_stack.top.app\n    banner = 'Python %s on %s\\nApp: %s%s\\nInstance: %s' % (\n        sys.version,\n        sys.platform,\n        app.import_name,\n        app.debug and ' [debug]' or '',\n        app.instance_path,\n    )\n    ctx = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get('PYTHONSTARTUP')\n    if startup and os.path.isfile(startup):\n        with open(startup, 'r') as f:\n            eval(compile(f.read(), startup, 'exec'), ctx)\n\n    ctx.update(app.make_shell_context())\n\n    code.interact(banner=banner, local=ctx)\n\n\n@click.command('routes', short_help='Show the routes for the app.')\n@click.option(\n    '--sort', '-s',\n    type=click.Choice(('endpoint', 'methods', 'rule', 'match')),\n    default='endpoint',\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        'routes when dispatching a request.'\n    )\n)\n@click.option(\n    '--all-methods',\n    is_flag=True,\n    help=\"Show HEAD and OPTIONS methods.\"\n)\n@with_appcontext\ndef routes_command(sort, all_methods):\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    ignored_methods = set(() if all_methods else ('HEAD', 'OPTIONS'))\n\n    if sort in ('endpoint', 'rule'):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == 'methods':\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\n        ', '.join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = ('Endpoint', 'Methods', 'Rule')\n    widths = (\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = '{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}'.format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*('-' * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n\n\ncli = FlaskGroup(help=\"\"\"\\\nThis shell command acts as general utility script for Flask applications.\n\nIt loads the application configured (through the FLASK_APP environment\nvariable) and then provides commands either provided by the application or\nFlask itself.\n\nThe most useful commands are the \"run\" and \"shell\" command.\n\nExample usage:\n\n\\b\n  %(prefix)s%(cmd)s FLASK_APP=hello.py\n  %(prefix)s%(cmd)s FLASK_DEBUG=1\n  %(prefix)sflask run\n\"\"\" % {\n    'cmd': os.name == 'posix' and 'export' or 'set',\n    'prefix': os.name == 'posix' and '$ ' or '',\n})\n\n\ndef main(as_module=False):\n    args = sys.argv[1:]\n\n    if as_module:\n        this_module = 'flask'\n\n        if sys.version_info < (2, 7):\n            this_module += '.cli'\n\n        name = 'python -m ' + this_module\n\n        # Python rewrites \"python -m flask\" to the path to the file in argv.\n        # Restore the original command so that the reloader works.\n        sys.argv = ['-m', this_module] + args\n    else:\n        name = None\n\n    cli.main(args=args, prog_name=name)\n\n\nif __name__ == '__main__':\n    main(as_module=True)\n\n\"\"\"\nGenerate tests which test: style cleanup\n[ci skip]\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_cli\n    ~~~~~~~~~~~~~~\n\n    :copyright: (c) 2016 by the Flask Team, see AUTHORS for more details.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n#\n# This file was part of Flask-CLI and was modified under the terms its license,\n# the Revised BSD License.\n# Copyright (C) 2015 CERN.\n#\nfrom __future__ import absolute_import, print_function\nimport os\nimport sys\nfrom functools import partial\n\nimport click\nimport pytest\nfrom click.testing import CliRunner\nfrom flask import Flask, current_app\n\nfrom flask.cli import cli, AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n    find_best_app, locate_app, with_appcontext, prepare_exec_for_file, \\\n    find_default_import_path, get_version\n\n\n@pytest.fixture\ndef runner():\n    return CliRunner()\n\n\ndef test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n    assert testapp.cli.name == testapp.name\n\n\ndef test_find_best_app(test_apps):\n    \"\"\"Test if `find_best_app` behaves as expected with different combinations of input.\"\"\"\n    script_info = ScriptInfo()\n\n    class Module:\n        app = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.app\n\n    class Module:\n        application = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.application\n\n    class Module:\n        myapp = Flask('appname')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def create_app(foo):\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def create_app(foo=None, script_info=None):\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask('appname')\n\n    assert isinstance(find_best_app(script_info, Module), Flask)\n    assert find_best_app(script_info, Module).name == 'appname'\n\n    class Module:\n        myapp = Flask('appname1')\n\n        @staticmethod\n        def create_app():\n            return Flask('appname2')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        myapp = Flask('appname1')\n\n        @staticmethod\n        def create_app():\n            return Flask('appname2')\n\n    assert find_best_app(script_info, Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        myapp1 = Flask('appname1')\n        myapp2 = Flask('appname2')\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask('appname2')\n\n    pytest.raises(NoAppException, find_best_app, script_info, Module)\n\n\ndef test_prepare_exec_for_file(test_apps):\n    \"\"\"Expect the correct path to be set and the correct module name to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect, where\n    the parent directory of given file is added to `sys.path`.\n    \"\"\"\n    realpath = os.path.realpath('\/tmp\/share\/test.py')\n    dirname = os.path.dirname(realpath)\n    assert prepare_exec_for_file('\/tmp\/share\/test.py') == 'test'\n    assert dirname in sys.path\n\n    realpath = os.path.realpath('\/tmp\/share\/__init__.py')\n    dirname = os.path.dirname(os.path.dirname(realpath))\n    assert prepare_exec_for_file('\/tmp\/share\/__init__.py') == 'share'\n    assert dirname in sys.path\n\n    with pytest.raises(NoAppException):\n        prepare_exec_for_file('\/tmp\/share\/test.txt')\n\n\ndef test_locate_app(test_apps):\n    \"\"\"Test of locate_app.\"\"\"\n    script_info = ScriptInfo()\n    assert locate_app(script_info, \"cliapp.app\").name == \"testapp\"\n    assert locate_app(script_info, \"cliapp.app:testapp\").name == \"testapp\"\n    assert locate_app(script_info, \"cliapp.factory\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app()\").name == \"create_app\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app2('foo', 'bar')\"\n    ).name == \"create_app2_foo_bar\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app2('foo', 'bar', )\"\n    ).name == \"create_app2_foo_bar\"\n    assert locate_app(\n        script_info, \"cliapp.factory:create_app3('baz', 'qux')\"\n    ).name == \"create_app3_baz_qux\"\n    assert locate_app(script_info, \"cliapp.multiapp:app1\").name == \"app1\"\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"notanpp.py\")\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"cliapp\/app\")\n    pytest.raises(\n        RuntimeError, locate_app, script_info, \"cliapp.app:notanapp\")\n    pytest.raises(\n        NoAppException, locate_app,\n        script_info, \"cliapp.factory:create_app2('foo')\")\n    pytest.raises(\n        NoAppException, locate_app,\n        script_info, \"cliapp.factory:create_app ()\")\n    pytest.raises(\n        NoAppException, locate_app, script_info, \"cliapp.importerrorapp\")\n    assert locate_app(\n        script_info, \"notanpp.py\", raise_if_not_found=False\n    ) is None\n\n\ndef test_find_default_import_path(test_apps, monkeypatch, tmpdir):\n    \"\"\"Test of find_default_import_path.\"\"\"\n    monkeypatch.delitem(os.environ, 'FLASK_APP', raising=False)\n    assert find_default_import_path() == None\n    monkeypatch.setitem(os.environ, 'FLASK_APP', 'notanapp')\n    assert find_default_import_path() == 'notanapp'\n    tmpfile = tmpdir.join('testapp.py')\n    tmpfile.write('')\n    monkeypatch.setitem(os.environ, 'FLASK_APP', str(tmpfile))\n    expect_rv = prepare_exec_for_file(str(tmpfile))\n    assert find_default_import_path() == expect_rv\n\n\ndef test_get_version(test_apps, capsys):\n    \"\"\"Test of get_version.\"\"\"\n    from flask import __version__ as flask_ver\n    from sys import version as py_ver\n\n    class MockCtx(object):\n        resilient_parsing = False\n        color = None\n\n        def exit(self): return\n\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert flask_ver in out\n    assert py_ver in out\n\n\ndef test_scriptinfo(test_apps, monkeypatch):\n    \"\"\"Test of ScriptInfo.\"\"\"\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    assert obj.load_app().name == \"testapp\"\n    assert obj.load_app().name == \"testapp\"\n\n    def create_app(info):\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() == app\n\n    obj = ScriptInfo()\n    pytest.raises(NoAppException, obj.load_app)\n\n    # import app from wsgi.py in current directory\n    monkeypatch.chdir(os.path.abspath(os.path.join(\n        os.path.dirname(__file__), 'test_apps', 'helloworld'\n    )))\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == 'hello'\n\n    # import app from app.py in current directory\n    monkeypatch.chdir(os.path.abspath(os.path.join(\n        os.path.dirname(__file__), 'test_apps', 'cliapp'\n    )))\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == 'testapp'\n\n\ndef test_with_appcontext(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testapp\\n'\n\n\ndef test_appgroup(runner):\n    \"\"\"Test of with_appcontext.\"\"\"\n\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command(with_appcontext=True)\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command(with_appcontext=True)\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda info: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, ['test'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n    result = runner.invoke(cli, ['subgroup', 'test2'], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == 'testappgroup\\n'\n\n\ndef test_flaskgroup(runner):\n    \"\"\"Test FlaskGroup.\"\"\"\n\n    def create_app(info):\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, ['test'])\n    assert result.exit_code == 0\n    assert result.output == 'flaskgroup\\n'\n\n\ndef test_print_exceptions(runner):\n    \"\"\"Print the stacktrace if the CLI.\"\"\"\n\n    def create_app(info):\n        raise Exception(\"oh no\")\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    result = runner.invoke(cli, ['--help'])\n    assert result.exit_code == 0\n    assert 'Exception: oh no' in result.output\n    assert 'Traceback' in result.output\n\n\nclass TestRoutes:\n    @pytest.fixture\n    def invoke(self, runner):\n        def create_app(info):\n            app = Flask(__name__)\n            app.testing = True\n\n            @app.route('\/get_post\/<int:x>\/<int:y>', methods=['GET', 'POST'])\n            def yyy_get_post(x, y):\n                pass\n\n            @app.route('\/zzz_post', methods=['POST'])\n            def aaa_post():\n                pass\n\n            return app\n\n        cli = FlaskGroup(create_app=create_app)\n        return partial(runner.invoke, cli)\n\n    def expect_order(self, order, output):\n        # skip the header and match the start of each row\n        for expect, line in zip(order, output.splitlines()[2:]):\n            # do this instead of startswith for nicer pytest output\n            assert line[:len(expect)] == expect\n\n    def test_simple(self, invoke):\n        result = invoke(['routes'])\n        assert result.exit_code == 0\n        self.expect_order(\n            ['aaa_post', 'static', 'yyy_get_post'],\n            result.output\n        )\n\n    def test_sort(self, invoke):\n        default_output = invoke(['routes']).output\n        endpoint_output = invoke(['routes', '-s', 'endpoint']).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            ['static', 'yyy_get_post', 'aaa_post'],\n            invoke(['routes', '-s', 'methods']).output\n        )\n        self.expect_order(\n            ['yyy_get_post', 'static', 'aaa_post'],\n            invoke(['routes', '-s', 'rule']).output\n        )\n        self.expect_order(\n            ['aaa_post', 'yyy_get_post', 'static'],\n            invoke(['routes', '-s', 'match']).output\n        )\n\n    def test_all_methods(self, invoke):\n        output = invoke(['routes']).output\n        assert 'GET, HEAD, OPTIONS, POST' not in output\n        output = invoke(['routes', '--all-methods']).output\n        assert 'GET, HEAD, OPTIONS, POST' in output\n"}
{"prompt":"Python3\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ['wsgi.errors'] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(logging.Formatter(\n    '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n))\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger('flask.app')\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: simplify logging configuration\nsingle default handler and formatter\ndon't remove handlers\nconfigure level once using setLevel\ndocument logging\nreorganize logging tests\n\"\"\"\n","completion":" import logging\nimport sys\n\nimport pytest\n\nfrom flask._compat import StringIO\nfrom flask.logging import default_handler, has_level_handler, \\\n    wsgi_errors_stream\n\n\n@pytest.fixture(autouse=True)\ndef reset_logging(monkeypatch):\n    root_handlers = logging.root.handlers[:]\n    root_level = logging.root.level\n\n    logger = logging.getLogger('flask.app')\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n\ndef test_logger(app):\n    assert app.logger.name == 'flask.app'\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n\n\ndef test_wsgi_errors_stream(app, client):\n    @app.route('\/')\n    def index():\n        app.logger.error('test')\n        return ''\n\n    stream = StringIO()\n    client.get('\/', errors_stream=stream)\n    assert 'ERROR in test_logging: test' in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n\n\ndef test_has_level_handler():\n    logger = logging.getLogger('flask.app')\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n\n\ndef test_log_view_exception(app, client):\n    @app.route('\/')\n    def index():\n        raise Exception('test')\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get('\/', errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert 'Exception on \/ [GET]' in err\n    assert 'Exception: test' in err\n"}
{"prompt":"Python3\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ['wsgi.errors'] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(logging.Formatter(\n    '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n))\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger('flask.app')\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: simplify logging configuration\nsingle default handler and formatter\ndon't remove handlers\nconfigure level once using setLevel\ndocument logging\nreorganize logging tests\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.templating\n    ~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\nimport logging\nfrom jinja2 import TemplateNotFound\nimport werkzeug.serving\n\n\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {'injected_value': 42}\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('context_template.html', value=23)\n\n    rv = client.get('\/')\n    assert rv.data == b'<p>23|42'\n\n\ndef test_original_win(app, client):\n    @app.route('\/')\n    def index():\n        return flask.render_template_string('{{ config }}', config=42)\n\n    rv = client.get('\/')\n    assert rv.data == b'42'\n\n\ndef test_request_less_rendering(app, app_ctx):\n    app.config['WORLD_NAME'] = 'Special World'\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string('Hello {{ config.WORLD_NAME }} '\n                                      '{{ foo }}')\n    assert rv == 'Hello Special World 42'\n\n\ndef test_standard_context(app, client):\n    @app.route('\/')\n    def index():\n        flask.g.foo = 23\n        flask.session['test'] = 'aha'\n        return flask.render_template_string('''\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        ''')\n\n    rv = client.get('\/?foo=42')\n    assert rv.data.split() == [b'42', b'23', b'False', b'aha']\n\n\ndef test_escaping(app, client):\n    text = '<p>Hello World!'\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('escaping_template.html', text=text,\n                                     html=flask.Markup(text))\n\n    lines = client.get('\/').data.splitlines()\n    assert lines == [\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!'\n    ]\n\n\ndef test_no_escaping(app, client):\n    text = '<p>Hello World!'\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('non_escaping_template.txt', text=text,\n                                     html=flask.Markup(text))\n\n    lines = client.get('\/').data.splitlines()\n    assert lines == [\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!'\n    ]\n\n\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\n        '{{ foo }}', foo='<test>') == '&lt;test&gt;'\n    assert flask.render_template('mail.txt', foo='<test>') == '<test> Mail'\n\n\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute('_macro.html', 'hello')\n    assert macro('World') == 'Hello World!'\n\n\ndef test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\n\ndef test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\n\ndef test_template_filter_with_name(app):\n    @app.template_filter('strrev')\n    def my_reverse(s):\n        return s[::-1]\n\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\n\ndef test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, 'strrev')\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\n\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter('super_reverse')\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, 'super_reverse')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_template_test_with_name(app):\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, 'boolean')\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, 'boolean')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert 'get_stuff' in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals['get_stuff'] == get_stuff\n    assert app.jinja_env.globals['get_stuff'](), 42\n\n    rv = flask.render_template_string('{{ get_stuff() }}')\n    assert rv == '42'\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n            return DictLoader({'index.html': 'Hello Custom World!'})\n\n    app = MyFlask(__name__)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('index.html')\n\n    c = app.test_client()\n    rv = c.get('\/')\n    assert rv.data == b'Hello Custom World!'\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {'whiskey': 'Jameson'}\n\n    @app.route('\/')\n    def index():\n        return flask.render_template(\n            ['no_template.xml',  # should skip this one\n             'simple_template.html',  # should render this\n             'context_template.html'],\n            value=23)\n\n    rv = client.get('\/')\n    assert rv.data == b'<h1>Jameson<\/h1>'\n\n\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.jinja_env.auto_reload is True\n\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n\n    app.run()\n    assert app.templates_auto_reload == False\n    assert app.jinja_env.auto_reload == False\n\n    app.run(debug=True)\n    assert app.templates_auto_reload == True\n    assert app.jinja_env.auto_reload == True\n\n\ndef test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(x, record):\n            called.append(True)\n            text = str(record.msg)\n            assert '1: trying loader of application \"blueprintapp\"' in text\n            assert ('2: trying loader of blueprint \"admin\" '\n                    '(blueprintapp.apps.admin)') in text\n            assert ('trying loader of blueprint \"frontend\" '\n                    '(blueprintapp.apps.frontend)') in text\n            assert 'Error: the template could not be found' in text\n            assert ('looked up from an endpoint that belongs to '\n                    'the blueprint \"frontend\"') in text\n            assert 'See http:\/\/flask.pocoo.org\/docs\/blueprints\/#templates' in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, 'EXPLAIN_TEMPLATE_LOADING', True)\n        monkeypatch.setattr(\n            logging.getLogger('flask'), 'handlers', [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get('\/missing')\n\n        assert 'missing_template.html' in str(excinfo.value)\n\n    assert len(called) == 1\n\n\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nBlueprint Example\n~~~~~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom flask import Flask\nfrom simple_page.simple_page import simple_page\n\napp = Flask(__name__)\napp.register_blueprint(simple_page)\n# Blueprint can be registered many times\napp.register_blueprint(simple_page, url_prefix='\/pages')\n\nif __name__=='__main__':\n  app.run()\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\nBlueprint Example Tests\n~~~~~~~~~~~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport blueprintexample\n\n\n@pytest.fixture\ndef client():\n    return blueprintexample.app.test_client()\n\n\ndef test_urls(client):\n    r = client.get('\/')\n    assert r.status_code == 200\n\n    r = client.get('\/hello')\n    assert r.status_code == 200\n\n    r = client.get('\/world')\n    assert r.status_code == 200\n\n    # second blueprint instance\n    r = client.get('\/pages\/hello')\n    assert r.status_code == 200\n\n    r = client.get('\/pages\/world')\n    assert r.status_code == 200\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit\n    ~~~~~~~~\n\n    A microblogging application written with Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport time\nfrom sqlite3 import dbapi2 as sqlite3\nfrom hashlib import md5\nfrom datetime import datetime\nfrom flask import Flask, request, session, url_for, redirect, \\\n     render_template, abort, g, flash, _app_ctx_stack\nfrom werkzeug import check_password_hash, generate_password_hash\n\n\n# configuration\nDATABASE = '\/tmp\/minitwit.db'\nPER_PAGE = 30\nDEBUG = True\nSECRET_KEY = b'_5#y2L\"F4Q8z\\n\\xec]\/'\n\n# create our little application :)\napp = Flask('minitwit')\napp.config.from_object(__name__)\napp.config.from_envvar('MINITWIT_SETTINGS', silent=True)\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    top = _app_ctx_stack.top\n    if not hasattr(top, 'sqlite_db'):\n        top.sqlite_db = sqlite3.connect(app.config['DATABASE'])\n        top.sqlite_db.row_factory = sqlite3.Row\n    return top.sqlite_db\n\n\n@app.teardown_appcontext\ndef close_database(exception):\n    \"\"\"Closes the database again at the end of the request.\"\"\"\n    top = _app_ctx_stack.top\n    if hasattr(top, 'sqlite_db'):\n        top.sqlite_db.close()\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\n@app.cli.command('initdb')\ndef initdb_command():\n    \"\"\"Creates the database tables.\"\"\"\n    init_db()\n    print('Initialized the database.')\n\n\ndef query_db(query, args=(), one=False):\n    \"\"\"Queries the database and returns a list of dictionaries.\"\"\"\n    cur = get_db().execute(query, args)\n    rv = cur.fetchall()\n    return (rv[0] if rv else None) if one else rv\n\n\ndef get_user_id(username):\n    \"\"\"Convenience method to look up the id for a username.\"\"\"\n    rv = query_db('select user_id from user where username = ?',\n                  [username], one=True)\n    return rv[0] if rv else None\n\n\ndef format_datetime(timestamp):\n    \"\"\"Format a timestamp for display.\"\"\"\n    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')\n\n\ndef gravatar_url(email, size=80):\n    \"\"\"Return the gravatar image for the given email address.\"\"\"\n    return 'https:\/\/www.gravatar.com\/avatar\/%s?d=identicon&s=%d' % \\\n        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)\n\n\n@app.before_request\ndef before_request():\n    g.user = None\n    if 'user_id' in session:\n        g.user = query_db('select * from user where user_id = ?',\n                          [session['user_id']], one=True)\n\n\n@app.route('\/')\ndef timeline():\n    \"\"\"Shows a users timeline or if no user is logged in it will\n    redirect to the public timeline.  This timeline shows the user's\n    messages as well as all the messages of followed users.\n    \"\"\"\n    if not g.user:\n        return redirect(url_for('public_timeline'))\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id and (\n            user.user_id = ? or\n            user.user_id in (select whom_id from follower\n                                    where who_id = ?))\n        order by message.pub_date desc limit ?''',\n        [session['user_id'], session['user_id'], PER_PAGE]))\n\n\n@app.route('\/public')\ndef public_timeline():\n    \"\"\"Displays the latest messages of all users.\"\"\"\n    return render_template('timeline.html', messages=query_db('''\n        select message.*, user.* from message, user\n        where message.author_id = user.user_id\n        order by message.pub_date desc limit ?''', [PER_PAGE]))\n\n\n@app.route('\/<username>')\ndef user_timeline(username):\n    \"\"\"Display's a users tweets.\"\"\"\n    profile_user = query_db('select * from user where username = ?',\n                            [username], one=True)\n    if profile_user is None:\n        abort(404)\n    followed = False\n    if g.user:\n        followed = query_db('''select 1 from follower where\n            follower.who_id = ? and follower.whom_id = ?''',\n            [session['user_id'], profile_user['user_id']],\n            one=True) is not None\n    return render_template('timeline.html', messages=query_db('''\n            select message.*, user.* from message, user where\n            user.user_id = message.author_id and user.user_id = ?\n            order by message.pub_date desc limit ?''',\n            [profile_user['user_id'], PER_PAGE]), followed=followed,\n            profile_user=profile_user)\n\n\n@app.route('\/<username>\/follow')\ndef follow_user(username):\n    \"\"\"Adds the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    db = get_db()\n    db.execute('insert into follower (who_id, whom_id) values (?, ?)',\n              [session['user_id'], whom_id])\n    db.commit()\n    flash('You are now following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/<username>\/unfollow')\ndef unfollow_user(username):\n    \"\"\"Removes the current user as follower of the given user.\"\"\"\n    if not g.user:\n        abort(401)\n    whom_id = get_user_id(username)\n    if whom_id is None:\n        abort(404)\n    db = get_db()\n    db.execute('delete from follower where who_id=? and whom_id=?',\n              [session['user_id'], whom_id])\n    db.commit()\n    flash('You are no longer following \"%s\"' % username)\n    return redirect(url_for('user_timeline', username=username))\n\n\n@app.route('\/add_message', methods=['POST'])\ndef add_message():\n    \"\"\"Registers a new message for the user.\"\"\"\n    if 'user_id' not in session:\n        abort(401)\n    if request.form['text']:\n        db = get_db()\n        db.execute('''insert into message (author_id, text, pub_date)\n          values (?, ?, ?)''', (session['user_id'], request.form['text'],\n                                int(time.time())))\n        db.commit()\n        flash('Your message was recorded')\n    return redirect(url_for('timeline'))\n\n\n@app.route('\/login', methods=['GET', 'POST'])\ndef login():\n    \"\"\"Logs the user in.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        user = query_db('''select * from user where\n            username = ?''', [request.form['username']], one=True)\n        if user is None:\n            error = 'Invalid username'\n        elif not check_password_hash(user['pw_hash'],\n                                     request.form['password']):\n            error = 'Invalid password'\n        else:\n            flash('You were logged in')\n            session['user_id'] = user['user_id']\n            return redirect(url_for('timeline'))\n    return render_template('login.html', error=error)\n\n\n@app.route('\/register', methods=['GET', 'POST'])\ndef register():\n    \"\"\"Registers the user.\"\"\"\n    if g.user:\n        return redirect(url_for('timeline'))\n    error = None\n    if request.method == 'POST':\n        if not request.form['username']:\n            error = 'You have to enter a username'\n        elif not request.form['email'] or \\\n                '@' not in request.form['email']:\n            error = 'You have to enter a valid email address'\n        elif not request.form['password']:\n            error = 'You have to enter a password'\n        elif request.form['password'] != request.form['password2']:\n            error = 'The two passwords do not match'\n        elif get_user_id(request.form['username']) is not None:\n            error = 'The username is already taken'\n        else:\n            db = get_db()\n            db.execute('''insert into user (\n              username, email, pw_hash) values (?, ?, ?)''',\n              [request.form['username'], request.form['email'],\n               generate_password_hash(request.form['password'])])\n            db.commit()\n            flash('You were successfully registered and can login now')\n            return redirect(url_for('login'))\n    return render_template('register.html', error=error)\n\n\n@app.route('\/logout')\ndef logout():\n    \"\"\"Logs the user out.\"\"\"\n    flash('You were logged out')\n    session.pop('user_id', None)\n    return redirect(url_for('public_timeline'))\n\n\n# add some filters to jinja\napp.jinja_env.filters['datetimeformat'] = format_datetime\napp.jinja_env.filters['gravatar'] = gravatar_url\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    MiniTwit Tests\n    ~~~~~~~~~~~~~~\n\n    Tests the MiniTwit application.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport tempfile\nimport pytest\nfrom minitwit import minitwit\n\n\n@pytest.fixture\ndef client():\n    db_fd, minitwit.app.config['DATABASE'] = tempfile.mkstemp()\n    client = minitwit.app.test_client()\n    with minitwit.app.app_context():\n        minitwit.init_db()\n\n    yield client\n\n    os.close(db_fd)\n    os.unlink(minitwit.app.config['DATABASE'])\n\n\ndef register(client, username, password, password2=None, email=None):\n    \"\"\"Helper function to register a user\"\"\"\n    if password2 is None:\n        password2 = password\n    if email is None:\n        email = username + '@example.com'\n    return client.post('\/register', data={\n        'username':     username,\n        'password':     password,\n        'password2':    password2,\n        'email':        email,\n    }, follow_redirects=True)\n\n\ndef login(client, username, password):\n    \"\"\"Helper function to login\"\"\"\n    return client.post('\/login', data={\n        'username': username,\n        'password': password\n    }, follow_redirects=True)\n\n\ndef register_and_login(client, username, password):\n    \"\"\"Registers and logs in in one go\"\"\"\n    register(client, username, password)\n    return login(client, username, password)\n\n\ndef logout(client):\n    \"\"\"Helper function to logout\"\"\"\n    return client.get('\/logout', follow_redirects=True)\n\n\ndef add_message(client, text):\n    \"\"\"Records a message\"\"\"\n    rv = client.post('\/add_message', data={'text': text},\n                     follow_redirects=True)\n    if text:\n        assert b'Your message was recorded' in rv.data\n    return rv\n\n\ndef test_register(client):\n    \"\"\"Make sure registering works\"\"\"\n    rv = register(client, 'user1', 'default')\n    assert b'You were successfully registered ' \\\n           b'and can login now' in rv.data\n    rv = register(client, 'user1', 'default')\n    assert b'The username is already taken' in rv.data\n    rv = register(client, '', 'default')\n    assert b'You have to enter a username' in rv.data\n    rv = register(client, 'meh', '')\n    assert b'You have to enter a password' in rv.data\n    rv = register(client, 'meh', 'x', 'y')\n    assert b'The two passwords do not match' in rv.data\n    rv = register(client, 'meh', 'foo', email='broken')\n    assert b'You have to enter a valid email address' in rv.data\n\n\ndef test_login_logout(client):\n    \"\"\"Make sure logging in and logging out works\"\"\"\n    rv = register_and_login(client, 'user1', 'default')\n    assert b'You were logged in' in rv.data\n    rv = logout(client)\n    assert b'You were logged out' in rv.data\n    rv = login(client, 'user1', 'wrongpassword')\n    assert b'Invalid password' in rv.data\n    rv = login(client, 'user2', 'wrongpassword')\n    assert b'Invalid username' in rv.data\n\n\ndef test_message_recording(client):\n    \"\"\"Check if adding messages works\"\"\"\n    register_and_login(client, 'foo', 'default')\n    add_message(client, 'test message 1')\n    add_message(client, '<test message 2>')\n    rv = client.get('\/')\n    assert b'test message 1' in rv.data\n    assert b'&lt;test message 2&gt;' in rv.data\n\n\ndef test_timelines(client):\n    \"\"\"Make sure that timelines work\"\"\"\n    register_and_login(client, 'foo', 'default')\n    add_message(client, 'the message by foo')\n    logout(client)\n    register_and_login(client, 'bar', 'default')\n    add_message(client, 'the message by bar')\n    rv = client.get('\/public')\n    assert b'the message by foo' in rv.data\n    assert b'the message by bar' in rv.data\n\n    # bar's timeline should just show bar's message\n    rv = client.get('\/')\n    assert b'the message by foo' not in rv.data\n    assert b'the message by bar' in rv.data\n\n    # now let's follow foo\n    rv = client.get('\/foo\/follow', follow_redirects=True)\n    assert b'You are now following &#34;foo&#34;' in rv.data\n\n    # we should now see foo's message\n    rv = client.get('\/')\n    assert b'the message by foo' in rv.data\n    assert b'the message by bar' in rv.data\n\n    # but on the user's page we only want the user's message\n    rv = client.get('\/bar')\n    assert b'the message by foo' not in rv.data\n    assert b'the message by bar' in rv.data\n    rv = client.get('\/foo')\n    assert b'the message by foo' in rv.data\n    assert b'the message by bar' not in rv.data\n\n    # now unfollow and check if that worked\n    rv = client.get('\/foo\/unfollow', follow_redirects=True)\n    assert b'You are no longer following &#34;foo&#34;' in rv.data\n    rv = client.get('\/')\n    assert b'the message by foo' not in rv.data\n    assert b'the message by bar' in rv.data\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.app\n    ~~~~~~~~~\n\n    This module implements the central WSGI application object.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nimport warnings\nfrom datetime import timedelta\nfrom functools import update_wrapper\nfrom itertools import chain\nfrom threading import Lock\n\nfrom werkzeug.datastructures import Headers, ImmutableDict\nfrom werkzeug.exceptions import BadRequest, BadRequestKeyError, HTTPException, \\\n    InternalServerError, MethodNotAllowed, default_exceptions\nfrom werkzeug.routing import BuildError, Map, RequestRedirect, Rule\n\nfrom . import cli, json\nfrom ._compat import integer_types, reraise, string_types, text_type\nfrom .config import Config, ConfigAttribute\nfrom .ctx import AppContext, RequestContext, _AppCtxGlobals\nfrom .globals import _request_ctx_stack, g, request, session\nfrom .helpers import _PackageBoundObject, \\\n    _endpoint_from_view_func, find_package, get_env, get_debug_flag, \\\n    get_flashed_messages, locked_cached_property, url_for\nfrom .logging import create_logger\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down, got_request_exception, \\\n    request_finished, request_started, request_tearing_down\nfrom .templating import DispatchingJinjaLoader, Environment, \\\n    _default_template_ctx_processor\nfrom .wrappers import Request, Response\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\n\n\ndef setupmethod(f):\n    \"\"\"Wraps a method so that it performs a check in debug mode if the\n    first request was already handled.\n    \"\"\"\n    def wrapper_func(self, *args, **kwargs):\n        if self.debug and self._got_first_request:\n            raise AssertionError('A setup function was called after the '\n                'first request was handled.  This usually indicates a bug '\n                'in the application where a module was not imported '\n                'and decorators or other functionality was called too late.\\n'\n                'To fix this make sure to import all your view modules, '\n                'database models and everything related at a central place '\n                'before the application starts serving requests.')\n        return f(self, *args, **kwargs)\n    return update_wrapper(wrapper_func, f)\n\n\nclass Flask(_PackageBoundObject):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication\/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 0.13\n       The `host_matching` and `static_host` parameters were added.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: the folder with static files that should be served\n                          at `static_url_path`.  Defaults to the ``'static'``\n                          folder in the root path of the application.\n    :param host_matching: sets the app's ``url_map.host_matching`` to the given\n                          value. Defaults to False.\n    :param static_host: the host to use when adding the static route. Defaults\n                        to None. Required when using ``host_matching=True``\n                        with a ``static_folder`` configured.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to ``True`` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    :param root_path: Flask by default will automatically calculate the path\n                      to the root of the application.  In certain situations\n                      this cannot be achieved (for instance if the package\n                      is a Python 3 namespace package) and needs to be\n                      manually defined.\n    \"\"\"\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class = Response\n\n    #: The class that is used for the Jinja environment.\n    #:\n    #: .. versionadded:: 0.11\n    jinja_environment = Environment\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on unexpected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is now application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    #: The class that is used for the ``config`` attribute of this app.\n    #: Defaults to :class:`~flask.Config`.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Default values for certain config options.\n    #: 2. Access to config values through attributes in addition to keys.\n    #:\n    #: .. versionadded:: 0.11\n    config_class = Config\n\n    #: The testing flag.  Set this to ``True`` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate test helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``TESTING`` configuration key.  Defaults to ``False``.\n    testing = ConfigAttribute('TESTING')\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and other things. Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.\n    secret_key = ConfigAttribute('SECRET_KEY')\n\n    #: The secure cookie uses this for the name of the session cookie.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``SESSION_COOKIE_NAME`` configuration key.  Defaults to ``'session'``\n    session_cookie_name = ConfigAttribute('SESSION_COOKIE_NAME')\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute('PERMANENT_SESSION_LIFETIME',\n        get_converter=_make_timedelta)\n\n    #: A :class:`~datetime.timedelta` which is used as default cache_timeout\n    #: for the :func:`send_file` functions. The default is 12 hours.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``SEND_FILE_MAX_AGE_DEFAULT`` configuration key. This configuration\n    #: variable can also be set with an integer value used as seconds.\n    #: Defaults to ``timedelta(hours=12)``\n    send_file_max_age_default = ConfigAttribute('SEND_FILE_MAX_AGE_DEFAULT',\n        get_converter=_make_timedelta)\n\n    #: Enable this if you want to use the X-Sendfile feature.  Keep in\n    #: mind that the server has to support this.  This only affects files\n    #: sent with the :func:`send_file` method.\n    #:\n    #: .. versionadded:: 0.2\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.\n    use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')\n\n    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_encoder = json.JSONEncoder\n\n    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_decoder = json.JSONDecoder\n\n    #: Options that are passed directly to the Jinja2 environment.\n    jinja_options = ImmutableDict(\n        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']\n    )\n\n    #: Default configuration parameters.\n    default_config = ImmutableDict({\n        'ENV':                                  None,\n        'DEBUG':                                None,\n        'TESTING':                              False,\n        'PROPAGATE_EXCEPTIONS':                 None,\n        'PRESERVE_CONTEXT_ON_EXCEPTION':        None,\n        'SECRET_KEY':                           None,\n        'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n        'USE_X_SENDFILE':                       False,\n        'SERVER_NAME':                          None,\n        'APPLICATION_ROOT':                     '\/',\n        'SESSION_COOKIE_NAME':                  'session',\n        'SESSION_COOKIE_DOMAIN':                None,\n        'SESSION_COOKIE_PATH':                  None,\n        'SESSION_COOKIE_HTTPONLY':              True,\n        'SESSION_COOKIE_SECURE':                False,\n        'SESSION_COOKIE_SAMESITE':              None,\n        'SESSION_REFRESH_EACH_REQUEST':         True,\n        'MAX_CONTENT_LENGTH':                   None,\n        'SEND_FILE_MAX_AGE_DEFAULT':            timedelta(hours=12),\n        'TRAP_BAD_REQUEST_ERRORS':              None,\n        'TRAP_HTTP_EXCEPTIONS':                 False,\n        'EXPLAIN_TEMPLATE_LOADING':             False,\n        'PREFERRED_URL_SCHEME':                 'http',\n        'JSON_AS_ASCII':                        True,\n        'JSON_SORT_KEYS':                       True,\n        'JSONIFY_PRETTYPRINT_REGULAR':          False,\n        'JSONIFY_MIMETYPE':                     'application\/json',\n        'TEMPLATES_AUTO_RELOAD':                None,\n    })\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: the test client that is used with when `test_client` is used.\n    #:\n    #: .. versionadded:: 0.7\n    test_client_class = None\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface = SecureCookieSessionInterface()\n\n    # TODO remove the next three attrs when Sphinx :inherited-members: works\n    # https:\/\/github.com\/sphinx-doc\/sphinx\/issues\/741\n\n    #: The name of the package or module that this app belongs to. Do not\n    #: change this once it is set by the constructor.\n    import_name = None\n\n    #: Location of the template files to be added to the template lookup.\n    #: ``None`` if templates should not be added.\n    template_folder = None\n\n    #: Absolute path to the package on the filesystem. Used to look up\n    #: resources contained in the package.\n    root_path = None\n\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder='static',\n        static_host=None,\n        host_matching=False,\n        template_folder='templates',\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None\n    ):\n        _PackageBoundObject.__init__(\n            self,\n            import_name,\n            template_folder=template_folder,\n            root_path=root_path\n        )\n\n        if static_url_path is not None:\n            self.static_url_path = static_url_path\n\n        if static_folder is not None:\n            self.static_folder = static_folder\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                'If an instance path is provided it must be absolute.'\n                ' A relative path was given instead.'\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: A dictionary of all view functions registered.  The keys will\n        #: be function names which are also used to generate URLs and\n        #: the values are the function objects themselves.\n        #: To register a view function, use the :meth:`route` decorator.\n        self.view_functions = {}\n\n        #: A dictionary of all registered error handlers.  The key is ``None``\n        #: for error handlers active on the application, otherwise the key is\n        #: the name of the blueprint.  Each key points to another dictionary\n        #: where the key is the status code of the http exception.  The\n        #: special key ``None`` points to a list of tuples where the first item\n        #: is the class for the instance check and the second the error handler\n        #: function.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        self.error_handler_spec = {}\n\n        #: A list of functions that are called when :meth:`url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n        #: is called with `error`, `endpoint` and `values`.  If a function\n        #: returns ``None`` or raises a :exc:`BuildError` the next function is\n        #: tried.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers = []\n\n        #: A dictionary with lists of functions that will be called at the\n        #: beginning of each request. The key of the dictionary is the name of\n        #: the blueprint this function is active for, or ``None`` for all\n        #: requests. To register a function, use the :meth:`before_request`\n        #: decorator.\n        self.before_request_funcs = {}\n\n        #: A list of functions that will be called at the beginning of the\n        #: first request to this instance. To register a function, use the\n        #: :meth:`before_first_request` decorator.\n        #:\n        #: .. versionadded:: 0.8\n        self.before_first_request_funcs = []\n\n        #: A dictionary with lists of functions that should be called after\n        #: each request.  The key of the dictionary is the name of the blueprint\n        #: this function is active for, ``None`` for all requests.  This can for\n        #: example be used to close database connections. To register a function\n        #: here, use the :meth:`after_request` decorator.\n        self.after_request_funcs = {}\n\n        #: A dictionary with lists of functions that are called after\n        #: each request, even if an exception has occurred. The key of the\n        #: dictionary is the name of the blueprint this function is active for,\n        #: ``None`` for all requests. These functions are not allowed to modify\n        #: the request, and their return values are ignored. If an exception\n        #: occurred while processing the request, it gets passed to each\n        #: teardown_request function. To register a function here, use the\n        #: :meth:`teardown_request` decorator.\n        #:\n        #: .. versionadded:: 0.7\n        self.teardown_request_funcs = {}\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs = []\n\n        #: A dictionary with lists of functions that are called before the\n        #: :attr:`before_request_funcs` functions. The key of the dictionary is\n        #: the name of the blueprint this function is active for, or ``None``\n        #: for all requests. To register a function, use\n        #: :meth:`url_value_preprocessor`.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_value_preprocessors = {}\n\n        #: A dictionary with lists of functions that can be used as URL value\n        #: preprocessors.  The key ``None`` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #: of URL values before they are used as the keyword arguments of the\n        #: view function.  For each function registered this one should also\n        #: provide a :meth:`url_defaults` function that adds the parameters\n        #: automatically again that were removed that way.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_default_functions = {}\n\n        #: A dictionary with list of functions that are called without argument\n        #: to populate the template context.  The key of the dictionary is the\n        #: name of the blueprint this function is active for, ``None`` for all\n        #: requests.  Each returns a dictionary that the template context is\n        #: updated with.  To register a function here, use the\n        #: :meth:`context_processor` decorator.\n        self.template_context_processors = {\n            None: [_default_template_ctx_processor]\n        }\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors = []\n\n        #: all the attached blueprints in a dictionary by name.  Blueprints\n        #: can be attached multiple times so this dictionary does not tell\n        #: you how often they got attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints = {}\n        self._blueprint_order = []\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.  For backwards compatibility extensions should register\n        #: themselves like this::\n        #:\n        #:      if not hasattr(app, 'extensions'):\n        #:          app.extensions = {}\n        #:      app.extensions['extensionname'] = SomeObject()\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = Map()\n\n        self.url_map.host_matching = host_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert bool(static_host) == host_matching, 'Invalid static_host\/host_matching combination'\n            self.add_url_rule(\n                self.static_url_path + '\/<path:filename>',\n                endpoint='static',\n                host=static_host,\n                view_func=self.send_static_file\n            )\n\n        #: The click command line context for this application.  Commands\n        #: registered here show up in the :command:`flask` command once the\n        #: application has been discovered.  The default commands are\n        #: provided by Flask itself and can be overridden.\n        #:\n        #: This is an instance of a :class:`click.Group` object.\n        self.cli = cli.AppGroup(self.name)\n\n    @locked_cached_property\n    def name(self):\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == '__main__':\n            fn = getattr(sys.modules['__main__'], '__file__', None)\n            if fn is None:\n                return '__main__'\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @property\n    def propagate_exceptions(self):\n        \"\"\"Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration\n        value in case it's set, otherwise a sensible default is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PROPAGATE_EXCEPTIONS']\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n\n    @property\n    def preserve_context_on_exception(self):\n        \"\"\"Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION``\n        configuration value in case it's set, otherwise a sensible default\n        is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PRESERVE_CONTEXT_ON_EXCEPTION']\n        if rv is not None:\n            return rv\n        return self.debug\n\n    @locked_cached_property\n    def logger(self):\n        \"\"\"The ``'flask.app'`` logger, a standard Python\n        :class:`~logging.Logger`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will be set\n        to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be added.\n        See :ref:`logging` for more information.\n\n        .. versionchanged:: 1.0\n            Behavior was simplified. The logger is always named\n            ``flask.app``. The level is only set during configuration, it\n            doesn't check ``app.debug`` each time. Only one format is used,\n            not different ones depending on ``app.debug``. No handlers are\n            removed, and a handler is only added if no handlers are already\n            configured.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        return create_logger(self)\n\n    @locked_cached_property\n    def jinja_env(self):\n        \"\"\"The Jinja2 environment used to load templates.\"\"\"\n        return self.create_jinja_environment()\n\n    @property\n    def got_first_request(self):\n        \"\"\"This attribute is set to ``True`` if the application started\n        handling the first request.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        return self._got_first_request\n\n    def make_config(self, instance_relative=False):\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults['ENV'] = get_env()\n        defaults['DEBUG'] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n\n    def auto_find_instance_path(self):\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, 'instance')\n        return os.path.join(prefix, 'var', self.name + '-instance')\n\n    def open_instance_resource(self, resource, mode='rb'):\n        \"\"\"Opens a resource from the application's instance folder\n        (:attr:`instance_path`).  Otherwise works like\n        :meth:`open_resource`.  Instance resources can also be opened for\n        writing.\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        :param mode: resource file opening mode, default is 'rb'.\n        \"\"\"\n        return open(os.path.join(self.instance_path, resource), mode)\n\n    def _get_templates_auto_reload(self):\n        \"\"\"Reload templates when they are changed. Used by\n        :meth:`create_jinja_environment`.\n\n        This attribute can be configured with :data:`TEMPLATES_AUTO_RELOAD`. If\n        not set, it will be enabled in debug mode.\n\n        .. versionadded:: 1.0\n            This property was added but the underlying config and behavior\n            already existed.\n        \"\"\"\n        rv = self.config['TEMPLATES_AUTO_RELOAD']\n        return rv if rv is not None else self.debug\n\n    def _set_templates_auto_reload(self, value):\n        self.config['TEMPLATES_AUTO_RELOAD'] = value\n\n    templates_auto_reload = property(\n        _get_templates_auto_reload, _set_templates_auto_reload\n    )\n    del _get_templates_auto_reload, _set_templates_auto_reload\n\n    def create_jinja_environment(self):\n        \"\"\"Creates the Jinja2 environment based on :attr:`jinja_options`\n        and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds\n        the Jinja2 globals and filters after initialization.  Override\n        this function to customize the behavior.\n\n        .. versionadded:: 0.5\n        .. versionchanged:: 0.11\n           ``Environment.auto_reload`` set in accordance with\n           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n        \"\"\"\n        options = dict(self.jinja_options)\n\n        if 'autoescape' not in options:\n            options['autoescape'] = self.select_jinja_autoescape\n\n        if 'auto_reload' not in options:\n            options['auto_reload'] = self.templates_auto_reload\n\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g\n        )\n        rv.filters['tojson'] = json.tojson_filter\n        return rv\n\n    def create_global_jinja_loader(self):\n        \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n\n    def select_jinja_autoescape(self, filename):\n        \"\"\"Returns ``True`` if autoescaping should be active for the given\n        template name. If no template name is given, returns `True`.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return True\n        return filename.endswith(('.html', '.htm', '.xml', '.xhtml'))\n\n    def update_template_context(self, context):\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        # make sure the original values win.  This makes it possible to\n        # easier add new variables in context processors without breaking\n        # existing views.\n        context.update(orig_ctx)\n\n    def make_shell_context(self):\n        \"\"\"Returns the shell context for an interactive shell for this\n        application.  This runs all the registered shell context\n        processors.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {'app': self, 'g': g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n\n    #: What environment the app is running in. Flask and extensions may\n    #: enable behaviors based on the environment, such as enabling debug\n    #: mode. This maps to the :data:`ENV` config key. This is set by the\n    #: :envvar:`FLASK_ENV` environment variable and may not behave as\n    #: expected if set in code.\n    #:\n    #: **Do not enable development when deploying in production.**\n    #:\n    #: Default: ``'production'``\n    env = ConfigAttribute('ENV')\n\n    def _get_debug(self):\n        return self.config['DEBUG']\n\n    def _set_debug(self, value):\n        self.config['DEBUG'] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n\n    #: Whether debug mode is enabled. When using ``flask run`` to start\n    #: the development server, an interactive debugger will be shown for\n    #: unhandled exceptions, and the server will be reloaded when code\n    #: changes. This maps to the :data:`DEBUG` config key. This is\n    #: enabled when :attr:`env` is ``'development'`` and is overridden\n    #: by the ``FLASK_DEBUG`` environment variable. It may not behave as\n    #: expected if set in code.\n    #:\n    #: **Do not enable debug mode when deploying in production.**\n    #:\n    #: Default: ``True`` if :attr:`env` is ``'development'``, or\n    #: ``False`` otherwise.\n    debug = property(_get_debug, _set_debug)\n    del _get_debug, _set_debug\n\n    def run(self, host=None, port=None, debug=None,\n            load_dotenv=True, **options):\n        \"\"\"Runs the application on a local development server.\n\n        Do not use ``run()`` in a production setting. It is not intended to\n        meet security and performance requirements for a production server.\n        Instead, see :ref:`deployment` for WSGI server recommendations.\n\n        If the :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        It is not recommended to use this function for development with\n        automatic reloading as this is badly supported.  Instead you should\n        be using the :command:`flask` command line script's ``run`` support.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to ``True`` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n            have the server available externally as well. Defaults to\n            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n            if present.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n            port defined in the ``SERVER_NAME`` config variable if present.\n        :param debug: if given, enable or disable debug mode. See\n            :attr:`debug`.\n        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n            files to set environment variables. Will also change the working\n            directory to the directory containing the first file found.\n        :param options: the options to be forwarded to the underlying Werkzeug\n            server. See :func:`werkzeug.serving.run_simple` for more\n            information.\n\n        .. versionchanged:: 1.0\n            If installed, python-dotenv will be used to load environment\n            variables from :file:`.env` and :file:`.flaskenv` files.\n\n            If set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG`\n            environment variables will override :attr:`env` and\n            :attr:`debug`.\n\n            Threaded mode is enabled by default.\n\n        .. versionchanged:: 0.10\n            The default port is now picked from the ``SERVER_NAME``\n            variable.\n        \"\"\"\n        # Change this into a no-op if the server is invoked from the\n        # command line. Have a look at cli.py for more information.\n        if os.environ.get('FLASK_RUN_FROM_CLI') == 'true':\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n\n        if load_dotenv:\n            cli.load_dotenv()\n\n            # if set, let env vars override previous values\n            if 'FLASK_ENV' in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif 'FLASK_DEBUG' in os.environ:\n                self.debug = get_debug_flag()\n\n        # debug passed to method overrides all other sources\n        if debug is not None:\n            self.debug = bool(debug)\n\n        _host = '127.0.0.1'\n        _port = 5000\n        server_name = self.config.get('SERVER_NAME')\n        sn_host, sn_port = None, None\n\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(':')\n\n        host = host or sn_host or _host\n        port = int(port or sn_port or _port)\n\n        options.setdefault('use_reloader', self.debug)\n        options.setdefault('use_debugger', self.debug)\n        options.setdefault('threaded', True)\n\n        cli.show_server_banner(self.env, self.debug, self.name)\n\n        from werkzeug.serving import run_simple\n\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # reset normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False\n\n    def test_client(self, use_cookies=True, **kwargs):\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :ref:`testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a ``with`` block to defer the closing down\n        of the context until the end of the ``with`` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('\/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        Additionally, you may pass optional keyword arguments that will then\n        be passed to the application's :attr:`test_client_class` constructor.\n        For example::\n\n            from flask.testing import FlaskClient\n\n            class CustomClient(FlaskClient):\n                def __init__(self, *args, **kwargs):\n                    self._authentication = kwargs.pop(\"authentication\")\n                    super(CustomClient,self).__init__( *args, **kwargs)\n\n            app.test_client_class = CustomClient\n            client = app.test_client(authentication='Basic ....')\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for ``with`` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n\n        .. versionchanged:: 0.11\n           Added `**kwargs` to support passing additional keyword arguments to\n           the constructor of :attr:`test_client_class`.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from flask.testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n\n    def open_session(self, request):\n        \"\"\"Creates or opens a new session.  Default implementation stores all\n        session data in a signed cookie.  This requires that the\n        :attr:`secret_key` is set.  Instead of overriding this method\n        we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.open_session``\n            instead.\n\n        :param request: an instance of :attr:`request_class`.\n        \"\"\"\n\n        warnings.warn(DeprecationWarning(\n            '\"open_session\" is deprecated and will be removed in 1.1. Use'\n            ' \"session_interface.open_session\" instead.'\n        ))\n        return self.session_interface.open_session(self, request)\n\n    def save_session(self, session, response):\n        \"\"\"Saves the session if it needs updates.  For the default\n        implementation, check :meth:`open_session`.  Instead of overriding this\n        method we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.save_session``\n            instead.\n\n        :param session: the session to be saved (a\n                        :class:`~werkzeug.contrib.securecookie.SecureCookie`\n                        object)\n        :param response: an instance of :attr:`response_class`\n        \"\"\"\n\n        warnings.warn(DeprecationWarning(\n            '\"save_session\" is deprecated and will be removed in 1.1. Use'\n            ' \"session_interface.save_session\" instead.'\n        ))\n        return self.session_interface.save_session(self, session, response)\n\n    def make_null_session(self):\n        \"\"\"Creates a new instance of a missing session.  Instead of overriding\n        this method we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.make_null_session``\n            instead.\n\n        .. versionadded:: 0.7\n        \"\"\"\n\n        warnings.warn(DeprecationWarning(\n            '\"make_null_session\" is deprecated and will be removed in 1.1. Use'\n            ' \"session_interface.make_null_session\" instead.'\n        ))\n        return self.session_interface.make_null_session(self)\n\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n        arguments passed to this method will override the defaults set on the\n        blueprint.\n\n        Calls the blueprint's :meth:`~flask.Blueprint.register` method after\n        recording the blueprint in the application's :attr:`blueprints`.\n\n        :param blueprint: The blueprint to register.\n        :param url_prefix: Blueprint routes will be prefixed with this.\n        :param subdomain: Blueprint routes will match on this subdomain.\n        :param url_defaults: Blueprint routes will use these default values for\n            view arguments.\n        :param options: Additional keyword arguments are passed to\n            :class:`~flask.blueprints.BlueprintSetupState`. They can be\n            accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        first_registration = False\n\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                'A name collision occurred between blueprints %r and %r. Both'\n                ' share the same name \"%s\". Blueprints that are created on the'\n                ' fly need unique names.' % (\n                    blueprint, self.blueprints[blueprint.name], blueprint.name\n                )\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n\n        blueprint.register(self, options, first_registration)\n\n    def iter_blueprints(self):\n        \"\"\"Iterates over all blueprints by the order they were registered.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return iter(self._blueprint_order)\n\n    @setupmethod\n    def add_url_rule(self, rule, endpoint=None, view_func=None,\n                     provide_automatic_options=None, **options):\n        \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n        decorator.  If a view_func is provided it will be registered with the\n        endpoint.\n\n        Basically this example::\n\n            @app.route('\/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('\/', 'index', index)\n\n        If the view_func is not provided you will need to connect the endpoint\n        to a view function like so::\n\n            app.view_functions['index'] = index\n\n        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n        to customize the behavior via subclassing you only need to change\n        this method.\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        .. versionchanged:: 0.2\n           `view_func` parameter added.\n\n        .. versionchanged:: 0.6\n           ``OPTIONS`` is added automatically as method.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param provide_automatic_options: controls whether the ``OPTIONS``\n            method should be added automatically. This can also be controlled\n            by setting the ``view_func.provide_automatic_options = False``\n            before adding the rule.\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options['endpoint'] = endpoint\n        methods = options.pop('methods', None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, 'methods', None) or ('GET',)\n        if isinstance(methods, string_types):\n            raise TypeError('Allowed methods have to be iterables of strings, '\n                            'for example: @app.route(..., methods=[\"POST\"])')\n        methods = set(item.upper() for item in methods)\n\n        # Methods that should always be added\n        required_methods = set(getattr(view_func, 'required_methods', ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(view_func,\n                'provide_automatic_options', None)\n\n        if provide_automatic_options is None:\n            if 'OPTIONS' not in methods:\n                provide_automatic_options = True\n                required_methods.add('OPTIONS')\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError('View function mapping is overwriting an '\n                                     'existing endpoint function: %s' % endpoint)\n            self.view_functions[endpoint] = view_func\n\n    def route(self, rule, **options):\n        \"\"\"A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as :meth:`add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('\/')\n            def index():\n                return 'Hello World'\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        def decorator(f):\n            endpoint = options.pop('endpoint', None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n        return decorator\n\n    @setupmethod\n    def endpoint(self, endpoint):\n        \"\"\"A decorator to register a function as an endpoint.\n        Example::\n\n            @app.endpoint('example.endpoint')\n            def example():\n                return \"example\"\n\n        :param endpoint: the name of the endpoint\n        \"\"\"\n        def decorator(f):\n            self.view_functions[endpoint] = f\n            return f\n        return decorator\n\n    @staticmethod\n    def _get_exc_class_and_code(exc_class_or_code):\n        \"\"\"Ensure that we register only exceptions as handler keys\"\"\"\n        if isinstance(exc_class_or_code, integer_types):\n            exc_class = default_exceptions[exc_class_or_code]\n        else:\n            exc_class = exc_class_or_code\n\n        assert issubclass(exc_class, Exception)\n\n        if issubclass(exc_class, HTTPException):\n            return exc_class, exc_class.code\n        else:\n            return exc_class, None\n\n    @setupmethod\n    def errorhandler(self, code_or_exception):\n        \"\"\"Register a function to handle errors by code or exception class.\n\n        A decorator that is used to register a function given an\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        .. versionadded:: 0.7\n            Use :meth:`register_error_handler` instead of modifying\n            :attr:`error_handler_spec` directly, for application wide error\n            handlers.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code_or_exception: the code as integer for the handler, or\n                                  an arbitrary exception\n        \"\"\"\n        def decorator(f):\n            self._register_error_handler(None, code_or_exception, f)\n            return f\n        return decorator\n\n    @setupmethod\n    def register_error_handler(self, code_or_exception, f):\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._register_error_handler(None, code_or_exception, f)\n\n    @setupmethod\n    def _register_error_handler(self, key, code_or_exception, f):\n        \"\"\"\n        :type key: None|str\n        :type code_or_exception: int|T<=Exception\n        :type f: callable\n        \"\"\"\n        if isinstance(code_or_exception, HTTPException):  # old broken behavior\n            raise ValueError(\n                'Tried to register a handler for an exception instance {0!r}.'\n                ' Handlers can only be registered for exception classes or'\n                ' HTTP error codes.'.format(code_or_exception)\n            )\n\n        try:\n            exc_class, code = self._get_exc_class_and_code(code_or_exception)\n        except KeyError:\n            raise KeyError(\n                \"'{0}' is not a recognized HTTP error code. Use a subclass of\"\n                \" HTTPException with that code instead.\".format(code_or_exception)\n            )\n\n        handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})\n        handlers[exc_class] = f\n\n    @setupmethod\n    def template_filter(self, name=None):\n        \"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        \"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f\n\n    @setupmethod\n    def template_test(self, name=None):\n        \"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        \"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f\n\n    @setupmethod\n    def template_global(self, name=None):\n        \"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        \"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f\n\n    @setupmethod\n    def before_request(self, f):\n        \"\"\"Registers a function to run before each request.\n\n        For example, this can be used to open a database connection, or to load\n        the logged in user from the session.\n\n        The function will be called without any arguments. If it returns a\n        non-None value, the value is handled as if it was the return value from\n        the view, and further request handling is stopped.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def before_first_request(self, f):\n        \"\"\"Registers a function to be run before the first request to this\n        instance of the application.\n\n        The function will be called without any arguments and its return\n        value is ignored.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.before_first_request_funcs.append(f)\n        return f\n\n    @setupmethod\n    def after_request(self, f):\n        \"\"\"Register a function to be run after each request.\n\n        Your function must take one parameter, an instance of\n        :attr:`response_class` and return a new response object or the\n        same (see :meth:`process_response`).\n\n        As of Flask 0.7 this function might not be executed at the end of the\n        request in case an unhandled exception occurred.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_request(self, f):\n        \"\"\"Register a function to be run at the end of each request,\n        regardless of whether there was an exception or not.  These functions\n        are executed when the request context is popped, even if not an\n        actual request was performed.\n\n        Example::\n\n            ctx = app.test_request_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the request context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Generally teardown functions must take every necessary step to avoid\n        that they will fail.  If they do execute code that might fail they\n        will have to surround the execution of these code by try\/except\n        statements and log occurring errors.\n\n        When a teardown function was called because of an exception it will\n        be passed an error object.\n\n        The return values of teardown functions are ignored.\n\n        .. admonition:: Debug Note\n\n           In debug mode Flask will not tear down a request on an exception\n           immediately.  Instead it will keep it alive so that the interactive\n           debugger can still access it.  This behavior can be controlled\n           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_appcontext(self, f):\n        \"\"\"Registers a function to be called when the application context\n        ends.  These functions are typically also called when the request\n        context is popped.\n\n        Example::\n\n            ctx = app.app_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the app context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Since a request context typically also manages an application\n        context it would also be called when you pop a request context.\n\n        When a teardown function was called because of an unhandled exception\n        it will be passed an error object. If an :meth:`errorhandler` is\n        registered, it will handle the exception and the teardown will not\n        receive it.\n\n        The return values of teardown functions are ignored.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n\n    @setupmethod\n    def context_processor(self, f):\n        \"\"\"Registers a template context processor function.\"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n\n    @setupmethod\n    def shell_context_processor(self, f):\n        \"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        self.shell_context_processors.append(f)\n        return f\n\n    @setupmethod\n    def url_value_preprocessor(self, f):\n        \"\"\"Register a URL value preprocessor function for all view\n        functions in the application. These functions will be called before the\n        :meth:`before_request` functions.\n\n        The function can modify the values captured from the matched url before\n        they are passed to the view. For example, this can be used to pop a\n        common language code value and place it in ``g`` rather than pass it to\n        every view.\n\n        The function is passed the endpoint name and values dict. The return\n        value is ignored.\n        \"\"\"\n        self.url_value_preprocessors.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def url_defaults(self, f):\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n        \"\"\"\n        self.url_default_functions.setdefault(None, []).append(f)\n        return f\n\n    def _find_error_handler(self, e):\n        \"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(type(e))\n\n        for name, c in (\n            (request.blueprint, code), (None, code),\n            (request.blueprint, None), (None, None)\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n\n            if not handler_map:\n                continue\n\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n\n                if handler is not None:\n                    return handler\n\n    def handle_http_exception(self, e):\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n\n    def trap_http_exception(self, e):\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config['TRAP_HTTP_EXCEPTIONS']:\n            return True\n\n        trap_bad_request = self.config['TRAP_BAD_REQUEST_ERRORS']\n\n        # if unset, trap based on debug mode\n        if (trap_bad_request is None and self.debug) or trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False\n\n    def handle_user_exception(self, e):\n        \"\"\"This method is called whenever an exception occurs that should be\n        handled.  A special case are\n        :class:`~werkzeug.exception.HTTPException`\\s which are forwarded by\n        this function to the :meth:`handle_http_exception` method.  This\n        function will either return a response value or reraise the\n        exception with the same traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the the bad\n            key in debug mode rather than a generic bad request message.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        assert exc_value is e\n        # ensure not to trash sys.exc_info() at that point in case someone\n        # wants the traceback preserved in handle_http_exception.  Of course\n        # we cannot prevent users from trashing it themselves in a custom\n        # trap_http_exception method so that's their fault then.\n\n        # MultiDict passes the key to the exception, but that's ignored\n        # when generating the response message. Set an informative\n        # description for key errors in debug mode or when trapping errors.\n        if (\n            (self.debug or self.config['TRAP_BAD_REQUEST_ERRORS'])\n            and isinstance(e, BadRequestKeyError)\n            # only set it if it's still the default description\n            and e.description is BadRequestKeyError.description\n        ):\n            e.description = \"KeyError: '{0}'\".format(*e.args)\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        handler = self._find_error_handler(e)\n\n        if handler is None:\n            reraise(exc_type, exc_value, tb)\n        return handler(e)\n\n    def handle_exception(self, e):\n        \"\"\"Default exception handling that kicks in when an exception\n        occurs that is not caught.  In debug mode the exception will\n        be re-raised immediately, otherwise it is logged and the handler\n        for a 500 internal server error is used.  If no such handler\n        exists, a default 500 internal server error message is displayed.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n\n        got_request_exception.send(self, exception=e)\n        handler = self._find_error_handler(InternalServerError())\n\n        if self.propagate_exceptions:\n            # if we want to repropagate the exception, we can attempt to\n            # raise it with the whole traceback in case we can do that\n            # (the function was actually called from the except part)\n            # otherwise, we just raise the error again\n            if exc_value is e:\n                reraise(exc_type, exc_value, tb)\n            else:\n                raise e\n\n        self.log_exception((exc_type, exc_value, tb))\n        if handler is None:\n            return InternalServerError()\n        return self.finalize_request(handler(e), from_error_handler=True)\n\n    def log_exception(self, exc_info):\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error('Exception on %s [%s]' % (\n            request.path,\n            request.method\n        ), exc_info=exc_info)\n\n    def raise_routing_exception(self, request):\n        \"\"\"Exceptions that are recording during routing are reraised with\n        this method.  During debug we are not reraising redirect requests\n        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n        a different error instead to help debug situations.\n\n        :internal:\n        \"\"\"\n        if not self.debug \\\n           or not isinstance(request.routing_exception, RequestRedirect) \\\n           or request.method in ('GET', 'HEAD', 'OPTIONS'):\n            raise request.routing_exception\n\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n\n    def dispatch_request(self):\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if getattr(rule, 'provide_automatic_options', False) \\\n           and req.method == 'OPTIONS':\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        return self.view_functions[rule.endpoint](**req.view_args)\n\n    def full_dispatch_request(self):\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n\n    def finalize_request(self, rv, from_error_handler=False):\n        \"\"\"Given the return value from a view function this finalizes\n        the request by converting it into a response and invoking the\n        postprocessing functions.  This is invoked for both normal\n        request dispatching as well as error handlers.\n\n        Because this means that it might be called as a result of a\n        failure a special safe mode is available which can be enabled\n        with the `from_error_handler` flag.  If enabled, failures in\n        response processing will be logged and otherwise ignored.\n\n        :internal:\n        \"\"\"\n        response = self.make_response(rv)\n        try:\n            response = self.process_response(response)\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception('Request finalizing failed with an '\n                                  'error while handling an error')\n        return response\n\n    def try_trigger_before_first_request_functions(self):\n        \"\"\"Called before each request and will ensure that it triggers\n        the :attr:`before_first_request_funcs` and only exactly once per\n        application instance (which means process usually).\n\n        :internal:\n        \"\"\"\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n\n    def make_default_options_response(self):\n        \"\"\"This method is called to create the default ``OPTIONS`` response.\n        This can be changed through subclassing to change the default\n        behavior of ``OPTIONS`` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        adapter = _request_ctx_stack.top.url_adapter\n        if hasattr(adapter, 'allowed_methods'):\n            methods = adapter.allowed_methods()\n        else:\n            # fallback for Werkzeug < 0.7\n            methods = []\n            try:\n                adapter.match(method='--')\n            except MethodNotAllowed as e:\n                methods = e.valid_methods\n            except HTTPException as e:\n                pass\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n\n    def should_ignore_error(self, error):\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns ``True`` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False\n\n    def make_response(self, rv):\n        \"\"\"Convert the return value from a view function to an instance of\n        :attr:`response_class`.\n\n        :param rv: the return value from the view function. The view function\n            must return a response. Returning ``None``, or the view ending\n            without returning, is not allowed. The following types are allowed\n            for ``view_rv``:\n\n            ``str`` (``unicode`` in Python 2)\n                A response object is created with the string encoded to UTF-8\n                as the body.\n\n            ``bytes`` (``str`` in Python 2)\n                A response object is created with the bytes as the body.\n\n            ``tuple``\n                Either ``(body, status, headers)``, ``(body, status)``, or\n                ``(body, headers)``, where ``body`` is any of the other types\n                allowed here, ``status`` is a string or an integer, and\n                ``headers`` is a dictionary or a list of ``(key, value)``\n                tuples. If ``body`` is a :attr:`response_class` instance,\n                ``status`` overwrites the exiting value and ``headers`` are\n                extended.\n\n            :attr:`response_class`\n                The object is returned unchanged.\n\n            other :class:`~werkzeug.wrappers.Response` class\n                The object is coerced to :attr:`response_class`.\n\n            :func:`callable`\n                The function is called as a WSGI application. The result is\n                used to create a response object.\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n\n        status = headers = None\n\n        # unpack tuple returns\n        if isinstance(rv, (tuple, list)):\n            len_rv = len(rv)\n\n            # a 3-tuple is unpacked directly\n            if len_rv == 3:\n                rv, status, headers = rv\n            # decide if a 2-tuple has status or headers\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            # other sized tuples are not allowed\n            else:\n                raise TypeError(\n                    'The view function did not return a valid response tuple.'\n                    ' The tuple must have the form (body, status, headers),'\n                    ' (body, status), or (body, headers).'\n                )\n\n        # the body must not be None\n        if rv is None:\n            raise TypeError(\n                'The view function did not return a valid response. The'\n                ' function either returned None or ended without a return'\n                ' statement.'\n            )\n\n        # make sure the body is an instance of the response class\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (text_type, bytes, bytearray)):\n                # let the response class set the status and headers instead of\n                # waiting to do it manually, so that the class can handle any\n                # special logic\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            else:\n                # evaluate a WSGI callable, or coerce a different response\n                # class to the correct type\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    new_error = TypeError(\n                        '{e}\\nThe view function did not return a valid'\n                        ' response. The return type must be a string, tuple,'\n                        ' Response instance, or WSGI callable, but it was a'\n                        ' {rv.__class__.__name__}.'.format(e=e, rv=rv)\n                    )\n                    reraise(TypeError, new_error, sys.exc_info()[2])\n\n        # prefer the status if it was provided\n        if status is not None:\n            if isinstance(status, (text_type, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n\n        # extend existing headers with provided headers\n        if headers:\n            rv.headers.extend(headers)\n\n        return rv\n\n    def create_url_adapter(self, request):\n        \"\"\"Creates a URL adapter for the given request.  The URL adapter\n        is created at a point where the request context is not yet set up\n        so the request is passed explicitly.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n           This can now also be called without a request object when the\n           URL adapter is created for the application context.\n        \"\"\"\n        if request is not None:\n            return self.url_map.bind_to_environ(request.environ,\n                server_name=self.config['SERVER_NAME'])\n        # We need at the very least the server name to be set for this\n        # to work.\n        if self.config['SERVER_NAME'] is not None:\n            return self.url_map.bind(\n                self.config['SERVER_NAME'],\n                script_name=self.config['APPLICATION_ROOT'],\n                url_scheme=self.config['PREFERRED_URL_SCHEME'])\n\n    def inject_url_defaults(self, endpoint, values):\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        funcs = self.url_default_functions.get(None, ())\n        if '.' in endpoint:\n            bp = endpoint.rsplit('.', 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n\n    def handle_url_build_error(self, error, endpoint, values):\n        \"\"\"Handle :class:`~werkzeug.routing.BuildError` on :meth:`url_for`.\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n                if rv is not None:\n                    return rv\n            except BuildError as e:\n                # make error available outside except block (py3)\n                error = e\n\n        # At this point we want to reraise the exception.  If the error is\n        # still the same one we can reraise it with the original traceback,\n        # otherwise we raise it from here.\n        if error is exc_value:\n            reraise(exc_type, exc_value, tb)\n        raise error\n\n    def preprocess_request(self):\n        \"\"\"Called before the request is dispatched. Calls\n        :attr:`url_value_preprocessors` registered with the app and the\n        current blueprint (if any). Then calls :attr:`before_request_funcs`\n        registered with the app and the blueprint.\n\n        If any :meth:`before_request` handler returns a non-None value, the\n        value is handled as if it was the return value from the view, and\n        further request handling is stopped.\n        \"\"\"\n\n        bp = _request_ctx_stack.top.request.blueprint\n\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n\n    def process_response(self, response):\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n\n    def do_teardown_request(self, exc=_sentinel):\n        \"\"\"Called after the actual request dispatching and will\n        call every as :meth:`teardown_request` decorated function.  This is\n        not actually called by the :class:`Flask` object itself but is always\n        triggered when the request context is popped.  That way we have a\n        tighter control over certain resources under testing environments.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.  Previously this was always using the\n           current exception information.\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n\n    def do_teardown_appcontext(self, exc=_sentinel):\n        \"\"\"Called when an application context is popped.  This works pretty\n        much the same as :meth:`do_teardown_request` but for the application\n        context.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n\n    def app_context(self):\n        \"\"\"Binds the application only.  For as long as the application is bound\n        to the current context the :data:`flask.current_app` points to that\n        application.  An application context is automatically created when a\n        request context is pushed if necessary.\n\n        Example usage::\n\n            with app.app_context():\n                ...\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ):\n        \"\"\"Creates a :class:`~flask.ctx.RequestContext` from the given\n        environment and binds it to the current context.  This must be used in\n        combination with the ``with`` statement because the request is only bound\n        to the current context for the duration of the ``with`` block.\n\n        Example usage::\n\n            with app.request_context(environ):\n                do_something_with(request)\n\n        The object returned can also be used without the ``with`` statement\n        which is useful for working in the shell.  The example above is\n        doing exactly the same as this code::\n\n            ctx = app.request_context(environ)\n            ctx.push()\n            try:\n                do_something_with(request)\n            finally:\n                ctx.pop()\n\n        .. versionchanged:: 0.3\n           Added support for non-with statement usage and ``with`` statement\n           is now passed the ctx object.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args, **kwargs):\n        \"\"\"Creates a WSGI environment from the given values (see\n        :class:`werkzeug.test.EnvironBuilder` for more information, this\n        function accepts the same arguments plus two additional).\n\n        Additional arguments (only if ``base_url`` is not specified):\n\n        :param subdomain: subdomain to use for route matching\n        :param url_scheme: scheme for the request, default\n            ``PREFERRED_URL_SCHEME`` or ``http``.\n        \"\"\"\n\n        from flask.testing import make_test_environ_builder\n\n        builder = make_test_environ_builder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(self, environ, start_response):\n        \"\"\"The actual WSGI application.  This is not implemented in\n        `__call__` so that middlewares can be applied without losing a\n        reference to the class.  So instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n           The behavior of the before and after request callbacks was changed\n           under error conditions and a new callback was added that will\n           always execute at the end of the request, independent on if an\n           error occurred or not.  See :ref:`callbacks-and-errors`.\n\n        :param environ: a WSGI environment\n        :param start_response: a callable accepting a status code,\n                               a list of headers and an optional\n                               exception context to start the response\n        \"\"\"\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            ctx.auto_pop(error)\n\n    def __call__(self, environ, start_response):\n        \"\"\"Shortcut for :attr:`wsgi_app`.\"\"\"\n        return self.wsgi_app(environ, start_response)\n\n    def __repr__(self):\n        return '<%s %r>' % (\n            self.__class__.__name__,\n            self.name,\n        )\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\nLarger App Tests\n~~~~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom yourapplication import app\nimport pytest\n\n@pytest.fixture\ndef client():\n    app.config['TESTING'] = True\n    client = app.test_client()\n    return client\n\ndef test_index(client):\n    rv = client.get('\/')\n    assert b\"Hello World!\" in rv.data\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.wrappers\n    ~~~~~~~~~~~~~~\n\n    Implements the WSGI wrappers (request and response).\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.wrappers import Request as RequestBase, Response as ResponseBase\n\nfrom flask import json\nfrom flask.globals import current_app\n\n\nclass JSONMixin(object):\n    \"\"\"Common mixin for both request and response objects to provide JSON\n    parsing capabilities.\n\n    .. versionadded:: 1.0\n    \"\"\"\n\n    _cached_json = Ellipsis\n\n    @property\n    def is_json(self):\n        \"\"\"Check if the mimetype indicates JSON data, either\n        :mimetype:`application\/json` or :mimetype:`application\/*+json`.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        mt = self.mimetype\n        return (\n            mt == 'application\/json'\n            or (mt.startswith('application\/')) and mt.endswith('+json')\n        )\n\n    @property\n    def json(self):\n        \"\"\"This will contain the parsed JSON data if the mimetype indicates\n        JSON (:mimetype:`application\/json`, see :meth:`is_json`), otherwise it\n        will be ``None``.\n        \"\"\"\n        return self.get_json()\n\n    def _get_data_for_json(self, cache):\n        return self.get_data(cache=cache)\n\n    def get_json(self, force=False, silent=False, cache=True):\n        \"\"\"Parse and return the data as JSON. If the mimetype does not indicate\n        JSON (:mimetype:`application\/json`, see :meth:`is_json`), this returns\n        ``None`` unless ``force`` is true. If parsing fails,\n        :meth:`on_json_loading_failed` is called and its return value is used\n        as the return value.\n\n        :param force: Ignore the mimetype and always try to parse JSON.\n        :param silent: Silence parsing errors and return ``None`` instead.\n        :param cache: Store the parsed JSON to return for subsequent calls.\n        \"\"\"\n        if cache and self._cached_json is not Ellipsis:\n            return self._cached_json\n\n        if not (force or self.is_json):\n            return None\n\n        # We accept MIME charset against the specification as certain clients\n        # have used this in the past. For responses, we assume that if the\n        # charset is set then the data has been encoded correctly as well.\n        charset = self.mimetype_params.get('charset')\n\n        try:\n            data = self._get_data_for_json(cache=cache)\n            rv = json.loads(data, encoding=charset)\n        except ValueError as e:\n            if silent:\n                rv = None\n            else:\n                rv = self.on_json_loading_failed(e)\n\n        if cache:\n            self._cached_json = rv\n\n        return rv\n\n    def on_json_loading_failed(self, e):\n        \"\"\"Called if :meth:`get_json` parsing fails and isn't silenced. If\n        this method returns a value, it is used as the return value for\n        :meth:`get_json`. The default implementation raises a\n        :class:`BadRequest` exception.\n\n        .. versionchanged:: 0.10\n           Raise a :exc:`BadRequest` error instead of returning an error\n           message as JSON. If you want that behavior you can add it by\n           subclassing.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if current_app is not None and current_app.debug:\n            raise BadRequest('Failed to decode JSON object: {0}'.format(e))\n\n        raise BadRequest()\n\n\nclass Request(RequestBase, JSONMixin):\n    \"\"\"The request object used by default in Flask.  Remembers the\n    matched endpoint and view arguments.\n\n    It is what ends up as :class:`~flask.request`.  If you want to replace\n    the request object used you can subclass this and set\n    :attr:`~flask.Flask.request_class` to your subclass.\n\n    The request object is a :class:`~werkzeug.wrappers.Request` subclass and\n    provides all of the attributes Werkzeug defines plus a few Flask\n    specific ones.\n    \"\"\"\n\n    #: The internal URL rule that matched the request.  This can be\n    #: useful to inspect which methods are allowed for the URL from\n    #: a before\/after handler (``request.url_rule.methods``) etc.\n    #: Though if the request's method was invalid for the URL rule,\n    #: the valid list is available in ``routing_exception.valid_methods``\n    #: instead (an attribute of the Werkzeug exception :exc:`~werkzeug.exceptions.MethodNotAllowed`)\n    #: because the request was never internally bound.\n    #:\n    #: .. versionadded:: 0.6\n    url_rule = None\n\n    #: A dict of view arguments that matched the request.  If an exception\n    #: happened when matching, this will be ``None``.\n    view_args = None\n\n    #: If matching the URL failed, this is the exception that will be\n    #: raised \/ was raised as part of the request handling.  This is\n    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n    #: something similar.\n    routing_exception = None\n\n    @property\n    def max_content_length(self):\n        \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"\n        if current_app:\n            return current_app.config['MAX_CONTENT_LENGTH']\n\n    @property\n    def endpoint(self):\n        \"\"\"The endpoint that matched the request.  This in combination with\n        :attr:`view_args` can be used to reconstruct the same or a\n        modified URL.  If an exception happened when matching, this will\n        be ``None``.\n        \"\"\"\n        if self.url_rule is not None:\n            return self.url_rule.endpoint\n\n    @property\n    def blueprint(self):\n        \"\"\"The name of the current blueprint\"\"\"\n        if self.url_rule and '.' in self.url_rule.endpoint:\n            return self.url_rule.endpoint.rsplit('.', 1)[0]\n\n    def _load_form_data(self):\n        RequestBase._load_form_data(self)\n\n        # In debug mode we're replacing the files multidict with an ad-hoc\n        # subclass that raises a different error for key errors.\n        if (\n            current_app\n            and current_app.debug\n            and self.mimetype != 'multipart\/form-data'\n            and not self.files\n        ):\n            from .debughelpers import attach_enctype_error_multidict\n            attach_enctype_error_multidict(self)\n\n\nclass Response(ResponseBase, JSONMixin):\n    \"\"\"The response object that is used by default in Flask.  Works like the\n    response object from Werkzeug but is set to have an HTML mimetype by\n    default.  Quite often you don't have to create this object yourself because\n    :meth:`~flask.Flask.make_response` will take care of that for you.\n\n    If you want to replace the response object used you can subclass this and\n    set :attr:`~flask.Flask.response_class` to your subclass.\n\n    .. versionchanged:: 1.0\n        JSON support is added to the response, like the request. This is useful\n        when testing to get the test client response data as JSON.\n    \"\"\"\n\n    default_mimetype = 'text\/html'\n\n    def _get_data_for_json(self, cache):\n        return self.get_data()\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\nLarger App Tests\n~~~~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom yourapplication import app\nimport pytest\n\n@pytest.fixture\ndef client():\n    app.config['TESTING'] = True\n    client = app.test_client()\n    return client\n\ndef test_index(client):\n    rv = client.get('\/')\n    assert b\"Hello World!\" in rv.data\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.conftest\n    ~~~~~~~~~~~~~~\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport gc\nimport os\nimport pkgutil\nimport sys\nimport textwrap\n\nimport pytest\nfrom _pytest import monkeypatch\n\nimport flask\nfrom flask import Flask as _Flask\n\n\n@pytest.fixture(scope='session', autouse=True)\ndef _standard_os_environ():\n    \"\"\"Set up ``os.environ`` at the start of the test session to have\n    standard values. Returns a list of operations that is used by\n    :func:`._reset_os_environ` after each test.\n    \"\"\"\n    mp = monkeypatch.MonkeyPatch()\n    out = (\n        (os.environ, 'FLASK_APP', monkeypatch.notset),\n        (os.environ, 'FLASK_ENV', monkeypatch.notset),\n        (os.environ, 'FLASK_DEBUG', monkeypatch.notset),\n        (os.environ, 'FLASK_RUN_FROM_CLI', monkeypatch.notset),\n        (os.environ, 'WERKZEUG_RUN_MAIN', monkeypatch.notset),\n    )\n\n    for _, key, value in out:\n        if value is monkeypatch.notset:\n            mp.delenv(key, False)\n        else:\n            mp.setenv(key, value)\n\n    yield out\n    mp.undo()\n\n\n@pytest.fixture(autouse=True)\ndef _reset_os_environ(monkeypatch, _standard_os_environ):\n    \"\"\"Reset ``os.environ`` to the standard environ after each test,\n    in case a test changed something without cleaning up.\n    \"\"\"\n    monkeypatch._setitem.extend(_standard_os_environ)\n\n\nclass Flask(_Flask):\n    testing = True\n    secret_key = 'test key'\n\n\n@pytest.fixture\ndef app():\n    app = Flask(__name__)\n    return app\n\n\n@pytest.fixture\ndef app_ctx(app):\n    with app.app_context() as ctx:\n        yield ctx\n\n\n@pytest.fixture\ndef req_ctx(app):\n    with app.test_request_context() as ctx:\n        yield ctx\n\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n\n\n@pytest.fixture\ndef test_apps(monkeypatch):\n    monkeypatch.syspath_prepend(\n        os.path.abspath(os.path.join(\n            os.path.dirname(__file__), 'test_apps'))\n    )\n\n\n@pytest.fixture(autouse=True)\ndef leak_detector():\n    yield\n\n    # make sure we're not leaking a request context since we are\n    # testing flask internally in debug mode in a few cases\n    leaks = []\n    while flask._request_ctx_stack.top is not None:\n        leaks.append(flask._request_ctx_stack.pop())\n    assert leaks == []\n\n\n@pytest.fixture(params=(True, False))\ndef limit_loader(request, monkeypatch):\n    \"\"\"Patch pkgutil.get_loader to give loader without get_filename or archive.\n\n    This provides for tests where a system has custom loaders, e.g. Google App\n    Engine's HardenedModulesHook, which have neither the `get_filename` method\n    nor the `archive` attribute.\n\n    This fixture will run the testcase twice, once with and once without the\n    limitation\/mock.\n    \"\"\"\n    if not request.param:\n        return\n\n    class LimitedLoader(object):\n        def __init__(self, loader):\n            self.loader = loader\n\n        def __getattr__(self, name):\n            if name in ('archive', 'get_filename'):\n                msg = 'Mocking a loader which does not have `%s.`' % name\n                raise AttributeError(msg)\n            return getattr(self.loader, name)\n\n    old_get_loader = pkgutil.get_loader\n\n    def get_loader(*args, **kwargs):\n        return LimitedLoader(old_get_loader(*args, **kwargs))\n\n    monkeypatch.setattr(pkgutil, 'get_loader', get_loader)\n\n\n@pytest.fixture\ndef modules_tmpdir(tmpdir, monkeypatch):\n    \"\"\"A tmpdir added to sys.path.\"\"\"\n    rv = tmpdir.mkdir('modules_tmpdir')\n    monkeypatch.syspath_prepend(str(rv))\n    return rv\n\n\n@pytest.fixture\ndef modules_tmpdir_prefix(modules_tmpdir, monkeypatch):\n    monkeypatch.setattr(sys, 'prefix', str(modules_tmpdir))\n    return modules_tmpdir\n\n\n@pytest.fixture\ndef site_packages(modules_tmpdir, monkeypatch):\n    \"\"\"Create a fake site-packages.\"\"\"\n    rv = modules_tmpdir \\\n        .mkdir('lib') \\\n        .mkdir('python{x[0]}.{x[1]}'.format(x=sys.version_info)) \\\n        .mkdir('site-packages')\n    monkeypatch.syspath_prepend(str(rv))\n    return rv\n\n\n@pytest.fixture\ndef install_egg(modules_tmpdir, monkeypatch):\n    \"\"\"Generate egg from package name inside base and put the egg into\n    sys.path.\"\"\"\n\n    def inner(name, base=modules_tmpdir):\n        if not isinstance(name, str):\n            raise ValueError(name)\n        base.join(name).ensure_dir()\n        base.join(name).join('__init__.py').ensure()\n\n        egg_setup = base.join('setup.py')\n        egg_setup.write(textwrap.dedent(\"\"\"\n        from setuptools import setup\n        setup(name='{0}',\n              version='1.0',\n              packages=['site_egg'],\n              zip_safe=True)\n        \"\"\".format(name)))\n\n        import subprocess\n        subprocess.check_call(\n            [sys.executable, 'setup.py', 'bdist_egg'],\n            cwd=str(modules_tmpdir)\n        )\n        egg_path, = modules_tmpdir.join('dist\/').listdir()\n        monkeypatch.syspath_prepend(str(egg_path))\n        return egg_path\n\n    return inner\n\n\n@pytest.fixture\ndef purge_module(request):\n    def inner(name):\n        request.addfinalizer(lambda: sys.modules.pop(name, None))\n\n    return inner\n\n\n@pytest.fixture(autouse=True)\ndef catch_deprecation_warnings(recwarn):\n    yield\n    gc.collect()\n    assert not recwarn.list, '\\n'.join(str(w.message) for w in recwarn.list)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.appctx\n    ~~~~~~~~~~~~\n\n    Tests the application context.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\n\n\ndef test_basic_url_generation(app):\n    app.config['SERVER_NAME'] = 'localhost'\n    app.config['PREFERRED_URL_SCHEME'] = 'https'\n\n    @app.route('\/')\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for('index')\n        assert rv == 'https:\/\/localhost\/'\n\n\ndef test_url_generation_requires_server_name(app):\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for('index')\n\n\ndef test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        flask.url_for('index')\n\n\ndef test_request_context_means_app_context(app):\n    with app.test_request_context():\n        assert flask.current_app._get_current_object() == app\n    assert flask._app_ctx_stack.top is None\n\n\ndef test_app_context_provides_current_app(app):\n    with app.app_context():\n        assert flask.current_app._get_current_object() == app\n    assert flask._app_ctx_stack.top is None\n\n\ndef test_app_tearing_down(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_previous_exception(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception('dummy')\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception('dummy')\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_app_handler(app, client):\n    app.config['PROPAGATE_EXCEPTIONS'] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route('\/')\n    def index():\n        raise Exception('dummy')\n\n    @app.errorhandler(Exception)\n    def handler(f):\n        return flask.jsonify(str(f))\n\n    with app.app_context():\n        client.get('\/')\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_unhandled_exception(app, client):\n    app.config['PROPAGATE_EXCEPTIONS'] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route('\/')\n    def index():\n        raise Exception('dummy')\n\n    with pytest.raises(Exception):\n        with app.app_context():\n            client.get('\/')\n\n    assert len(cleanup_stuff) == 1\n    assert isinstance(cleanup_stuff[0], Exception)\n    assert str(cleanup_stuff[0]) == 'dummy'\n\n\ndef test_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get('foo') is None\n    assert flask.g.get('foo', 'bar') == 'bar'\n    # __contains__\n    assert 'foo' not in flask.g\n    flask.g.foo = 'bar'\n    assert 'foo' in flask.g\n    # setdefault\n    flask.g.setdefault('bar', 'the cake is a lie')\n    flask.g.setdefault('bar', 'hello world')\n    assert flask.g.bar == 'the cake is a lie'\n    # pop\n    assert flask.g.pop('bar') == 'the cake is a lie'\n    with pytest.raises(KeyError):\n        flask.g.pop('bar')\n    assert flask.g.pop('bar', 'more cake') == 'more cake'\n    # __iter__\n    assert list(flask.g) == ['foo']\n\n\ndef test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals(object):\n        def __init__(self):\n            self.spam = 'eggs'\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string('{{ g.spam }}') == 'eggs'\n\n\ndef test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append('request')\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append('app')\n\n    @app.route('\/')\n    def index():\n        with flask._app_ctx_stack.top:\n            with flask._request_ctx_stack.top:\n                pass\n        env = flask._request_ctx_stack.top.request.environ\n        assert env['werkzeug.request'] is not None\n        return u''\n\n    res = client.get('\/')\n    assert res.status_code == 200\n    assert res.data == b''\n    assert called == ['request', 'app']\n\n\ndef test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        1 \/ 0\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append('TEARDOWN')\n\n    try:\n        with app.test_request_context():\n            called.append(flask.current_app.name)\n    except ZeroDivisionError:\n        pass\n\n    assert called == ['conftest', 'TEARDOWN']\n    assert not flask.current_app\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.basic\n    ~~~~~~~~~~~~~~~~~~~~~\n\n    The basic functionality.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport re\nimport time\nimport uuid\nfrom datetime import datetime\nfrom threading import Thread\n\nimport pytest\nimport werkzeug.serving\nfrom werkzeug.exceptions import BadRequest, Forbidden, NotFound\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\n\nimport flask\nfrom flask._compat import text_type\n\n\ndef test_options_work(app, client):\n    @app.route('\/', methods=['GET', 'POST'])\n    def index():\n        return 'Hello World'\n\n    rv = client.open('\/', method='OPTIONS')\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']\n    assert rv.data == b''\n\n\ndef test_options_on_multiple_rules(app, client):\n    @app.route('\/', methods=['GET', 'POST'])\n    def index():\n        return 'Hello World'\n\n    @app.route('\/', methods=['PUT'])\n    def index_put():\n        return 'Aha!'\n\n    rv = client.open('\/', method='OPTIONS')\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n\ndef test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return 'Hello World!'\n\n    index.provide_automatic_options = False\n    app.route('\/')(index)\n    rv = app.test_client().open('\/', method='OPTIONS')\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return 'Hello World!'\n\n    index2.provide_automatic_options = True\n    app.route('\/', methods=['OPTIONS'])(index2)\n    rv = app.test_client().open('\/', method='OPTIONS')\n    assert sorted(rv.allow) == ['OPTIONS']\n\n\ndef test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule('\/', view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        '\/more', view_func=more, methods=['GET', 'POST'],\n        provide_automatic_options=False\n    )\n    assert client.get('\/').data == b'GET'\n\n    rv = client.post('\/')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD']\n\n    # Older versions of Werkzeug.test.Client don't have an options method\n    if hasattr(client, 'options'):\n        rv = client.options('\/')\n    else:\n        rv = client.open('\/', method='OPTIONS')\n\n    assert rv.status_code == 405\n\n    rv = client.head('\/')\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post('\/more').data == b'POST'\n    assert client.get('\/more').data == b'GET'\n\n    rv = client.delete('\/more')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']\n\n    if hasattr(client, 'options'):\n        rv = client.options('\/more')\n    else:\n        rv = client.open('\/more', method='OPTIONS')\n\n    assert rv.status_code == 405\n\n\ndef test_request_dispatching(app, client):\n    @app.route('\/')\n    def index():\n        return flask.request.method\n\n    @app.route('\/more', methods=['GET', 'POST'])\n    def more():\n        return flask.request.method\n\n    assert client.get('\/').data == b'GET'\n    rv = client.post('\/')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']\n    rv = client.head('\/')\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post('\/more').data == b'POST'\n    assert client.get('\/more').data == b'GET'\n    rv = client.delete('\/more')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']\n\n\ndef test_disallow_string_for_allowed_methods(app):\n    with pytest.raises(TypeError):\n        @app.route('\/', methods='GET POST')\n        def index():\n            return \"Hey\"\n\n\ndef test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule('\/', 'index', index)\n    app.add_url_rule('\/more', 'more', more, methods=['GET', 'POST'])\n\n    # Issue 1288: Test that automatic options are not added when non-uppercase 'options' in methods\n    app.add_url_rule('\/options', 'options', options, methods=['options'])\n\n    assert client.get('\/').data == b'GET'\n    rv = client.post('\/')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']\n    rv = client.head('\/')\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post('\/more').data == b'POST'\n    assert client.get('\/more').data == b'GET'\n    rv = client.delete('\/more')\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']\n    rv = client.open('\/options', method='OPTIONS')\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")\n\n\ndef test_werkzeug_routing(app, client):\n    from werkzeug.routing import Submount, Rule\n    app.url_map.add(Submount('\/foo', [\n        Rule('\/bar', endpoint='bar'),\n        Rule('\/', endpoint='index')\n    ]))\n\n    def bar():\n        return 'bar'\n\n    def index():\n        return 'index'\n\n    app.view_functions['bar'] = bar\n    app.view_functions['index'] = index\n\n    assert client.get('\/foo\/').data == b'index'\n    assert client.get('\/foo\/bar').data == b'bar'\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Submount, Rule\n    app.url_map.add(Submount('\/foo', [\n        Rule('\/bar', endpoint='bar'),\n        Rule('\/', endpoint='index')\n    ]))\n\n    @app.endpoint('bar')\n    def bar():\n        return 'bar'\n\n    @app.endpoint('index')\n    def index():\n        return 'index'\n\n    assert client.get('\/foo\/').data == b'index'\n    assert client.get('\/foo\/bar').data == b'bar'\n\n\ndef test_session(app, client):\n    @app.route('\/set', methods=['POST'])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session['value'] = flask.request.form['value']\n        assert flask.session.accessed\n        assert flask.session.modified\n        return 'value set'\n\n    @app.route('\/get')\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get('value', 'None')\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post('\/set', data={'value': '42'}).data == b'value set'\n    assert client.get('\/get').data == b'42'\n\n\ndef test_session_using_server_name(app, client):\n    app.config.update(\n        SERVER_NAME='example.com'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n\n    rv = client.get('\/', 'http:\/\/example.com\/')\n    assert 'domain=.example.com' in rv.headers['set-cookie'].lower()\n    assert 'httponly' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_server_name_and_port(app, client):\n    app.config.update(\n        SERVER_NAME='example.com:8080'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n\n    rv = client.get('\/', 'http:\/\/example.com:8080\/')\n    assert 'domain=.example.com' in rv.headers['set-cookie'].lower()\n    assert 'httponly' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_server_name_port_and_path(app, client):\n    app.config.update(\n        SERVER_NAME='example.com:8080',\n        APPLICATION_ROOT='\/foo'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n\n    rv = client.get('\/', 'http:\/\/example.com:8080\/foo')\n    assert 'domain=example.com' in rv.headers['set-cookie'].lower()\n    assert 'path=\/foo' in rv.headers['set-cookie'].lower()\n    assert 'httponly' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_application_root(app, client):\n    class PrefixPathMiddleware(object):\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ['SCRIPT_NAME'] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, '\/bar')\n    app.config.update(\n        APPLICATION_ROOT='\/bar'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n\n    rv = client.get('\/', 'http:\/\/example.com:8080\/')\n    assert 'path=\/bar' in rv.headers['set-cookie'].lower()\n\n\ndef test_session_using_session_settings(app, client):\n    app.config.update(\n        SERVER_NAME='www.example.com:8080',\n        APPLICATION_ROOT='\/test',\n        SESSION_COOKIE_DOMAIN='.example.com',\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_SAMESITE='Lax',\n        SESSION_COOKIE_PATH='\/'\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n\n    rv = client.get('\/', 'http:\/\/www.example.com:8080\/test\/')\n    cookie = rv.headers['set-cookie'].lower()\n    assert 'domain=.example.com' in cookie\n    assert 'path=\/' in cookie\n    assert 'secure' in cookie\n    assert 'httponly' not in cookie\n    assert 'samesite' in cookie\n\n\ndef test_session_using_samesite_attribute(app, client):\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'Hello World'\n\n    app.config.update(SESSION_COOKIE_SAMESITE='invalid')\n\n    with pytest.raises(ValueError):\n        client.get('\/')\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get('\/')\n    cookie = rv.headers['set-cookie'].lower()\n    assert 'samesite' not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE='Strict')\n    rv = client.get('\/')\n    cookie = rv.headers['set-cookie'].lower()\n    assert 'samesite=strict' in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE='Lax')\n    rv = client.get('\/')\n    cookie = rv.headers['set-cookie'].lower()\n    assert 'samesite=lax' in cookie\n\n\ndef test_session_localhost_warning(recwarn, app, client):\n    app.config.update(\n        SERVER_NAME='localhost:5000',\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'testing'\n\n    rv = client.get('\/', 'http:\/\/localhost:5000\/')\n    assert 'domain' not in rv.headers['set-cookie'].lower()\n    w = recwarn.pop(UserWarning)\n    assert '\"localhost\" is not a valid cookie domain' in str(w.message)\n\n\ndef test_session_ip_warning(recwarn, app, client):\n    app.config.update(\n        SERVER_NAME='127.0.0.1:5000',\n    )\n\n    @app.route('\/')\n    def index():\n        flask.session['testing'] = 42\n        return 'testing'\n\n    rv = client.get('\/', 'http:\/\/127.0.0.1:5000\/')\n    assert 'domain=127.0.0.1' in rv.headers['set-cookie'].lower()\n    w = recwarn.pop(UserWarning)\n    assert 'cookie domain is an IP' in str(w.message)\n\n\ndef test_missing_session(app):\n    app.secret_key = None\n\n    def expect_exception(f, *args, **kwargs):\n        e = pytest.raises(RuntimeError, f, *args, **kwargs)\n        assert e.value.args and 'session is unavailable' in e.value.args[0]\n\n    with app.test_request_context():\n        assert flask.session.get('missing_key') is None\n        expect_exception(flask.session.__setitem__, 'foo', 42)\n        expect_exception(flask.session.pop, 'foo')\n\n\ndef test_session_expiration(app, client):\n    permanent = True\n\n    @app.route('\/')\n    def index():\n        flask.session['test'] = 42\n        flask.session.permanent = permanent\n        return ''\n\n    @app.route('\/test')\n    def test():\n        return text_type(flask.session.permanent)\n\n    rv = client.get('\/')\n    assert 'set-cookie' in rv.headers\n    match = re.search(r'(?i)\\bexpires=([^;]+)', rv.headers['set-cookie'])\n    expires = parse_date(match.group())\n    expected = datetime.utcnow() + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get('\/test')\n    assert rv.data == b'True'\n\n    permanent = False\n    rv = client.get('\/')\n    assert 'set-cookie' in rv.headers\n    match = re.search(r'\\bexpires=([^;]+)', rv.headers['set-cookie'])\n    assert match is None\n\n\ndef test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session['foo'] = 42\n        return response\n\n    @app.route('\/')\n    def dump_session_contents():\n        return repr(flask.session.get('foo'))\n\n    assert client.get('\/').data == b'None'\n    assert client.get('\/').data == b'42'\n\n\ndef test_session_special_types(app, client):\n    now = datetime.utcnow().replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.route('\/')\n    def dump_session_contents():\n        flask.session['t'] = (1, 2, 3)\n        flask.session['b'] = b'\\xff'\n        flask.session['m'] = flask.Markup('<html>')\n        flask.session['u'] = the_uuid\n        flask.session['d'] = now\n        flask.session['t_tag'] = {' t': 'not-a-tuple'}\n        flask.session['di_t_tag'] = {' t__': 'not-a-tuple'}\n        flask.session['di_tag'] = {' di': 'not-a-dict'}\n        return '', 204\n\n    with client:\n        client.get('\/')\n        s = flask.session\n        assert s['t'] == (1, 2, 3)\n        assert type(s['b']) == bytes\n        assert s['b'] == b'\\xff'\n        assert type(s['m']) == flask.Markup\n        assert s['m'] == flask.Markup('<html>')\n        assert s['u'] == the_uuid\n        assert s['d'] == now\n        assert s['t_tag'] == {' t': 'not-a-tuple'}\n        assert s['di_t_tag'] == {' t__': 'not-a-tuple'}\n        assert s['di_tag'] == {' di': 'not-a-dict'}\n\n\ndef test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route('\/bump')\n    def bump():\n        rv = flask.session['foo'] = flask.session.get('foo', 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route('\/read')\n    def read():\n        return str(flask.session.get('foo', 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get('\/bump').data == b'1'\n            assert c.get('\/bump').data == b'2'\n            assert c.get('\/bump').data == b'3'\n\n            rv = c.get('\/read')\n            set_cookie = rv.headers.get('set-cookie')\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b'3'\n\n    is_permanent = True\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config['SESSION_REFRESH_EACH_REQUEST'] = False\n    run_test(expect_header=False)\n\n\ndef test_session_vary_cookie(app, client):\n    @app.route('\/set')\n    def set_session():\n        flask.session['test'] = 'test'\n        return ''\n\n    @app.route('\/get')\n    def get():\n        return flask.session.get('test')\n\n    @app.route('\/getitem')\n    def getitem():\n        return flask.session['test']\n\n    @app.route('\/setdefault')\n    def setdefault():\n        return flask.session.setdefault('test', 'default')\n\n    @app.route('\/vary-cookie-header-set')\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add('Cookie')\n        flask.session['test'] = 'test'\n        return response\n\n    @app.route('\/vary-header-set')\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update(('Accept-Encoding', 'Accept-Language'))\n        flask.session['test'] = 'test'\n        return response\n\n    @app.route('\/no-vary-header')\n    def no_vary_header():\n        return ''\n\n    def expect(path, header_value='Cookie'):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all('Vary')) == 1\n            assert rv.headers['Vary'] == header_value\n        else:\n            assert 'Vary' not in rv.headers\n\n    expect('\/set')\n    expect('\/get')\n    expect('\/getitem')\n    expect('\/setdefault')\n    expect('\/vary-cookie-header-set')\n    expect('\/vary-header-set', 'Accept-Encoding, Accept-Language, Cookie')\n    expect('\/no-vary-header', None)\n\n\ndef test_flashes(app, req_ctx):\n    assert not flask.session.modified\n    flask.flash('Zap')\n    flask.session.modified = False\n    flask.flash('Zip')\n    assert flask.session.modified\n    assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']\n\n\ndef test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route('\/')\n    def index():\n        flask.flash(u'Hello World')\n        flask.flash(u'Hello World', 'error')\n        flask.flash(flask.Markup(u'<em>Testing<\/em>'), 'warning')\n        return ''\n\n    @app.route('\/test\/')\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            u'Hello World',\n            u'Hello World',\n            flask.Markup(u'<em>Testing<\/em>')\n        ]\n        return ''\n\n    @app.route('\/test_with_categories\/')\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            ('message', u'Hello World'),\n            ('error', u'Hello World'),\n            ('warning', flask.Markup(u'<em>Testing<\/em>'))\n        ]\n        return ''\n\n    @app.route('\/test_filter\/')\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=['message'], with_categories=True)\n        assert list(messages) == [('message', u'Hello World')]\n        return ''\n\n    @app.route('\/test_filters\/')\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=['message', 'warning'], with_categories=True)\n        assert list(messages) == [\n            ('message', u'Hello World'),\n            ('warning', flask.Markup(u'<em>Testing<\/em>'))\n        ]\n        return ''\n\n    @app.route('\/test_filters_without_returning_categories\/')\n    def test_filters2():\n        messages = flask.get_flashed_messages(\n            category_filter=['message', 'warning'])\n        assert len(messages) == 2\n        assert messages[0] == u'Hello World'\n        assert messages[1] == flask.Markup(u'<em>Testing<\/em>')\n        return ''\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get('\/')\n    client.get('\/test_with_categories\/')\n\n    client = app.test_client()\n    client.get('\/')\n    client.get('\/test_filter\/')\n\n    client = app.test_client()\n    client.get('\/')\n    client.get('\/test_filters\/')\n\n    client = app.test_client()\n    client.get('\/')\n    client.get('\/test_filters_without_returning_categories\/')\n\n\ndef test_request_processing(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append('before')\n\n    @app.after_request\n    def after_request(response):\n        response.data += b'|after'\n        evts.append('after')\n        return response\n\n    @app.route('\/')\n    def index():\n        assert 'before' in evts\n        assert 'after' not in evts\n        return 'request'\n\n    assert 'after' not in evts\n    rv = client.get('\/').data\n    assert 'after' in evts\n    assert rv == b'request|after'\n\n\ndef test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route('\/')\n    def index():\n        evts.append('index')\n        return \"damnit\"\n\n    rv = client.get('\/').data.strip()\n    assert rv == b'hello'\n    assert evts == [1, 2]\n\n\ndef test_after_request_processing(app, client):\n    @app.route('\/')\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers['X-Foo'] = 'a header'\n            return response\n\n        return 'Test'\n\n    resp = client.get('\/')\n    assert resp.status_code == 200\n    assert resp.headers['X-Foo'] == 'a header'\n\n\ndef test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route('\/')\n    def root():\n        return \"Response\"\n\n    rv = client.get('\/')\n    assert rv.status_code == 200\n    assert b'Response' in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route('\/')\n    def root():\n        return \"Response\"\n\n    rv = client.get('\/')\n    assert rv.status_code == 200\n    assert b'Response' in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except:\n            pass\n\n    @app.route('\/')\n    def fails():\n        1 \/\/ 0\n\n    rv = client.get('\/')\n    assert rv.status_code == 500\n    assert b'Internal Server Error' in rv.data\n    assert len(called) == 2\n\n\ndef test_before_after_request_order(app, client):\n    called = []\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route('\/')\n    def index():\n        return '42'\n\n    rv = client.get('\/')\n    assert rv.data == b'42'\n    assert called == [1, 2, 3, 4, 5, 6]\n\n\ndef test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return 'not found', 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return 'internal server error', 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return 'forbidden', 403\n\n    @app.route('\/')\n    def index():\n        flask.abort(404)\n\n    @app.route('\/error')\n    def error():\n        1 \/\/ 0\n\n    @app.route('\/forbidden')\n    def error2():\n        flask.abort(403)\n\n    rv = client.get('\/')\n    assert rv.status_code == 404\n    assert rv.data == b'not found'\n    rv = client.get('\/error')\n    assert rv.status_code == 500\n    assert b'internal server error' == rv.data\n    rv = client.get('\/forbidden')\n    assert rv.status_code == 403\n    assert b'forbidden' == rv.data\n\n\ndef test_error_handler_unknown_code(app):\n    with pytest.raises(KeyError) as exc_info:\n        app.register_error_handler(999, lambda e: ('999', 999))\n\n    assert 'Use a subclass' in exc_info.value.args[0]\n\n\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return 'internal server error', 500\n\n    @app.route('\/')\n    def broken_func():\n        1 \/\/ 0\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = 'text\/x-special'\n        return resp\n\n    resp = client.get('\/')\n    assert resp.mimetype == 'text\/x-special'\n    assert resp.data == b'internal server error'\n\n\ndef test_baseexception_error_handling(app, client):\n    app.testing = False\n\n    @app.route('\/')\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get('\/')\n\n        ctx = flask._request_ctx_stack.top\n        assert ctx.preserved\n        assert type(ctx._preserved_exc) is KeyboardInterrupt\n\n\ndef test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = 'value'\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get('\/')\n    assert rv.status_code == 404\n    assert rv.data == b'value'\n\n\ndef test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return '42'\n\n    @app.route('\/')\n    def index():\n        raise MyException()\n\n    assert client.get('\/').data == b'42'\n\n\ndef test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return 'banana'\n\n    @app.errorhandler(403)\n    def handle_forbidden_subclass(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return 'apple'\n\n    @app.route('\/1')\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route('\/2')\n    def index2():\n        flask.abort(403)\n\n    @app.route('\/3')\n    def index3():\n        raise Forbidden()\n\n    assert client.get('\/1').data == b'banana'\n    assert client.get('\/2').data == b'apple'\n    assert client.get('\/3').data == b'apple'\n\n\ndef test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return 'E2'\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return 'Exception'\n\n    @app.route('\/E1')\n    def raise_e1():\n        raise E1\n\n    @app.route('\/E3')\n    def raise_e3():\n        raise E3\n\n    rv = client.get('\/E1')\n    assert rv.data == b'Exception'\n\n    rv = client.get('\/E3')\n    assert rv.data == b'E2'\n\n\ndef test_trapping_of_bad_request_key_errors(app, client):\n    @app.route('\/fail')\n    def fail():\n        flask.request.form['missing_key']\n\n    rv = client.get('\/fail')\n    assert rv.status_code == 400\n    assert b'missing_key' not in rv.data\n\n    app.config['TRAP_BAD_REQUEST_ERRORS'] = True\n\n    with pytest.raises(KeyError) as e:\n        client.get(\"\/fail\")\n\n    assert e.errisinstance(BadRequest)\n    assert 'missing_key' in e.value.description\n\n\ndef test_trapping_of_all_http_exceptions(app, client):\n    app.config['TRAP_HTTP_EXCEPTIONS'] = True\n\n    @app.route('\/fail')\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get('\/fail')\n\n\ndef test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if trigger == 'before':\n            1 \/\/ 0\n\n    @app.after_request\n    def after_request(response):\n        if trigger == 'after':\n            1 \/\/ 0\n        return response\n\n    @app.route('\/')\n    def index():\n        return 'Foo'\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return 'Hello Server Error', 500\n\n    for trigger in 'before', 'after':\n        rv = client.get('\/')\n        assert rv.status_code == 500\n        assert rv.data == b'Hello Server Error'\n\n\ndef test_enctype_debug_helper(app, client):\n    from flask.debughelpers import DebugFilesKeyError\n    app.debug = True\n\n    @app.route('\/fail', methods=['POST'])\n    def index():\n        return flask.request.files['foo'].filename\n\n    # with statement is important because we leave an exception on the\n    # stack otherwise and we want to ensure that this is not the case\n    # to not negatively affect other tests.\n    with client:\n        with pytest.raises(DebugFilesKeyError) as e:\n            client.post('\/fail', data={'foo': 'index.txt'})\n        assert 'no file contents were transmitted' in str(e.value)\n        assert 'This was submitted: \"index.txt\"' in str(e.value)\n\n\ndef test_response_types(app, client):\n    @app.route('\/text')\n    def from_text():\n        return u'H\u00e4llo W\u00f6rld'\n\n    @app.route('\/bytes')\n    def from_bytes():\n        return u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n\n    @app.route('\/full_tuple')\n    def from_full_tuple():\n        return 'Meh', 400, {\n            'X-Foo': 'Testing',\n            'Content-Type': 'text\/plain; charset=utf-8'\n        }\n\n    @app.route('\/text_headers')\n    def from_text_headers():\n        return 'Hello', {\n            'X-Foo': 'Test',\n            'Content-Type': 'text\/plain; charset=utf-8'\n        }\n\n    @app.route('\/text_status')\n    def from_text_status():\n        return 'Hi, status!', 400\n\n    @app.route('\/response_headers')\n    def from_response_headers():\n        return flask.Response('Hello world', 404, {'X-Foo': 'Baz'}), {\n            \"X-Foo\": \"Bar\",\n            \"X-Bar\": \"Foo\"\n        }\n\n    @app.route('\/response_status')\n    def from_response_status():\n        return app.response_class('Hello world', 400), 500\n\n    @app.route('\/wsgi')\n    def from_wsgi():\n        return NotFound()\n\n    assert client.get('\/text').data == u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n    assert client.get('\/bytes').data == u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n\n    rv = client.get('\/full_tuple')\n    assert rv.data == b'Meh'\n    assert rv.headers['X-Foo'] == 'Testing'\n    assert rv.status_code == 400\n    assert rv.mimetype == 'text\/plain'\n\n    rv = client.get('\/text_headers')\n    assert rv.data == b'Hello'\n    assert rv.headers['X-Foo'] == 'Test'\n    assert rv.status_code == 200\n    assert rv.mimetype == 'text\/plain'\n\n    rv = client.get('\/text_status')\n    assert rv.data == b'Hi, status!'\n    assert rv.status_code == 400\n    assert rv.mimetype == 'text\/html'\n\n    rv = client.get('\/response_headers')\n    assert rv.data == b'Hello world'\n    assert rv.headers.getlist('X-Foo') == ['Baz', 'Bar']\n    assert rv.headers['X-Bar'] == 'Foo'\n    assert rv.status_code == 404\n\n    rv = client.get('\/response_status')\n    assert rv.data == b'Hello world'\n    assert rv.status_code == 500\n\n    rv = client.get('\/wsgi')\n    assert b'Not Found' in rv.data\n    assert rv.status_code == 404\n\n\ndef test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route('\/none')\n    def from_none():\n        pass\n\n    @app.route('\/small_tuple')\n    def from_small_tuple():\n        return 'Hello',\n\n    @app.route('\/large_tuple')\n    def from_large_tuple():\n        return 'Hello', 234, {'X-Foo': 'Bar'}, '???'\n\n    @app.route('\/bad_type')\n    def from_bad_type():\n        return True\n\n    @app.route('\/bad_wsgi')\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get('\/none')\n        assert 'returned None' in str(e)\n\n    with pytest.raises(TypeError) as e:\n        c.get('\/small_tuple')\n        assert 'tuple must have the form' in str(e)\n\n    pytest.raises(TypeError, c.get, '\/large_tuple')\n\n    with pytest.raises(TypeError) as e:\n        c.get('\/bad_type')\n        assert 'it was a bool' in str(e)\n\n    pytest.raises(TypeError, c.get, '\/bad_wsgi')\n\n\ndef test_make_response(app, req_ctx):\n    rv = flask.make_response()\n    assert rv.status_code == 200\n    assert rv.data == b''\n    assert rv.mimetype == 'text\/html'\n\n    rv = flask.make_response('Awesome')\n    assert rv.status_code == 200\n    assert rv.data == b'Awesome'\n    assert rv.mimetype == 'text\/html'\n\n    rv = flask.make_response('W00t', 404)\n    assert rv.status_code == 404\n    assert rv.data == b'W00t'\n    assert rv.mimetype == 'text\/html'\n\n\ndef test_make_response_with_response_instance(app, req_ctx):\n    rv = flask.make_response(\n        flask.jsonify({'msg': 'W00t'}), 400)\n    assert rv.status_code == 400\n    assert rv.data == b'{\"msg\":\"W00t\"}\\n'\n    assert rv.mimetype == 'application\/json'\n\n    rv = flask.make_response(\n        flask.Response(''), 400)\n    assert rv.status_code == 400\n    assert rv.data == b''\n    assert rv.mimetype == 'text\/html'\n\n    rv = flask.make_response(\n        flask.Response('', headers={'Content-Type': 'text\/html'}),\n        400, [('X-Foo', 'bar')])\n    assert rv.status_code == 400\n    assert rv.headers['Content-Type'] == 'text\/html'\n    assert rv.headers['X-Foo'] == 'bar'\n\n\ndef test_jsonify_no_prettyprint(app, req_ctx):\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": False})\n    compressed_msg = b'{\"msg\":{\"submsg\":\"W00t\"},\"msg2\":\"foobar\"}\\n'\n    uncompressed_msg = {\n        \"msg\": {\n            \"submsg\": \"W00t\"\n        },\n        \"msg2\": \"foobar\"\n    }\n\n    rv = flask.make_response(\n        flask.jsonify(uncompressed_msg), 200)\n    assert rv.data == compressed_msg\n\n\ndef test_jsonify_prettyprint(app, req_ctx):\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": True})\n    compressed_msg = {\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"}\n    pretty_response = \\\n        b'{\\n  \"msg\": {\\n    \"submsg\": \"W00t\"\\n  }, \\n  \"msg2\": \"foobar\"\\n}\\n'\n\n    rv = flask.make_response(\n        flask.jsonify(compressed_msg), 200)\n    assert rv.data == pretty_response\n\n\ndef test_jsonify_mimetype(app, req_ctx):\n    app.config.update({\"JSONIFY_MIMETYPE\": 'application\/vnd.api+json'})\n    msg = {\n        \"msg\": {\"submsg\": \"W00t\"},\n    }\n    rv = flask.make_response(\n        flask.jsonify(msg), 200)\n    assert rv.mimetype == 'application\/vnd.api+json'\n\n\ndef test_jsonify_args_and_kwargs_check(app, req_ctx):\n    with pytest.raises(TypeError) as e:\n        flask.jsonify('fake args', kwargs='fake')\n    assert 'behavior undefined' in str(e.value)\n\n\ndef test_url_generation(app, req_ctx):\n    @app.route('\/hello\/<name>', methods=['POST'])\n    def hello():\n        pass\n\n    assert flask.url_for('hello', name='test x') == '\/hello\/test%20x'\n    assert flask.url_for('hello', name='test x', _external=True) == \\\n           'http:\/\/localhost\/hello\/test%20x'\n\n\ndef test_build_error_handler(app):\n    # Test base case, a URL which results in a BuildError.\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, 'spam')\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for('spam')\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError('Test case where BuildError is not current.')\n    except RuntimeError:\n        pytest.raises(\n            BuildError, app.handle_url_build_error, error, 'spam', {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return '\/test_handler\/'\n\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for('spam') == '\/test_handler\/'\n\n\ndef test_build_error_handler_reraise(app):\n    # Test a custom handler which reraises the BuildError\n    def handler_raises_build_error(error, endpoint, values):\n        raise error\n\n    app.url_build_error_handlers.append(handler_raises_build_error)\n\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, 'not.existing')\n\n\ndef test_url_for_passes_special_values_to_build_error_handler(app):\n    @app.url_build_error_handlers.append\n    def handler(error, endpoint, values):\n        assert values == {\n            '_external': False,\n            '_anchor': None,\n            '_method': None,\n            '_scheme': None,\n        }\n        return 'handled'\n\n    with app.test_request_context():\n        flask.url_for('\/')\n\n\ndef test_custom_converters(app, client):\n    from werkzeug.routing import BaseConverter\n\n    class ListConverter(BaseConverter):\n        def to_python(self, value):\n            return value.split(',')\n\n        def to_url(self, value):\n            base_to_url = super(ListConverter, self).to_url\n            return ','.join(base_to_url(x) for x in value)\n\n    app.url_map.converters['list'] = ListConverter\n\n    @app.route('\/<list:args>')\n    def index(args):\n        return '|'.join(args)\n\n    assert client.get('\/1,2,3').data == b'1|2|3'\n\n\ndef test_static_files(app, client):\n    rv = client.get('\/static\/index.html')\n    assert rv.status_code == 200\n    assert rv.data.strip() == b'<h1>Hello World!<\/h1>'\n    with app.test_request_context():\n        assert flask.url_for('static', filename='index.html') == \\\n               '\/static\/index.html'\n    rv.close()\n\n\ndef test_static_url_path():\n    app = flask.Flask(__name__, static_url_path='\/foo')\n    app.testing = True\n    rv = app.test_client().get('\/foo\/index.html')\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for('static', filename='index.html') == '\/foo\/index.html'\n\n\ndef test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host='example.com')\n    c = app.test_client()\n    rv = c.get('http:\/\/example.com\/static\/index.html')\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for('static', filename='index.html', _external=True)\n        assert rv == 'http:\/\/example.com\/static\/index.html'\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(Exception):\n        flask.Flask(__name__, static_host='example.com')\n    # Providing host_matching=True with static_folder but without static_host should error.\n    with pytest.raises(Exception):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)\n\n\ndef test_request_locals():\n    assert repr(flask.g) == '<LocalProxy unbound>'\n    assert not flask.g\n\n\ndef test_test_app_proper_environ(app, client):\n    app.config.update(\n        SERVER_NAME='localhost.localdomain:5000'\n    )\n\n    @app.route('\/')\n    def index():\n        return 'Foo'\n\n    @app.route('\/', subdomain='foo')\n    def subdomain():\n        return 'Foo SubDomain'\n\n    rv = client.get('\/')\n    assert rv.data == b'Foo'\n\n    rv = client.get('\/', 'http:\/\/localhost.localdomain:5000')\n    assert rv.data == b'Foo'\n\n    rv = client.get('\/', 'https:\/\/localhost.localdomain:5000')\n    assert rv.data == b'Foo'\n\n    app.config.update(SERVER_NAME='localhost.localdomain')\n    rv = client.get('\/', 'https:\/\/localhost.localdomain')\n    assert rv.data == b'Foo'\n\n    try:\n        app.config.update(SERVER_NAME='localhost.localdomain:443')\n        rv = client.get('\/', 'https:\/\/localhost.localdomain')\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain:443') does not match the \"\n            \"server name from the WSGI environment ('localhost.localdomain')\"\n        )\n\n    try:\n        app.config.update(SERVER_NAME='localhost.localdomain')\n        rv = client.get('\/', 'http:\/\/foo.localhost')\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain') does not match the \"\n            \"server name from the WSGI environment ('foo.localhost')\"\n        )\n\n    rv = client.get('\/', 'http:\/\/foo.localhost.localdomain')\n    assert rv.data == b'Foo SubDomain'\n\n\ndef test_exception_propagation(app, client):\n    def apprunner(config_key):\n\n        @app.route('\/')\n        def index():\n            1 \/\/ 0\n\n        if config_key is not None:\n            app.config[config_key] = True\n            with pytest.raises(Exception):\n                client.get('\/')\n        else:\n            assert client.get('\/').status_code == 500\n\n    # we have to run this test in an isolated thread because if the\n    # debug flag is set to true and an exception happens the context is\n    # not torn down.  This causes other tests that run after this fail\n    # when they expect no exception on the stack.\n    for config_key in 'TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', None:\n        t = Thread(target=apprunner, args=(config_key,))\n        t.start()\n        t.join()\n\n\n@pytest.mark.parametrize('debug', [True, False])\n@pytest.mark.parametrize('use_debugger', [True, False])\n@pytest.mark.parametrize('use_reloader', [True, False])\n@pytest.mark.parametrize('propagate_exceptions', [None, True, False])\ndef test_werkzeug_passthrough_errors(monkeypatch, debug, use_debugger,\n                                     use_reloader, propagate_exceptions, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv['passthrough_errors'] = kwargs.get('passthrough_errors')\n\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n    app.config['PROPAGATE_EXCEPTIONS'] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)\n\n\ndef test_max_content_length(app, client):\n    app.config['MAX_CONTENT_LENGTH'] = 64\n\n    @app.before_request\n    def always_first():\n        flask.request.form['myfile']\n        assert False\n\n    @app.route('\/accept', methods=['POST'])\n    def accept_file():\n        flask.request.form['myfile']\n        assert False\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return '42'\n\n    rv = client.post('\/accept', data={'myfile': 'foo' * 100})\n    assert rv.data == b'42'\n\n\ndef test_url_processors(app, client):\n\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and \\\n                app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n            values.setdefault('lang_code', flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop('lang_code', None)\n\n    @app.route('\/<lang_code>\/')\n    def index():\n        return flask.url_for('about')\n\n    @app.route('\/<lang_code>\/about')\n    def about():\n        return flask.url_for('something_else')\n\n    @app.route('\/foo')\n    def something_else():\n        return flask.url_for('about', lang_code='en')\n\n    assert client.get('\/de\/').data == b'\/de\/about'\n    assert client.get('\/de\/about').data == b'\/foo'\n    assert client.get('\/foo').data == b'\/en\/about'\n\n\ndef test_inject_blueprint_url_defaults(app):\n    bp = flask.Blueprint('foo.bar.baz', __name__,\n                         template_folder='template')\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values['page'] = 'login'\n\n    @bp.route('\/<page>')\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults('foo.bar.baz.view', values)\n    expected = dict(page='login')\n    assert values == expected\n\n    with app.test_request_context('\/somepage'):\n        url = flask.url_for('foo.bar.baz.view')\n    expected = '\/login'\n    assert url == expected\n\n\ndef test_nonascii_pathinfo(app, client):\n    @app.route(u'\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442')\n    def index():\n        return 'Hello World!'\n\n    rv = client.get(u'\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442')\n    assert rv.data == b'Hello World!'\n\n\ndef test_debug_mode_complains_after_first_request(app, client):\n    app.debug = True\n\n    @app.route('\/')\n    def index():\n        return 'Awesome'\n\n    assert not app.got_first_request\n    assert client.get('\/').data == b'Awesome'\n    with pytest.raises(AssertionError) as e:\n        @app.route('\/foo')\n        def broken():\n            return 'Meh'\n    assert 'A setup function was called' in str(e)\n\n    app.debug = False\n\n    @app.route('\/foo')\n    def working():\n        return 'Meh'\n\n    assert client.get('\/foo').data == b'Meh'\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions(app, client):\n    got = []\n\n    @app.before_first_request\n    def foo():\n        got.append(42)\n\n    client.get('\/')\n    assert got == [42]\n    client.get('\/')\n    assert got == [42]\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions_concurrent(app, client):\n    got = []\n\n    @app.before_first_request\n    def foo():\n        time.sleep(0.2)\n        got.append(42)\n\n    def get_and_assert():\n        client.get(\"\/\")\n        assert got == [42]\n\n    t = Thread(target=get_and_assert)\n    t.start()\n    get_and_assert()\n    t.join()\n    assert app.got_first_request\n\n\ndef test_routing_redirect_debugging(app, client):\n    app.debug = True\n\n    @app.route('\/foo\/', methods=['GET', 'POST'])\n    def foo():\n        return 'success'\n\n    with client:\n        with pytest.raises(AssertionError) as e:\n            client.post('\/foo', data={})\n        assert 'http:\/\/localhost\/foo\/' in str(e)\n        assert ('Make sure to directly send '\n                'your POST-request to this URL') in str(e)\n\n        rv = client.get('\/foo', data={}, follow_redirects=True)\n        assert rv.data == b'success'\n\n    app.debug = False\n    with client:\n        rv = client.post('\/foo', data={}, follow_redirects=True)\n        assert rv.data == b'success'\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route('\/foo\/')\n    def foo():\n        return flask.request.endpoint\n\n    @app.route('\/bar\/', endpoint='bar')\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route('\/bar\/123', endpoint='123')\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for('foo') == '\/foo\/'\n        assert flask.url_for('bar') == '\/bar\/'\n        assert flask.url_for('123') == '\/bar\/123'\n\n    assert client.get('\/foo\/').data == b'foo'\n    assert client.get('\/bar\/').data == b'bar'\n    assert client.get('\/bar\/123').data == b'123'\n\n\ndef test_preserve_only_once(app, client):\n    app.debug = True\n\n    @app.route('\/fail')\n    def fail_func():\n        1 \/\/ 0\n\n    for x in range(3):\n        with pytest.raises(ZeroDivisionError):\n            client.get('\/fail')\n\n    assert flask._request_ctx_stack.top is not None\n    assert flask._app_ctx_stack.top is not None\n    # implicit appctx disappears too\n    flask._request_ctx_stack.top.pop()\n    assert flask._request_ctx_stack.top is None\n    assert flask._app_ctx_stack.top is None\n\n\ndef test_preserve_remembers_exception(app, client):\n    app.debug = True\n    errors = []\n\n    @app.route('\/fail')\n    def fail_func():\n        1 \/\/ 0\n\n    @app.route('\/success')\n    def success_func():\n        return 'Okay'\n\n    @app.teardown_request\n    def teardown_handler(exc):\n        errors.append(exc)\n\n    # After this failure we did not yet call the teardown handler\n    with pytest.raises(ZeroDivisionError):\n        client.get('\/fail')\n    assert errors == []\n\n    # But this request triggers it, and it's an error\n    client.get('\/success')\n    assert len(errors) == 2\n    assert isinstance(errors[0], ZeroDivisionError)\n\n    # At this point another request does nothing.\n    client.get('\/success')\n    assert len(errors) == 3\n    assert errors[1] is None\n\n\ndef test_get_method_on_g(app_ctx):\n    assert flask.g.get('x') is None\n    assert flask.g.get('x', 11) == 11\n    flask.g.x = 42\n    assert flask.g.get('x') == 42\n    assert flask.g.x == 42\n\n\ndef test_g_iteration_protocol(app_ctx):\n    flask.g.foo = 23\n    flask.g.bar = 42\n    assert 'foo' in flask.g\n    assert 'foos' not in flask.g\n    assert sorted(flask.g) == ['bar', 'foo']\n\n\ndef test_subdomain_basic_support(app, client):\n    app.config['SERVER_NAME'] = 'localhost.localdomain'\n\n    @app.route('\/')\n    def normal_index():\n        return 'normal index'\n\n    @app.route('\/', subdomain='test')\n    def test_index():\n        return 'test index'\n\n    rv = client.get('\/', 'http:\/\/localhost.localdomain\/')\n    assert rv.data == b'normal index'\n\n    rv = client.get('\/', 'http:\/\/test.localhost.localdomain\/')\n    assert rv.data == b'test index'\n\n\ndef test_subdomain_matching(app, client):\n    app.config['SERVER_NAME'] = 'localhost.localdomain'\n\n    @app.route('\/', subdomain='<user>')\n    def index(user):\n        return 'index for %s' % user\n\n    rv = client.get('\/', 'http:\/\/mitsuhiko.localhost.localdomain\/')\n    assert rv.data == b'index for mitsuhiko'\n\n\ndef test_subdomain_matching_with_ports(app, client):\n    app.config['SERVER_NAME'] = 'localhost.localdomain:3000'\n\n    @app.route('\/', subdomain='<user>')\n    def index(user):\n        return 'index for %s' % user\n\n    rv = client.get('\/', 'http:\/\/mitsuhiko.localhost.localdomain:3000\/')\n    assert rv.data == b'index for mitsuhiko'\n\n\ndef test_multi_route_rules(app, client):\n    @app.route('\/')\n    @app.route('\/<test>\/')\n    def index(test='a'):\n        return test\n\n    rv = client.open('\/')\n    assert rv.data == b'a'\n    rv = client.open('\/b\/')\n    assert rv.data == b'b'\n\n\ndef test_multi_route_class_views(app, client):\n    class View(object):\n        def __init__(self, app):\n            app.add_url_rule('\/', 'index', self.index)\n            app.add_url_rule('\/<test>\/', 'index', self.index)\n\n        def index(self, test='a'):\n            return test\n\n    _ = View(app)\n    rv = client.open('\/')\n    assert rv.data == b'a'\n    rv = client.open('\/b\/')\n    assert rv.data == b'b'\n\n\ndef test_run_defaults(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv['result'] = 'running...'\n\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n    app.run()\n    assert rv['result'] == 'running...'\n\n\ndef test_run_server_port(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(hostname, port, application, *args, **kwargs):\n        rv['result'] = 'running on %s:%s ...' % (hostname, port)\n\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n    hostname, port = 'localhost', 8000\n    app.run(hostname, port, debug=True)\n    assert rv['result'] == 'running on %s:%s ...' % (hostname, port)\n\n\n@pytest.mark.parametrize('host,port,expect_host,expect_port', (\n        (None, None, 'pocoo.org', 8080),\n        ('localhost', None, 'localhost', 8080),\n        (None, 80, 'pocoo.org', 80),\n        ('localhost', 80, 'localhost', 80),\n))\ndef test_run_from_config(monkeypatch, host, port, expect_host, expect_port, app):\n    def run_simple_mock(hostname, port, *args, **kwargs):\n        assert hostname == expect_host\n        assert port == expect_port\n\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n    app.config['SERVER_NAME'] = 'pocoo.org:8080'\n    app.run(host, port)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.blueprints\n    ~~~~~~~~~~~~~~~~\n\n    Blueprints (and currently modules)\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\n\nfrom flask._compat import text_type\nfrom werkzeug.http import parse_cache_control_header\nfrom jinja2 import TemplateNotFound\n\n\ndef test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint('frontend', __name__)\n    backend = flask.Blueprint('backend', __name__)\n    sideend = flask.Blueprint('sideend', __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return 'frontend says no', 403\n\n    @frontend.route('\/frontend-no')\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return 'backend says no', 403\n\n    @backend.route('\/backend-no')\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route('\/what-is-a-sideend')\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return 'application itself says no', 403\n\n    assert client.get('\/frontend-no').data == b'frontend says no'\n    assert client.get('\/backend-no').data == b'backend says no'\n    assert client.get('\/what-is-a-sideend').data == b'application itself says no'\n\n\ndef test_blueprint_specific_user_error_handling(app, client):\n    class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint('blue', __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return 'boom'\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return 'bam'\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route('\/decorator')\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route('\/function')\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.register_blueprint(blue)\n\n    assert client.get('\/decorator').data == b'boom'\n    assert client.get('\/function').data == b'bam'\n\n\ndef test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint('errors', __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return 'you shall not pass', 403\n\n    @app.route('\/forbidden')\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint('forbidden_bp', __name__)\n\n    @forbidden_bp.route('\/nope')\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get('\/forbidden').data == b'you shall not pass'\n    assert client.get('\/nope').data == b'you shall not pass'\n\n\ndef test_blueprint_url_definitions(app, client):\n    bp = flask.Blueprint('test', __name__)\n\n    @bp.route('\/foo', defaults={'baz': 42})\n    def foo(bar, baz):\n        return '%s\/%d' % (bar, baz)\n\n    @bp.route('\/bar')\n    def bar(bar):\n        return text_type(bar)\n\n    app.register_blueprint(bp, url_prefix='\/1', url_defaults={'bar': 23})\n    app.register_blueprint(bp, url_prefix='\/2', url_defaults={'bar': 19})\n\n    assert client.get('\/1\/foo').data == b'23\/42'\n    assert client.get('\/2\/foo').data == b'19\/42'\n    assert client.get('\/1\/bar').data == b'23'\n    assert client.get('\/2\/bar').data == b'19'\n\n\ndef test_blueprint_url_processors(app, client):\n    bp = flask.Blueprint('frontend', __name__, url_prefix='\/<lang_code>')\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault('lang_code', flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop('lang_code')\n\n    @bp.route('\/')\n    def index():\n        return flask.url_for('.about')\n\n    @bp.route('\/about')\n    def about():\n        return flask.url_for('.index')\n\n    app.register_blueprint(bp)\n\n    assert client.get('\/de\/').data == b'\/de\/about'\n    assert client.get('\/de\/about').data == b'\/de\/'\n\n\ndef test_templates_and_static(test_apps):\n    from blueprintapp import app\n    client = app.test_client()\n\n    rv = client.get('\/')\n    assert rv.data == b'Hello from the Frontend'\n    rv = client.get('\/admin\/')\n    assert rv.data == b'Hello from the Admin'\n    rv = client.get('\/admin\/index2')\n    assert rv.data == b'Hello from the Admin'\n    rv = client.get('\/admin\/static\/test.txt')\n    assert rv.data.strip() == b'Admin File'\n    rv.close()\n    rv = client.get('\/admin\/static\/css\/test.css')\n    assert rv.data.strip() == b'\/* nested file *\/'\n    rv.close()\n\n    # try\/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n    try:\n        expected_max_age = 3600\n        if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == expected_max_age:\n            expected_max_age = 7200\n        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = expected_max_age\n        rv = client.get('\/admin\/static\/css\/test.css')\n        cc = parse_cache_control_header(rv.headers['Cache-Control'])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n    with app.test_request_context():\n        assert flask.url_for('admin.static', filename='test.txt') == '\/admin\/static\/test.txt'\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template('missing.html')\n        assert e.value.name == 'missing.html'\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template('nested\/nested.txt') == 'I\\'m nested'\n\n\ndef test_default_static_cache_timeout(app):\n    class MyBlueprint(flask.Blueprint):\n        def get_send_file_max_age(self, filename):\n            return 100\n\n    blueprint = MyBlueprint('blueprint', __name__, static_folder='static')\n    app.register_blueprint(blueprint)\n\n    # try\/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config['SEND_FILE_MAX_AGE_DEFAULT']\n    try:\n        with app.test_request_context():\n            unexpected_max_age = 3600\n            if app.config['SEND_FILE_MAX_AGE_DEFAULT'] == unexpected_max_age:\n                unexpected_max_age = 7200\n            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = unexpected_max_age\n            rv = blueprint.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default\n\n\ndef test_templates_list(test_apps):\n    from blueprintapp import app\n    templates = sorted(app.jinja_env.list_templates())\n    assert templates == ['admin\/index.html', 'frontend\/index.html']\n\n\ndef test_dotted_names(app, client):\n    frontend = flask.Blueprint('myapp.frontend', __name__)\n    backend = flask.Blueprint('myapp.backend', __name__)\n\n    @frontend.route('\/fe')\n    def frontend_index():\n        return flask.url_for('myapp.backend.backend_index')\n\n    @frontend.route('\/fe2')\n    def frontend_page2():\n        return flask.url_for('.frontend_index')\n\n    @backend.route('\/be')\n    def backend_index():\n        return flask.url_for('myapp.frontend.frontend_index')\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n\n    assert client.get('\/fe').data.strip() == b'\/be'\n    assert client.get('\/fe2').data.strip() == b'\/fe'\n    assert client.get('\/be').data.strip() == b'\/fe'\n\n\ndef test_dotted_names_from_app(app, client):\n    test = flask.Blueprint('test', __name__)\n\n    @app.route('\/')\n    def app_index():\n        return flask.url_for('test.index')\n\n    @test.route('\/test\/')\n    def index():\n        return flask.url_for('app_index')\n\n    app.register_blueprint(test)\n\n    rv = client.get('\/')\n    assert rv.data == b'\/test\/'\n\n\ndef test_empty_url_defaults(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.route('\/', defaults={'page': 1})\n    @bp.route('\/page\/<int:page>')\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get('\/').data == b'1'\n    assert client.get('\/page\/2').data == b'2'\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.route('\/foo')\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route('\/bar', endpoint='bar')\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route('\/bar\/123', endpoint='123')\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route('\/bar\/foo')\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    @app.route('\/')\n    def index():\n        return flask.request.endpoint\n\n    assert client.get('\/').data == b'index'\n    assert client.get('\/py\/foo').data == b'bp.foo'\n    assert client.get('\/py\/bar').data == b'bp.bar'\n    assert client.get('\/py\/bar\/123').data == b'bp.123'\n    assert client.get('\/py\/bar\/foo').data == b'bp.bar_foo'\n\n\ndef test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.route('\/foo')\n    def foo():\n        return flask.request.endpoint\n\n    try:\n        @bp.route('\/bar', endpoint='bar.bar')\n        def foo_bar():\n            return flask.request.endpoint\n    except AssertionError:\n        pass\n    else:\n        raise AssertionError('expected AssertionError not raised')\n\n    try:\n        @bp.route('\/bar\/123', endpoint='bar.123')\n        def foo_bar_foo():\n            return flask.request.endpoint\n    except AssertionError:\n        pass\n    else:\n        raise AssertionError('expected AssertionError not raised')\n\n    def foo_foo_foo():\n        pass\n\n    pytest.raises(\n        AssertionError,\n        lambda: bp.add_url_rule(\n            '\/bar\/123', endpoint='bar.123', view_func=foo_foo_foo\n        )\n    )\n\n    pytest.raises(\n        AssertionError,\n        bp.route('\/bar\/123', endpoint='bar.123'),\n        lambda: None\n    )\n\n    foo_foo_foo.__name__ = 'bar.123'\n\n    pytest.raises(\n        AssertionError,\n        lambda: bp.add_url_rule(\n            '\/bar\/123', view_func=foo_foo_foo\n        )\n    )\n\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    assert client.get('\/py\/foo').data == b'bp.foo'\n    # The rule's didn't actually made it through\n    rv = client.get('\/py\/bar')\n    assert rv.status_code == 404\n    rv = client.get('\/py\/bar\/123')\n    assert rv.status_code == 404\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n    app.url_map.add(Rule('\/foo', endpoint='bar'))\n\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.endpoint('bar')\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix='\/bp_prefix')\n\n    assert client.get('\/foo').data == b'bar'\n    assert client.get('\/bp_prefix\/bar').status_code == 404\n\n\ndef test_template_filter(app):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\n\ndef test_add_template_filter(app):\n    bp = flask.Blueprint('bp', __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\n\ndef test_template_filter_with_name(app):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.app_template_filter('strrev')\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\n\ndef test_add_template_filter_with_name(app):\n    bp = flask.Blueprint('bp', __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, 'strrev')\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\n\ndef test_template_filter_with_template(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_template_filter_after_route_with_template(app, client):\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix='\/py')\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_add_template_filter_with_template(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    def super_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(super_reverse)\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.app_template_filter('super_reverse')\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, 'super_reverse')\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_template_test(app):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.app_template_test()\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'is_boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['is_boolean'] == is_boolean\n    assert app.jinja_env.tests['is_boolean'](False)\n\n\ndef test_add_template_test(app):\n    bp = flask.Blueprint('bp', __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean)\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'is_boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['is_boolean'] == is_boolean\n    assert app.jinja_env.tests['is_boolean'](False)\n\n\ndef test_template_test_with_name(app):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.app_template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_add_template_test_with_name(app):\n    bp = flask.Blueprint('bp', __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, 'boolean')\n    app.register_blueprint(bp, url_prefix='\/py')\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_template_test_with_template(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_template_test_after_route_with_template(app, client):\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix='\/py')\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    def boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(boolean)\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.app_template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, 'boolean')\n    app.register_blueprint(bp, url_prefix='\/py')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_context_processing(app, client):\n    answer_bp = flask.Blueprint('answer_bp', __name__)\n\n    template_string = lambda: flask.render_template_string(\n        '{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}'\n        '{% if answer %}{{ answer }} is the answer.{% endif %}'\n    )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {'notanswer': 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {'answer': 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route('\/bp')\n    def bp_page():\n        return template_string()\n\n    @app.route('\/')\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get('\/').data\n    answer_page_bytes = client.get('\/bp').data\n\n    assert b'43' in app_page_bytes\n    assert b'42' not in app_page_bytes\n\n    assert b'42' in answer_page_bytes\n    assert b'43' in answer_page_bytes\n\n\ndef test_template_global(app):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.app_template_global()\n    def get_answer():\n        return 42\n\n    # Make sure the function is not in the jinja_env already\n    assert 'get_answer' not in app.jinja_env.globals.keys()\n    app.register_blueprint(bp)\n\n    # Tests\n    assert 'get_answer' in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals['get_answer'] is get_answer\n    assert app.jinja_env.globals['get_answer']() == 42\n\n    with app.app_context():\n        rv = flask.render_template_string('{{ get_answer() }}')\n        assert rv == '42'\n\n\ndef test_request_processing(app, client):\n    bp = flask.Blueprint('bp', __name__)\n    evts = []\n\n    @bp.before_request\n    def before_bp():\n        evts.append('before')\n\n    @bp.after_request\n    def after_bp(response):\n        response.data += b'|after'\n        evts.append('after')\n        return response\n\n    @bp.teardown_request\n    def teardown_bp(exc):\n        evts.append('teardown')\n\n    # Setup routes for testing\n    @bp.route('\/bp')\n    def bp_endpoint():\n        return 'request'\n\n    app.register_blueprint(bp)\n\n    assert evts == []\n    rv = client.get('\/bp')\n    assert rv.data == b'request|after'\n    assert evts == ['before', 'after', 'teardown']\n\n\ndef test_app_request_processing(app, client):\n    bp = flask.Blueprint('bp', __name__)\n    evts = []\n\n    @bp.before_app_first_request\n    def before_first_request():\n        evts.append('first')\n\n    @bp.before_app_request\n    def before_app():\n        evts.append('before')\n\n    @bp.after_app_request\n    def after_app(response):\n        response.data += b'|after'\n        evts.append('after')\n        return response\n\n    @bp.teardown_app_request\n    def teardown_app(exc):\n        evts.append('teardown')\n\n    app.register_blueprint(bp)\n\n    # Setup routes for testing\n    @app.route('\/')\n    def bp_endpoint():\n        return 'request'\n\n    # before first request\n    assert evts == []\n\n    # first request\n    resp = client.get('\/').data\n    assert resp == b'request|after'\n    assert evts == ['first', 'before', 'after', 'teardown']\n\n    # second request\n    resp = client.get('\/').data\n    assert resp == b'request|after'\n    assert evts == ['first'] + ['before', 'after', 'teardown'] * 2\n\n\ndef test_app_url_processors(app, client):\n    bp = flask.Blueprint('bp', __name__)\n\n    # Register app-wide url defaults and preprocessor on blueprint\n    @bp.app_url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault('lang_code', flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop('lang_code')\n\n    # Register route rules at the app level\n    @app.route('\/<lang_code>\/')\n    def index():\n        return flask.url_for('about')\n\n    @app.route('\/<lang_code>\/about')\n    def about():\n        return flask.url_for('index')\n\n    app.register_blueprint(bp)\n\n    assert client.get('\/de\/').data == b'\/de\/about'\n    assert client.get('\/de\/about').data == b'\/de\/'\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_config\n    ~~~~~~~~~~~~~~~~~\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom datetime import timedelta\nimport os\nimport textwrap\n\nimport flask\nfrom flask._compat import PY2\nimport pytest\n\n\n# config keys used for the TestConfig\nTEST_KEY = 'foo'\nSECRET_KEY = 'config'\n\n\ndef common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config\n\n\ndef test_config_from_file():\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(__file__.rsplit('.', 1)[0] + '.py')\n    common_object_test(app)\n\n\ndef test_config_from_object():\n    app = flask.Flask(__name__)\n    app.config.from_object(__name__)\n    common_object_test(app)\n\n\ndef test_config_from_json():\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_json(os.path.join(current_dir, 'static', 'config.json'))\n    common_object_test(app)\n\n\ndef test_config_from_mapping():\n    app = flask.Flask(__name__)\n    app.config.from_mapping({\n        'SECRET_KEY': 'config',\n        'TEST_KEY': 'foo'\n    })\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([\n        ('SECRET_KEY', 'config'),\n        ('TEST_KEY', 'foo')\n    ])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(\n        SECRET_KEY='config',\n        TEST_KEY='foo'\n    )\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping(\n            {}, {}\n        )\n\n\ndef test_config_from_class():\n    class Base(object):\n        TEST_KEY = 'foo'\n\n    class Test(Base):\n        SECRET_KEY = 'config'\n\n    app = flask.Flask(__name__)\n    app.config.from_object(Test)\n    common_object_test(app)\n\n\ndef test_config_from_envvar():\n    env = os.environ\n    try:\n        os.environ = {}\n        app = flask.Flask(__name__)\n        with pytest.raises(RuntimeError) as e:\n            app.config.from_envvar('FOO_SETTINGS')\n        assert \"'FOO_SETTINGS' is not set\" in str(e.value)\n        assert not app.config.from_envvar('FOO_SETTINGS', silent=True)\n\n        os.environ = {'FOO_SETTINGS': __file__.rsplit('.', 1)[0] + '.py'}\n        assert app.config.from_envvar('FOO_SETTINGS')\n        common_object_test(app)\n    finally:\n        os.environ = env\n\n\ndef test_config_from_envvar_missing():\n    env = os.environ\n    try:\n        os.environ = {'FOO_SETTINGS': 'missing.cfg'}\n        with pytest.raises(IOError) as e:\n            app = flask.Flask(__name__)\n            app.config.from_envvar('FOO_SETTINGS')\n        msg = str(e.value)\n        assert msg.startswith('[Errno 2] Unable to load configuration '\n                              'file (No such file or directory):')\n        assert msg.endswith(\"missing.cfg'\")\n        assert not app.config.from_envvar('FOO_SETTINGS', silent=True)\n    finally:\n        os.environ = env\n\n\ndef test_config_missing():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_pyfile('missing.cfg')\n    msg = str(e.value)\n    assert msg.startswith('[Errno 2] Unable to load configuration '\n                          'file (No such file or directory):')\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_pyfile('missing.cfg', silent=True)\n\n\ndef test_config_missing_json():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_json('missing.json')\n    msg = str(e.value)\n    assert msg.startswith('[Errno 2] Unable to load configuration '\n                          'file (No such file or directory):')\n    assert msg.endswith(\"missing.json'\")\n    assert not app.config.from_json('missing.json', silent=True)\n\n\ndef test_custom_config_class():\n    class Config(flask.Config):\n        pass\n\n    class Flask(flask.Flask):\n        config_class = Config\n    app = Flask(__name__)\n    assert isinstance(app.config, Config)\n    app.config.from_object(__name__)\n    common_object_test(app)\n\n\ndef test_session_lifetime():\n    app = flask.Flask(__name__)\n    app.config['PERMANENT_SESSION_LIFETIME'] = 42\n    assert app.permanent_session_lifetime.seconds == 42\n\n\ndef test_send_file_max_age():\n    app = flask.Flask(__name__)\n    app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 3600\n    assert app.send_file_max_age_default.seconds == 3600\n    app.config['SEND_FILE_MAX_AGE_DEFAULT'] = timedelta(hours=2)\n    assert app.send_file_max_age_default.seconds == 7200\n\n\ndef test_get_namespace():\n    app = flask.Flask(__name__)\n    app.config['FOO_OPTION_1'] = 'foo option 1'\n    app.config['FOO_OPTION_2'] = 'foo option 2'\n    app.config['BAR_STUFF_1'] = 'bar stuff 1'\n    app.config['BAR_STUFF_2'] = 'bar stuff 2'\n    foo_options = app.config.get_namespace('FOO_')\n    assert 2 == len(foo_options)\n    assert 'foo option 1' == foo_options['option_1']\n    assert 'foo option 2' == foo_options['option_2']\n    bar_options = app.config.get_namespace('BAR_', lowercase=False)\n    assert 2 == len(bar_options)\n    assert 'bar stuff 1' == bar_options['STUFF_1']\n    assert 'bar stuff 2' == bar_options['STUFF_2']\n    foo_options = app.config.get_namespace('FOO_', trim_namespace=False)\n    assert 2 == len(foo_options)\n    assert 'foo option 1' == foo_options['foo_option_1']\n    assert 'foo option 2' == foo_options['foo_option_2']\n    bar_options = app.config.get_namespace('BAR_', lowercase=False, trim_namespace=False)\n    assert 2 == len(bar_options)\n    assert 'bar stuff 1' == bar_options['BAR_STUFF_1']\n    assert 'bar stuff 2' == bar_options['BAR_STUFF_2']\n\n\n@pytest.mark.parametrize('encoding', ['utf-8', 'iso-8859-15', 'latin-1'])\ndef test_from_pyfile_weird_encoding(tmpdir, encoding):\n    f = tmpdir.join('my_config.py')\n    f.write_binary(textwrap.dedent(u'''\n    # -*- coding: {0} -*-\n    TEST_VALUE = \"f\u00f6\u00f6\"\n    '''.format(encoding)).encode(encoding))\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(str(f))\n    value = app.config['TEST_VALUE']\n    if PY2:\n        value = value.decode(encoding)\n    assert value == u'f\u00f6\u00f6'\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.helpers\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Various helpers.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport datetime\nimport os\nimport uuid\n\nimport pytest\nfrom werkzeug.datastructures import Range\nfrom werkzeug.exceptions import BadRequest, NotFound\nfrom werkzeug.http import http_date, parse_cache_control_header, \\\n    parse_options_header\n\nimport flask\nfrom flask._compat import StringIO, text_type\nfrom flask.helpers import get_debug_flag, get_env\n\n\ndef has_encoding(name):\n    try:\n        import codecs\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n\n\nclass FixedOffset(datetime.tzinfo):\n    \"\"\"Fixed offset in hours east from UTC.\n\n    This is a slight adaptation of the ``FixedOffset`` example found in\n    https:\/\/docs.python.org\/2.7\/library\/datetime.html.\n    \"\"\"\n\n    def __init__(self, hours, name):\n        self.__offset = datetime.timedelta(hours=hours)\n        self.__name = name\n\n    def utcoffset(self, dt):\n        return self.__offset\n\n    def tzname(self, dt):\n        return self.__name\n\n    def dst(self, dt):\n        return datetime.timedelta()\n\n\nclass TestJSON(object):\n    def test_ignore_cached_json(self, app):\n        with app.test_request_context('\/', method='POST', data='malformed',\n                                      content_type='application\/json'):\n            assert flask.request.get_json(silent=True, cache=True) is None\n            with pytest.raises(BadRequest):\n                flask.request.get_json(silent=False, cache=False)\n\n    def test_post_empty_json_adds_exception_to_response_content_in_debug(self, app, client):\n        app.config['DEBUG'] = True\n        app.config['TRAP_BAD_REQUEST_ERRORS'] = False\n\n        @app.route('\/json', methods=['POST'])\n        def post_json():\n            flask.request.get_json()\n            return None\n\n        rv = client.post('\/json', data=None, content_type='application\/json')\n        assert rv.status_code == 400\n        assert b'Failed to decode JSON object' in rv.data\n\n    def test_post_empty_json_wont_add_exception_to_response_if_no_debug(self, app, client):\n        app.config['DEBUG'] = False\n        app.config['TRAP_BAD_REQUEST_ERRORS'] = False\n\n        @app.route('\/json', methods=['POST'])\n        def post_json():\n            flask.request.get_json()\n            return None\n\n        rv = client.post('\/json', data=None, content_type='application\/json')\n        assert rv.status_code == 400\n        assert b'Failed to decode JSON object' not in rv.data\n\n    def test_json_bad_requests(self, app, client):\n\n        @app.route('\/json', methods=['POST'])\n        def return_json():\n            return flask.jsonify(foo=text_type(flask.request.get_json()))\n\n        rv = client.post('\/json', data='malformed', content_type='application\/json')\n        assert rv.status_code == 400\n\n    def test_json_custom_mimetypes(self, app, client):\n\n        @app.route('\/json', methods=['POST'])\n        def return_json():\n            return flask.request.get_json()\n\n        rv = client.post('\/json', data='\"foo\"', content_type='application\/x+json')\n        assert rv.data == b'foo'\n\n    def test_json_body_encoding(self, app, client):\n\n        @app.route('\/')\n        def index():\n            return flask.request.get_json()\n\n        resp = client.get('\/', data=u'\"H\u00e4llo W\u00f6rld\"'.encode('iso-8859-15'),\n                          content_type='application\/json; charset=iso-8859-15')\n        assert resp.data == u'H\u00e4llo W\u00f6rld'.encode('utf-8')\n\n    @pytest.mark.parametrize('test_value,expected', [(True, '\"\\\\u2603\"'), (False, u'\"\\u2603\"')])\n    def test_json_as_unicode(self, test_value, expected, app, app_ctx):\n\n        app.config['JSON_AS_ASCII'] = test_value\n        rv = flask.json.dumps(u'\\N{SNOWMAN}')\n        assert rv == expected\n\n    def test_json_dump_to_file(self, app, app_ctx):\n        test_data = {'name': 'Flask'}\n        out = StringIO()\n\n        flask.json.dump(test_data, out)\n        out.seek(0)\n        rv = flask.json.load(out)\n        assert rv == test_data\n\n    @pytest.mark.parametrize('test_value', [0, -1, 1, 23, 3.14, 's', \"longer string\", True, False, None])\n    def test_jsonify_basic_types(self, test_value, app, client):\n        \"\"\"Test jsonify with basic types.\"\"\"\n\n        url = '\/jsonify_basic_types'\n        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n        rv = client.get(url)\n        assert rv.mimetype == 'application\/json'\n        assert flask.json.loads(rv.data) == test_value\n\n    def test_jsonify_dicts(self, app, client):\n        \"\"\"Test jsonify with dicts and kwargs unpacking.\"\"\"\n        d = {'a': 0, 'b': 23, 'c': 3.14, 'd': 't',\n             'e': 'Hi', 'f': True, 'g': False,\n             'h': ['test list', 10, False],\n             'i': {'test': 'dict'}}\n\n        @app.route('\/kw')\n        def return_kwargs():\n            return flask.jsonify(**d)\n\n        @app.route('\/dict')\n        def return_dict():\n            return flask.jsonify(d)\n\n        for url in '\/kw', '\/dict':\n            rv = client.get(url)\n            assert rv.mimetype == 'application\/json'\n            assert flask.json.loads(rv.data) == d\n\n    def test_jsonify_arrays(self, app, client):\n        \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n        l = [\n            0, 42, 3.14, 't', 'hello', True, False,\n            ['test list', 2, False],\n            {'test': 'dict'}\n        ]\n\n        @app.route('\/args_unpack')\n        def return_args_unpack():\n            return flask.jsonify(*l)\n\n        @app.route('\/array')\n        def return_array():\n            return flask.jsonify(l)\n\n        for url in '\/args_unpack', '\/array':\n            rv = client.get(url)\n            assert rv.mimetype == 'application\/json'\n            assert flask.json.loads(rv.data) == l\n\n    def test_jsonify_date_types(self, app, client):\n        \"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"\n        test_dates = (\n            datetime.datetime(1973, 3, 11, 6, 30, 45),\n            datetime.date(1975, 1, 5)\n        )\n\n        for i, d in enumerate(test_dates):\n            url = '\/datetest{0}'.format(i)\n            app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n            rv = client.get(url)\n            assert rv.mimetype == 'application\/json'\n            assert flask.json.loads(rv.data)['x'] == http_date(d.timetuple())\n\n    @pytest.mark.parametrize('tz', (('UTC', 0), ('PST', -8), ('KST', 9)))\n    def test_jsonify_aware_datetimes(self, tz):\n        \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n        tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n        dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n        gmt = FixedOffset(hours=0, name='GMT')\n        expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n        assert flask.json.JSONEncoder().encode(dt) == expected\n\n    def test_jsonify_uuid_types(self, app, client):\n        \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n        test_uuid = uuid.UUID(bytes=b'\\xDE\\xAD\\xBE\\xEF' * 4)\n        url = '\/uuid_test'\n        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n        rv = client.get(url)\n\n        rv_x = flask.json.loads(rv.data)['x']\n        assert rv_x == str(test_uuid)\n        rv_uuid = uuid.UUID(rv_x)\n        assert rv_uuid == test_uuid\n\n    def test_json_attr(self, app, client):\n\n        @app.route('\/add', methods=['POST'])\n        def add():\n            json = flask.request.get_json()\n            return text_type(json['a'] + json['b'])\n\n        rv = client.post('\/add', data=flask.json.dumps({'a': 1, 'b': 2}),\n                         content_type='application\/json')\n        assert rv.data == b'3'\n\n    def test_template_escaping(self, app, req_ctx):\n        render = flask.render_template_string\n        rv = flask.json.htmlsafe_dumps('<\/script>')\n        assert rv == u'\"\\\\u003c\/script\\\\u003e\"'\n        assert type(rv) == text_type\n        rv = render('{{ \"<\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n        rv = render('{{ \"<\\0\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\\\\u0000\/script\\\\u003e\"'\n        rv = render('{{ \"<!--<script>\"|tojson }}')\n        assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n        rv = render('{{ \"&\"|tojson }}')\n        assert rv == '\"\\\\u0026\"'\n        rv = render('{{ \"\\'\"|tojson }}')\n        assert rv == '\"\\\\u0027\"'\n        rv = render(\"<a ng-data='{{ data|tojson }}'><\/a>\",\n                    data={'x': [\"foo\", \"bar\", \"baz'\"]})\n        assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'><\/a>'\n\n    def test_json_customization(self, app, client):\n        class X(object):\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return '<%d>' % o.val\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault('object_hook', self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and '_foo' in obj:\n                    return X(obj['_foo'])\n                return obj\n\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n\n        @app.route('\/', methods=['POST'])\n        def index():\n            return flask.json.dumps(flask.request.get_json()['x'])\n\n        rv = client.post('\/', data=flask.json.dumps({\n            'x': {'_foo': 42}\n        }), content_type='application\/json')\n        assert rv.data == b'\"<42>\"'\n\n    def test_blueprint_json_customization(self, app, client):\n        class X(object):\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return '<%d>' % o.val\n\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault('object_hook', self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and '_foo' in obj:\n                    return X(obj['_foo'])\n\n                return obj\n\n        bp = flask.Blueprint('bp', __name__)\n        bp.json_encoder = MyEncoder\n        bp.json_decoder = MyDecoder\n\n        @bp.route('\/bp', methods=['POST'])\n        def index():\n            return flask.json.dumps(flask.request.get_json()['x'])\n\n        app.register_blueprint(bp)\n\n        rv = client.post('\/bp', data=flask.json.dumps({\n            'x': {'_foo': 42}\n        }), content_type='application\/json')\n        assert rv.data == b'\"<42>\"'\n\n    def test_modified_url_encoding(self, app, client):\n        class ModifiedRequest(flask.Request):\n            url_charset = 'euc-kr'\n\n        app.request_class = ModifiedRequest\n        app.url_map.charset = 'euc-kr'\n\n        @app.route('\/')\n        def index():\n            return flask.request.args['foo']\n\n        rv = client.get(u'\/?foo=\uc815\uc0c1\ucc98\ub9ac'.encode('euc-kr'))\n        assert rv.status_code == 200\n        assert rv.data == u'\uc815\uc0c1\ucc98\ub9ac'.encode('utf-8')\n\n    if not has_encoding('euc-kr'):\n        test_modified_url_encoding = None\n\n    def test_json_key_sorting(self, app, client):\n        app.debug = True\n\n        assert app.config['JSON_SORT_KEYS'] == True\n        d = dict.fromkeys(range(20), 'foo')\n\n        @app.route('\/')\n        def index():\n            return flask.jsonify(values=d)\n\n        rv = client.get('\/')\n        lines = [x.strip() for x in rv.data.strip().decode('utf-8').splitlines()]\n        sorted_by_str = [\n            '{',\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\"',\n            '}',\n            '}'\n        ]\n        sorted_by_int = [\n            '{',\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\"',\n            '}',\n            '}'\n        ]\n\n        try:\n            assert lines == sorted_by_int\n        except AssertionError:\n            assert lines == sorted_by_str\n\n\nclass TestSendfile(object):\n    def test_send_file_regular(self, app, req_ctx):\n        rv = flask.send_file('static\/index.html')\n        assert rv.direct_passthrough\n        assert rv.mimetype == 'text\/html'\n        with app.open_resource('static\/index.html') as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    def test_send_file_xsendfile(self, app, req_ctx, catch_deprecation_warnings):\n        app.use_x_sendfile = True\n        rv = flask.send_file('static\/index.html')\n        assert rv.direct_passthrough\n        assert 'x-sendfile' in rv.headers\n        assert rv.headers['x-sendfile'] == \\\n               os.path.join(app.root_path, 'static\/index.html')\n        assert rv.mimetype == 'text\/html'\n        rv.close()\n\n    def test_send_file_last_modified(self, app, client):\n        last_modified = datetime.datetime(1999, 1, 1)\n\n        @app.route('\/')\n        def index():\n            return flask.send_file(StringIO(\"party like it's\"),\n                                   last_modified=last_modified,\n                                   mimetype='text\/plain')\n\n        rv = client.get('\/')\n        assert rv.last_modified == last_modified\n\n    def test_send_file_object_without_mimetype(self, app, req_ctx):\n        with pytest.raises(ValueError) as excinfo:\n            flask.send_file(StringIO(\"LOL\"))\n        assert 'Unable to infer MIME-type' in str(excinfo)\n        assert 'no filename is available' in str(excinfo)\n\n        flask.send_file(StringIO(\"LOL\"), attachment_filename='filename')\n\n    def test_send_file_object(self, app, req_ctx):\n        with open(os.path.join(app.root_path, 'static\/index.html'), mode='rb') as f:\n            rv = flask.send_file(f, mimetype='text\/html')\n            rv.direct_passthrough = False\n            with app.open_resource('static\/index.html') as f:\n                assert rv.data == f.read()\n            assert rv.mimetype == 'text\/html'\n            rv.close()\n\n        app.use_x_sendfile = True\n\n        with open(os.path.join(app.root_path, 'static\/index.html')) as f:\n            rv = flask.send_file(f, mimetype='text\/html')\n            assert rv.mimetype == 'text\/html'\n            assert 'x-sendfile' not in rv.headers\n            rv.close()\n\n        app.use_x_sendfile = False\n        f = StringIO('Test')\n        rv = flask.send_file(f, mimetype='application\/octet-stream')\n        rv.direct_passthrough = False\n        assert rv.data == b'Test'\n        assert rv.mimetype == 'application\/octet-stream'\n        rv.close()\n\n        class PyStringIO(object):\n            def __init__(self, *args, **kwargs):\n                self._io = StringIO(*args, **kwargs)\n\n            def __getattr__(self, name):\n                return getattr(self._io, name)\n\n        f = PyStringIO('Test')\n        f.name = 'test.txt'\n        rv = flask.send_file(f, attachment_filename=f.name)\n        rv.direct_passthrough = False\n        assert rv.data == b'Test'\n        assert rv.mimetype == 'text\/plain'\n        rv.close()\n\n        f = StringIO('Test')\n        rv = flask.send_file(f, mimetype='text\/plain')\n        rv.direct_passthrough = False\n        assert rv.data == b'Test'\n        assert rv.mimetype == 'text\/plain'\n        rv.close()\n\n        app.use_x_sendfile = True\n\n        f = StringIO('Test')\n        rv = flask.send_file(f, mimetype='text\/html')\n        assert 'x-sendfile' not in rv.headers\n        rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, 'to_content_range_header', None)),\n        reason=\"not implemented within werkzeug\"\n    )\n    def test_send_file_range_request(self, app, client):\n        @app.route('\/')\n        def index():\n            return flask.send_file('static\/index.html', conditional=True)\n\n        rv = client.get('\/', headers={'Range': 'bytes=4-15'})\n        assert rv.status_code == 206\n        with app.open_resource('static\/index.html') as f:\n            assert rv.data == f.read()[4:16]\n        rv.close()\n\n        rv = client.get('\/', headers={'Range': 'bytes=4-'})\n        assert rv.status_code == 206\n        with app.open_resource('static\/index.html') as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get('\/', headers={'Range': 'bytes=4-1000'})\n        assert rv.status_code == 206\n        with app.open_resource('static\/index.html') as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get('\/', headers={'Range': 'bytes=-10'})\n        assert rv.status_code == 206\n        with app.open_resource('static\/index.html') as f:\n            assert rv.data == f.read()[-10:]\n        rv.close()\n\n        rv = client.get('\/', headers={'Range': 'bytes=1000-'})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get('\/', headers={'Range': 'bytes=-'})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get('\/', headers={'Range': 'somethingsomething'})\n        assert rv.status_code == 416\n        rv.close()\n\n        last_modified = datetime.datetime.utcfromtimestamp(os.path.getmtime(\n            os.path.join(app.root_path, 'static\/index.html'))).replace(\n            microsecond=0)\n\n        rv = client.get('\/', headers={'Range': 'bytes=4-15',\n                                      'If-Range': http_date(last_modified)})\n        assert rv.status_code == 206\n        rv.close()\n\n        rv = client.get('\/', headers={'Range': 'bytes=4-15', 'If-Range': http_date(\n            datetime.datetime(1999, 1, 1))})\n        assert rv.status_code == 200\n        rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, 'to_content_range_header', None)),\n        reason=\"not implemented within werkzeug\"\n    )\n    def test_send_file_range_request_xsendfile_invalid(self, app, client):\n        # https:\/\/github.com\/pallets\/flask\/issues\/2526\n        app.use_x_sendfile = True\n\n        @app.route('\/')\n        def index():\n            return flask.send_file('static\/index.html', conditional=True)\n\n        rv = client.get('\/', headers={'Range': 'bytes=1000-'})\n        assert rv.status_code == 416\n        rv.close()\n\n    def test_attachment(self, app, req_ctx):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            with open(os.path.join(app.root_path, 'static\/index.html')) as f:\n                rv = flask.send_file(f, as_attachment=True,\n                                     attachment_filename='index.html')\n                value, options = \\\n                    parse_options_header(rv.headers['Content-Disposition'])\n                assert value == 'attachment'\n                rv.close()\n\n        with open(os.path.join(app.root_path, 'static\/index.html')) as f:\n            rv = flask.send_file(f, as_attachment=True,\n                                 attachment_filename='index.html')\n            value, options = \\\n                parse_options_header(rv.headers['Content-Disposition'])\n            assert value == 'attachment'\n            assert options['filename'] == 'index.html'\n            assert 'filename*' not in rv.headers['Content-Disposition']\n            rv.close()\n\n        rv = flask.send_file('static\/index.html', as_attachment=True)\n        value, options = parse_options_header(rv.headers['Content-Disposition'])\n        assert value == 'attachment'\n        assert options['filename'] == 'index.html'\n        rv.close()\n\n        rv = flask.send_file(StringIO('Test'), as_attachment=True,\n                             attachment_filename='index.txt',\n                             add_etags=False)\n        assert rv.mimetype == 'text\/plain'\n        value, options = parse_options_header(rv.headers['Content-Disposition'])\n        assert value == 'attachment'\n        assert options['filename'] == 'index.txt'\n        rv.close()\n\n    def test_attachment_with_utf8_filename(self, app, req_ctx):\n        rv = flask.send_file('static\/index.html', as_attachment=True, attachment_filename=u'\u00d1and\u00fa\uff0fping\u00fcino.txt')\n        content_disposition = set(rv.headers['Content-Disposition'].split('; '))\n        assert content_disposition == set((\n            'attachment',\n            'filename=\"Nandu\/pinguino.txt\"',\n            \"filename*=UTF-8''%C3%91and%C3%BA%EF%BC%8Fping%C3%BCino.txt\"\n        ))\n        rv.close()\n\n    def test_static_file(self, app, req_ctx):\n        # default cache timeout is 12 hours\n\n        # Test with static file handler.\n        rv = app.send_static_file('index.html')\n        cc = parse_cache_control_header(rv.headers['Cache-Control'])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file('static\/index.html')\n        cc = parse_cache_control_header(rv.headers['Cache-Control'])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file('index.html')\n        cc = parse_cache_control_header(rv.headers['Cache-Control'])\n        assert cc.max_age == 3600\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file('static\/index.html')\n        cc = parse_cache_control_header(rv.headers['Cache-Control'])\n        assert cc.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 10\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 10\n            rv.close()\n\n    def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(os.path.dirname(__file__),\n                                     'test_apps', 'subdomaintestmodule')\n        rv = flask.send_from_directory('static', 'hello.txt')\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b'Hello Subdomain'\n        rv.close()\n\n    def test_send_from_directory_bad_request(self, app, req_ctx):\n        app.root_path = os.path.join(os.path.dirname(__file__),\n                                     'test_apps', 'subdomaintestmodule')\n\n        with pytest.raises(BadRequest):\n            flask.send_from_directory('static', 'bad\\x00')\n\n\nclass TestUrlFor(object):\n    def test_url_for_with_anchor(self, app, req_ctx):\n\n        @app.route('\/')\n        def index():\n            return '42'\n\n        assert flask.url_for('index', _anchor='x y') == '\/#x%20y'\n\n    def test_url_for_with_scheme(self, app, req_ctx):\n\n        @app.route('\/')\n        def index():\n            return '42'\n\n        assert flask.url_for('index', _external=True, _scheme='https') == 'https:\/\/localhost\/'\n\n    def test_url_for_with_scheme_not_external(self, app, req_ctx):\n\n        @app.route('\/')\n        def index():\n            return '42'\n\n        pytest.raises(ValueError,\n                      flask.url_for,\n                      'index',\n                      _scheme='https')\n\n    def test_url_for_with_alternating_schemes(self, app, req_ctx):\n\n        @app.route('\/')\n        def index():\n            return '42'\n\n        assert flask.url_for('index', _external=True) == 'http:\/\/localhost\/'\n        assert flask.url_for('index', _external=True, _scheme='https') == 'https:\/\/localhost\/'\n        assert flask.url_for('index', _external=True) == 'http:\/\/localhost\/'\n\n    def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return 'List'\n                return 'Get %d' % id\n\n            def post(self):\n                return 'Create'\n\n        myview = MyView.as_view('myview')\n        app.add_url_rule('\/myview\/', methods=['GET'],\n                         view_func=myview)\n        app.add_url_rule('\/myview\/<int:id>', methods=['GET'],\n                         view_func=myview)\n        app.add_url_rule('\/myview\/create', methods=['POST'],\n                         view_func=myview)\n\n        assert flask.url_for('myview', _method='GET') == '\/myview\/'\n        assert flask.url_for('myview', id=42, _method='GET') == '\/myview\/42'\n        assert flask.url_for('myview', _method='POST') == '\/myview\/create'\n\n\nclass TestNoImports(object):\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self, modules_tmpdir):\n        modules_tmpdir.join('importerror.py').write('raise NotImplementedError()')\n        try:\n            flask.Flask('importerror')\n        except NotImplementedError:\n            assert False, 'Flask(import_name) is importing import_name.'\n\n\nclass TestStreaming(object):\n    def test_streaming_with_context(self, app, client):\n\n        @app.route('\/')\n        def index():\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get('\/?name=World')\n        assert rv.data == b'Hello World!'\n\n    def test_streaming_with_context_as_decorator(self, app, client):\n\n        @app.route('\/')\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args['name']\n                yield '!'\n\n            return flask.Response(generate('Hello '))\n\n        rv = client.get('\/?name=World')\n        assert rv.data == b'Hello World!'\n\n    def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper(object):\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route('\/')\n        def index():\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n\n            return flask.Response(flask.stream_with_context(\n                Wrapper(generate())))\n\n        rv = client.get('\/?name=World')\n        assert rv.data == b'Hello World!'\n        assert called == [42]\n\n    def test_stream_keeps_session(self, app, client):\n        @app.route('\/')\n        def index():\n            flask.session['test'] = 'flask'\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session['test']\n\n            return flask.Response(gen())\n\n        rv = client.get('\/')\n        assert rv.data == b'flask'\n\n\nclass TestSafeJoin(object):\n    def test_safe_join(self):\n        # Valid combinations of *args and expected joined paths.\n        passing = (\n            (('a\/b\/c',), 'a\/b\/c'),\n            (('\/', 'a\/', 'b\/', 'c\/'), '\/a\/b\/c'),\n            (('a', 'b', 'c'), 'a\/b\/c'),\n            (('\/a', 'b\/c'), '\/a\/b\/c'),\n            (('a\/b', 'X\/..\/c'), 'a\/b\/c'),\n            (('\/a\/b', 'c\/X\/..'), '\/a\/b\/c'),\n            # If last path is '' add a slash\n            (('\/a\/b\/c', ''), '\/a\/b\/c\/'),\n            # Preserve dot slash\n            (('\/a\/b\/c', '.\/'), '\/a\/b\/c\/.'),\n            (('a\/b\/c', 'X\/..'), 'a\/b\/c\/.'),\n            # Base directory is always considered safe\n            (('..\/', 'a\/b\/c'), '..\/a\/b\/c'),\n            (('\/..',), '\/..'),\n        )\n\n        for args, expected in passing:\n            assert flask.safe_join(*args) == expected\n\n    def test_safe_join_exceptions(self):\n        # Should raise werkzeug.exceptions.NotFound on unsafe joins.\n        failing = (\n            # path.isabs and ``..'' checks\n            ('\/a', 'b', '\/c'),\n            ('\/a', '..\/b\/c'),\n            ('\/a', '..', 'b\/c'),\n            # Boundaries violations after path normalization\n            ('\/a', 'b\/..\/b\/..\/..\/c'),\n            ('\/a', 'b', 'c\/..\/..'),\n            ('\/a', 'b\/..\/..\/c'),\n        )\n\n        for args in failing:\n            with pytest.raises(NotFound):\n                print(flask.safe_join(*args))\n\nclass TestHelpers(object):\n\n    @pytest.mark.parametrize('debug, expected_flag, expected_default_flag', [\n        ('', False, False),\n        ('0', False, False),\n        ('False', False, False),\n        ('No', False, False),\n        ('True', True, True)\n    ])\n    def test_get_debug_flag(self, monkeypatch, debug, expected_flag, expected_default_flag):\n        monkeypatch.setenv('FLASK_DEBUG', debug)\n        if expected_flag is None:\n            assert get_debug_flag() is None\n        else:\n            assert get_debug_flag() == expected_flag\n        assert get_debug_flag() == expected_default_flag\n\n    @pytest.mark.parametrize('env, ref_env, debug', [\n        ('', 'production', False),\n        ('production', 'production', False),\n        ('development', 'development', True),\n        ('other', 'other', False),\n    ])\n    def test_get_env(self, monkeypatch, env, ref_env, debug):\n        monkeypatch.setenv('FLASK_ENV', env)\n        assert get_debug_flag() == debug\n        assert get_env() == ref_env\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == 'text\/html'\n\n            rv = flask.helpers.make_response('Hello')\n            assert rv.status_code == 200\n            assert rv.data == b'Hello'\n            assert rv.mimetype == 'text\/html'\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.test_instance\n    ~~~~~~~~~~~~~~~~~~~\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\n\nimport pytest\nimport flask\nfrom flask._compat import PY2\n\n\ndef test_explicit_instance_paths(modules_tmpdir):\n    with pytest.raises(ValueError) as excinfo:\n        flask.Flask(__name__, instance_path='instance')\n    assert 'must be absolute' in str(excinfo.value)\n\n    app = flask.Flask(__name__, instance_path=str(modules_tmpdir))\n    assert app.instance_path == str(modules_tmpdir)\n\n\ndef test_main_module_paths(modules_tmpdir, purge_module):\n    app = modules_tmpdir.join('main_app.py')\n    app.write('import flask\\n\\napp = flask.Flask(\"__main__\")')\n    purge_module('main_app')\n\n    from main_app import app\n    here = os.path.abspath(os.getcwd())\n    assert app.instance_path == os.path.join(here, 'instance')\n\n\ndef test_uninstalled_module_paths(modules_tmpdir, purge_module):\n    app = modules_tmpdir.join('config_module_app.py').write(\n        'import os\\n'\n        'import flask\\n'\n        'here = os.path.abspath(os.path.dirname(__file__))\\n'\n        'app = flask.Flask(__name__)\\n'\n    )\n    purge_module('config_module_app')\n\n    from config_module_app import app\n    assert app.instance_path == str(modules_tmpdir.join('instance'))\n\n\ndef test_uninstalled_package_paths(modules_tmpdir, purge_module):\n    app = modules_tmpdir.mkdir('config_package_app')\n    init = app.join('__init__.py')\n    init.write(\n        'import os\\n'\n        'import flask\\n'\n        'here = os.path.abspath(os.path.dirname(__file__))\\n'\n        'app = flask.Flask(__name__)\\n'\n    )\n    purge_module('config_package_app')\n\n    from config_package_app import app\n    assert app.instance_path == str(modules_tmpdir.join('instance'))\n\n\ndef test_installed_module_paths(modules_tmpdir, modules_tmpdir_prefix,\n                                purge_module, site_packages, limit_loader):\n    site_packages.join('site_app.py').write(\n        'import flask\\n'\n        'app = flask.Flask(__name__)\\n'\n    )\n    purge_module('site_app')\n\n    from site_app import app\n    assert app.instance_path == \\\n        modules_tmpdir.join('var').join('site_app-instance')\n\n\ndef test_installed_package_paths(limit_loader, modules_tmpdir,\n                                 modules_tmpdir_prefix, purge_module,\n                                 monkeypatch):\n    installed_path = modules_tmpdir.mkdir('path')\n    monkeypatch.syspath_prepend(installed_path)\n\n    app = installed_path.mkdir('installed_package')\n    init = app.join('__init__.py')\n    init.write('import flask\\napp = flask.Flask(__name__)')\n    purge_module('installed_package')\n\n    from installed_package import app\n    assert app.instance_path == \\\n        modules_tmpdir.join('var').join('installed_package-instance')\n\n\ndef test_prefix_package_paths(limit_loader, modules_tmpdir,\n                              modules_tmpdir_prefix, purge_module,\n                              site_packages):\n    app = site_packages.mkdir('site_package')\n    init = app.join('__init__.py')\n    init.write('import flask\\napp = flask.Flask(__name__)')\n    purge_module('site_package')\n\n    import site_package\n    assert site_package.app.instance_path == \\\n        modules_tmpdir.join('var').join('site_package-instance')\n\n\ndef test_egg_installed_paths(install_egg, modules_tmpdir,\n                             modules_tmpdir_prefix):\n    modules_tmpdir.mkdir('site_egg').join('__init__.py').write(\n        'import flask\\n\\napp = flask.Flask(__name__)'\n    )\n    install_egg('site_egg')\n    try:\n        import site_egg\n        assert site_egg.app.instance_path == \\\n            str(modules_tmpdir.join('var\/').join('site_egg-instance'))\n    finally:\n        if 'site_egg' in sys.modules:\n            del sys.modules['site_egg']\n\n\n@pytest.mark.skipif(not PY2, reason='This only works under Python 2.')\ndef test_meta_path_loader_without_is_package(request, modules_tmpdir):\n    app = modules_tmpdir.join('unimportable.py')\n    app.write('import flask\\napp = flask.Flask(__name__)')\n\n    class Loader(object):\n        def find_module(self, name, path=None):\n            return self\n\n    sys.meta_path.append(Loader())\n    request.addfinalizer(sys.meta_path.pop)\n\n    with pytest.raises(AttributeError):\n        import unimportable\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ['wsgi.errors'] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(logging.Formatter(\n    '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n))\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger('flask.app')\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\ntests.test_logging\n~~~~~~~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport logging\nimport sys\n\nimport pytest\n\nfrom flask._compat import StringIO\nfrom flask.logging import default_handler, has_level_handler, \\\n    wsgi_errors_stream\n\n\n@pytest.fixture(autouse=True)\ndef reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger('flask.app')\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(\n        name='logging-plugin')\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, 'logging-plugin')\n\n\ndef test_logger(app):\n    assert app.logger.name == 'flask.app'\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n\n\ndef test_wsgi_errors_stream(app, client):\n    @app.route('\/')\n    def index():\n        app.logger.error('test')\n        return ''\n\n    stream = StringIO()\n    client.get('\/', errors_stream=stream)\n    assert 'ERROR in test_logging: test' in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n\n\ndef test_has_level_handler():\n    logger = logging.getLogger('flask.app')\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n\n\ndef test_log_view_exception(app, client):\n    @app.route('\/')\n    def index():\n        raise Exception('test')\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get('\/', errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert 'Exception on \/ [GET]' in err\n    assert 'Exception: test' in err\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.regression\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Tests regressions.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport gc\nimport sys\nimport threading\n\nimport pytest\nfrom werkzeug.exceptions import NotFound\n\nimport flask\n\n_gc_lock = threading.Lock()\n\n\nclass assert_no_leak(object):\n\n    def __enter__(self):\n        gc.disable()\n        _gc_lock.acquire()\n        loc = flask._request_ctx_stack._local\n\n        # Force Python to track this dictionary at all times.\n        # This is necessary since Python only starts tracking\n        # dicts if they contain mutable objects.  It's a horrible,\n        # horrible hack but makes this kinda testable.\n        loc.__storage__['FOOO'] = [1, 2, 3]\n\n        gc.collect()\n        self.old_objects = len(gc.get_objects())\n\n    def __exit__(self, exc_type, exc_value, tb):\n        gc.collect()\n        new_objects = len(gc.get_objects())\n        if new_objects > self.old_objects:\n            pytest.fail('Example code leaked')\n        _gc_lock.release()\n        gc.enable()\n\n\ndef test_memory_consumption():\n    app = flask.Flask(__name__)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('simple_template.html', whiskey=42)\n\n    def fire():\n        with app.test_client() as c:\n            rv = c.get('\/')\n            assert rv.status_code == 200\n            assert rv.data == b'<h1>42<\/h1>'\n\n    # Trigger caches\n    fire()\n\n    # This test only works on CPython 2.7.\n    if sys.version_info >= (2, 7) and \\\n            not hasattr(sys, 'pypy_translation_info'):\n        with assert_no_leak():\n            for x in range(10):\n                fire()\n\n\ndef test_safe_join_toplevel_pardir():\n    from flask.helpers import safe_join\n    with pytest.raises(NotFound):\n        safe_join('\/foo', '..')\n\n\ndef test_aborting(app):\n    class Foo(Exception):\n        whatever = 42\n\n    @app.errorhandler(Foo)\n    def handle_foo(e):\n        return str(e.whatever)\n\n    @app.route('\/')\n    def index():\n        raise flask.abort(flask.redirect(flask.url_for('test')))\n\n    @app.route('\/test')\n    def test():\n        raise Foo()\n\n    with app.test_client() as c:\n        rv = c.get('\/')\n        assert rv.headers['Location'] == 'http:\/\/localhost\/test'\n        rv = c.get('\/test')\n        assert rv.data == b'42'\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.reqctx\n    ~~~~~~~~~~~~\n\n    Tests the request context.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\nfrom flask.sessions import SessionInterface\n\ntry:\n    from greenlet import greenlet\nexcept ImportError:\n    greenlet = None\n\n\ndef test_teardown_on_pop(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    ctx = app.test_request_context()\n    ctx.push()\n    assert buffer == []\n    ctx.pop()\n    assert buffer == [None]\n\n\ndef test_teardown_with_previous_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    try:\n        raise Exception('dummy')\n    except Exception:\n        pass\n\n    with app.test_request_context():\n        assert buffer == []\n    assert buffer == [None]\n\n\ndef test_teardown_with_handled_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    with app.test_request_context():\n        assert buffer == []\n        try:\n            raise Exception('dummy')\n        except Exception:\n            pass\n    assert buffer == [None]\n\n\ndef test_proper_test_request_context(app):\n    app.config.update(\n        SERVER_NAME='localhost.localdomain:5000'\n    )\n\n    @app.route('\/')\n    def index():\n        return None\n\n    @app.route('\/', subdomain='foo')\n    def sub():\n        return None\n\n    with app.test_request_context('\/'):\n        assert flask.url_for('index', _external=True) == \\\n               'http:\/\/localhost.localdomain:5000\/'\n\n    with app.test_request_context('\/'):\n        assert flask.url_for('sub', _external=True) == \\\n               'http:\/\/foo.localhost.localdomain:5000\/'\n\n    try:\n        with app.test_request_context('\/', environ_overrides={'HTTP_HOST': 'localhost'}):\n            pass\n    except ValueError as e:\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain:5000') does not match the \"\n            \"server name from the WSGI environment ('localhost')\"\n        )\n\n    app.config.update(SERVER_NAME='localhost')\n    with app.test_request_context('\/', environ_overrides={'SERVER_NAME': 'localhost'}):\n        pass\n\n    app.config.update(SERVER_NAME='localhost:80')\n    with app.test_request_context('\/', environ_overrides={'SERVER_NAME': 'localhost:80'}):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route('\/')\n    def index():\n        return 'Hello %s!' % flask.request.args['name']\n\n    @app.route('\/meh')\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context('\/?name=World'):\n        assert index() == 'Hello World!'\n    with app.test_request_context('\/meh'):\n        assert meh() == 'http:\/\/localhost\/meh'\n    assert flask._request_ctx_stack.top is None\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route('\/')\n    def index():\n        return 'Hello %s!' % flask.request.args['name']\n\n    ctx = app.test_request_context('\/?name=World')\n    ctx.push()\n    assert index() == 'Hello World!'\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason='greenlet not installed')\nclass TestGreenletContextCopying(object):\n\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route('\/')\n        def index():\n            reqctx = flask._request_ctx_stack.top.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == '\/'\n                    assert flask.request.args['foo'] == 'bar'\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return 'Hello World!'\n\n        rv = client.get('\/?foo=bar')\n        assert rv.data == b'Hello World!'\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route('\/')\n        def index():\n            reqctx = flask._request_ctx_stack.top.copy()\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == '\/'\n                assert flask.request.args['foo'] == 'bar'\n                return 42\n\n            greenlets.append(greenlet(g))\n            return 'Hello World!'\n\n        rv = client.get('\/?foo=bar')\n        assert rv.data == b'Hello World!'\n\n        result = greenlets[0].run()\n        assert result == 42\n\n\ndef test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route('\/')\n    def index():\n        # shouldn't get here\n        assert False\n\n    response = app.test_client().get('\/')\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.signals\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Signalling.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\ntry:\n    import blinker\nexcept ImportError:\n    blinker = None\n\nimport flask\n\npytestmark = pytest.mark.skipif(\n    blinker is None,\n    reason='Signals require the blinker library.'\n)\n\n\ndef test_template_rendered(app, client):\n    @app.route('\/')\n    def index():\n        return flask.render_template('simple_template.html', whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        recorded.append((template, context))\n\n    flask.template_rendered.connect(record, app)\n    try:\n        client.get('\/')\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == 'simple_template.html'\n        assert context['whiskey'] == 42\n    finally:\n        flask.template_rendered.disconnect(record, app)\n\n\ndef test_before_render_template():\n    app = flask.Flask(__name__)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('simple_template.html', whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        context['whiskey'] = 43\n        recorded.append((template, context))\n\n    flask.before_render_template.connect(record, app)\n    try:\n        rv = app.test_client().get('\/')\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == 'simple_template.html'\n        assert context['whiskey'] == 43\n        assert rv.data == b'<h1>43<\/h1>'\n    finally:\n        flask.before_render_template.disconnect(record, app)\n\n\ndef test_request_signals():\n    app = flask.Flask(__name__)\n    calls = []\n\n    def before_request_signal(sender):\n        calls.append('before-signal')\n\n    def after_request_signal(sender, response):\n        assert response.data == b'stuff'\n        calls.append('after-signal')\n\n    @app.before_request\n    def before_request_handler():\n        calls.append('before-handler')\n\n    @app.after_request\n    def after_request_handler(response):\n        calls.append('after-handler')\n        response.data = 'stuff'\n        return response\n\n    @app.route('\/')\n    def index():\n        calls.append('handler')\n        return 'ignored anyway'\n\n    flask.request_started.connect(before_request_signal, app)\n    flask.request_finished.connect(after_request_signal, app)\n\n    try:\n        rv = app.test_client().get('\/')\n        assert rv.data == b'stuff'\n\n        assert calls == ['before-signal', 'before-handler', 'handler',\n                         'after-handler', 'after-signal']\n    finally:\n        flask.request_started.disconnect(before_request_signal, app)\n        flask.request_finished.disconnect(after_request_signal, app)\n\n\ndef test_request_exception_signal():\n    app = flask.Flask(__name__)\n    recorded = []\n\n    @app.route('\/')\n    def index():\n        1 \/\/ 0\n\n    def record(sender, exception):\n        recorded.append(exception)\n\n    flask.got_request_exception.connect(record, app)\n    try:\n        assert app.test_client().get('\/').status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.got_request_exception.disconnect(record, app)\n\n\ndef test_appcontext_signals():\n    app = flask.Flask(__name__)\n    recorded = []\n\n    def record_push(sender, **kwargs):\n        recorded.append('push')\n\n    def record_pop(sender, **kwargs):\n        recorded.append('pop')\n\n    @app.route('\/')\n    def index():\n        return 'Hello'\n\n    flask.appcontext_pushed.connect(record_push, app)\n    flask.appcontext_popped.connect(record_pop, app)\n    try:\n        with app.test_client() as c:\n            rv = c.get('\/')\n            assert rv.data == b'Hello'\n            assert recorded == ['push']\n        assert recorded == ['push', 'pop']\n    finally:\n        flask.appcontext_pushed.disconnect(record_push, app)\n        flask.appcontext_popped.disconnect(record_pop, app)\n\n\ndef test_flash_signal(app):\n    @app.route('\/')\n    def index():\n        flask.flash('This is a flash message', category='notice')\n        return flask.redirect('\/other')\n\n    recorded = []\n\n    def record(sender, message, category):\n        recorded.append((message, category))\n\n    flask.message_flashed.connect(record, app)\n    try:\n        client = app.test_client()\n        with client.session_transaction():\n            client.get('\/')\n            assert len(recorded) == 1\n            message, category = recorded[0]\n            assert message == 'This is a flash message'\n            assert category == 'notice'\n    finally:\n        flask.message_flashed.disconnect(record, app)\n\n\ndef test_appcontext_tearing_down_signal():\n    app = flask.Flask(__name__)\n    recorded = []\n\n    def record_teardown(sender, **kwargs):\n        recorded.append(('tear_down', kwargs))\n\n    @app.route('\/')\n    def index():\n        1 \/\/ 0\n\n    flask.appcontext_tearing_down.connect(record_teardown, app)\n    try:\n        with app.test_client() as c:\n            rv = c.get('\/')\n            assert rv.status_code == 500\n            assert recorded == []\n        assert recorded == [('tear_down', {'exc': None})]\n    finally:\n        flask.appcontext_tearing_down.disconnect(record_teardown, app)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.subclassing\n    ~~~~~~~~~~~~~~~~~\n\n    Test that certain behavior of flask can be customized by\n    subclasses.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport flask\n\nfrom flask._compat import StringIO\n\n\ndef test_suppressed_exception_logging():\n    class SuppressedFlask(flask.Flask):\n        def log_exception(self, exc_info):\n            pass\n\n    out = StringIO()\n    app = SuppressedFlask(__name__)\n\n    @app.route('\/')\n    def index():\n        raise Exception('test')\n\n    rv = app.test_client().get('\/', errors_stream=out)\n    assert rv.status_code == 500\n    assert b'Internal Server Error' in rv.data\n    assert not out.getvalue()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.templating\n    ~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\nimport logging\nfrom jinja2 import TemplateNotFound\nimport werkzeug.serving\n\n\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {'injected_value': 42}\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('context_template.html', value=23)\n\n    rv = client.get('\/')\n    assert rv.data == b'<p>23|42'\n\n\ndef test_original_win(app, client):\n    @app.route('\/')\n    def index():\n        return flask.render_template_string('{{ config }}', config=42)\n\n    rv = client.get('\/')\n    assert rv.data == b'42'\n\n\ndef test_request_less_rendering(app, app_ctx):\n    app.config['WORLD_NAME'] = 'Special World'\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string('Hello {{ config.WORLD_NAME }} '\n                                      '{{ foo }}')\n    assert rv == 'Hello Special World 42'\n\n\ndef test_standard_context(app, client):\n    @app.route('\/')\n    def index():\n        flask.g.foo = 23\n        flask.session['test'] = 'aha'\n        return flask.render_template_string('''\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        ''')\n\n    rv = client.get('\/?foo=42')\n    assert rv.data.split() == [b'42', b'23', b'False', b'aha']\n\n\ndef test_escaping(app, client):\n    text = '<p>Hello World!'\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('escaping_template.html', text=text,\n                                     html=flask.Markup(text))\n\n    lines = client.get('\/').data.splitlines()\n    assert lines == [\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!'\n    ]\n\n\ndef test_no_escaping(app, client):\n    text = '<p>Hello World!'\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('non_escaping_template.txt', text=text,\n                                     html=flask.Markup(text))\n\n    lines = client.get('\/').data.splitlines()\n    assert lines == [\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!'\n    ]\n\n\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\n        '{{ foo }}', foo='<test>') == '&lt;test&gt;'\n    assert flask.render_template('mail.txt', foo='<test>') == '<test> Mail'\n\n\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute('_macro.html', 'hello')\n    assert macro('World') == 'Hello World!'\n\n\ndef test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\n\ndef test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\n\ndef test_template_filter_with_name(app):\n    @app.template_filter('strrev')\n    def my_reverse(s):\n        return s[::-1]\n\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\n\ndef test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, 'strrev')\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\n\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter('super_reverse')\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, 'super_reverse')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_template_test_with_name(app):\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, 'boolean')\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, 'boolean')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert 'get_stuff' in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals['get_stuff'] == get_stuff\n    assert app.jinja_env.globals['get_stuff'](), 42\n\n    rv = flask.render_template_string('{{ get_stuff() }}')\n    assert rv == '42'\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n            return DictLoader({'index.html': 'Hello Custom World!'})\n\n    app = MyFlask(__name__)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('index.html')\n\n    c = app.test_client()\n    rv = c.get('\/')\n    assert rv.data == b'Hello Custom World!'\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {'whiskey': 'Jameson'}\n\n    @app.route('\/')\n    def index():\n        return flask.render_template(\n            ['no_template.xml',  # should skip this one\n             'simple_template.html',  # should render this\n             'context_template.html'],\n            value=23)\n\n    rv = client.get('\/')\n    assert rv.data == b'<h1>Jameson<\/h1>'\n\n\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.jinja_env.auto_reload is True\n\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n\n    app.run()\n    assert app.templates_auto_reload == False\n    assert app.jinja_env.auto_reload == False\n\n    app.run(debug=True)\n    assert app.templates_auto_reload == True\n    assert app.jinja_env.auto_reload == True\n\n\ndef test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(x, record):\n            called.append(True)\n            text = str(record.msg)\n            assert '1: trying loader of application \"blueprintapp\"' in text\n            assert ('2: trying loader of blueprint \"admin\" '\n                    '(blueprintapp.apps.admin)') in text\n            assert ('trying loader of blueprint \"frontend\" '\n                    '(blueprintapp.apps.frontend)') in text\n            assert 'Error: the template could not be found' in text\n            assert ('looked up from an endpoint that belongs to '\n                    'the blueprint \"frontend\"') in text\n            assert 'See http:\/\/flask.pocoo.org\/docs\/blueprints\/#templates' in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, 'EXPLAIN_TEMPLATE_LOADING', True)\n        monkeypatch.setattr(\n            logging.getLogger('flask'), 'handlers', [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get('\/missing')\n\n        assert 'missing_template.html' in str(excinfo.value)\n\n    assert len(called) == 1\n\n\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ['wsgi.errors'] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(logging.Formatter(\n    '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n))\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger('flask.app')\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.templating\n    ~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\nimport logging\nfrom jinja2 import TemplateNotFound\nimport werkzeug.serving\n\n\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {'injected_value': 42}\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('context_template.html', value=23)\n\n    rv = client.get('\/')\n    assert rv.data == b'<p>23|42'\n\n\ndef test_original_win(app, client):\n    @app.route('\/')\n    def index():\n        return flask.render_template_string('{{ config }}', config=42)\n\n    rv = client.get('\/')\n    assert rv.data == b'42'\n\n\ndef test_request_less_rendering(app, app_ctx):\n    app.config['WORLD_NAME'] = 'Special World'\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string('Hello {{ config.WORLD_NAME }} '\n                                      '{{ foo }}')\n    assert rv == 'Hello Special World 42'\n\n\ndef test_standard_context(app, client):\n    @app.route('\/')\n    def index():\n        flask.g.foo = 23\n        flask.session['test'] = 'aha'\n        return flask.render_template_string('''\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        ''')\n\n    rv = client.get('\/?foo=42')\n    assert rv.data.split() == [b'42', b'23', b'False', b'aha']\n\n\ndef test_escaping(app, client):\n    text = '<p>Hello World!'\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('escaping_template.html', text=text,\n                                     html=flask.Markup(text))\n\n    lines = client.get('\/').data.splitlines()\n    assert lines == [\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!'\n    ]\n\n\ndef test_no_escaping(app, client):\n    text = '<p>Hello World!'\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('non_escaping_template.txt', text=text,\n                                     html=flask.Markup(text))\n\n    lines = client.get('\/').data.splitlines()\n    assert lines == [\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!'\n    ]\n\n\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\n        '{{ foo }}', foo='<test>') == '&lt;test&gt;'\n    assert flask.render_template('mail.txt', foo='<test>') == '<test> Mail'\n\n\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute('_macro.html', 'hello')\n    assert macro('World') == 'Hello World!'\n\n\ndef test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\n\ndef test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\n\ndef test_template_filter_with_name(app):\n    @app.template_filter('strrev')\n    def my_reverse(s):\n        return s[::-1]\n\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\n\ndef test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, 'strrev')\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\n\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter('super_reverse')\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, 'super_reverse')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_template_test_with_name(app):\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, 'boolean')\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, 'boolean')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert 'get_stuff' in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals['get_stuff'] == get_stuff\n    assert app.jinja_env.globals['get_stuff'](), 42\n\n    rv = flask.render_template_string('{{ get_stuff() }}')\n    assert rv == '42'\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n            return DictLoader({'index.html': 'Hello Custom World!'})\n\n    app = MyFlask(__name__)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('index.html')\n\n    c = app.test_client()\n    rv = c.get('\/')\n    assert rv.data == b'Hello Custom World!'\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {'whiskey': 'Jameson'}\n\n    @app.route('\/')\n    def index():\n        return flask.render_template(\n            ['no_template.xml',  # should skip this one\n             'simple_template.html',  # should render this\n             'context_template.html'],\n            value=23)\n\n    rv = client.get('\/')\n    assert rv.data == b'<h1>Jameson<\/h1>'\n\n\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.jinja_env.auto_reload is True\n\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n\n    app.run()\n    assert app.templates_auto_reload == False\n    assert app.jinja_env.auto_reload == False\n\n    app.run(debug=True)\n    assert app.templates_auto_reload == True\n    assert app.jinja_env.auto_reload == True\n\n\ndef test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(x, record):\n            called.append(True)\n            text = str(record.msg)\n            assert '1: trying loader of application \"blueprintapp\"' in text\n            assert ('2: trying loader of blueprint \"admin\" '\n                    '(blueprintapp.apps.admin)') in text\n            assert ('trying loader of blueprint \"frontend\" '\n                    '(blueprintapp.apps.frontend)') in text\n            assert 'Error: the template could not be found' in text\n            assert ('looked up from an endpoint that belongs to '\n                    'the blueprint \"frontend\"') in text\n            assert 'See http:\/\/flask.pocoo.org\/docs\/blueprints\/#templates' in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, 'EXPLAIN_TEMPLATE_LOADING', True)\n        monkeypatch.setattr(\n            logging.getLogger('flask'), 'handlers', [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get('\/missing')\n\n        assert 'missing_template.html' in str(excinfo.value)\n\n    assert len(called) == 1\n\n\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.testing\n    ~~~~~~~~~~~~~\n\n    Test client and more.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\nimport werkzeug\n\nfrom flask._compat import text_type\nfrom flask.json import jsonify\nfrom flask.testing import make_test_environ_builder\n\n\ndef test_environ_defaults_from_config(app, client):\n    app.config['SERVER_NAME'] = 'example.com:1234'\n    app.config['APPLICATION_ROOT'] = '\/foo'\n\n    @app.route('\/')\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == 'http:\/\/example.com:1234\/foo\/'\n\n    rv = client.get('\/')\n    assert rv.data == b'http:\/\/example.com:1234\/foo\/'\n\n\ndef test_environ_defaults(app, client, app_ctx, req_ctx):\n    @app.route('\/')\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == 'http:\/\/localhost\/'\n    with client:\n        rv = client.get('\/')\n        assert rv.data == b'http:\/\/localhost\/'\n\n\ndef test_environ_base_default(app, client, app_ctx):\n    @app.route('\/')\n    def index():\n        flask.g.user_agent = flask.request.headers[\"User-Agent\"]\n        return flask.request.remote_addr\n\n    rv = client.get('\/')\n    assert rv.data == b'127.0.0.1'\n    assert flask.g.user_agent == 'werkzeug\/' + werkzeug.__version__\n\n\ndef test_environ_base_modified(app, client, app_ctx):\n    @app.route('\/')\n    def index():\n        flask.g.user_agent = flask.request.headers[\"User-Agent\"]\n        return flask.request.remote_addr\n\n    client.environ_base['REMOTE_ADDR'] = '0.0.0.0'\n    client.environ_base['HTTP_USER_AGENT'] = 'Foo'\n    rv = client.get('\/')\n    assert rv.data == b'0.0.0.0'\n    assert flask.g.user_agent == 'Foo'\n\n    client.environ_base['REMOTE_ADDR'] = '0.0.0.1'\n    client.environ_base['HTTP_USER_AGENT'] = 'Bar'\n    rv = client.get('\/')\n    assert rv.data == b'0.0.0.1'\n    assert flask.g.user_agent == 'Bar'\n\n\ndef test_client_open_environ(app, client, request):\n    @app.route('\/index')\n    def index():\n        return flask.request.remote_addr\n\n    builder = make_test_environ_builder(app, path='\/index', method='GET')\n    request.addfinalizer(builder.close)\n\n    rv = client.open(builder)\n    assert rv.data == b'127.0.0.1'\n\n    environ = builder.get_environ()\n    client.environ_base['REMOTE_ADDR'] = '127.0.0.2'\n    rv = client.open(environ)\n    assert rv.data == b'127.0.0.2'\n\n\ndef test_specify_url_scheme(app, client):\n    @app.route('\/')\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context(url_scheme='https')\n    assert ctx.request.url == 'https:\/\/localhost\/'\n\n    rv = client.get('\/', url_scheme='https')\n    assert rv.data == b'https:\/\/localhost\/'\n\n\ndef test_path_is_url(app):\n    eb = make_test_environ_builder(app, 'https:\/\/example.com\/')\n    assert eb.url_scheme == 'https'\n    assert eb.host == 'example.com'\n    assert eb.script_root == ''\n    assert eb.path == '\/'\n\n\ndef test_blueprint_with_subdomain(app, client):\n    app.config['SERVER_NAME'] = 'example.com:1234'\n    app.config['APPLICATION_ROOT'] = '\/foo'\n\n    bp = flask.Blueprint('company', __name__, subdomain='xxx')\n\n    @bp.route('\/')\n    def index():\n        return flask.request.url\n\n    app.register_blueprint(bp)\n\n    ctx = app.test_request_context('\/', subdomain='xxx')\n    assert ctx.request.url == 'http:\/\/xxx.example.com:1234\/foo\/'\n    assert ctx.request.blueprint == bp.name\n\n    rv = client.get('\/', subdomain='xxx')\n    assert rv.data == b'http:\/\/xxx.example.com:1234\/foo\/'\n\n\ndef test_redirect_keep_session(app, client, app_ctx):\n    @app.route('\/', methods=['GET', 'POST'])\n    def index():\n        if flask.request.method == 'POST':\n            return flask.redirect('\/getsession')\n        flask.session['data'] = 'foo'\n        return 'index'\n\n    @app.route('\/getsession')\n    def get_session():\n        return flask.session.get('data', '<missing>')\n\n    with client:\n        rv = client.get('\/getsession')\n        assert rv.data == b'<missing>'\n\n        rv = client.get('\/')\n        assert rv.data == b'index'\n        assert flask.session.get('data') == 'foo'\n        rv = client.post('\/', data={}, follow_redirects=True)\n        assert rv.data == b'foo'\n\n        # This support requires a new Werkzeug version\n        if not hasattr(client, 'redirect_client'):\n            assert flask.session.get('data') == 'foo'\n\n        rv = client.get('\/getsession')\n        assert rv.data == b'foo'\n\n\ndef test_session_transactions(app, client):\n    @app.route('\/')\n    def index():\n        return text_type(flask.session['foo'])\n\n    with client:\n        with client.session_transaction() as sess:\n            assert len(sess) == 0\n            sess['foo'] = [42]\n            assert len(sess) == 1\n        rv = client.get('\/')\n        assert rv.data == b'[42]'\n        with client.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess['foo'] == [42]\n\n\ndef test_session_transactions_no_null_sessions():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    with app.test_client() as c:\n        with pytest.raises(RuntimeError) as e:\n            with c.session_transaction() as sess:\n                pass\n        assert 'Session backend did not open a session' in str(e.value)\n\n\ndef test_session_transactions_keep_context(app, client, req_ctx):\n    rv = client.get('\/')\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()\n\n\ndef test_session_transaction_needs_cookies(app):\n    c = app.test_client(use_cookies=False)\n    with pytest.raises(RuntimeError) as e:\n        with c.session_transaction() as s:\n            pass\n    assert 'cookies' in str(e.value)\n\n\ndef test_test_client_context_binding(app, client):\n    app.testing = False\n\n    @app.route('\/')\n    def index():\n        flask.g.value = 42\n        return 'Hello World!'\n\n    @app.route('\/other')\n    def other():\n        1 \/\/ 0\n\n    with client:\n        resp = client.get('\/')\n        assert flask.g.value == 42\n        assert resp.data == b'Hello World!'\n        assert resp.status_code == 200\n\n        resp = client.get('\/other')\n        assert not hasattr(flask.g, 'value')\n        assert b'Internal Server Error' in resp.data\n        assert resp.status_code == 500\n        flask.g.value = 23\n\n    try:\n        flask.g.value\n    except (AttributeError, RuntimeError):\n        pass\n    else:\n        raise AssertionError('some kind of exception expected')\n\n\ndef test_reuse_client(client):\n    c = client\n\n    with c:\n        assert client.get('\/').status_code == 404\n\n    with c:\n        assert client.get('\/').status_code == 404\n\n\ndef test_test_client_calls_teardown_handlers(app, client):\n    called = []\n\n    @app.teardown_request\n    def remember(error):\n        called.append(error)\n\n    with client:\n        assert called == []\n        client.get('\/')\n        assert called == []\n    assert called == [None]\n\n    del called[:]\n    with client:\n        assert called == []\n        client.get('\/')\n        assert called == []\n        client.get('\/')\n        assert called == [None]\n    assert called == [None, None]\n\n\ndef test_full_url_request(app, client):\n    @app.route('\/action', methods=['POST'])\n    def action():\n        return 'x'\n\n    with client:\n        rv = client.post('http:\/\/domain.com\/action?vodka=42', data={'gin': 43})\n        assert rv.status_code == 200\n        assert 'gin' in flask.request.form\n        assert 'vodka' in flask.request.args\n\n\ndef test_json_request_and_response(app, client):\n    @app.route('\/echo', methods=['POST'])\n    def echo():\n        return jsonify(flask.request.get_json())\n\n    with client:\n        json_data = {'drink': {'gin': 1, 'tonic': True}, 'price': 10}\n        rv = client.post('\/echo', json=json_data)\n\n        # Request should be in JSON\n        assert flask.request.is_json\n        assert flask.request.get_json() == json_data\n\n        # Response should be in JSON\n        assert rv.status_code == 200\n        assert rv.is_json\n        assert rv.get_json() == json_data\n\n\ndef test_subdomain(app, client):\n    app.config['SERVER_NAME'] = 'example.com'\n\n    @app.route('\/', subdomain='<company_id>')\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for('view', company_id='xxx')\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b'xxx' == response.data\n\n\ndef test_nosubdomain(app, client):\n    app.config['SERVER_NAME'] = 'example.com'\n\n    @app.route('\/<company_id>')\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for('view', company_id='xxx')\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b'xxx' == response.data\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\ntests.test_user_error_handler\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom werkzeug.exceptions import (\n    Forbidden,\n    InternalServerError,\n    HTTPException,\n    NotFound\n    )\nimport flask\n\n\ndef test_error_handler_no_match(app, client):\n\n    class CustomException(Exception):\n        pass\n\n    @app.errorhandler(CustomException)\n    def custom_exception_handler(e):\n        assert isinstance(e, CustomException)\n        return 'custom'\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        return type(e).__name__\n\n    @app.route('\/custom')\n    def custom_test():\n        raise CustomException()\n\n    @app.route('\/keyerror')\n    def key_error():\n        raise KeyError()\n\n    app.testing = False\n    assert client.get('\/custom').data == b'custom'\n    assert client.get('\/keyerror').data == b'KeyError'\n\n\ndef test_error_handler_subclass(app):\n    class ParentException(Exception):\n        pass\n\n    class ChildExceptionUnregistered(ParentException):\n        pass\n\n    class ChildExceptionRegistered(ParentException):\n        pass\n\n    @app.errorhandler(ParentException)\n    def parent_exception_handler(e):\n        assert isinstance(e, ParentException)\n        return 'parent'\n\n    @app.errorhandler(ChildExceptionRegistered)\n    def child_exception_handler(e):\n        assert isinstance(e, ChildExceptionRegistered)\n        return 'child-registered'\n\n    @app.route('\/parent')\n    def parent_test():\n        raise ParentException()\n\n    @app.route('\/child-unregistered')\n    def unregistered_test():\n        raise ChildExceptionUnregistered()\n\n    @app.route('\/child-registered')\n    def registered_test():\n        raise ChildExceptionRegistered()\n\n    c = app.test_client()\n\n    assert c.get('\/parent').data == b'parent'\n    assert c.get('\/child-unregistered').data == b'parent'\n    assert c.get('\/child-registered').data == b'child-registered'\n\n\ndef test_error_handler_http_subclass(app):\n    class ForbiddenSubclassRegistered(Forbidden):\n        pass\n\n    class ForbiddenSubclassUnregistered(Forbidden):\n        pass\n\n    @app.errorhandler(403)\n    def code_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return 'forbidden'\n\n    @app.errorhandler(ForbiddenSubclassRegistered)\n    def subclass_exception_handler(e):\n        assert isinstance(e, ForbiddenSubclassRegistered)\n        return 'forbidden-registered'\n\n    @app.route('\/forbidden')\n    def forbidden_test():\n        raise Forbidden()\n\n    @app.route('\/forbidden-registered')\n    def registered_test():\n        raise ForbiddenSubclassRegistered()\n\n    @app.route('\/forbidden-unregistered')\n    def unregistered_test():\n        raise ForbiddenSubclassUnregistered()\n\n    c = app.test_client()\n\n    assert c.get('\/forbidden').data == b'forbidden'\n    assert c.get('\/forbidden-unregistered').data == b'forbidden'\n    assert c.get('\/forbidden-registered').data == b'forbidden-registered'\n\n\ndef test_error_handler_blueprint(app):\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.errorhandler(500)\n    def bp_exception_handler(e):\n        return 'bp-error'\n\n    @bp.route('\/error')\n    def bp_test():\n        raise InternalServerError()\n\n    @app.errorhandler(500)\n    def app_exception_handler(e):\n        return 'app-error'\n\n    @app.route('\/error')\n    def app_test():\n        raise InternalServerError()\n\n    app.register_blueprint(bp, url_prefix='\/bp')\n\n    c = app.test_client()\n\n    assert c.get('\/error').data == b'app-error'\n    assert c.get('\/bp\/error').data == b'bp-error'\n\n\ndef test_default_error_handler():\n    bp = flask.Blueprint('bp', __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return 'bp-default'\n\n    @bp.errorhandler(Forbidden)\n    def bp_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return 'bp-forbidden'\n\n    @bp.route('\/undefined')\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route('\/forbidden')\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_errorhandler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return 'default'\n\n    @app.errorhandler(Forbidden)\n    def catchall_errorhandler(e):\n        assert isinstance(e, Forbidden)\n        return 'forbidden'\n\n    @app.route('\/forbidden')\n    def forbidden():\n        raise Forbidden()\n\n    app.register_blueprint(bp, url_prefix='\/bp')\n\n    c = app.test_client()\n    assert c.get('\/bp\/undefined').data == b'bp-default'\n    assert c.get('\/bp\/forbidden').data == b'bp-forbidden'\n    assert c.get('\/undefined').data == b'default'\n    assert c.get('\/forbidden').data == b'forbidden'\n\n\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    Flaskr\n    ~~~~~~\n\n    A microblog example application written as Flask tutorial with\n    Flask and sqlite3.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom sqlite3 import dbapi2 as sqlite3\nfrom flask import Blueprint, request, session, g, redirect, url_for, abort, \\\n     render_template, flash, current_app\n\n\n# create our blueprint :)\nbp = Blueprint('flaskr', __name__)\n\n\ndef connect_db():\n    \"\"\"Connects to the specific database.\"\"\"\n    rv = sqlite3.connect(current_app.config['DATABASE'])\n    rv.row_factory = sqlite3.Row\n    return rv\n\n\ndef init_db():\n    \"\"\"Initializes the database.\"\"\"\n    db = get_db()\n    with current_app.open_resource('schema.sql', mode='r') as f:\n        db.cursor().executescript(f.read())\n    db.commit()\n\n\ndef get_db():\n    \"\"\"Opens a new database connection if there is none yet for the\n    current application context.\n    \"\"\"\n    if not hasattr(g, 'sqlite_db'):\n        g.sqlite_db = connect_db()\n    return g.sqlite_db\n\n\n@bp.route('\/')\ndef show_entries():\n    db = get_db()\n    cur = db.execute('select title, text from entries order by id desc')\n    entries = cur.fetchall()\n    return render_template('show_entries.html', entries=entries)\n\n\n@bp.route('\/add', methods=['POST'])\ndef add_entry():\n    if not session.get('logged_in'):\n        abort(401)\n    db = get_db()\n    db.execute('insert into entries (title, text) values (?, ?)',\n               [request.form['title'], request.form['text']])\n    db.commit()\n    flash('New entry was successfully posted')\n    return redirect(url_for('flaskr.show_entries'))\n\n\n@bp.route('\/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != current_app.config['USERNAME']:\n            error = 'Invalid username'\n        elif request.form['password'] != current_app.config['PASSWORD']:\n            error = 'Invalid password'\n        else:\n            session['logged_in'] = True\n            flash('You were logged in')\n            return redirect(url_for('flaskr.show_entries'))\n    return render_template('login.html', error=error)\n\n\n@bp.route('\/logout')\ndef logout():\n    session.pop('logged_in', None)\n    flash('You were logged out')\n    return redirect(url_for('flaskr.show_entries'))\n\n\"\"\"\nGenerate tests which test: revert copyright year to project start\nadd copyright header to files\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.views\n    ~~~~~~~~~~~\n\n    Pluggable views.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\nimport flask.views\n\nfrom werkzeug.http import parse_set_header\n\n\ndef common_test(app):\n    c = app.test_client()\n\n    assert c.get('\/').data == b'GET'\n    assert c.post('\/').data == b'POST'\n    assert c.put('\/').status_code == 405\n    meths = parse_set_header(c.open('\/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']\n\n\ndef test_basic_view(app):\n    class Index(flask.views.View):\n        methods = ['GET', 'POST']\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n    common_test(app)\n\n\ndef test_method_based_view(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return 'GET'\n\n        def post(self):\n            return 'POST'\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n    common_test(app)\n\n\ndef test_view_patching(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            1 \/\/ 0\n\n        def post(self):\n            1 \/\/ 0\n\n    class Other(Index):\n        def get(self):\n            return 'GET'\n\n        def post(self):\n            return 'POST'\n\n    view = Index.as_view('index')\n    view.view_class = Other\n    app.add_url_rule('\/', view_func=view)\n    common_test(app)\n\n\ndef test_view_inheritance(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return 'GET'\n\n        def post(self):\n            return 'POST'\n\n    class BetterIndex(Index):\n        def delete(self):\n            return 'DELETE'\n\n    app.add_url_rule('\/', view_func=BetterIndex.as_view('index'))\n\n    meths = parse_set_header(client.open('\/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST']\n\n\ndef test_view_decorators(app, client):\n    def add_x_parachute(f):\n        def new_function(*args, **kwargs):\n            resp = flask.make_response(f(*args, **kwargs))\n            resp.headers['X-Parachute'] = 'awesome'\n            return resp\n\n        return new_function\n\n    class Index(flask.views.View):\n        decorators = [add_x_parachute]\n\n        def dispatch_request(self):\n            return 'Awesome'\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n    rv = client.get('\/')\n    assert rv.headers['X-Parachute'] == 'awesome'\n    assert rv.data == b'Awesome'\n\n\ndef test_view_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    class Index1(flask.views.View):\n        provide_automatic_options = False\n\n        def dispatch_request(self):\n            return 'Hello World!'\n\n    app.add_url_rule('\/', view_func=Index1.as_view('index'))\n    c = app.test_client()\n    rv = c.open('\/', method='OPTIONS')\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    class Index2(flask.views.View):\n        methods = ['OPTIONS']\n        provide_automatic_options = True\n\n        def dispatch_request(self):\n            return 'Hello World!'\n\n    app.add_url_rule('\/', view_func=Index2.as_view('index'))\n    c = app.test_client()\n    rv = c.open('\/', method='OPTIONS')\n    assert sorted(rv.allow) == ['OPTIONS']\n\n    app = flask.Flask(__name__)\n\n    class Index3(flask.views.View):\n        def dispatch_request(self):\n            return 'Hello World!'\n\n    app.add_url_rule('\/', view_func=Index3.as_view('index'))\n    c = app.test_client()\n    rv = c.open('\/', method='OPTIONS')\n    assert 'OPTIONS' in rv.allow\n\n\ndef test_implicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return flask.Response('Blub', headers={\n                'X-Method': flask.request.method\n            })\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n    rv = client.get('\/')\n    assert rv.data == b'Blub'\n    assert rv.headers['X-Method'] == 'GET'\n    rv = client.head('\/')\n    assert rv.data == b''\n    assert rv.headers['X-Method'] == 'HEAD'\n\n\ndef test_explicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return 'GET'\n\n        def head(self):\n            return flask.Response('', headers={'X-Method': 'HEAD'})\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n    rv = client.get('\/')\n    assert rv.data == b'GET'\n    rv = client.head('\/')\n    assert rv.data == b''\n    assert rv.headers['X-Method'] == 'HEAD'\n\n\ndef test_endpoint_override(app):\n    app.debug = True\n\n    class Index(flask.views.View):\n        methods = ['GET', 'POST']\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n    with pytest.raises(AssertionError):\n        app.add_url_rule('\/', view_func=Index.as_view('index'))\n\n    # But these tests should still pass. We just log a warning.\n    common_test(app)\n\n\ndef test_multiple_inheritance(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return 'GET'\n\n    class DeleteView(flask.views.MethodView):\n        def delete(self):\n            return 'DELETE'\n\n    class GetDeleteView(GetView, DeleteView):\n        pass\n\n    app.add_url_rule('\/', view_func=GetDeleteView.as_view('index'))\n\n    assert client.get('\/').data == b'GET'\n    assert client.delete('\/').data == b'DELETE'\n    assert sorted(GetDeleteView.methods) == ['DELETE', 'GET']\n\n\ndef test_remove_method_from_parent(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return 'GET'\n\n    class OtherView(flask.views.MethodView):\n        def post(self):\n            return 'POST'\n\n    class View(GetView, OtherView):\n        methods = ['GET']\n\n    app.add_url_rule('\/', view_func=View.as_view('index'))\n\n    assert client.get('\/').data == b'GET'\n    assert client.post('\/').status_code == 405\n    assert sorted(View.methods) == ['GET']\n"}
{"prompt":"Python3\nfrom flask import (\n    Blueprint, flash, g, redirect, render_template, request, url_for\n)\nfrom werkzeug.exceptions import abort\n\nfrom flaskr.auth import login_required\nfrom flaskr.db import get_db\n\nbp = Blueprint('blog', __name__)\n\n\n@bp.route('\/')\ndef index():\n    \"\"\"Show all the posts, most recent first.\"\"\"\n    db = get_db()\n    posts = db.execute(\n        'SELECT p.id, title, body, created, author_id, username'\n        ' FROM post p JOIN user u ON p.author_id = u.id'\n        ' ORDER BY created DESC'\n    ).fetchall()\n    return render_template('blog\/index.html', posts=posts)\n\n\ndef get_post(id, check_author=True):\n    \"\"\"Get a post and its author by id.\n\n    Checks that the id exists and optionally that the current user is\n    the author.\n\n    :param id: id of post to get\n    :param check_author: require the current user to be the author\n    :return: the post with author information\n    :raise 404: if a post with the given id doesn't exist\n    :raise 403: if the current user isn't the author\n    \"\"\"\n    post = get_db().execute(\n        'SELECT p.id, title, body, created, author_id, username'\n        ' FROM post p JOIN user u ON p.author_id = u.id'\n        ' WHERE p.id = ?',\n        (id,)\n    ).fetchone()\n\n    if post is None:\n        abort(404, \"Post id {0} doesn't exist.\".format(id))\n\n    if check_author and post['author_id'] != g.user['id']:\n        abort(403)\n\n    return post\n\n\n@bp.route('\/create', methods=('GET', 'POST'))\n@login_required\ndef create():\n    \"\"\"Create a new post for the current user.\"\"\"\n    if request.method == 'POST':\n        title = request.form['title']\n        body = request.form['body']\n        error = None\n\n        if not title:\n            error = 'Title is required.'\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                'INSERT INTO post (title, body, author_id)'\n                ' VALUES (?, ?, ?)',\n                (title, body, g.user['id'])\n            )\n            db.commit()\n            return redirect(url_for('blog.index'))\n\n    return render_template('blog\/create.html')\n\n\n@bp.route('\/<int:id>\/update', methods=('GET', 'POST'))\n@login_required\ndef update(id):\n    \"\"\"Update a post if the current user is the author.\"\"\"\n    post = get_post(id)\n\n    if request.method == 'POST':\n        title = request.form['title']\n        body = request.form['body']\n        error = None\n\n        if not title:\n            error = 'Title is required.'\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                'UPDATE post SET title = ?, body = ? WHERE id = ?',\n                (title, body, id)\n            )\n            db.commit()\n            return redirect(url_for('blog.index'))\n\n    return render_template('blog\/update.html', post=post)\n\n\n@bp.route('\/<int:id>\/delete', methods=('POST',))\n@login_required\ndef delete(id):\n    \"\"\"Delete a post.\n\n    Ensures that the post exists and that the logged in user is the\n    author of the post.\n    \"\"\"\n    get_post(id)\n    db = get_db()\n    db.execute('DELETE FROM post WHERE id = ?', (id,))\n    db.commit()\n    return redirect(url_for('blog.index'))\n\n\"\"\"\nGenerate tests which test: rewrite tutorial docs and example\n\"\"\"\n","completion":" import pytest\nfrom flask import g, session\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get('\/auth\/register').status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\n        '\/auth\/register', data={'username': 'a', 'password': 'a'}\n    )\n    assert 'http:\/\/localhost\/auth\/login' == response.headers['Location']\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert get_db().execute(\n            \"select * from user where username = 'a'\",\n        ).fetchone() is not None\n\n\n@pytest.mark.parametrize(('username', 'password', 'message'), (\n    ('', '', b'Username is required.'),\n    ('a', '', b'Password is required.'),\n    ('test', 'test', b'already registered'),\n))\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        '\/auth\/register',\n        data={'username': username, 'password': password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get('\/auth\/login').status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers['Location'] == 'http:\/\/localhost\/'\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get('\/')\n        assert session['user_id'] == 1\n        assert g.user['username'] == 'test'\n\n\n@pytest.mark.parametrize(('username', 'password', 'message'), (\n    ('a', 'test', b'Incorrect username.'),\n    ('test', 'a', b'Incorrect password.'),\n))\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert 'user_id' not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.jsonimpl\n    ~~~~~~~~~~~~~~\n\n    Implementation helpers for the JSON support in Flask.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport codecs\nimport io\nimport uuid\nfrom datetime import date\nfrom .globals import current_app, request\nfrom ._compat import text_type, PY2\n\nfrom werkzeug.http import http_date\nfrom jinja2 import Markup\n\n# Use the same json implementation as itsdangerous on which we\n# depend anyways.\nfrom itsdangerous import json as _json\n\n\n# Figure out if simplejson escapes slashes.  This behavior was changed\n# from one version to another without reason.\n_slash_escape = '\\\\\/' not in _json.dumps('\/')\n\n\n__all__ = ['dump', 'dumps', 'load', 'loads', 'htmlsafe_dump',\n           'htmlsafe_dumps', 'JSONDecoder', 'JSONEncoder',\n           'jsonify']\n\n\ndef _wrap_reader_for_text(fp, encoding):\n    if isinstance(fp.read(0), bytes):\n        fp = io.TextIOWrapper(io.BufferedReader(fp), encoding)\n    return fp\n\n\ndef _wrap_writer_for_text(fp, encoding):\n    try:\n        fp.write('')\n    except TypeError:\n        fp = io.TextIOWrapper(fp, encoding)\n    return fp\n\n\nclass JSONEncoder(_json.JSONEncoder):\n    \"\"\"The default Flask JSON encoder.  This one extends the default simplejson\n    encoder by also supporting ``datetime`` objects, ``UUID`` as well as\n    ``Markup`` objects which are serialized as RFC 822 datetime strings (same\n    as the HTTP date format).  In order to support more data types override the\n    :meth:`default` method.\n    \"\"\"\n\n    def default(self, o):\n        \"\"\"Implement this method in a subclass such that it returns a\n        serializable object for ``o``, or calls the base implementation (to\n        raise a :exc:`TypeError`).\n\n        For example, to support arbitrary iterators, you could implement\n        default like this::\n\n            def default(self, o):\n                try:\n                    iterable = iter(o)\n                except TypeError:\n                    pass\n                else:\n                    return list(iterable)\n                return JSONEncoder.default(self, o)\n        \"\"\"\n        if isinstance(o, date):\n            return http_date(o.timetuple())\n        if isinstance(o, uuid.UUID):\n            return str(o)\n        if hasattr(o, '__html__'):\n            return text_type(o.__html__())\n        return _json.JSONEncoder.default(self, o)\n\n\nclass JSONDecoder(_json.JSONDecoder):\n    \"\"\"The default JSON decoder.  This one does not change the behavior from\n    the default simplejson decoder.  Consult the :mod:`json` documentation\n    for more information.  This decoder is not only used for the load\n    functions of this module but also :attr:`~flask.Request`.\n    \"\"\"\n\n\ndef _dump_arg_defaults(kwargs):\n    \"\"\"Inject default arguments for dump functions.\"\"\"\n    if current_app:\n        kwargs.setdefault('cls', current_app.json_encoder)\n        if not current_app.config['JSON_AS_ASCII']:\n            kwargs.setdefault('ensure_ascii', False)\n        kwargs.setdefault('sort_keys', current_app.config['JSON_SORT_KEYS'])\n    else:\n        kwargs.setdefault('sort_keys', True)\n        kwargs.setdefault('cls', JSONEncoder)\n\n\ndef _load_arg_defaults(kwargs):\n    \"\"\"Inject default arguments for load functions.\"\"\"\n    if current_app:\n        kwargs.setdefault('cls', current_app.json_decoder)\n    else:\n        kwargs.setdefault('cls', JSONDecoder)\n\n\ndef detect_encoding(data):\n    \"\"\"Detect which UTF codec was used to encode the given bytes.\n\n    The latest JSON standard (:rfc:`8259`) suggests that only UTF-8 is\n    accepted. Older documents allowed 8, 16, or 32. 16 and 32 can be big\n    or little endian. Some editors or libraries may prepend a BOM.\n\n    :param data: Bytes in unknown UTF encoding.\n    :return: UTF encoding name\n    \"\"\"\n    head = data[:4]\n\n    if head[:3] == codecs.BOM_UTF8:\n        return 'utf-8-sig'\n\n    if b'\\x00' not in head:\n        return 'utf-8'\n\n    if head in (codecs.BOM_UTF32_BE, codecs.BOM_UTF32_LE):\n        return 'utf-32'\n\n    if head[:2] in (codecs.BOM_UTF16_BE, codecs.BOM_UTF16_LE):\n        return 'utf-16'\n\n    if len(head) == 4:\n        if head[:3] == b'\\x00\\x00\\x00':\n            return 'utf-32-be'\n\n        if head[::2] == b'\\x00\\x00':\n            return 'utf-16-be'\n\n        if head[1:] == b'\\x00\\x00\\x00':\n            return 'utf-32-le'\n\n        if head[1::2] == b'\\x00\\x00':\n            return 'utf-16-le'\n\n    if len(head) == 2:\n        return 'utf-16-be' if head.startswith(b'\\x00') else 'utf-16-le'\n\n    return 'utf-8'\n\n\ndef dumps(obj, **kwargs):\n    \"\"\"Serialize ``obj`` to a JSON formatted ``str`` by using the application's\n    configured encoder (:attr:`~flask.Flask.json_encoder`) if there is an\n    application on the stack.\n\n    This function can return ``unicode`` strings or ascii-only bytestrings by\n    default which coerce into unicode strings automatically.  That behavior by\n    default is controlled by the ``JSON_AS_ASCII`` configuration variable\n    and can be overridden by the simplejson ``ensure_ascii`` parameter.\n    \"\"\"\n    _dump_arg_defaults(kwargs)\n    encoding = kwargs.pop('encoding', None)\n    rv = _json.dumps(obj, **kwargs)\n    if encoding is not None and isinstance(rv, text_type):\n        rv = rv.encode(encoding)\n    return rv\n\n\ndef dump(obj, fp, **kwargs):\n    \"\"\"Like :func:`dumps` but writes into a file object.\"\"\"\n    _dump_arg_defaults(kwargs)\n    encoding = kwargs.pop('encoding', None)\n    if encoding is not None:\n        fp = _wrap_writer_for_text(fp, encoding)\n    _json.dump(obj, fp, **kwargs)\n\n\ndef loads(s, **kwargs):\n    \"\"\"Unserialize a JSON object from a string ``s`` by using the application's\n    configured decoder (:attr:`~flask.Flask.json_decoder`) if there is an\n    application on the stack.\n    \"\"\"\n    _load_arg_defaults(kwargs)\n    if isinstance(s, bytes):\n        encoding = kwargs.pop('encoding', None)\n        if encoding is None:\n            encoding = detect_encoding(s)\n        s = s.decode(encoding)\n    return _json.loads(s, **kwargs)\n\n\ndef load(fp, **kwargs):\n    \"\"\"Like :func:`loads` but reads from a file object.\n    \"\"\"\n    _load_arg_defaults(kwargs)\n    if not PY2:\n        fp = _wrap_reader_for_text(fp, kwargs.pop('encoding', None) or 'utf-8')\n    return _json.load(fp, **kwargs)\n\n\ndef htmlsafe_dumps(obj, **kwargs):\n    \"\"\"Works exactly like :func:`dumps` but is safe for use in ``<script>``\n    tags.  It accepts the same arguments and returns a JSON string.  Note that\n    this is available in templates through the ``|tojson`` filter which will\n    also mark the result as safe.  Due to how this function escapes certain\n    characters this is safe even if used outside of ``<script>`` tags.\n\n    The following characters are escaped in strings:\n\n    -   ``<``\n    -   ``>``\n    -   ``&``\n    -   ``'``\n\n    This makes it safe to embed such strings in any place in HTML with the\n    notable exception of double quoted attributes.  In that case single\n    quote your attributes or HTML escape it in addition.\n\n    .. versionchanged:: 0.10\n       This function's return value is now always safe for HTML usage, even\n       if outside of script tags or if used in XHTML.  This rule does not\n       hold true when using this function in HTML attributes that are double\n       quoted.  Always single quote attributes if you use the ``|tojson``\n       filter.  Alternatively use ``|tojson|forceescape``.\n    \"\"\"\n    rv = dumps(obj, **kwargs) \\\n        .replace(u'<', u'\\\\u003c') \\\n        .replace(u'>', u'\\\\u003e') \\\n        .replace(u'&', u'\\\\u0026') \\\n        .replace(u\"'\", u'\\\\u0027')\n    if not _slash_escape:\n        rv = rv.replace('\\\\\/', '\/')\n    return rv\n\n\ndef htmlsafe_dump(obj, fp, **kwargs):\n    \"\"\"Like :func:`htmlsafe_dumps` but writes into a file object.\"\"\"\n    fp.write(text_type(htmlsafe_dumps(obj, **kwargs)))\n\n\ndef jsonify(*args, **kwargs):\n    \"\"\"This function wraps :func:`dumps` to add a few enhancements that make\n    life easier.  It turns the JSON output into a :class:`~flask.Response`\n    object with the :mimetype:`application\/json` mimetype.  For convenience, it\n    also converts multiple arguments into an array or multiple keyword arguments\n    into a dict.  This means that both ``jsonify(1,2,3)`` and\n    ``jsonify([1,2,3])`` serialize to ``[1,2,3]``.\n\n    For clarity, the JSON serialization behavior has the following differences\n    from :func:`dumps`:\n\n    1. Single argument: Passed straight through to :func:`dumps`.\n    2. Multiple arguments: Converted to an array before being passed to\n       :func:`dumps`.\n    3. Multiple keyword arguments: Converted to a dict before being passed to\n       :func:`dumps`.\n    4. Both args and kwargs: Behavior undefined and will throw an exception.\n\n    Example usage::\n\n        from flask import jsonify\n\n        @app.route('\/_get_current_user')\n        def get_current_user():\n            return jsonify(username=g.user.username,\n                           email=g.user.email,\n                           id=g.user.id)\n\n    This will send a JSON response like this to the browser::\n\n        {\n            \"username\": \"admin\",\n            \"email\": \"admin@localhost\",\n            \"id\": 42\n        }\n\n\n    .. versionchanged:: 0.11\n       Added support for serializing top-level arrays. This introduces a\n       security risk in ancient browsers. See :ref:`json-security` for details.\n\n    This function's response will be pretty printed if it was not requested\n    with ``X-Requested-With: XMLHttpRequest`` to simplify debugging unless\n    the ``JSONIFY_PRETTYPRINT_REGULAR`` config parameter is set to false.\n    Compressed (not pretty) formatting currently means no indents and no\n    spaces after separators.\n\n    .. versionadded:: 0.2\n    \"\"\"\n\n    indent = None\n    separators = (',', ':')\n\n    if current_app.config['JSONIFY_PRETTYPRINT_REGULAR'] and not request.is_xhr:\n        indent = 2\n        separators = (', ', ': ')\n\n    if args and kwargs:\n        raise TypeError('jsonify() behavior undefined when passed both args and kwargs')\n    elif len(args) == 1:  # single args are passed directly to dumps()\n        data = args[0]\n    else:\n        data = args or kwargs\n\n    return current_app.response_class(\n        (dumps(data, indent=indent, separators=separators), '\\n'),\n        mimetype=current_app.config['JSONIFY_MIMETYPE']\n    )\n\n\ndef tojson_filter(obj, **kwargs):\n    return Markup(htmlsafe_dumps(obj, **kwargs))\n\n\"\"\"\nGenerate tests which test: detect UTF encodings when loading json\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.helpers\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Various helpers.\n\n    :copyright: (c) 2015 by Armin Ronacher.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport os\nimport uuid\nimport datetime\n\nimport flask\nfrom logging import StreamHandler\nfrom werkzeug.datastructures import Range\nfrom werkzeug.exceptions import BadRequest, NotFound\nfrom werkzeug.http import parse_cache_control_header, parse_options_header\nfrom werkzeug.http import http_date\n\nfrom flask import json\nfrom flask._compat import StringIO, text_type\n\n\ndef has_encoding(name):\n    try:\n        import codecs\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n\n\nclass TestJSON(object):\n    @pytest.mark.parametrize('value', (\n        1, 't', True, False, None,\n        [], [1, 2, 3],\n        {}, {'foo': u'\ud83d\udc0d'},\n    ))\n    @pytest.mark.parametrize('encoding', (\n        'utf-8', 'utf-8-sig',\n        'utf-16-le', 'utf-16-be', 'utf-16',\n        'utf-32-le', 'utf-32-be', 'utf-32',\n    ))\n    def test_detect_encoding(self, value, encoding):\n        data = json.dumps(value).encode(encoding)\n        assert json.detect_encoding(data) == encoding\n        assert json.loads(data) == value\n\n    def test_ignore_cached_json(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context('\/', method='POST', data='malformed',\n                                      content_type='application\/json'):\n            assert flask.request.get_json(silent=True, cache=True) is None\n            with pytest.raises(BadRequest):\n                flask.request.get_json(silent=False, cache=False)\n\n    def test_post_empty_json_adds_exception_to_response_content_in_debug(self):\n        app = flask.Flask(__name__)\n        app.config['DEBUG'] = True\n        @app.route('\/json', methods=['POST'])\n        def post_json():\n            flask.request.get_json()\n            return None\n        c = app.test_client()\n        rv = c.post('\/json', data=None, content_type='application\/json')\n        assert rv.status_code == 400\n        assert b'Failed to decode JSON object' in rv.data\n\n    def test_post_empty_json_wont_add_exception_to_response_if_no_debug(self):\n        app = flask.Flask(__name__)\n        app.config['DEBUG'] = False\n        @app.route('\/json', methods=['POST'])\n        def post_json():\n            flask.request.get_json()\n            return None\n        c = app.test_client()\n        rv = c.post('\/json', data=None, content_type='application\/json')\n        assert rv.status_code == 400\n        assert b'Failed to decode JSON object' not in rv.data\n\n    def test_json_bad_requests(self):\n        app = flask.Flask(__name__)\n        @app.route('\/json', methods=['POST'])\n        def return_json():\n            return flask.jsonify(foo=text_type(flask.request.get_json()))\n        c = app.test_client()\n        rv = c.post('\/json', data='malformed', content_type='application\/json')\n        assert rv.status_code == 400\n\n    def test_json_custom_mimetypes(self):\n        app = flask.Flask(__name__)\n        @app.route('\/json', methods=['POST'])\n        def return_json():\n            return flask.request.get_json()\n        c = app.test_client()\n        rv = c.post('\/json', data='\"foo\"', content_type='application\/x+json')\n        assert rv.data == b'foo'\n\n    def test_json_as_unicode(self):\n        app = flask.Flask(__name__)\n\n        app.config['JSON_AS_ASCII'] = True\n        with app.app_context():\n            rv = flask.json.dumps(u'\\N{SNOWMAN}')\n            assert rv == '\"\\\\u2603\"'\n\n        app.config['JSON_AS_ASCII'] = False\n        with app.app_context():\n            rv = flask.json.dumps(u'\\N{SNOWMAN}')\n            assert rv == u'\"\\u2603\"'\n\n    def test_json_dump_to_file(self):\n        app = flask.Flask(__name__)\n        test_data = {'name': 'Flask'}\n        out = StringIO()\n\n        with app.app_context():\n            flask.json.dump(test_data, out)\n            out.seek(0)\n            rv = flask.json.load(out)\n            assert rv == test_data\n\n    @pytest.mark.parametrize('test_value', [0, -1, 1, 23, 3.14, 's', \"longer string\", True, False, None])\n    def test_jsonify_basic_types(self, test_value):\n        \"\"\"Test jsonify with basic types.\"\"\"\n        app = flask.Flask(__name__)\n        c = app.test_client()\n\n        url = '\/jsonify_basic_types'\n        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n        rv = c.get(url)\n        assert rv.mimetype == 'application\/json'\n        assert flask.json.loads(rv.data) == test_value\n\n    def test_jsonify_dicts(self):\n        \"\"\"Test jsonify with dicts and kwargs unpacking.\"\"\"\n        d = dict(\n            a=0, b=23, c=3.14, d='t', e='Hi', f=True, g=False,\n            h=['test list', 10, False],\n            i={'test':'dict'}\n        )\n        app = flask.Flask(__name__)\n        @app.route('\/kw')\n        def return_kwargs():\n            return flask.jsonify(**d)\n        @app.route('\/dict')\n        def return_dict():\n            return flask.jsonify(d)\n        c = app.test_client()\n        for url in '\/kw', '\/dict':\n            rv = c.get(url)\n            assert rv.mimetype == 'application\/json'\n            assert flask.json.loads(rv.data) == d\n\n    def test_jsonify_arrays(self):\n        \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n        l = [\n            0, 42, 3.14, 't', 'hello', True, False,\n            ['test list', 2, False],\n            {'test':'dict'}\n        ]\n        app = flask.Flask(__name__)\n        @app.route('\/args_unpack')\n        def return_args_unpack():\n            return flask.jsonify(*l)\n        @app.route('\/array')\n        def return_array():\n            return flask.jsonify(l)\n        c = app.test_client()\n        for url in '\/args_unpack', '\/array':\n            rv = c.get(url)\n            assert rv.mimetype == 'application\/json'\n            assert flask.json.loads(rv.data) == l\n\n    def test_jsonify_date_types(self):\n        \"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"\n        test_dates = (\n            datetime.datetime(1973, 3, 11, 6, 30, 45),\n            datetime.date(1975, 1, 5)\n        )\n        app = flask.Flask(__name__)\n        c = app.test_client()\n\n        for i, d in enumerate(test_dates):\n            url = '\/datetest{0}'.format(i)\n            app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n            rv = c.get(url)\n            assert rv.mimetype == 'application\/json'\n            assert flask.json.loads(rv.data)['x'] == http_date(d.timetuple())\n\n    def test_jsonify_uuid_types(self):\n        \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n        test_uuid = uuid.UUID(bytes=b'\\xDE\\xAD\\xBE\\xEF' * 4)\n        app = flask.Flask(__name__)\n        url = '\/uuid_test'\n        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n        c = app.test_client()\n        rv = c.get(url)\n\n        rv_x = flask.json.loads(rv.data)['x']\n        assert rv_x == str(test_uuid)\n        rv_uuid = uuid.UUID(rv_x)\n        assert rv_uuid == test_uuid\n\n    def test_json_attr(self):\n        app = flask.Flask(__name__)\n        @app.route('\/add', methods=['POST'])\n        def add():\n            json = flask.request.get_json()\n            return text_type(json['a'] + json['b'])\n        c = app.test_client()\n        rv = c.post('\/add', data=flask.json.dumps({'a': 1, 'b': 2}),\n                            content_type='application\/json')\n        assert rv.data == b'3'\n\n    def test_template_escaping(self):\n        app = flask.Flask(__name__)\n        render = flask.render_template_string\n        with app.test_request_context():\n            rv = flask.json.htmlsafe_dumps('<\/script>')\n            assert rv == u'\"\\\\u003c\/script\\\\u003e\"'\n            assert type(rv) == text_type\n            rv = render('{{ \"<\/script>\"|tojson }}')\n            assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n            rv = render('{{ \"<\\0\/script>\"|tojson }}')\n            assert rv == '\"\\\\u003c\\\\u0000\/script\\\\u003e\"'\n            rv = render('{{ \"<!--<script>\"|tojson }}')\n            assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n            rv = render('{{ \"&\"|tojson }}')\n            assert rv == '\"\\\\u0026\"'\n            rv = render('{{ \"\\'\"|tojson }}')\n            assert rv == '\"\\\\u0027\"'\n            rv = render(\"<a ng-data='{{ data|tojson }}'><\/a>\",\n                data={'x': [\"foo\", \"bar\", \"baz'\"]})\n            assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'><\/a>'\n\n    def test_json_customization(self):\n        class X(object):\n            def __init__(self, val):\n                self.val = val\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return '<%d>' % o.val\n                return flask.json.JSONEncoder.default(self, o)\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault('object_hook', self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n            def object_hook(self, obj):\n                if len(obj) == 1 and '_foo' in obj:\n                    return X(obj['_foo'])\n                return obj\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n        @app.route('\/', methods=['POST'])\n        def index():\n            return flask.json.dumps(flask.request.get_json()['x'])\n        c = app.test_client()\n        rv = c.post('\/', data=flask.json.dumps({\n            'x': {'_foo': 42}\n        }), content_type='application\/json')\n        assert rv.data == b'\"<42>\"'\n\n    def test_modified_url_encoding(self):\n        class ModifiedRequest(flask.Request):\n            url_charset = 'euc-kr'\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.request_class = ModifiedRequest\n        app.url_map.charset = 'euc-kr'\n\n        @app.route('\/')\n        def index():\n            return flask.request.args['foo']\n\n        rv = app.test_client().get(u'\/?foo=\uc815\uc0c1\ucc98\ub9ac'.encode('euc-kr'))\n        assert rv.status_code == 200\n        assert rv.data == u'\uc815\uc0c1\ucc98\ub9ac'.encode('utf-8')\n\n    if not has_encoding('euc-kr'):\n        test_modified_url_encoding = None\n\n    def test_json_key_sorting(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        assert app.config['JSON_SORT_KEYS'] == True\n        d = dict.fromkeys(range(20), 'foo')\n\n        @app.route('\/')\n        def index():\n            return flask.jsonify(values=d)\n\n        c = app.test_client()\n        rv = c.get('\/')\n        lines = [x.strip() for x in rv.data.strip().decode('utf-8').splitlines()]\n        sorted_by_str = [\n            '{',\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\"',\n            '}',\n            '}'\n        ]\n        sorted_by_int = [\n            '{',\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\"',\n            '}',\n            '}'\n        ]\n\n        try:\n            assert lines == sorted_by_int\n        except AssertionError:\n            assert lines == sorted_by_str\n\nclass TestSendfile(object):\n\n    def test_send_file_regular(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.send_file('static\/index.html')\n            assert rv.direct_passthrough\n            assert rv.mimetype == 'text\/html'\n            with app.open_resource('static\/index.html') as f:\n                rv.direct_passthrough = False\n                assert rv.data == f.read()\n            rv.close()\n\n    def test_send_file_xsendfile(self, catch_deprecation_warnings):\n        app = flask.Flask(__name__)\n        app.use_x_sendfile = True\n        with app.test_request_context():\n            rv = flask.send_file('static\/index.html')\n            assert rv.direct_passthrough\n            assert 'x-sendfile' in rv.headers\n            assert rv.headers['x-sendfile'] == \\\n                os.path.join(app.root_path, 'static\/index.html')\n            assert rv.mimetype == 'text\/html'\n            rv.close()\n\n    def test_send_file_last_modified(self):\n        app = flask.Flask(__name__)\n        last_modified = datetime.datetime(1999, 1, 1)\n\n        @app.route('\/')\n        def index():\n            return flask.send_file(StringIO(\"party like it's\"),\n                                   last_modified=last_modified,\n                                   mimetype='text\/plain')\n\n        c = app.test_client()\n        rv = c.get('\/')\n        assert rv.last_modified == last_modified\n\n    def test_send_file_object_without_mimetype(self):\n        app = flask.Flask(__name__)\n\n        with app.test_request_context():\n            with pytest.raises(ValueError) as excinfo:\n                flask.send_file(StringIO(\"LOL\"))\n            assert 'Unable to infer MIME-type' in str(excinfo)\n            assert 'no filename is available' in str(excinfo)\n\n        with app.test_request_context():\n            flask.send_file(StringIO(\"LOL\"), attachment_filename='filename')\n\n    def test_send_file_object(self):\n        app = flask.Flask(__name__)\n\n        with app.test_request_context():\n            with open(os.path.join(app.root_path, 'static\/index.html'), mode='rb') as f:\n                rv = flask.send_file(f, mimetype='text\/html')\n                rv.direct_passthrough = False\n                with app.open_resource('static\/index.html') as f:\n                    assert rv.data == f.read()\n                assert rv.mimetype == 'text\/html'\n                rv.close()\n\n        app.use_x_sendfile = True\n\n        with app.test_request_context():\n            with open(os.path.join(app.root_path, 'static\/index.html')) as f:\n                rv = flask.send_file(f, mimetype='text\/html')\n                assert rv.mimetype == 'text\/html'\n                assert 'x-sendfile' not in rv.headers\n                rv.close()\n\n        app.use_x_sendfile = False\n        with app.test_request_context():\n            f = StringIO('Test')\n            rv = flask.send_file(f, mimetype='application\/octet-stream')\n            rv.direct_passthrough = False\n            assert rv.data == b'Test'\n            assert rv.mimetype == 'application\/octet-stream'\n            rv.close()\n\n            class PyStringIO(object):\n                def __init__(self, *args, **kwargs):\n                    self._io = StringIO(*args, **kwargs)\n                def __getattr__(self, name):\n                    return getattr(self._io, name)\n            f = PyStringIO('Test')\n            f.name = 'test.txt'\n            rv = flask.send_file(f, attachment_filename=f.name)\n            rv.direct_passthrough = False\n            assert rv.data == b'Test'\n            assert rv.mimetype == 'text\/plain'\n            rv.close()\n\n            f = StringIO('Test')\n            rv = flask.send_file(f, mimetype='text\/plain')\n            rv.direct_passthrough = False\n            assert rv.data == b'Test'\n            assert rv.mimetype == 'text\/plain'\n            rv.close()\n\n        app.use_x_sendfile = True\n\n        with app.test_request_context():\n            f = StringIO('Test')\n            rv = flask.send_file(f, mimetype='text\/html')\n            assert 'x-sendfile' not in rv.headers\n            rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, 'to_content_range_header', None)),\n        reason=\"not implemented within werkzeug\"\n    )\n    def test_send_file_range_request(self):\n        app = flask.Flask(__name__)\n\n        @app.route('\/')\n        def index():\n            return flask.send_file('static\/index.html', conditional=True)\n\n        c = app.test_client()\n\n        rv = c.get('\/', headers={'Range': 'bytes=4-15'})\n        assert rv.status_code == 206\n        with app.open_resource('static\/index.html') as f:\n            assert rv.data == f.read()[4:16]\n        rv.close()\n\n        rv = c.get('\/', headers={'Range': 'bytes=4-'})\n        assert rv.status_code == 206\n        with app.open_resource('static\/index.html') as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = c.get('\/', headers={'Range': 'bytes=4-1000'})\n        assert rv.status_code == 206\n        with app.open_resource('static\/index.html') as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = c.get('\/', headers={'Range': 'bytes=-10'})\n        assert rv.status_code == 206\n        with app.open_resource('static\/index.html') as f:\n            assert rv.data == f.read()[-10:]\n        rv.close()\n\n        rv = c.get('\/', headers={'Range': 'bytes=1000-'})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = c.get('\/', headers={'Range': 'bytes=-'})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = c.get('\/', headers={'Range': 'somethingsomething'})\n        assert rv.status_code == 416\n        rv.close()\n\n        last_modified = datetime.datetime.utcfromtimestamp(os.path.getmtime(\n            os.path.join(app.root_path, 'static\/index.html'))).replace(\n            microsecond=0)\n\n        rv = c.get('\/', headers={'Range': 'bytes=4-15',\n                                 'If-Range': http_date(last_modified)})\n        assert rv.status_code == 206\n        rv.close()\n\n        rv = c.get('\/', headers={'Range': 'bytes=4-15', 'If-Range': http_date(\n            datetime.datetime(1999, 1, 1))})\n        assert rv.status_code == 200\n        rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, 'to_content_range_header', None)),\n        reason=\"not implemented within werkzeug\"\n    )\n    def test_send_file_range_request_xsendfile_invalid(self):\n        # https:\/\/github.com\/pallets\/flask\/issues\/2526\n        app = flask.Flask(__name__)\n        app.use_x_sendfile = True\n\n        @app.route('\/')\n        def index():\n            return flask.send_file('static\/index.html', conditional=True)\n\n        c = app.test_client()\n\n        rv = c.get('\/', headers={'Range': 'bytes=1000-'})\n        assert rv.status_code == 416\n        rv.close()\n\n    def test_attachment(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            with open(os.path.join(app.root_path, 'static\/index.html')) as f:\n                rv = flask.send_file(f, as_attachment=True,\n                                     attachment_filename='index.html')\n                value, options = \\\n                    parse_options_header(rv.headers['Content-Disposition'])\n                assert value == 'attachment'\n                rv.close()\n\n        with app.test_request_context():\n            assert options['filename'] == 'index.html'\n            rv = flask.send_file('static\/index.html', as_attachment=True)\n            value, options = parse_options_header(rv.headers['Content-Disposition'])\n            assert value == 'attachment'\n            assert options['filename'] == 'index.html'\n            rv.close()\n\n        with app.test_request_context():\n            rv = flask.send_file(StringIO('Test'), as_attachment=True,\n                                 attachment_filename='index.txt',\n                                 add_etags=False)\n            assert rv.mimetype == 'text\/plain'\n            value, options = parse_options_header(rv.headers['Content-Disposition'])\n            assert value == 'attachment'\n            assert options['filename'] == 'index.txt'\n            rv.close()\n\n    def test_static_file(self):\n        app = flask.Flask(__name__)\n        # default cache timeout is 12 hours\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 12 * 60 * 60\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 12 * 60 * 60\n            rv.close()\n        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 3600\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 3600\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 3600\n            rv.close()\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file('index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 10\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file('static\/index.html')\n            cc = parse_cache_control_header(rv.headers['Cache-Control'])\n            assert cc.max_age == 10\n            rv.close()\n\n    def test_send_from_directory(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.root_path = os.path.join(os.path.dirname(__file__),\n                                     'test_apps', 'subdomaintestmodule')\n        with app.test_request_context():\n            rv = flask.send_from_directory('static', 'hello.txt')\n            rv.direct_passthrough = False\n            assert rv.data.strip() == b'Hello Subdomain'\n            rv.close()\n\n    def test_send_from_directory_bad_request(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        app.root_path = os.path.join(os.path.dirname(__file__),\n                                     'test_apps', 'subdomaintestmodule')\n        with app.test_request_context():\n            with pytest.raises(BadRequest):\n                flask.send_from_directory('static', 'bad\\x00')\n\nclass TestLogging(object):\n\n    def test_logger_cache(self):\n        app = flask.Flask(__name__)\n        logger1 = app.logger\n        assert app.logger is logger1\n        assert logger1.name == __name__\n        app.logger_name = __name__ + '\/test_logger_cache'\n        assert app.logger is not logger1\n\n    def test_debug_log(self, capsys):\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        @app.route('\/')\n        def index():\n            app.logger.warning('the standard library is dead')\n            app.logger.debug('this is a debug statement')\n            return ''\n\n        @app.route('\/exc')\n        def exc():\n            1 \/\/ 0\n\n        with app.test_client() as c:\n            c.get('\/')\n            out, err = capsys.readouterr()\n            assert 'WARNING in test_helpers [' in err\n            assert os.path.basename(__file__.rsplit('.', 1)[0] + '.py') in err\n            assert 'the standard library is dead' in err\n            assert 'this is a debug statement' in err\n\n            with pytest.raises(ZeroDivisionError):\n                c.get('\/exc')\n\n    def test_debug_log_override(self):\n        app = flask.Flask(__name__)\n        app.debug = True\n        app.logger_name = 'flask_tests\/test_debug_log_override'\n        app.logger.level = 10\n        assert app.logger.level == 10\n\n    def test_exception_logging(self):\n        out = StringIO()\n        app = flask.Flask(__name__)\n        app.config['LOGGER_HANDLER_POLICY'] = 'never'\n        app.logger_name = 'flask_tests\/test_exception_logging'\n        app.logger.addHandler(StreamHandler(out))\n\n        @app.route('\/')\n        def index():\n            1 \/\/ 0\n\n        rv = app.test_client().get('\/')\n        assert rv.status_code == 500\n        assert b'Internal Server Error' in rv.data\n\n        err = out.getvalue()\n        assert 'Exception on \/ [GET]' in err\n        assert 'Traceback (most recent call last):' in err\n        assert '1 \/\/ 0' in err\n        assert 'ZeroDivisionError:' in err\n\n    def test_processor_exceptions(self):\n        app = flask.Flask(__name__)\n        app.config['LOGGER_HANDLER_POLICY'] = 'never'\n        @app.before_request\n        def before_request():\n            if trigger == 'before':\n                1 \/\/ 0\n        @app.after_request\n        def after_request(response):\n            if trigger == 'after':\n                1 \/\/ 0\n            return response\n        @app.route('\/')\n        def index():\n            return 'Foo'\n        @app.errorhandler(500)\n        def internal_server_error(e):\n            return 'Hello Server Error', 500\n        for trigger in 'before', 'after':\n            rv = app.test_client().get('\/')\n            assert rv.status_code == 500\n            assert rv.data == b'Hello Server Error'\n\n    def test_url_for_with_anchor(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            assert flask.url_for('index', _anchor='x y') == '\/#x%20y'\n\n    def test_url_for_with_scheme(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            assert flask.url_for('index', _external=True, _scheme='https') == 'https:\/\/localhost\/'\n\n    def test_url_for_with_scheme_not_external(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            pytest.raises(ValueError,\n                               flask.url_for,\n                               'index',\n                               _scheme='https')\n\n    def test_url_for_with_alternating_schemes(self):\n        app = flask.Flask(__name__)\n        @app.route('\/')\n        def index():\n            return '42'\n        with app.test_request_context():\n            assert flask.url_for('index', _external=True) == 'http:\/\/localhost\/'\n            assert flask.url_for('index', _external=True, _scheme='https') == 'https:\/\/localhost\/'\n            assert flask.url_for('index', _external=True) == 'http:\/\/localhost\/'\n\n    def test_url_with_method(self):\n        from flask.views import MethodView\n        app = flask.Flask(__name__)\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return 'List'\n                return 'Get %d' % id\n            def post(self):\n                return 'Create'\n        myview = MyView.as_view('myview')\n        app.add_url_rule('\/myview\/', methods=['GET'],\n                         view_func=myview)\n        app.add_url_rule('\/myview\/<int:id>', methods=['GET'],\n                         view_func=myview)\n        app.add_url_rule('\/myview\/create', methods=['POST'],\n                         view_func=myview)\n\n        with app.test_request_context():\n            assert flask.url_for('myview', _method='GET') == '\/myview\/'\n            assert flask.url_for('myview', id=42, _method='GET') == '\/myview\/42'\n            assert flask.url_for('myview', _method='POST') == '\/myview\/create'\n\n\nclass TestNoImports(object):\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self, modules_tmpdir):\n        modules_tmpdir.join('importerror.py').write('raise NotImplementedError()')\n        try:\n            flask.Flask('importerror')\n        except NotImplementedError:\n            assert False, 'Flask(import_name) is importing import_name.'\n\n\nclass TestStreaming(object):\n\n    def test_streaming_with_context(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(flask.stream_with_context(generate()))\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        assert rv.data == b'Hello World!'\n\n    def test_streaming_with_context_as_decorator(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        @app.route('\/')\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(generate('Hello '))\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        assert rv.data == b'Hello World!'\n\n    def test_streaming_with_context_and_custom_close(self):\n        app = flask.Flask(__name__)\n        app.testing = True\n        called = []\n        class Wrapper(object):\n            def __init__(self, gen):\n                self._gen = gen\n            def __iter__(self):\n                return self\n            def close(self):\n                called.append(42)\n            def __next__(self):\n                return next(self._gen)\n            next = __next__\n        @app.route('\/')\n        def index():\n            def generate():\n                yield 'Hello '\n                yield flask.request.args['name']\n                yield '!'\n            return flask.Response(flask.stream_with_context(\n                Wrapper(generate())))\n        c = app.test_client()\n        rv = c.get('\/?name=World')\n        assert rv.data == b'Hello World!'\n        assert called == [42]\n\n\nclass TestSafeJoin(object):\n    def test_safe_join(self):\n        # Valid combinations of *args and expected joined paths.\n        passing = (\n            (('a\/b\/c',), 'a\/b\/c'),\n            (('\/', 'a\/', 'b\/', 'c\/'), '\/a\/b\/c'),\n            (('a', 'b', 'c'), 'a\/b\/c'),\n            (('\/a', 'b\/c'), '\/a\/b\/c'),\n            (('a\/b', 'X\/..\/c'), 'a\/b\/c'),\n            (('\/a\/b', 'c\/X\/..'), '\/a\/b\/c'),\n            # If last path is '' add a slash\n            (('\/a\/b\/c', ''), '\/a\/b\/c\/'),\n            # Preserve dot slash\n            (('\/a\/b\/c', '.\/'), '\/a\/b\/c\/.'),\n            (('a\/b\/c', 'X\/..'), 'a\/b\/c\/.'),\n            # Base directory is always considered safe\n            (('..\/', 'a\/b\/c'), '..\/a\/b\/c'),\n            (('\/..', ), '\/..'),\n        )\n\n        for args, expected in passing:\n            assert flask.safe_join(*args) == expected\n\n    def test_safe_join_exceptions(self):\n        # Should raise werkzeug.exceptions.NotFound on unsafe joins.\n        failing = (\n            # path.isabs and ``..'' checks\n            ('\/a', 'b', '\/c'),\n            ('\/a', '..\/b\/c'),\n            ('\/a', '..', 'b\/c'),\n            # Boundaries violations after path normalization\n            ('\/a', 'b\/..\/b\/..\/..\/c'),\n            ('\/a', 'b', 'c\/..\/..'),\n            ('\/a', 'b\/..\/..\/c'),\n        )\n\n        for args in failing:\n            with pytest.raises(NotFound):\n                print(flask.safe_join(*args))\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.app\n    ~~~~~~~~~\n\n    This module implements the central WSGI application object.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nimport warnings\nfrom datetime import timedelta\nfrom functools import update_wrapper\nfrom itertools import chain\nfrom threading import Lock\n\nfrom werkzeug.datastructures import Headers, ImmutableDict\nfrom werkzeug.exceptions import (\n    BadRequest,\n    BadRequestKeyError,\n    HTTPException,\n    InternalServerError,\n    MethodNotAllowed,\n    default_exceptions,\n)\nfrom werkzeug.routing import BuildError, Map, RequestRedirect, RoutingException, Rule\n\nfrom . import cli, json\nfrom ._compat import integer_types, reraise, string_types, text_type\nfrom .config import Config, ConfigAttribute\nfrom .ctx import AppContext, RequestContext, _AppCtxGlobals\nfrom .globals import _request_ctx_stack, g, request, session\nfrom .helpers import (\n    _PackageBoundObject,\n    _endpoint_from_view_func,\n    find_package,\n    get_env,\n    get_debug_flag,\n    get_flashed_messages,\n    locked_cached_property,\n    url_for,\n    get_load_dotenv,\n)\nfrom .logging import create_logger\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import (\n    appcontext_tearing_down,\n    got_request_exception,\n    request_finished,\n    request_started,\n    request_tearing_down,\n)\nfrom .templating import (\n    DispatchingJinjaLoader,\n    Environment,\n    _default_template_ctx_processor,\n)\nfrom .wrappers import Request, Response\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\n\n\ndef setupmethod(f):\n    \"\"\"Wraps a method so that it performs a check in debug mode if the\n    first request was already handled.\n    \"\"\"\n\n    def wrapper_func(self, *args, **kwargs):\n        if self.debug and self._got_first_request:\n            raise AssertionError(\n                \"A setup function was called after the \"\n                \"first request was handled.  This usually indicates a bug \"\n                \"in the application where a module was not imported \"\n                \"and decorators or other functionality was called too late.\\n\"\n                \"To fix this make sure to import all your view modules, \"\n                \"database models and everything related at a central place \"\n                \"before the application starts serving requests.\"\n            )\n        return f(self, *args, **kwargs)\n\n    return update_wrapper(wrapper_func, f)\n\n\nclass Flask(_PackageBoundObject):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication\/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: the folder with static files that should be served\n                          at `static_url_path`.  Defaults to the ``'static'``\n                          folder in the root path of the application.\n    :param static_host: the host to use when adding the static route.\n        Defaults to None. Required when using ``host_matching=True``\n        with a ``static_folder`` configured.\n    :param host_matching: set ``url_map.host_matching`` attribute.\n        Defaults to False.\n    :param subdomain_matching: consider the subdomain relative to\n        :data:`SERVER_NAME` when matching routes. Defaults to False.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to ``True`` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    :param root_path: Flask by default will automatically calculate the path\n                      to the root of the application.  In certain situations\n                      this cannot be achieved (for instance if the package\n                      is a Python 3 namespace package) and needs to be\n                      manually defined.\n    \"\"\"\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class = Response\n\n    #: The class that is used for the Jinja environment.\n    #:\n    #: .. versionadded:: 0.11\n    jinja_environment = Environment\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on unexpected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is now application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    #: The class that is used for the ``config`` attribute of this app.\n    #: Defaults to :class:`~flask.Config`.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Default values for certain config options.\n    #: 2. Access to config values through attributes in addition to keys.\n    #:\n    #: .. versionadded:: 0.11\n    config_class = Config\n\n    #: The testing flag.  Set this to ``True`` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate test helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``TESTING`` configuration key.  Defaults to ``False``.\n    testing = ConfigAttribute(\"TESTING\")\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and other things. Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n\n    #: The secure cookie uses this for the name of the session cookie.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``SESSION_COOKIE_NAME`` configuration key.  Defaults to ``'session'``\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n\n    #: A :class:`~datetime.timedelta` which is used as default cache_timeout\n    #: for the :func:`send_file` functions. The default is 12 hours.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``SEND_FILE_MAX_AGE_DEFAULT`` configuration key. This configuration\n    #: variable can also be set with an integer value used as seconds.\n    #: Defaults to ``timedelta(hours=12)``\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n\n    #: Enable this if you want to use the X-Sendfile feature.  Keep in\n    #: mind that the server has to support this.  This only affects files\n    #: sent with the :func:`send_file` method.\n    #:\n    #: .. versionadded:: 0.2\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n\n    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_encoder = json.JSONEncoder\n\n    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_decoder = json.JSONDecoder\n\n    #: Options that are passed directly to the Jinja2 environment.\n    jinja_options = ImmutableDict(\n        extensions=[\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]\n    )\n\n    #: Default configuration parameters.\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"\/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application\/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: the test client that is used with when `test_client` is used.\n    #:\n    #: .. versionadded:: 0.7\n    test_client_class = None\n\n    #: The :class:`~click.testing.CliRunner` subclass, by default\n    #: :class:`~flask.testing.FlaskCliRunner` that is used by\n    #: :meth:`test_cli_runner`. Its ``__init__`` method should take a\n    #: Flask app object as the first argument.\n    #:\n    #: .. versionadded:: 1.0\n    test_cli_runner_class = None\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface = SecureCookieSessionInterface()\n\n    # TODO remove the next three attrs when Sphinx :inherited-members: works\n    # https:\/\/github.com\/sphinx-doc\/sphinx\/issues\/741\n\n    #: The name of the package or module that this app belongs to. Do not\n    #: change this once it is set by the constructor.\n    import_name = None\n\n    #: Location of the template files to be added to the template lookup.\n    #: ``None`` if templates should not be added.\n    template_folder = None\n\n    #: Absolute path to the package on the filesystem. Used to look up\n    #: resources contained in the package.\n    root_path = None\n\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        _PackageBoundObject.__init__(\n            self, import_name, template_folder=template_folder, root_path=root_path\n        )\n\n        if static_url_path is not None:\n            self.static_url_path = static_url_path\n\n        if static_folder is not None:\n            self.static_folder = static_folder\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: A dictionary of all view functions registered.  The keys will\n        #: be function names which are also used to generate URLs and\n        #: the values are the function objects themselves.\n        #: To register a view function, use the :meth:`route` decorator.\n        self.view_functions = {}\n\n        #: A dictionary of all registered error handlers.  The key is ``None``\n        #: for error handlers active on the application, otherwise the key is\n        #: the name of the blueprint.  Each key points to another dictionary\n        #: where the key is the status code of the http exception.  The\n        #: special key ``None`` points to a list of tuples where the first item\n        #: is the class for the instance check and the second the error handler\n        #: function.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        self.error_handler_spec = {}\n\n        #: A list of functions that are called when :meth:`url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n        #: is called with `error`, `endpoint` and `values`.  If a function\n        #: returns ``None`` or raises a :exc:`BuildError` the next function is\n        #: tried.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers = []\n\n        #: A dictionary with lists of functions that will be called at the\n        #: beginning of each request. The key of the dictionary is the name of\n        #: the blueprint this function is active for, or ``None`` for all\n        #: requests. To register a function, use the :meth:`before_request`\n        #: decorator.\n        self.before_request_funcs = {}\n\n        #: A list of functions that will be called at the beginning of the\n        #: first request to this instance. To register a function, use the\n        #: :meth:`before_first_request` decorator.\n        #:\n        #: .. versionadded:: 0.8\n        self.before_first_request_funcs = []\n\n        #: A dictionary with lists of functions that should be called after\n        #: each request.  The key of the dictionary is the name of the blueprint\n        #: this function is active for, ``None`` for all requests.  This can for\n        #: example be used to close database connections. To register a function\n        #: here, use the :meth:`after_request` decorator.\n        self.after_request_funcs = {}\n\n        #: A dictionary with lists of functions that are called after\n        #: each request, even if an exception has occurred. The key of the\n        #: dictionary is the name of the blueprint this function is active for,\n        #: ``None`` for all requests. These functions are not allowed to modify\n        #: the request, and their return values are ignored. If an exception\n        #: occurred while processing the request, it gets passed to each\n        #: teardown_request function. To register a function here, use the\n        #: :meth:`teardown_request` decorator.\n        #:\n        #: .. versionadded:: 0.7\n        self.teardown_request_funcs = {}\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs = []\n\n        #: A dictionary with lists of functions that are called before the\n        #: :attr:`before_request_funcs` functions. The key of the dictionary is\n        #: the name of the blueprint this function is active for, or ``None``\n        #: for all requests. To register a function, use\n        #: :meth:`url_value_preprocessor`.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_value_preprocessors = {}\n\n        #: A dictionary with lists of functions that can be used as URL value\n        #: preprocessors.  The key ``None`` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #: of URL values before they are used as the keyword arguments of the\n        #: view function.  For each function registered this one should also\n        #: provide a :meth:`url_defaults` function that adds the parameters\n        #: automatically again that were removed that way.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_default_functions = {}\n\n        #: A dictionary with list of functions that are called without argument\n        #: to populate the template context.  The key of the dictionary is the\n        #: name of the blueprint this function is active for, ``None`` for all\n        #: requests.  Each returns a dictionary that the template context is\n        #: updated with.  To register a function here, use the\n        #: :meth:`context_processor` decorator.\n        self.template_context_processors = {None: [_default_template_ctx_processor]}\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors = []\n\n        #: all the attached blueprints in a dictionary by name.  Blueprints\n        #: can be attached multiple times so this dictionary does not tell\n        #: you how often they got attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints = {}\n        self._blueprint_order = []\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.  For backwards compatibility extensions should register\n        #: themselves like this::\n        #:\n        #:      if not hasattr(app, 'extensions'):\n        #:          app.extensions = {}\n        #:      app.extensions['extensionname'] = SomeObject()\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = Map()\n\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host\/host_matching combination\"\n            self.add_url_rule(\n                self.static_url_path + \"\/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n\n        #: The click command line context for this application.  Commands\n        #: registered here show up in the :command:`flask` command once the\n        #: application has been discovered.  The default commands are\n        #: provided by Flask itself and can be overridden.\n        #:\n        #: This is an instance of a :class:`click.Group` object.\n        self.cli = cli.AppGroup(self.name)\n\n    @locked_cached_property\n    def name(self):\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @property\n    def propagate_exceptions(self):\n        \"\"\"Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration\n        value in case it's set, otherwise a sensible default is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n\n    @property\n    def preserve_context_on_exception(self):\n        \"\"\"Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION``\n        configuration value in case it's set, otherwise a sensible default\n        is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n\n    @locked_cached_property\n    def logger(self):\n        \"\"\"The ``'flask.app'`` logger, a standard Python\n        :class:`~logging.Logger`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will be set\n        to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be added.\n        See :ref:`logging` for more information.\n\n        .. versionchanged:: 1.0\n            Behavior was simplified. The logger is always named\n            ``flask.app``. The level is only set during configuration, it\n            doesn't check ``app.debug`` each time. Only one format is used,\n            not different ones depending on ``app.debug``. No handlers are\n            removed, and a handler is only added if no handlers are already\n            configured.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        return create_logger(self)\n\n    @locked_cached_property\n    def jinja_env(self):\n        \"\"\"The Jinja2 environment used to load templates.\"\"\"\n        return self.create_jinja_environment()\n\n    @property\n    def got_first_request(self):\n        \"\"\"This attribute is set to ``True`` if the application started\n        handling the first request.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        return self._got_first_request\n\n    def make_config(self, instance_relative=False):\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n\n    def auto_find_instance_path(self):\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, \"instance\")\n        return os.path.join(prefix, \"var\", self.name + \"-instance\")\n\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        \"\"\"Opens a resource from the application's instance folder\n        (:attr:`instance_path`).  Otherwise works like\n        :meth:`open_resource`.  Instance resources can also be opened for\n        writing.\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        :param mode: resource file opening mode, default is 'rb'.\n        \"\"\"\n        return open(os.path.join(self.instance_path, resource), mode)\n\n    def _get_templates_auto_reload(self):\n        \"\"\"Reload templates when they are changed. Used by\n        :meth:`create_jinja_environment`.\n\n        This attribute can be configured with :data:`TEMPLATES_AUTO_RELOAD`. If\n        not set, it will be enabled in debug mode.\n\n        .. versionadded:: 1.0\n            This property was added but the underlying config and behavior\n            already existed.\n        \"\"\"\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n\n    def _set_templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n\n    templates_auto_reload = property(\n        _get_templates_auto_reload, _set_templates_auto_reload\n    )\n    del _get_templates_auto_reload, _set_templates_auto_reload\n\n    def create_jinja_environment(self):\n        \"\"\"Creates the Jinja2 environment based on :attr:`jinja_options`\n        and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds\n        the Jinja2 globals and filters after initialization.  Override\n        this function to customize the behavior.\n\n        .. versionadded:: 0.5\n        .. versionchanged:: 0.11\n           ``Environment.auto_reload`` set in accordance with\n           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n        \"\"\"\n        options = dict(self.jinja_options)\n\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n\n    def create_global_jinja_loader(self):\n        \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n\n    def select_jinja_autoescape(self, filename):\n        \"\"\"Returns ``True`` if autoescaping should be active for the given\n        template name. If no template name is given, returns `True`.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n\n    def update_template_context(self, context):\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        # make sure the original values win.  This makes it possible to\n        # easier add new variables in context processors without breaking\n        # existing views.\n        context.update(orig_ctx)\n\n    def make_shell_context(self):\n        \"\"\"Returns the shell context for an interactive shell for this\n        application.  This runs all the registered shell context\n        processors.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n\n    #: What environment the app is running in. Flask and extensions may\n    #: enable behaviors based on the environment, such as enabling debug\n    #: mode. This maps to the :data:`ENV` config key. This is set by the\n    #: :envvar:`FLASK_ENV` environment variable and may not behave as\n    #: expected if set in code.\n    #:\n    #: **Do not enable development when deploying in production.**\n    #:\n    #: Default: ``'production'``\n    env = ConfigAttribute(\"ENV\")\n\n    def _get_debug(self):\n        return self.config[\"DEBUG\"]\n\n    def _set_debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n\n    #: Whether debug mode is enabled. When using ``flask run`` to start\n    #: the development server, an interactive debugger will be shown for\n    #: unhandled exceptions, and the server will be reloaded when code\n    #: changes. This maps to the :data:`DEBUG` config key. This is\n    #: enabled when :attr:`env` is ``'development'`` and is overridden\n    #: by the ``FLASK_DEBUG`` environment variable. It may not behave as\n    #: expected if set in code.\n    #:\n    #: **Do not enable debug mode when deploying in production.**\n    #:\n    #: Default: ``True`` if :attr:`env` is ``'development'``, or\n    #: ``False`` otherwise.\n    debug = property(_get_debug, _set_debug)\n    del _get_debug, _set_debug\n\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        \"\"\"Runs the application on a local development server.\n\n        Do not use ``run()`` in a production setting. It is not intended to\n        meet security and performance requirements for a production server.\n        Instead, see :ref:`deployment` for WSGI server recommendations.\n\n        If the :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        It is not recommended to use this function for development with\n        automatic reloading as this is badly supported.  Instead you should\n        be using the :command:`flask` command line script's ``run`` support.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to ``True`` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n            have the server available externally as well. Defaults to\n            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n            if present.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n            port defined in the ``SERVER_NAME`` config variable if present.\n        :param debug: if given, enable or disable debug mode. See\n            :attr:`debug`.\n        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n            files to set environment variables. Will also change the working\n            directory to the directory containing the first file found.\n        :param options: the options to be forwarded to the underlying Werkzeug\n            server. See :func:`werkzeug.serving.run_simple` for more\n            information.\n\n        .. versionchanged:: 1.0\n            If installed, python-dotenv will be used to load environment\n            variables from :file:`.env` and :file:`.flaskenv` files.\n\n            If set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG`\n            environment variables will override :attr:`env` and\n            :attr:`debug`.\n\n            Threaded mode is enabled by default.\n\n        .. versionchanged:: 0.10\n            The default port is now picked from the ``SERVER_NAME``\n            variable.\n        \"\"\"\n        # Change this into a no-op if the server is invoked from the\n        # command line. Have a look at cli.py for more information.\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n\n            explain_ignored_app_run()\n            return\n\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n\n            # if set, let env vars override previous values\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n\n        # debug passed to method overrides all other sources\n        if debug is not None:\n            self.debug = bool(debug)\n\n        _host = \"127.0.0.1\"\n        _port = 5000\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host, sn_port = None, None\n\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n\n        host = host or sn_host or _host\n        port = int(port or sn_port or _port)\n\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n\n        from werkzeug.serving import run_simple\n\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # reset normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False\n\n    def test_client(self, use_cookies=True, **kwargs):\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :ref:`testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a ``with`` block to defer the closing down\n        of the context until the end of the ``with`` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('\/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        Additionally, you may pass optional keyword arguments that will then\n        be passed to the application's :attr:`test_client_class` constructor.\n        For example::\n\n            from flask.testing import FlaskClient\n\n            class CustomClient(FlaskClient):\n                def __init__(self, *args, **kwargs):\n                    self._authentication = kwargs.pop(\"authentication\")\n                    super(CustomClient,self).__init__( *args, **kwargs)\n\n            app.test_client_class = CustomClient\n            client = app.test_client(authentication='Basic ....')\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for ``with`` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n\n        .. versionchanged:: 0.11\n           Added `**kwargs` to support passing additional keyword arguments to\n           the constructor of :attr:`test_client_class`.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from flask.testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n\n    def test_cli_runner(self, **kwargs):\n        \"\"\"Create a CLI runner for testing CLI commands.\n        See :ref:`testing-cli`.\n\n        Returns an instance of :attr:`test_cli_runner_class`, by default\n        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is\n        passed as the first argument.\n\n        .. versionadded:: 1.0\n        \"\"\"\n        cls = self.test_cli_runner_class\n\n        if cls is None:\n            from flask.testing import FlaskCliRunner as cls\n\n        return cls(self, **kwargs)\n\n    def open_session(self, request):\n        \"\"\"Creates or opens a new session.  Default implementation stores all\n        session data in a signed cookie.  This requires that the\n        :attr:`secret_key` is set.  Instead of overriding this method\n        we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.open_session``\n            instead.\n\n        :param request: an instance of :attr:`request_class`.\n        \"\"\"\n\n        warnings.warn(\n            DeprecationWarning(\n                '\"open_session\" is deprecated and will be removed in 1.1. Use'\n                ' \"session_interface.open_session\" instead.'\n            )\n        )\n        return self.session_interface.open_session(self, request)\n\n    def save_session(self, session, response):\n        \"\"\"Saves the session if it needs updates.  For the default\n        implementation, check :meth:`open_session`.  Instead of overriding this\n        method we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.save_session``\n            instead.\n\n        :param session: the session to be saved (a\n                        :class:`~werkzeug.contrib.securecookie.SecureCookie`\n                        object)\n        :param response: an instance of :attr:`response_class`\n        \"\"\"\n\n        warnings.warn(\n            DeprecationWarning(\n                '\"save_session\" is deprecated and will be removed in 1.1. Use'\n                ' \"session_interface.save_session\" instead.'\n            )\n        )\n        return self.session_interface.save_session(self, session, response)\n\n    def make_null_session(self):\n        \"\"\"Creates a new instance of a missing session.  Instead of overriding\n        this method we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.make_null_session``\n            instead.\n\n        .. versionadded:: 0.7\n        \"\"\"\n\n        warnings.warn(\n            DeprecationWarning(\n                '\"make_null_session\" is deprecated and will be removed in 1.1. Use'\n                ' \"session_interface.make_null_session\" instead.'\n            )\n        )\n        return self.session_interface.make_null_session(self)\n\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n        arguments passed to this method will override the defaults set on the\n        blueprint.\n\n        Calls the blueprint's :meth:`~flask.Blueprint.register` method after\n        recording the blueprint in the application's :attr:`blueprints`.\n\n        :param blueprint: The blueprint to register.\n        :param url_prefix: Blueprint routes will be prefixed with this.\n        :param subdomain: Blueprint routes will match on this subdomain.\n        :param url_defaults: Blueprint routes will use these default values for\n            view arguments.\n        :param options: Additional keyword arguments are passed to\n            :class:`~flask.blueprints.BlueprintSetupState`. They can be\n            accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        first_registration = False\n\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints %r and %r. Both\"\n                ' share the same name \"%s\". Blueprints that are created on the'\n                \" fly need unique names.\"\n                % (blueprint, self.blueprints[blueprint.name], blueprint.name)\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n\n        blueprint.register(self, options, first_registration)\n\n    def iter_blueprints(self):\n        \"\"\"Iterates over all blueprints by the order they were registered.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return iter(self._blueprint_order)\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options\n    ):\n        \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n        decorator.  If a view_func is provided it will be registered with the\n        endpoint.\n\n        Basically this example::\n\n            @app.route('\/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('\/', 'index', index)\n\n        If the view_func is not provided you will need to connect the endpoint\n        to a view function like so::\n\n            app.view_functions['index'] = index\n\n        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n        to customize the behavior via subclassing you only need to change\n        this method.\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        .. versionchanged:: 0.2\n           `view_func` parameter added.\n\n        .. versionchanged:: 0.6\n           ``OPTIONS`` is added automatically as method.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param provide_automatic_options: controls whether the ``OPTIONS``\n            method should be added automatically. This can also be controlled\n            by setting the ``view_func.provide_automatic_options = False``\n            before adding the rule.\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, string_types):\n            raise TypeError(\n                \"Allowed methods have to be iterables of strings, \"\n                'for example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = set(item.upper() for item in methods)\n\n        # Methods that should always be added\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an \"\n                    \"existing endpoint function: %s\" % endpoint\n                )\n            self.view_functions[endpoint] = view_func\n\n    def route(self, rule, **options):\n        \"\"\"A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as :meth:`add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('\/')\n            def index():\n                return 'Hello World'\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n\n        def decorator(f):\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def endpoint(self, endpoint):\n        \"\"\"A decorator to register a function as an endpoint.\n        Example::\n\n            @app.endpoint('example.endpoint')\n            def example():\n                return \"example\"\n\n        :param endpoint: the name of the endpoint\n        \"\"\"\n\n        def decorator(f):\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator\n\n    @staticmethod\n    def _get_exc_class_and_code(exc_class_or_code):\n        \"\"\"Ensure that we register only exceptions as handler keys\"\"\"\n        if isinstance(exc_class_or_code, integer_types):\n            exc_class = default_exceptions[exc_class_or_code]\n        else:\n            exc_class = exc_class_or_code\n\n        assert issubclass(exc_class, Exception)\n\n        if issubclass(exc_class, HTTPException):\n            return exc_class, exc_class.code\n        else:\n            return exc_class, None\n\n    @setupmethod\n    def errorhandler(self, code_or_exception):\n        \"\"\"Register a function to handle errors by code or exception class.\n\n        A decorator that is used to register a function given an\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        .. versionadded:: 0.7\n            Use :meth:`register_error_handler` instead of modifying\n            :attr:`error_handler_spec` directly, for application wide error\n            handlers.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code_or_exception: the code as integer for the handler, or\n                                  an arbitrary exception\n        \"\"\"\n\n        def decorator(f):\n            self._register_error_handler(None, code_or_exception, f)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def register_error_handler(self, code_or_exception, f):\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._register_error_handler(None, code_or_exception, f)\n\n    @setupmethod\n    def _register_error_handler(self, key, code_or_exception, f):\n        \"\"\"\n        :type key: None|str\n        :type code_or_exception: int|T<=Exception\n        :type f: callable\n        \"\"\"\n        if isinstance(code_or_exception, HTTPException):  # old broken behavior\n            raise ValueError(\n                \"Tried to register a handler for an exception instance {0!r}.\"\n                \" Handlers can only be registered for exception classes or\"\n                \" HTTP error codes.\".format(code_or_exception)\n            )\n\n        try:\n            exc_class, code = self._get_exc_class_and_code(code_or_exception)\n        except KeyError:\n            raise KeyError(\n                \"'{0}' is not a recognized HTTP error code. Use a subclass of\"\n                \" HTTPException with that code instead.\".format(code_or_exception)\n            )\n\n        handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})\n        handlers[exc_class] = f\n\n    @setupmethod\n    def template_filter(self, name=None):\n        \"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        \"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f\n\n    @setupmethod\n    def template_test(self, name=None):\n        \"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        \"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f\n\n    @setupmethod\n    def template_global(self, name=None):\n        \"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        \"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f\n\n    @setupmethod\n    def before_request(self, f):\n        \"\"\"Registers a function to run before each request.\n\n        For example, this can be used to open a database connection, or to load\n        the logged in user from the session.\n\n        The function will be called without any arguments. If it returns a\n        non-None value, the value is handled as if it was the return value from\n        the view, and further request handling is stopped.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def before_first_request(self, f):\n        \"\"\"Registers a function to be run before the first request to this\n        instance of the application.\n\n        The function will be called without any arguments and its return\n        value is ignored.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.before_first_request_funcs.append(f)\n        return f\n\n    @setupmethod\n    def after_request(self, f):\n        \"\"\"Register a function to be run after each request.\n\n        Your function must take one parameter, an instance of\n        :attr:`response_class` and return a new response object or the\n        same (see :meth:`process_response`).\n\n        As of Flask 0.7 this function might not be executed at the end of the\n        request in case an unhandled exception occurred.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_request(self, f):\n        \"\"\"Register a function to be run at the end of each request,\n        regardless of whether there was an exception or not.  These functions\n        are executed when the request context is popped, even if not an\n        actual request was performed.\n\n        Example::\n\n            ctx = app.test_request_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the request context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Generally teardown functions must take every necessary step to avoid\n        that they will fail.  If they do execute code that might fail they\n        will have to surround the execution of these code by try\/except\n        statements and log occurring errors.\n\n        When a teardown function was called because of an exception it will\n        be passed an error object.\n\n        The return values of teardown functions are ignored.\n\n        .. admonition:: Debug Note\n\n           In debug mode Flask will not tear down a request on an exception\n           immediately.  Instead it will keep it alive so that the interactive\n           debugger can still access it.  This behavior can be controlled\n           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_appcontext(self, f):\n        \"\"\"Registers a function to be called when the application context\n        ends.  These functions are typically also called when the request\n        context is popped.\n\n        Example::\n\n            ctx = app.app_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the app context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Since a request context typically also manages an application\n        context it would also be called when you pop a request context.\n\n        When a teardown function was called because of an unhandled exception\n        it will be passed an error object. If an :meth:`errorhandler` is\n        registered, it will handle the exception and the teardown will not\n        receive it.\n\n        The return values of teardown functions are ignored.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n\n    @setupmethod\n    def context_processor(self, f):\n        \"\"\"Registers a template context processor function.\"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n\n    @setupmethod\n    def shell_context_processor(self, f):\n        \"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        self.shell_context_processors.append(f)\n        return f\n\n    @setupmethod\n    def url_value_preprocessor(self, f):\n        \"\"\"Register a URL value preprocessor function for all view\n        functions in the application. These functions will be called before the\n        :meth:`before_request` functions.\n\n        The function can modify the values captured from the matched url before\n        they are passed to the view. For example, this can be used to pop a\n        common language code value and place it in ``g`` rather than pass it to\n        every view.\n\n        The function is passed the endpoint name and values dict. The return\n        value is ignored.\n        \"\"\"\n        self.url_value_preprocessors.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def url_defaults(self, f):\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n        \"\"\"\n        self.url_default_functions.setdefault(None, []).append(f)\n        return f\n\n    def _find_error_handler(self, e):\n        \"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(type(e))\n\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n\n            if not handler_map:\n                continue\n\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n\n                if handler is not None:\n                    return handler\n\n    def handle_http_exception(self, e):\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionchanged:: 1.0.3\n            ``RoutingException``, used internally for actions such as\n             slash redirects during routing, is not passed to error\n             handlers.\n\n        .. versionchanged:: 1.0\n            Exceptions are looked up by code *and* by MRO, so\n            ``HTTPExcpetion`` subclasses can be handled with a catch-all\n            handler for the base ``HTTPException``.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        # RoutingExceptions are used internally to trigger routing\n        # actions, such as slash redirects raising RequestRedirect. They\n        # are not raised or handled in user code.\n        if isinstance(e, RoutingException):\n            return e\n\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n\n    def trap_http_exception(self, e):\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n\n        # if unset, trap key errors in debug mode\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False\n\n    def handle_user_exception(self, e):\n        \"\"\"This method is called whenever an exception occurs that\n        should be handled. A special case is :class:`~werkzeug\n        .exceptions.HTTPException` which is forwarded to the\n        :meth:`handle_http_exception` method. This function will either\n        return a response value or reraise the exception with the same\n        traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the\n            bad key in debug mode rather than a generic bad request\n            message.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        assert exc_value is e\n        # ensure not to trash sys.exc_info() at that point in case someone\n        # wants the traceback preserved in handle_http_exception.  Of course\n        # we cannot prevent users from trashing it themselves in a custom\n        # trap_http_exception method so that's their fault then.\n\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                # Werkzeug < 0.15 doesn't add the KeyError to the 400\n                # message, add it in manually.\n                description = e.get_description()\n\n                if e.args[0] not in description:\n                    e.description = \"KeyError: '{}'\".format(*e.args)\n            else:\n                # Werkzeug >= 0.15 does add it, remove it in production\n                e.args = ()\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        handler = self._find_error_handler(e)\n\n        if handler is None:\n            reraise(exc_type, exc_value, tb)\n        return handler(e)\n\n    def handle_exception(self, e):\n        \"\"\"Default exception handling that kicks in when an exception\n        occurs that is not caught.  In debug mode the exception will\n        be re-raised immediately, otherwise it is logged and the handler\n        for a 500 internal server error is used.  If no such handler\n        exists, a default 500 internal server error message is displayed.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        got_request_exception.send(self, exception=e)\n\n        if self.propagate_exceptions:\n            # if we want to repropagate the exception, we can attempt to\n            # raise it with the whole traceback in case we can do that\n            # (the function was actually called from the except part)\n            # otherwise, we just raise the error again\n            if exc_value is e:\n                reraise(exc_type, exc_value, tb)\n            else:\n                raise e\n\n        self.log_exception((exc_type, exc_value, tb))\n        handler = self._find_error_handler(InternalServerError())\n        if handler is None:\n            return InternalServerError()\n        return self.finalize_request(handler(e), from_error_handler=True)\n\n    def log_exception(self, exc_info):\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error(\n            \"Exception on %s [%s]\" % (request.path, request.method), exc_info=exc_info\n        )\n\n    def raise_routing_exception(self, request):\n        \"\"\"Exceptions that are recording during routing are reraised with\n        this method.  During debug we are not reraising redirect requests\n        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n        a different error instead to help debug situations.\n\n        :internal:\n        \"\"\"\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n\n        from .debughelpers import FormDataRoutingRedirect\n\n        raise FormDataRoutingRedirect(request)\n\n    def dispatch_request(self):\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        return self.view_functions[rule.endpoint](**req.view_args)\n\n    def full_dispatch_request(self):\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n\n    def finalize_request(self, rv, from_error_handler=False):\n        \"\"\"Given the return value from a view function this finalizes\n        the request by converting it into a response and invoking the\n        postprocessing functions.  This is invoked for both normal\n        request dispatching as well as error handlers.\n\n        Because this means that it might be called as a result of a\n        failure a special safe mode is available which can be enabled\n        with the `from_error_handler` flag.  If enabled, failures in\n        response processing will be logged and otherwise ignored.\n\n        :internal:\n        \"\"\"\n        response = self.make_response(rv)\n        try:\n            response = self.process_response(response)\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an \" \"error while handling an error\"\n            )\n        return response\n\n    def try_trigger_before_first_request_functions(self):\n        \"\"\"Called before each request and will ensure that it triggers\n        the :attr:`before_first_request_funcs` and only exactly once per\n        application instance (which means process usually).\n\n        :internal:\n        \"\"\"\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n\n    def make_default_options_response(self):\n        \"\"\"This method is called to create the default ``OPTIONS`` response.\n        This can be changed through subclassing to change the default\n        behavior of ``OPTIONS`` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        adapter = _request_ctx_stack.top.url_adapter\n        if hasattr(adapter, \"allowed_methods\"):\n            methods = adapter.allowed_methods()\n        else:\n            # fallback for Werkzeug < 0.7\n            methods = []\n            try:\n                adapter.match(method=\"--\")\n            except MethodNotAllowed as e:\n                methods = e.valid_methods\n            except HTTPException as e:\n                pass\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n\n    def should_ignore_error(self, error):\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns ``True`` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False\n\n    def make_response(self, rv):\n        \"\"\"Convert the return value from a view function to an instance of\n        :attr:`response_class`.\n\n        :param rv: the return value from the view function. The view function\n            must return a response. Returning ``None``, or the view ending\n            without returning, is not allowed. The following types are allowed\n            for ``view_rv``:\n\n            ``str`` (``unicode`` in Python 2)\n                A response object is created with the string encoded to UTF-8\n                as the body.\n\n            ``bytes`` (``str`` in Python 2)\n                A response object is created with the bytes as the body.\n\n            ``tuple``\n                Either ``(body, status, headers)``, ``(body, status)``, or\n                ``(body, headers)``, where ``body`` is any of the other types\n                allowed here, ``status`` is a string or an integer, and\n                ``headers`` is a dictionary or a list of ``(key, value)``\n                tuples. If ``body`` is a :attr:`response_class` instance,\n                ``status`` overwrites the exiting value and ``headers`` are\n                extended.\n\n            :attr:`response_class`\n                The object is returned unchanged.\n\n            other :class:`~werkzeug.wrappers.Response` class\n                The object is coerced to :attr:`response_class`.\n\n            :func:`callable`\n                The function is called as a WSGI application. The result is\n                used to create a response object.\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n\n        status = headers = None\n\n        # unpack tuple returns\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n\n            # a 3-tuple is unpacked directly\n            if len_rv == 3:\n                rv, status, headers = rv\n            # decide if a 2-tuple has status or headers\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            # other sized tuples are not allowed\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n\n        # the body must not be None\n        if rv is None:\n            raise TypeError(\n                \"The view function did not return a valid response. The\"\n                \" function either returned None or ended without a return\"\n                \" statement.\"\n            )\n\n        # make sure the body is an instance of the response class\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (text_type, bytes, bytearray)):\n                # let the response class set the status and headers instead of\n                # waiting to do it manually, so that the class can handle any\n                # special logic\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            else:\n                # evaluate a WSGI callable, or coerce a different response\n                # class to the correct type\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    new_error = TypeError(\n                        \"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string, tuple,\"\n                        \" Response instance, or WSGI callable, but it was a\"\n                        \" {rv.__class__.__name__}.\".format(e=e, rv=rv)\n                    )\n                    reraise(TypeError, new_error, sys.exc_info()[2])\n\n        # prefer the status if it was provided\n        if status is not None:\n            if isinstance(status, (text_type, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n\n        # extend existing headers with provided headers\n        if headers:\n            rv.headers.extend(headers)\n\n        return rv\n\n    def create_url_adapter(self, request):\n        \"\"\"Creates a URL adapter for the given request. The URL adapter\n        is created at a point where the request context is not yet set\n        up so the request is passed explicitly.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n           This can now also be called without a request object when the\n           URL adapter is created for the application context.\n\n        .. versionchanged:: 1.0\n            :data:`SERVER_NAME` no longer implicitly enables subdomain\n            matching. Use :attr:`subdomain_matching` instead.\n        \"\"\"\n        if request is not None:\n            # If subdomain matching is disabled (the default), use the\n            # default subdomain in all cases. This should be the default\n            # in Werkzeug but it currently does not have that feature.\n            subdomain = (\n                (self.url_map.default_subdomain or None)\n                if not self.subdomain_matching\n                else None\n            )\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        # We need at the very least the server name to be set for this\n        # to work.\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n\n    def inject_url_defaults(self, endpoint, values):\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n\n    def handle_url_build_error(self, error, endpoint, values):\n        \"\"\"Handle :class:`~werkzeug.routing.BuildError` on :meth:`url_for`.\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n                if rv is not None:\n                    return rv\n            except BuildError as e:\n                # make error available outside except block (py3)\n                error = e\n\n        # At this point we want to reraise the exception.  If the error is\n        # still the same one we can reraise it with the original traceback,\n        # otherwise we raise it from here.\n        if error is exc_value:\n            reraise(exc_type, exc_value, tb)\n        raise error\n\n    def preprocess_request(self):\n        \"\"\"Called before the request is dispatched. Calls\n        :attr:`url_value_preprocessors` registered with the app and the\n        current blueprint (if any). Then calls :attr:`before_request_funcs`\n        registered with the app and the blueprint.\n\n        If any :meth:`before_request` handler returns a non-None value, the\n        value is handled as if it was the return value from the view, and\n        further request handling is stopped.\n        \"\"\"\n\n        bp = _request_ctx_stack.top.request.blueprint\n\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n\n    def process_response(self, response):\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n\n    def do_teardown_request(self, exc=_sentinel):\n        \"\"\"Called after the request is dispatched and the response is\n        returned, right before the request context is popped.\n\n        This calls all functions decorated with\n        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`\n        if a blueprint handled the request. Finally, the\n        :data:`request_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,\n        which may be delayed during testing to maintain access to\n        resources.\n\n        :param exc: An unhandled exception raised while dispatching the\n            request. Detected from the current exception information if\n            not passed. Passed to each teardown function.\n\n        .. versionchanged:: 0.9\n            Added the ``exc`` argument.\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n\n    def do_teardown_appcontext(self, exc=_sentinel):\n        \"\"\"Called right before the application context is popped.\n\n        When handling a request, the application context is popped\n        after the request context. See :meth:`do_teardown_request`.\n\n        This calls all functions decorated with\n        :meth:`teardown_appcontext`. Then the\n        :data:`appcontext_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n\n    def app_context(self):\n        \"\"\"Create an :class:`~flask.ctx.AppContext`. Use as a ``with``\n        block to push the context, which will make :data:`current_app`\n        point at this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`\/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ):\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`\/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args, **kwargs):\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`\/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop()\n\n        Takes the same arguments as Werkzeug's\n        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from\n        the application. See the linked Werkzeug docs for most of the\n        available arguments. Flask-specific behavior is listed here.\n\n        :param path: URL path being requested.\n        :param base_url: Base URL where the app is being served, which\n            ``path`` is relative to. If not given, built from\n            :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n        :param subdomain: Subdomain name to append to\n            :data:`SERVER_NAME`.\n        :param url_scheme: Scheme to use instead of\n            :data:`PREFERRED_URL_SCHEME`.\n        :param data: The request body, either as a string or a dict of\n            form keys and values.\n        :param json: If given, this is serialized as JSON and passed as\n            ``data``. Also defaults ``content_type`` to\n            ``application\/json``.\n        :param args: other positional arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        :param kwargs: other keyword arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        \"\"\"\n        from flask.testing import make_test_environ_builder\n\n        builder = make_test_environ_builder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(self, environ, start_response):\n        \"\"\"The actual WSGI application. This is not implemented in\n        :meth:`__call__` so that middlewares can be applied without\n        losing a reference to the app object. Instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            ctx.auto_pop(error)\n\n    def __call__(self, environ, start_response):\n        \"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app` which can be\n        wrapped to applying middleware.\"\"\"\n        return self.wsgi_app(environ, start_response)\n\n    def __repr__(self):\n        return \"<%s %r>\" % (self.__class__.__name__, self.name)\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" import pytest\n\nfrom js_example import app\n\n\n@pytest.fixture(name=\"app\")\ndef fixture_app():\n    app.testing = True\n    yield app\n    app.testing = False\n\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.wrappers\n    ~~~~~~~~~~~~~~\n\n    Implements the WSGI wrappers (request and response).\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.wrappers import Request as RequestBase, Response as ResponseBase\n\nfrom flask import json\nfrom flask.globals import current_app\n\n\nclass JSONMixin(object):\n    \"\"\"Common mixin for both request and response objects to provide JSON\n    parsing capabilities.\n\n    .. versionadded:: 1.0\n    \"\"\"\n\n    _cached_json = (Ellipsis, Ellipsis)\n\n    @property\n    def is_json(self):\n        \"\"\"Check if the mimetype indicates JSON data, either\n        :mimetype:`application\/json` or :mimetype:`application\/*+json`.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        mt = self.mimetype\n        return (\n            mt == \"application\/json\"\n            or (mt.startswith(\"application\/\"))\n            and mt.endswith(\"+json\")\n        )\n\n    @property\n    def json(self):\n        \"\"\"This will contain the parsed JSON data if the mimetype indicates\n        JSON (:mimetype:`application\/json`, see :meth:`is_json`), otherwise it\n        will be ``None``.\n        \"\"\"\n        return self.get_json()\n\n    def _get_data_for_json(self, cache):\n        return self.get_data(cache=cache)\n\n    def get_json(self, force=False, silent=False, cache=True):\n        \"\"\"Parse and return the data as JSON. If the mimetype does not\n        indicate JSON (:mimetype:`application\/json`, see\n        :meth:`is_json`), this returns ``None`` unless ``force`` is\n        true. If parsing fails, :meth:`on_json_loading_failed` is called\n        and its return value is used as the return value.\n\n        :param force: Ignore the mimetype and always try to parse JSON.\n        :param silent: Silence parsing errors and return ``None``\n            instead.\n        :param cache: Store the parsed JSON to return for subsequent\n            calls.\n        \"\"\"\n        if cache and self._cached_json[silent] is not Ellipsis:\n            return self._cached_json[silent]\n\n        if not (force or self.is_json):\n            return None\n\n        data = self._get_data_for_json(cache=cache)\n\n        try:\n            rv = json.loads(data)\n        except ValueError as e:\n            if silent:\n                rv = None\n                if cache:\n                    normal_rv, _ = self._cached_json\n                    self._cached_json = (normal_rv, rv)\n            else:\n                rv = self.on_json_loading_failed(e)\n                if cache:\n                    _, silent_rv = self._cached_json\n                    self._cached_json = (rv, silent_rv)\n        else:\n            if cache:\n                self._cached_json = (rv, rv)\n\n        return rv\n\n    def on_json_loading_failed(self, e):\n        \"\"\"Called if :meth:`get_json` parsing fails and isn't silenced. If\n        this method returns a value, it is used as the return value for\n        :meth:`get_json`. The default implementation raises a\n        :class:`BadRequest` exception.\n\n        .. versionchanged:: 0.10\n           Raise a :exc:`BadRequest` error instead of returning an error\n           message as JSON. If you want that behavior you can add it by\n           subclassing.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if current_app is not None and current_app.debug:\n            raise BadRequest(\"Failed to decode JSON object: {0}\".format(e))\n\n        raise BadRequest()\n\n\nclass Request(RequestBase, JSONMixin):\n    \"\"\"The request object used by default in Flask.  Remembers the\n    matched endpoint and view arguments.\n\n    It is what ends up as :class:`~flask.request`.  If you want to replace\n    the request object used you can subclass this and set\n    :attr:`~flask.Flask.request_class` to your subclass.\n\n    The request object is a :class:`~werkzeug.wrappers.Request` subclass and\n    provides all of the attributes Werkzeug defines plus a few Flask\n    specific ones.\n    \"\"\"\n\n    #: The internal URL rule that matched the request.  This can be\n    #: useful to inspect which methods are allowed for the URL from\n    #: a before\/after handler (``request.url_rule.methods``) etc.\n    #: Though if the request's method was invalid for the URL rule,\n    #: the valid list is available in ``routing_exception.valid_methods``\n    #: instead (an attribute of the Werkzeug exception :exc:`~werkzeug.exceptions.MethodNotAllowed`)\n    #: because the request was never internally bound.\n    #:\n    #: .. versionadded:: 0.6\n    url_rule = None\n\n    #: A dict of view arguments that matched the request.  If an exception\n    #: happened when matching, this will be ``None``.\n    view_args = None\n\n    #: If matching the URL failed, this is the exception that will be\n    #: raised \/ was raised as part of the request handling.  This is\n    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n    #: something similar.\n    routing_exception = None\n\n    @property\n    def max_content_length(self):\n        \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"\n        if current_app:\n            return current_app.config[\"MAX_CONTENT_LENGTH\"]\n\n    @property\n    def endpoint(self):\n        \"\"\"The endpoint that matched the request.  This in combination with\n        :attr:`view_args` can be used to reconstruct the same or a\n        modified URL.  If an exception happened when matching, this will\n        be ``None``.\n        \"\"\"\n        if self.url_rule is not None:\n            return self.url_rule.endpoint\n\n    @property\n    def blueprint(self):\n        \"\"\"The name of the current blueprint\"\"\"\n        if self.url_rule and \".\" in self.url_rule.endpoint:\n            return self.url_rule.endpoint.rsplit(\".\", 1)[0]\n\n    def _load_form_data(self):\n        RequestBase._load_form_data(self)\n\n        # In debug mode we're replacing the files multidict with an ad-hoc\n        # subclass that raises a different error for key errors.\n        if (\n            current_app\n            and current_app.debug\n            and self.mimetype != \"multipart\/form-data\"\n            and not self.files\n        ):\n            from .debughelpers import attach_enctype_error_multidict\n\n            attach_enctype_error_multidict(self)\n\n\nclass Response(ResponseBase, JSONMixin):\n    \"\"\"The response object that is used by default in Flask.  Works like the\n    response object from Werkzeug but is set to have an HTML mimetype by\n    default.  Quite often you don't have to create this object yourself because\n    :meth:`~flask.Flask.make_response` will take care of that for you.\n\n    If you want to replace the response object used you can subclass this and\n    set :attr:`~flask.Flask.response_class` to your subclass.\n\n    .. versionchanged:: 1.0\n        JSON support is added to the response, like the request. This is useful\n        when testing to get the test client response data as JSON.\n\n    .. versionchanged:: 1.0\n\n        Added :attr:`max_cookie_size`.\n    \"\"\"\n\n    default_mimetype = \"text\/html\"\n\n    def _get_data_for_json(self, cache):\n        return self.get_data()\n\n    @property\n    def max_cookie_size(self):\n        \"\"\"Read-only view of the :data:`MAX_COOKIE_SIZE` config key.\n\n        See :attr:`~werkzeug.wrappers.BaseResponse.max_cookie_size` in\n        Werkzeug's docs.\n        \"\"\"\n        if current_app:\n            return current_app.config[\"MAX_COOKIE_SIZE\"]\n\n        # return Werkzeug's default when not in an app context\n        return super(Response, self).max_cookie_size\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" import pytest\n\nfrom js_example import app\n\n\n@pytest.fixture(name=\"app\")\ndef fixture_app():\n    app.testing = True\n    yield app\n    app.testing = False\n\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n"}
{"prompt":"Python3\nfrom flask import Blueprint, flash, g, redirect, render_template, request, url_for\nfrom werkzeug.exceptions import abort\n\nfrom flaskr.auth import login_required\nfrom flaskr.db import get_db\n\nbp = Blueprint(\"blog\", __name__)\n\n\n@bp.route(\"\/\")\ndef index():\n    \"\"\"Show all the posts, most recent first.\"\"\"\n    db = get_db()\n    posts = db.execute(\n        \"SELECT p.id, title, body, created, author_id, username\"\n        \" FROM post p JOIN user u ON p.author_id = u.id\"\n        \" ORDER BY created DESC\"\n    ).fetchall()\n    return render_template(\"blog\/index.html\", posts=posts)\n\n\ndef get_post(id, check_author=True):\n    \"\"\"Get a post and its author by id.\n\n    Checks that the id exists and optionally that the current user is\n    the author.\n\n    :param id: id of post to get\n    :param check_author: require the current user to be the author\n    :return: the post with author information\n    :raise 404: if a post with the given id doesn't exist\n    :raise 403: if the current user isn't the author\n    \"\"\"\n    post = (\n        get_db()\n        .execute(\n            \"SELECT p.id, title, body, created, author_id, username\"\n            \" FROM post p JOIN user u ON p.author_id = u.id\"\n            \" WHERE p.id = ?\",\n            (id,),\n        )\n        .fetchone()\n    )\n\n    if post is None:\n        abort(404, \"Post id {0} doesn't exist.\".format(id))\n\n    if check_author and post[\"author_id\"] != g.user[\"id\"]:\n        abort(403)\n\n    return post\n\n\n@bp.route(\"\/create\", methods=(\"GET\", \"POST\"))\n@login_required\ndef create():\n    \"\"\"Create a new post for the current user.\"\"\"\n    if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"INSERT INTO post (title, body, author_id)\" \" VALUES (?, ?, ?)\",\n                (title, body, g.user[\"id\"]),\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog\/create.html\")\n\n\n@bp.route(\"\/<int:id>\/update\", methods=(\"GET\", \"POST\"))\n@login_required\ndef update(id):\n    \"\"\"Update a post if the current user is the author.\"\"\"\n    post = get_post(id)\n\n    if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"UPDATE post SET title = ?, body = ? WHERE id = ?\", (title, body, id)\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog\/update.html\", post=post)\n\n\n@bp.route(\"\/<int:id>\/delete\", methods=(\"POST\",))\n@login_required\ndef delete(id):\n    \"\"\"Delete a post.\n\n    Ensures that the post exists and that the logged in user is the\n    author of the post.\n    \"\"\"\n    get_post(id)\n    db = get_db()\n    db.execute(\"DELETE FROM post WHERE id = ?\", (id,))\n    db.commit()\n    return redirect(url_for(\"blog.index\"))\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" import pytest\nfrom flask import g, session\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.config\n    ~~~~~~~~~~~~\n\n    Implements the configuration related objects.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport types\nimport errno\n\nfrom werkzeug.utils import import_string\nfrom ._compat import string_types, iteritems\nfrom . import json\n\n\nclass ConfigAttribute(object):\n    \"\"\"Makes an attribute forward to the config\"\"\"\n\n    def __init__(self, name, get_converter=None):\n        self.__name__ = name\n        self.get_converter = get_converter\n\n    def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        rv = obj.config[self.__name__]\n        if self.get_converter is not None:\n            rv = self.get_converter(rv)\n        return rv\n\n    def __set__(self, obj, value):\n        obj.config[self.__name__] = value\n\n\nclass Config(dict):\n    \"\"\"Works exactly like a dict but provides ways to fill it from files\n    or special dictionaries.  There are two common patterns to populate the\n    config.\n\n    Either you can fill the config from a config file::\n\n        app.config.from_pyfile('yourconfig.cfg')\n\n    Or alternatively you can define the configuration options in the\n    module that calls :meth:`from_object` or provide an import path to\n    a module that should be loaded.  It is also possible to tell it to\n    use the same module and with that provide the configuration values\n    just before the call::\n\n        DEBUG = True\n        SECRET_KEY = 'development key'\n        app.config.from_object(__name__)\n\n    In both cases (loading from any Python file or loading from modules),\n    only uppercase keys are added to the config.  This makes it possible to use\n    lowercase values in the config file for temporary values that are not added\n    to the config or to define the config keys in the same file that implements\n    the application.\n\n    Probably the most interesting way to load configurations is from an\n    environment variable pointing to a file::\n\n        app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n\n    In this case before launching the application you have to set this\n    environment variable to the file you want to use.  On Linux and OS X\n    use the export statement::\n\n        export YOURAPPLICATION_SETTINGS='\/path\/to\/config\/file'\n\n    On windows use `set` instead.\n\n    :param root_path: path to which files are read relative from.  When the\n                      config object is created by the application, this is\n                      the application's :attr:`~flask.Flask.root_path`.\n    :param defaults: an optional dictionary of default values\n    \"\"\"\n\n    def __init__(self, root_path, defaults=None):\n        dict.__init__(self, defaults or {})\n        self.root_path = root_path\n\n    def from_envvar(self, variable_name, silent=False):\n        \"\"\"Loads a configuration from an environment variable pointing to\n        a configuration file.  This is basically just a shortcut with nicer\n        error messages for this line of code::\n\n            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n        :param variable_name: name of the environment variable\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: bool. ``True`` if able to load config, ``False`` otherwise.\n        \"\"\"\n        rv = os.environ.get(variable_name)\n        if not rv:\n            if silent:\n                return False\n            raise RuntimeError(\n                \"The environment variable %r is not set \"\n                \"and as such configuration could not be \"\n                \"loaded.  Set this variable and make it \"\n                \"point to a configuration file\" % variable_name\n            )\n        return self.from_pyfile(rv, silent=silent)\n\n    def from_pyfile(self, filename, silent=False):\n        \"\"\"Updates the values in the config from a Python file.  This function\n        behaves as if the file was imported as module with the\n        :meth:`from_object` function.\n\n        :param filename: the filename of the config.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n\n        .. versionadded:: 0.7\n           `silent` parameter.\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n        d = types.ModuleType(\"config\")\n        d.__file__ = filename\n        try:\n            with open(filename, mode=\"rb\") as config_file:\n                exec(compile(config_file.read(), filename, \"exec\"), d.__dict__)\n        except IOError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):\n                return False\n            e.strerror = \"Unable to load configuration file (%s)\" % e.strerror\n            raise\n        self.from_object(d)\n        return True\n\n    def from_object(self, obj):\n        \"\"\"Updates the values from the given object.  An object can be of one\n        of the following two types:\n\n        -   a string: in this case the object with that name will be imported\n        -   an actual object reference: that object is used directly\n\n        Objects are usually either modules or classes. :meth:`from_object`\n        loads only the uppercase attributes of the module\/class. A ``dict``\n        object will not work with :meth:`from_object` because the keys of a\n        ``dict`` are not attributes of the ``dict`` class.\n\n        Example of module-based configuration::\n\n            app.config.from_object('yourapplication.default_config')\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n        Nothing is done to the object before loading. If the object is a\n        class and has ``@property`` attributes, it needs to be\n        instantiated before being passed to this method.\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults.  The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        See :ref:`config-dev-prod` for an example of class-based configuration\n        using :meth:`from_object`.\n\n        :param obj: an import name or object\n        \"\"\"\n        if isinstance(obj, string_types):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)\n\n    def from_json(self, filename, silent=False):\n        \"\"\"Updates the values in the config from a JSON file. This function\n        behaves as if the JSON object was a dictionary and passed to the\n        :meth:`from_mapping` function.\n\n        :param filename: the filename of the JSON file.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename) as json_file:\n                obj = json.loads(json_file.read())\n        except IOError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n            e.strerror = \"Unable to load configuration file (%s)\" % e.strerror\n            raise\n        return self.from_mapping(obj)\n\n    def from_mapping(self, *mapping, **kwargs):\n        \"\"\"Updates the config like :meth:`update` ignoring items with non-upper\n        keys.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        mappings = []\n        if len(mapping) == 1:\n            if hasattr(mapping[0], \"items\"):\n                mappings.append(mapping[0].items())\n            else:\n                mappings.append(mapping[0])\n        elif len(mapping) > 1:\n            raise TypeError(\n                \"expected at most 1 positional argument, got %d\" % len(mapping)\n            )\n        mappings.append(kwargs.items())\n        for mapping in mappings:\n            for (key, value) in mapping:\n                if key.isupper():\n                    self[key] = value\n        return True\n\n    def get_namespace(self, namespace, lowercase=True, trim_namespace=True):\n        \"\"\"Returns a dictionary containing a subset of configuration options\n        that match the specified namespace\/prefix. Example usage::\n\n            app.config['IMAGE_STORE_TYPE'] = 'fs'\n            app.config['IMAGE_STORE_PATH'] = '\/var\/app\/images'\n            app.config['IMAGE_STORE_BASE_URL'] = 'http:\/\/img.website.com'\n            image_store_config = app.config.get_namespace('IMAGE_STORE_')\n\n        The resulting dictionary `image_store_config` would look like::\n\n            {\n                'type': 'fs',\n                'path': '\/var\/app\/images',\n                'base_url': 'http:\/\/img.website.com'\n            }\n\n        This is often useful when configuration options map directly to\n        keyword arguments in functions or class constructors.\n\n        :param namespace: a configuration namespace\n        :param lowercase: a flag indicating if the keys of the resulting\n                          dictionary should be lowercase\n        :param trim_namespace: a flag indicating if the keys of the resulting\n                          dictionary should not include the namespace\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {}\n        for k, v in iteritems(self):\n            if not k.startswith(namespace):\n                continue\n            if trim_namespace:\n                key = k[len(namespace) :]\n            else:\n                key = k\n            if lowercase:\n                key = key.lower()\n            rv[key] = v\n        return rv\n\n    def __repr__(self):\n        return \"<%s %s>\" % (self.__class__.__name__, dict.__repr__(self))\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" import pytest\nfrom flask import g, session\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.debughelpers\n    ~~~~~~~~~~~~~~~~~~\n\n    Various helpers to make the development experience better.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom warnings import warn\n\nfrom ._compat import implements_to_string, text_type\nfrom .app import Flask\nfrom .blueprints import Blueprint\nfrom .globals import _request_ctx_stack\n\n\nclass UnexpectedUnicodeError(AssertionError, UnicodeError):\n    \"\"\"Raised in places where we want some better error reporting for\n    unexpected unicode or binary data.\n    \"\"\"\n\n\n@implements_to_string\nclass DebugFilesKeyError(KeyError, AssertionError):\n    \"\"\"Raised from request.files during debugging.  The idea is that it can\n    provide a better error message than just a generic KeyError\/BadRequest.\n    \"\"\"\n\n    def __init__(self, request, key):\n        form_matches = request.form.getlist(key)\n        buf = [\n            'You tried to access the file \"%s\" in the request.files '\n            \"dictionary but it does not exist.  The mimetype for the request \"\n            'is \"%s\" instead of \"multipart\/form-data\" which means that no '\n            \"file contents were transmitted.  To fix this error you should \"\n            'provide enctype=\"multipart\/form-data\" in your form.'\n            % (key, request.mimetype)\n        ]\n        if form_matches:\n            buf.append(\n                \"\\n\\nThe browser instead transmitted some file names. \"\n                \"This was submitted: %s\" % \", \".join('\"%s\"' % x for x in form_matches)\n            )\n        self.msg = \"\".join(buf)\n\n    def __str__(self):\n        return self.msg\n\n\nclass FormDataRoutingRedirect(AssertionError):\n    \"\"\"This exception is raised by Flask in debug mode if it detects a\n    redirect caused by the routing system when the request method is not\n    GET, HEAD or OPTIONS.  Reasoning: form data will be dropped.\n    \"\"\"\n\n    def __init__(self, request):\n        exc = request.routing_exception\n        buf = [\n            \"A request was sent to this URL (%s) but a redirect was \"\n            'issued automatically by the routing system to \"%s\".'\n            % (request.url, exc.new_url)\n        ]\n\n        # In case just a slash was appended we can be extra helpful\n        if request.base_url + \"\/\" == exc.new_url.split(\"?\")[0]:\n            buf.append(\n                \"  The URL was defined with a trailing slash so \"\n                \"Flask will automatically redirect to the URL \"\n                \"with the trailing slash if it was accessed \"\n                \"without one.\"\n            )\n\n        buf.append(\n            \"  Make sure to directly send your %s-request to this URL \"\n            \"since we can't make browsers or HTTP clients redirect \"\n            \"with form data reliably or without user interaction.\" % request.method\n        )\n        buf.append(\"\\n\\nNote: this exception is only raised in debug mode\")\n        AssertionError.__init__(self, \"\".join(buf).encode(\"utf-8\"))\n\n\ndef attach_enctype_error_multidict(request):\n    \"\"\"Since Flask 0.8 we're monkeypatching the files object in case a\n    request is detected that does not use multipart form data but the files\n    object is accessed.\n    \"\"\"\n    oldcls = request.files.__class__\n\n    class newcls(oldcls):\n        def __getitem__(self, key):\n            try:\n                return oldcls.__getitem__(self, key)\n            except KeyError:\n                if key not in request.form:\n                    raise\n                raise DebugFilesKeyError(request, key)\n\n    newcls.__name__ = oldcls.__name__\n    newcls.__module__ = oldcls.__module__\n    request.files.__class__ = newcls\n\n\ndef _dump_loader_info(loader):\n    yield \"class: %s.%s\" % (type(loader).__module__, type(loader).__name__)\n    for key, value in sorted(loader.__dict__.items()):\n        if key.startswith(\"_\"):\n            continue\n        if isinstance(value, (tuple, list)):\n            if not all(isinstance(x, (str, text_type)) for x in value):\n                continue\n            yield \"%s:\" % key\n            for item in value:\n                yield \"  - %s\" % item\n            continue\n        elif not isinstance(value, (str, text_type, int, float, bool)):\n            continue\n        yield \"%s: %r\" % (key, value)\n\n\ndef explain_template_loading_attempts(app, template, attempts):\n    \"\"\"This should help developers understand what failed\"\"\"\n    info = ['Locating template \"%s\":' % template]\n    total_found = 0\n    blueprint = None\n    reqctx = _request_ctx_stack.top\n    if reqctx is not None and reqctx.request.blueprint is not None:\n        blueprint = reqctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, Flask):\n            src_info = 'application \"%s\"' % srcobj.import_name\n        elif isinstance(srcobj, Blueprint):\n            src_info = 'blueprint \"%s\" (%s)' % (srcobj.name, srcobj.import_name)\n        else:\n            src_info = repr(srcobj)\n\n        info.append(\"% 5d: trying loader of %s\" % (idx + 1, src_info))\n\n        for line in _dump_loader_info(loader):\n            info.append(\"       %s\" % line)\n\n        if triple is None:\n            detail = \"no match\"\n        else:\n            detail = \"found (%r)\" % (triple[1] or \"<string>\")\n            total_found += 1\n        info.append(\"       -> %s\" % detail)\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(\"Error: the template could not be found.\")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(\"Warning: multiple loaders returned a match for the template.\")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            \"  The template was looked up from an endpoint that \"\n            'belongs to the blueprint \"%s\".' % blueprint\n        )\n        info.append(\"  Maybe you did not place a template in the right folder?\")\n        info.append(\"  See http:\/\/flask.pocoo.org\/docs\/blueprints\/#templates\")\n\n    app.logger.info(\"\\n\".join(info))\n\n\ndef explain_ignored_app_run():\n    if os.environ.get(\"WERKZEUG_RUN_MAIN\") != \"true\":\n        warn(\n            Warning(\n                \"Silently ignoring app.run() because the \"\n                \"application is run from the flask command line \"\n                \"executable.  Consider putting app.run() behind an \"\n                'if __name__ == \"__main__\" guard to silence this '\n                \"warning.\"\n            ),\n            stacklevel=3,\n        )\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" import pytest\nfrom flask import g, session\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.globals\n    ~~~~~~~~~~~~~\n\n    Defines all the global objects that are proxies to the current\n    active context.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom functools import partial\nfrom werkzeug.local import LocalStack, LocalProxy\n\n\n_request_ctx_err_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request.  Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_app_ctx_err_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nto interface with the current application object in some way. To solve\nthis, set up an application context with app.app_context().  See the\ndocumentation for more information.\\\n\"\"\"\n\n\ndef _lookup_req_object(name):\n    top = _request_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_request_ctx_err_msg)\n    return getattr(top, name)\n\n\ndef _lookup_app_object(name):\n    top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n    return getattr(top, name)\n\n\ndef _find_app():\n    top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n    return top.app\n\n\n# context locals\n_request_ctx_stack = LocalStack()\n_app_ctx_stack = LocalStack()\ncurrent_app = LocalProxy(_find_app)\nrequest = LocalProxy(partial(_lookup_req_object, \"request\"))\nsession = LocalProxy(partial(_lookup_req_object, \"session\"))\ng = LocalProxy(partial(_lookup_app_object, \"g\"))\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" import pytest\nfrom flask import g, session\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nTagged JSON\n~~~~~~~~~~~\n\nA compact representation for lossless serialization of non-standard JSON types.\n:class:`~flask.sessions.SecureCookieSessionInterface` uses this to serialize\nthe session data, but it may be useful in other places. It can be extended to\nsupport other types.\n\n.. autoclass:: TaggedJSONSerializer\n    :members:\n\n.. autoclass:: JSONTag\n    :members:\n\nLet's seen an example that adds support for :class:`~collections.OrderedDict`.\nDicts don't have an order in Python or JSON, so to handle this we will dump\nthe items as a list of ``[key, value]`` pairs. Subclass :class:`JSONTag` and\ngive it the new key ``' od'`` to identify the type. The session serializer\nprocesses dicts first, so insert the new tag at the front of the order since\n``OrderedDict`` must be processed before ``dict``. ::\n\n    from flask.json.tag import JSONTag\n\n    class TagOrderedDict(JSONTag):\n        __slots__ = ('serializer',)\n        key = ' od'\n\n        def check(self, value):\n            return isinstance(value, OrderedDict)\n\n        def to_json(self, value):\n            return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]\n\n        def to_python(self, value):\n            return OrderedDict(value)\n\n    app.session_interface.serializer.register(TagOrderedDict, index=0)\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom base64 import b64decode, b64encode\nfrom datetime import datetime\nfrom uuid import UUID\n\nfrom jinja2 import Markup\nfrom werkzeug.http import http_date, parse_date\n\nfrom flask._compat import iteritems, text_type\nfrom flask.json import dumps, loads\n\n\nclass JSONTag(object):\n    \"\"\"Base class for defining type tags for :class:`TaggedJSONSerializer`.\"\"\"\n\n    __slots__ = (\"serializer\",)\n\n    #: The tag to mark the serialized object with. If ``None``, this tag is\n    #: only used as an intermediate step during tagging.\n    key = None\n\n    def __init__(self, serializer):\n        \"\"\"Create a tagger for the given serializer.\"\"\"\n        self.serializer = serializer\n\n    def check(self, value):\n        \"\"\"Check if the given value should be tagged by this tag.\"\"\"\n        raise NotImplementedError\n\n    def to_json(self, value):\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n\n    def to_python(self, value):\n        \"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"\n        raise NotImplementedError\n\n    def tag(self, value):\n        \"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"\n        return {self.key: self.to_json(value)}\n\n\nclass TagDict(JSONTag):\n    \"\"\"Tag for 1-item dicts whose only key matches a registered tag.\n\n    Internally, the dict key is suffixed with `__`, and the suffix is removed\n    when deserializing.\n    \"\"\"\n\n    __slots__ = ()\n    key = \" di\"\n\n    def check(self, value):\n        return (\n            isinstance(value, dict)\n            and len(value) == 1\n            and next(iter(value)) in self.serializer.tags\n        )\n\n    def to_json(self, value):\n        key = next(iter(value))\n        return {key + \"__\": self.serializer.tag(value[key])}\n\n    def to_python(self, value):\n        key = next(iter(value))\n        return {key[:-2]: value[key]}\n\n\nclass PassDict(JSONTag):\n    __slots__ = ()\n\n    def check(self, value):\n        return isinstance(value, dict)\n\n    def to_json(self, value):\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return dict((k, self.serializer.tag(v)) for k, v in iteritems(value))\n\n    tag = to_json\n\n\nclass TagTuple(JSONTag):\n    __slots__ = ()\n    key = \" t\"\n\n    def check(self, value):\n        return isinstance(value, tuple)\n\n    def to_json(self, value):\n        return [self.serializer.tag(item) for item in value]\n\n    def to_python(self, value):\n        return tuple(value)\n\n\nclass PassList(JSONTag):\n    __slots__ = ()\n\n    def check(self, value):\n        return isinstance(value, list)\n\n    def to_json(self, value):\n        return [self.serializer.tag(item) for item in value]\n\n    tag = to_json\n\n\nclass TagBytes(JSONTag):\n    __slots__ = ()\n    key = \" b\"\n\n    def check(self, value):\n        return isinstance(value, bytes)\n\n    def to_json(self, value):\n        return b64encode(value).decode(\"ascii\")\n\n    def to_python(self, value):\n        return b64decode(value)\n\n\nclass TagMarkup(JSONTag):\n    \"\"\"Serialize anything matching the :class:`~flask.Markup` API by\n    having a ``__html__`` method to the result of that method. Always\n    deserializes to an instance of :class:`~flask.Markup`.\"\"\"\n\n    __slots__ = ()\n    key = \" m\"\n\n    def check(self, value):\n        return callable(getattr(value, \"__html__\", None))\n\n    def to_json(self, value):\n        return text_type(value.__html__())\n\n    def to_python(self, value):\n        return Markup(value)\n\n\nclass TagUUID(JSONTag):\n    __slots__ = ()\n    key = \" u\"\n\n    def check(self, value):\n        return isinstance(value, UUID)\n\n    def to_json(self, value):\n        return value.hex\n\n    def to_python(self, value):\n        return UUID(value)\n\n\nclass TagDateTime(JSONTag):\n    __slots__ = ()\n    key = \" d\"\n\n    def check(self, value):\n        return isinstance(value, datetime)\n\n    def to_json(self, value):\n        return http_date(value)\n\n    def to_python(self, value):\n        return parse_date(value)\n\n\nclass TaggedJSONSerializer(object):\n    \"\"\"Serializer that uses a tag system to compactly represent objects that\n    are not JSON types. Passed as the intermediate serializer to\n    :class:`itsdangerous.Serializer`.\n\n    The following extra types are supported:\n\n    * :class:`dict`\n    * :class:`tuple`\n    * :class:`bytes`\n    * :class:`~flask.Markup`\n    * :class:`~uuid.UUID`\n    * :class:`~datetime.datetime`\n    \"\"\"\n\n    __slots__ = (\"tags\", \"order\")\n\n    #: Tag classes to bind when creating the serializer. Other tags can be\n    #: added later using :meth:`~register`.\n    default_tags = [\n        TagDict,\n        PassDict,\n        TagTuple,\n        PassList,\n        TagBytes,\n        TagMarkup,\n        TagUUID,\n        TagDateTime,\n    ]\n\n    def __init__(self):\n        self.tags = {}\n        self.order = []\n\n        for cls in self.default_tags:\n            self.register(cls)\n\n    def register(self, tag_class, force=False, index=None):\n        \"\"\"Register a new tag with this serializer.\n\n        :param tag_class: tag class to register. Will be instantiated with this\n            serializer instance.\n        :param force: overwrite an existing tag. If false (default), a\n            :exc:`KeyError` is raised.\n        :param index: index to insert the new tag in the tag order. Useful when\n            the new tag is a special case of an existing tag. If ``None``\n            (default), the tag is appended to the end of the order.\n\n        :raise KeyError: if the tag key is already registered and ``force`` is\n            not true.\n        \"\"\"\n        tag = tag_class(self)\n        key = tag.key\n\n        if key is not None:\n            if not force and key in self.tags:\n                raise KeyError(\"Tag '{0}' is already registered.\".format(key))\n\n            self.tags[key] = tag\n\n        if index is None:\n            self.order.append(tag)\n        else:\n            self.order.insert(index, tag)\n\n    def tag(self, value):\n        \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n        for tag in self.order:\n            if tag.check(value):\n                return tag.tag(value)\n\n        return value\n\n    def untag(self, value):\n        \"\"\"Convert a tagged representation back to the original type.\"\"\"\n        if len(value) != 1:\n            return value\n\n        key = next(iter(value))\n\n        if key not in self.tags:\n            return value\n\n        return self.tags[key].to_python(value[key])\n\n    def dumps(self, value):\n        \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n        return dumps(self.tag(value), separators=(\",\", \":\"))\n\n    def loads(self, value):\n        \"\"\"Load data from a JSON string and deserialized any tagged objects.\"\"\"\n        return loads(value, object_hook=self.untag)\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" import pytest\nfrom flask import g, session\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(\"flask.app\")\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" import pytest\nfrom flask import g, session\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.signals\n    ~~~~~~~~~~~~~\n\n    Implements signals based on blinker if available, otherwise\n    falls silently back to a noop.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nsignals_available = False\ntry:\n    from blinker import Namespace\n\n    signals_available = True\nexcept ImportError:\n\n    class Namespace(object):\n        def signal(self, name, doc=None):\n            return _FakeSignal(name, doc)\n\n    class _FakeSignal(object):\n        \"\"\"If blinker is unavailable, create a fake class with the same\n        interface that allows sending of signals but will fail with an\n        error on anything else.  Instead of doing anything on send, it\n        will just ignore the arguments and do nothing instead.\n        \"\"\"\n\n        def __init__(self, name, doc=None):\n            self.name = name\n            self.__doc__ = doc\n\n        def _fail(self, *args, **kwargs):\n            raise RuntimeError(\n                \"signalling support is unavailable \"\n                \"because the blinker library is \"\n                \"not installed.\"\n            )\n\n        send = lambda *a, **kw: None\n        connect = (\n            disconnect\n        ) = (\n            has_receivers_for\n        ) = receivers_for = temporarily_connected_to = connected_to = _fail\n        del _fail\n\n\n# The namespace for code signals.  If you are not Flask code, do\n# not put signals in here.  Create your own namespace instead.\n_signals = Namespace()\n\n\n# Core signals.  For usage examples grep the source code or consult\n# the API documentation in docs\/api.rst as well as docs\/signals.rst\ntemplate_rendered = _signals.signal(\"template-rendered\")\nbefore_render_template = _signals.signal(\"before-render-template\")\nrequest_started = _signals.signal(\"request-started\")\nrequest_finished = _signals.signal(\"request-finished\")\nrequest_tearing_down = _signals.signal(\"request-tearing-down\")\ngot_request_exception = _signals.signal(\"got-request-exception\")\nappcontext_tearing_down = _signals.signal(\"appcontext-tearing-down\")\nappcontext_pushed = _signals.signal(\"appcontext-pushed\")\nappcontext_popped = _signals.signal(\"appcontext-popped\")\nmessage_flashed = _signals.signal(\"message-flashed\")\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" import pytest\nfrom flask import g, session\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.templating\n    ~~~~~~~~~~~~~~~~\n\n    Implements the bridge to Jinja2.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom jinja2 import BaseLoader, Environment as BaseEnvironment, TemplateNotFound\n\nfrom .globals import _request_ctx_stack, _app_ctx_stack\nfrom .signals import template_rendered, before_render_template\n\n\ndef _default_template_ctx_processor():\n    \"\"\"Default template context processor.  Injects `request`,\n    `session` and `g`.\n    \"\"\"\n    reqctx = _request_ctx_stack.top\n    appctx = _app_ctx_stack.top\n    rv = {}\n    if appctx is not None:\n        rv[\"g\"] = appctx.g\n    if reqctx is not None:\n        rv[\"request\"] = reqctx.request\n        rv[\"session\"] = reqctx.session\n    return rv\n\n\nclass Environment(BaseEnvironment):\n    \"\"\"Works like a regular Jinja2 environment but has some additional\n    knowledge of how Flask's blueprint works so that it can prepend the\n    name of the blueprint to referenced templates if necessary.\n    \"\"\"\n\n    def __init__(self, app, **options):\n        if \"loader\" not in options:\n            options[\"loader\"] = app.create_global_jinja_loader()\n        BaseEnvironment.__init__(self, **options)\n        self.app = app\n\n\nclass DispatchingJinjaLoader(BaseLoader):\n    \"\"\"A loader that looks for templates in the application and all\n    the blueprint folders.\n    \"\"\"\n\n    def __init__(self, app):\n        self.app = app\n\n    def get_source(self, environment, template):\n        if self.app.config[\"EXPLAIN_TEMPLATE_LOADING\"]:\n            return self._get_source_explained(environment, template)\n        return self._get_source_fast(environment, template)\n\n    def _get_source_explained(self, environment, template):\n        attempts = []\n        trv = None\n\n        for srcobj, loader in self._iter_loaders(template):\n            try:\n                rv = loader.get_source(environment, template)\n                if trv is None:\n                    trv = rv\n            except TemplateNotFound:\n                rv = None\n            attempts.append((loader, srcobj, rv))\n\n        from .debughelpers import explain_template_loading_attempts\n\n        explain_template_loading_attempts(self.app, template, attempts)\n\n        if trv is not None:\n            return trv\n        raise TemplateNotFound(template)\n\n    def _get_source_fast(self, environment, template):\n        for srcobj, loader in self._iter_loaders(template):\n            try:\n                return loader.get_source(environment, template)\n            except TemplateNotFound:\n                continue\n        raise TemplateNotFound(template)\n\n    def _iter_loaders(self, template):\n        loader = self.app.jinja_loader\n        if loader is not None:\n            yield self.app, loader\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                yield blueprint, loader\n\n    def list_templates(self):\n        result = set()\n        loader = self.app.jinja_loader\n        if loader is not None:\n            result.update(loader.list_templates())\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                for template in loader.list_templates():\n                    result.add(template)\n\n        return list(result)\n\n\ndef _render(template, context, app):\n    \"\"\"Renders the template and fires the signal\"\"\"\n\n    before_render_template.send(app, template=template, context=context)\n    rv = template.render(context)\n    template_rendered.send(app, template=template, context=context)\n    return rv\n\n\ndef render_template(template_name_or_list, **context):\n    \"\"\"Renders a template from the template folder with the given\n    context.\n\n    :param template_name_or_list: the name of the template to be\n                                  rendered, or an iterable with template names\n                                  the first one existing will be rendered\n    :param context: the variables that should be available in the\n                    context of the template.\n    \"\"\"\n    ctx = _app_ctx_stack.top\n    ctx.app.update_template_context(context)\n    return _render(\n        ctx.app.jinja_env.get_or_select_template(template_name_or_list),\n        context,\n        ctx.app,\n    )\n\n\ndef render_template_string(source, **context):\n    \"\"\"Renders a template from the given template source string\n    with the given context. Template variables will be autoescaped.\n\n    :param source: the source code of the template to be\n                   rendered\n    :param context: the variables that should be available in the\n                    context of the template.\n    \"\"\"\n    ctx = _app_ctx_stack.top\n    ctx.app.update_template_context(context)\n    return _render(ctx.app.jinja_env.from_string(source), context, ctx.app)\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" import pytest\nfrom flask import g, session\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.sessions\n    ~~~~~~~~~~~~~~\n\n    Implements cookie based sessions based on itsdangerous.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport hashlib\nimport warnings\nfrom datetime import datetime\n\nfrom itsdangerous import BadSignature, URLSafeTimedSerializer\nfrom werkzeug.datastructures import CallbackDict\n\nfrom flask._compat import collections_abc\nfrom flask.helpers import is_ip, total_seconds\nfrom flask.json.tag import TaggedJSONSerializer\n\n\nclass SessionMixin(collections_abc.MutableMapping):\n    \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n\n    @property\n    def permanent(self):\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)\n\n    @permanent.setter\n    def permanent(self, value):\n        self[\"_permanent\"] = bool(value)\n\n    #: Some implementations can detect whether a session is newly\n    #: created, but that is not guaranteed. Use with caution. The mixin\n    # default is hard-coded ``False``.\n    new = False\n\n    #: Some implementations can detect changes to the session and set\n    #: this when that happens. The mixin default is hard coded to\n    #: ``True``.\n    modified = True\n\n    #: Some implementations can detect when session data is read or\n    #: written and set this when that happens. The mixin default is hard\n    #: coded to ``True``.\n    accessed = True\n\n\nclass SecureCookieSession(CallbackDict, SessionMixin):\n    \"\"\"Base class for sessions based on signed cookies.\n\n    This session backend will set the :attr:`modified` and\n    :attr:`accessed` attributes. It cannot reliably track whether a\n    session is new (vs. empty), so :attr:`new` remains hard coded to\n    ``False``.\n    \"\"\"\n\n    #: When data is changed, this is set to ``True``. Only the session\n    #: dictionary itself is tracked; if the session contains mutable\n    #: data (for example a nested dict) then this must be set to\n    #: ``True`` manually when modifying that data. The session cookie\n    #: will only be written to the response if this is ``True``.\n    modified = False\n\n    #: When data is read or written, this is set to ``True``. Used by\n    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``\n    #: header, which allows caching proxies to cache different pages for\n    #: different users.\n    accessed = False\n\n    def __init__(self, initial=None):\n        def on_update(self):\n            self.modified = True\n            self.accessed = True\n\n        super(SecureCookieSession, self).__init__(initial, on_update)\n\n    def __getitem__(self, key):\n        self.accessed = True\n        return super(SecureCookieSession, self).__getitem__(key)\n\n    def get(self, key, default=None):\n        self.accessed = True\n        return super(SecureCookieSession, self).get(key, default)\n\n    def setdefault(self, key, default=None):\n        self.accessed = True\n        return super(SecureCookieSession, self).setdefault(key, default)\n\n\nclass NullSession(SecureCookieSession):\n    \"\"\"Class used to generate nicer error messages if sessions are not\n    available.  Will still allow read-only access to the empty session\n    but fail on setting.\n    \"\"\"\n\n    def _fail(self, *args, **kwargs):\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n\n    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail\n    del _fail\n\n\nclass SessionInterface(object):\n    \"\"\"The basic interface you have to implement in order to replace the\n    default session interface which uses werkzeug's securecookie\n    implementation.  The only methods you have to implement are\n    :meth:`open_session` and :meth:`save_session`, the others have\n    useful defaults which you don't need to change.\n\n    The session object returned by the :meth:`open_session` method has to\n    provide a dictionary like interface plus the properties and methods\n    from the :class:`SessionMixin`.  We recommend just subclassing a dict\n    and adding that mixin::\n\n        class Session(dict, SessionMixin):\n            pass\n\n    If :meth:`open_session` returns ``None`` Flask will call into\n    :meth:`make_null_session` to create a session that acts as replacement\n    if the session support cannot work because some requirement is not\n    fulfilled.  The default :class:`NullSession` class that is created\n    will complain that the secret key was not set.\n\n    To replace the session interface on an application all you have to do\n    is to assign :attr:`flask.Flask.session_interface`::\n\n        app = Flask(__name__)\n        app.session_interface = MySessionInterface()\n\n    .. versionadded:: 0.8\n    \"\"\"\n\n    #: :meth:`make_null_session` will look here for the class that should\n    #: be created when a null session is requested.  Likewise the\n    #: :meth:`is_null_session` method will perform a typecheck against\n    #: this type.\n    null_session_class = NullSession\n\n    #: A flag that indicates if the session interface is pickle based.\n    #: This can be used by Flask extensions to make a decision in regards\n    #: to how to deal with the session object.\n    #:\n    #: .. versionadded:: 0.10\n    pickle_based = False\n\n    def make_null_session(self, app):\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n\n    def is_null_session(self, obj):\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n\n    def get_cookie_domain(self, app):\n        \"\"\"Returns the domain that should be set for the session cookie.\n\n        Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise\n        falls back to detecting the domain based on ``SERVER_NAME``.\n\n        Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is\n        updated to avoid re-running the logic.\n        \"\"\"\n\n        rv = app.config[\"SESSION_COOKIE_DOMAIN\"]\n\n        # set explicitly, or cached from SERVER_NAME detection\n        # if False, return None\n        if rv is not None:\n            return rv if rv else None\n\n        rv = app.config[\"SERVER_NAME\"]\n\n        # server name not set, cache False to return none next time\n        if not rv:\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        # chop off the port which is usually not supported by browsers\n        # remove any leading '.' since we'll add that later\n        rv = rv.rsplit(\":\", 1)[0].lstrip(\".\")\n\n        if \".\" not in rv:\n            # Chrome doesn't allow names without a '.'\n            # this should only come up with localhost\n            # hack around this by not setting the name, and show a warning\n            warnings.warn(\n                '\"{rv}\" is not a valid cookie domain, it must contain a \".\".'\n                \" Add an entry to your hosts file, for example\"\n                ' \"{rv}.localdomain\", and use that instead.'.format(rv=rv)\n            )\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        ip = is_ip(rv)\n\n        if ip:\n            warnings.warn(\n                \"The session cookie domain is an IP address. This may not work\"\n                \" as intended in some browsers. Add an entry to your hosts\"\n                ' file, for example \"localhost.localdomain\", and use that'\n                \" instead.\"\n            )\n\n        # if this is not an ip and app is mounted at the root, allow subdomain\n        # matching by adding a '.' prefix\n        if self.get_cookie_path(app) == \"\/\" and not ip:\n            rv = \".\" + rv\n\n        app.config[\"SESSION_COOKIE_DOMAIN\"] = rv\n        return rv\n\n    def get_cookie_path(self, app):\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``\/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]\n\n    def get_cookie_httponly(self, app):\n        \"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_HTTPONLY\"]\n\n    def get_cookie_secure(self, app):\n        \"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SECURE\"]\n\n    def get_cookie_samesite(self, app):\n        \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SAMESITE\"]\n\n    def get_expiration_time(self, app, session):\n        \"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"\n        if session.permanent:\n            return datetime.utcnow() + app.permanent_session_lifetime\n\n    def should_set_cookie(self, app, session):\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n\n    def open_session(self, app, request):\n        \"\"\"This method has to be implemented and must either return ``None``\n        in case the loading failed because of a configuration error or an\n        instance of a session object which implements a dictionary like\n        interface + the methods and attributes on :class:`SessionMixin`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def save_session(self, app, session, response):\n        \"\"\"This is called for actual sessions returned by :meth:`open_session`\n        at the end of the request.  This is still called during a request\n        context so if you absolutely need access to the request you can do\n        that.\n        \"\"\"\n        raise NotImplementedError()\n\n\nsession_json_serializer = TaggedJSONSerializer()\n\n\nclass SecureCookieSessionInterface(SessionInterface):\n    \"\"\"The default session interface that stores sessions in signed cookies\n    through the :mod:`itsdangerous` module.\n    \"\"\"\n\n    #: the salt that should be applied on top of the secret key for the\n    #: signing of cookie based sessions.\n    salt = \"cookie-session\"\n    #: the hash function to use for the signature.  The default is sha1\n    digest_method = staticmethod(hashlib.sha1)\n    #: the name of the itsdangerous supported key derivation.  The default\n    #: is hmac.\n    key_derivation = \"hmac\"\n    #: A python serializer for the payload.  The default is a compact\n    #: JSON derived serializer with support for some extra Python types\n    #: such as datetime objects or tuples.\n    serializer = session_json_serializer\n    session_class = SecureCookieSession\n\n    def get_signing_serializer(self, app):\n        if not app.secret_key:\n            return None\n        signer_kwargs = dict(\n            key_derivation=self.key_derivation, digest_method=self.digest_method\n        )\n        return URLSafeTimedSerializer(\n            app.secret_key,\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs=signer_kwargs,\n        )\n\n    def open_session(self, app, request):\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(app.session_cookie_name)\n        if not val:\n            return self.session_class()\n        max_age = total_seconds(app.permanent_session_lifetime)\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(\n                    app.session_cookie_name, domain=domain, path=path\n                )\n\n            return\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        httponly = self.get_cookie_httponly(app)\n        secure = self.get_cookie_secure(app)\n        samesite = self.get_cookie_samesite(app)\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))\n        response.set_cookie(\n            app.session_cookie_name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            samesite=samesite,\n        )\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" import pytest\nfrom flask import g, session\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n#!\/usr\/bin\/env python\nfrom __future__ import print_function\n\nimport os\nimport re\nimport sys\nfrom datetime import date, datetime\nfrom subprocess import PIPE, Popen\n\n_date_strip_re = re.compile(r\"(?<=\\d)(st|nd|rd|th)\")\n\n\ndef parse_changelog():\n    with open(\"CHANGES.rst\") as f:\n        lineiter = iter(f)\n        for line in lineiter:\n            match = re.search(\"^Version\\s+(.*)\", line.strip())\n\n            if match is None:\n                continue\n\n            version = match.group(1).strip()\n\n            if next(lineiter).count(\"-\") != len(match.group(0)):\n                continue\n\n            while 1:\n                change_info = next(lineiter).strip()\n\n                if change_info:\n                    break\n\n            match = re.search(\n                r\"released on (\\w+\\s+\\d+\\w+\\s+\\d+)(?:, codename (.*))?\",\n                change_info,\n                flags=re.IGNORECASE,\n            )\n\n            if match is None:\n                continue\n\n            datestr, codename = match.groups()\n            return version, parse_date(datestr), codename\n\n\ndef bump_version(version):\n    try:\n        parts = [int(i) for i in version.split(\".\")]\n    except ValueError:\n        fail(\"Current version is not numeric\")\n\n    parts[-1] += 1\n    return \".\".join(map(str, parts))\n\n\ndef parse_date(string):\n    string = _date_strip_re.sub(\"\", string)\n    return datetime.strptime(string, \"%B %d %Y\")\n\n\ndef set_filename_version(filename, version_number, pattern):\n    changed = []\n\n    def inject_version(match):\n        before, old, after = match.groups()\n        changed.append(True)\n        return before + version_number + after\n\n    with open(filename) as f:\n        contents = re.sub(\n            r\"^(\\s*%s\\s*=\\s*')(.+?)(')\" % pattern,\n            inject_version,\n            f.read(),\n            flags=re.DOTALL | re.MULTILINE,\n        )\n\n    if not changed:\n        fail(\"Could not find %s in %s\", pattern, filename)\n\n    with open(filename, \"w\") as f:\n        f.write(contents)\n\n\ndef set_init_version(version):\n    info(\"Setting __init__.py version to %s\", version)\n    set_filename_version(\"flask\/__init__.py\", version, \"__version__\")\n\n\ndef build():\n    cmd = [sys.executable, \"setup.py\", \"sdist\", \"bdist_wheel\"]\n    Popen(cmd).wait()\n\n\ndef fail(message, *args):\n    print(\"Error:\", message % args, file=sys.stderr)\n    sys.exit(1)\n\n\ndef info(message, *args):\n    print(message % args, file=sys.stderr)\n\n\ndef get_git_tags():\n    return set(Popen([\"git\", \"tag\"], stdout=PIPE).communicate()[0].splitlines())\n\n\ndef git_is_clean():\n    return Popen([\"git\", \"diff\", \"--quiet\"]).wait() == 0\n\n\ndef make_git_commit(message, *args):\n    message = message % args\n    Popen([\"git\", \"commit\", \"-am\", message]).wait()\n\n\ndef make_git_tag(tag):\n    info('Tagging \"%s\"', tag)\n    Popen([\"git\", \"tag\", tag]).wait()\n\n\ndef main():\n    os.chdir(os.path.join(os.path.dirname(__file__), \"..\"))\n\n    rv = parse_changelog()\n\n    if rv is None:\n        fail(\"Could not parse changelog\")\n\n    version, release_date, codename = rv\n    dev_version = bump_version(version) + \".dev\"\n\n    info(\n        \"Releasing %s (codename %s, release date %s)\",\n        version,\n        codename,\n        release_date.strftime(\"%d\/%m\/%Y\"),\n    )\n    tags = get_git_tags()\n\n    if version in tags:\n        fail('Version \"%s\" is already tagged', version)\n\n    if release_date.date() != date.today():\n        fail(\"Release date is not today (%s != %s)\", release_date.date(), date.today())\n\n    if not git_is_clean():\n        fail(\"You have uncommitted changes in git\")\n\n    try:\n        import wheel  # noqa: F401\n    except ImportError:\n        fail(\"You need to install the wheel package.\")\n\n    set_init_version(version)\n    make_git_commit(\"Bump version number to %s\", version)\n    make_git_tag(version)\n    build()\n    set_init_version(dev_version)\n\n\nif __name__ == \"__main__\":\n    main()\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.basic\n    ~~~~~~~~~~~~~~~~~~~~~\n\n    The basic functionality.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport re\nimport time\nimport uuid\nfrom datetime import datetime\nfrom threading import Thread\n\nimport pytest\nimport werkzeug.serving\nfrom werkzeug.exceptions import BadRequest, Forbidden, NotFound\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\n\nimport flask\nfrom flask._compat import text_type\n\n\ndef test_options_work(app, client):\n    @app.route(\"\/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"\/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"\n\n\ndef test_options_on_multiple_rules(app, client):\n    @app.route(\"\/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"\/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"\/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]\n\n\ndef test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"\/\")(index)\n    rv = app.test_client().open(\"\/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return \"Hello World!\"\n\n    index2.provide_automatic_options = True\n    app.route(\"\/\", methods=[\"OPTIONS\"])(index2)\n    rv = app.test_client().open(\"\/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n\n\ndef test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"\/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"\/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"\/\").data == b\"GET\"\n\n    rv = client.post(\"\/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    # Older versions of Werkzeug.test.Client don't have an options method\n    if hasattr(client, \"options\"):\n        rv = client.options(\"\/\")\n    else:\n        rv = client.open(\"\/\", method=\"OPTIONS\")\n\n    assert rv.status_code == 405\n\n    rv = client.head(\"\/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"\/more\").data == b\"POST\"\n    assert client.get(\"\/more\").data == b\"GET\"\n\n    rv = client.delete(\"\/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    if hasattr(client, \"options\"):\n        rv = client.options(\"\/more\")\n    else:\n        rv = client.open(\"\/more\", method=\"OPTIONS\")\n\n    assert rv.status_code == 405\n\n\ndef test_request_dispatching(app, client):\n    @app.route(\"\/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"\/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"\/\").data == b\"GET\"\n    rv = client.post(\"\/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"\/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"\/more\").data == b\"POST\"\n    assert client.get(\"\/more\").data == b\"GET\"\n    rv = client.delete(\"\/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n\n\ndef test_disallow_string_for_allowed_methods(app):\n    with pytest.raises(TypeError):\n\n        @app.route(\"\/\", methods=\"GET POST\")\n        def index():\n            return \"Hey\"\n\n\ndef test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"\/\", \"index\", index)\n    app.add_url_rule(\"\/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added when non-uppercase 'options' in methods\n    app.add_url_rule(\"\/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"\/\").data == b\"GET\"\n    rv = client.post(\"\/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"\/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"\/more\").data == b\"POST\"\n    assert client.get(\"\/more\").data == b\"GET\"\n    rv = client.delete(\"\/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"\/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")\n\n\ndef test_werkzeug_routing(app, client):\n    from werkzeug.routing import Submount, Rule\n\n    app.url_map.add(\n        Submount(\"\/foo\", [Rule(\"\/bar\", endpoint=\"bar\"), Rule(\"\/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"\/foo\/\").data == b\"index\"\n    assert client.get(\"\/foo\/bar\").data == b\"bar\"\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Submount, Rule\n\n    app.url_map.add(\n        Submount(\"\/foo\", [Rule(\"\/bar\", endpoint=\"bar\"), Rule(\"\/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"\/foo\/\").data == b\"index\"\n    assert client.get(\"\/foo\/bar\").data == b\"bar\"\n\n\ndef test_session(app, client):\n    @app.route(\"\/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"\/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"\/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"\/get\").data == b\"42\"\n\n\ndef test_session_using_server_name(app, client):\n    app.config.update(SERVER_NAME=\"example.com\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com\/\")\n    assert \"domain=.example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_server_name_and_port(app, client):\n    app.config.update(SERVER_NAME=\"example.com:8080\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com:8080\/\")\n    assert \"domain=.example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_server_name_port_and_path(app, client):\n    app.config.update(SERVER_NAME=\"example.com:8080\", APPLICATION_ROOT=\"\/foo\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com:8080\/foo\")\n    assert \"domain=example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"path=\/foo\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_application_root(app, client):\n    class PrefixPathMiddleware(object):\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"\/bar\")\n    app.config.update(APPLICATION_ROOT=\"\/bar\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com:8080\/\")\n    assert \"path=\/bar\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_session_settings(app, client):\n    app.config.update(\n        SERVER_NAME=\"www.example.com:8080\",\n        APPLICATION_ROOT=\"\/test\",\n        SESSION_COOKIE_DOMAIN=\".example.com\",\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_SAMESITE=\"Lax\",\n        SESSION_COOKIE_PATH=\"\/\",\n    )\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/www.example.com:8080\/test\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"domain=.example.com\" in cookie\n    assert \"path=\/\" in cookie\n    assert \"secure\" in cookie\n    assert \"httponly\" not in cookie\n    assert \"samesite\" in cookie\n\n\ndef test_session_using_samesite_attribute(app, client):\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"\/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie\n\n\ndef test_session_localhost_warning(recwarn, app, client):\n    app.config.update(SERVER_NAME=\"localhost:5000\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"testing\"\n\n    rv = client.get(\"\/\", \"http:\/\/localhost:5000\/\")\n    assert \"domain\" not in rv.headers[\"set-cookie\"].lower()\n    w = recwarn.pop(UserWarning)\n    assert '\"localhost\" is not a valid cookie domain' in str(w.message)\n\n\ndef test_session_ip_warning(recwarn, app, client):\n    app.config.update(SERVER_NAME=\"127.0.0.1:5000\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"testing\"\n\n    rv = client.get(\"\/\", \"http:\/\/127.0.0.1:5000\/\")\n    assert \"domain=127.0.0.1\" in rv.headers[\"set-cookie\"].lower()\n    w = recwarn.pop(UserWarning)\n    assert \"cookie domain is an IP\" in str(w.message)\n\n\ndef test_missing_session(app):\n    app.secret_key = None\n\n    def expect_exception(f, *args, **kwargs):\n        e = pytest.raises(RuntimeError, f, *args, **kwargs)\n        assert e.value.args and \"session is unavailable\" in e.value.args[0]\n\n    with app.test_request_context():\n        assert flask.session.get(\"missing_key\") is None\n        expect_exception(flask.session.__setitem__, \"foo\", 42)\n        expect_exception(flask.session.pop, \"foo\")\n\n\ndef test_session_expiration(app, client):\n    permanent = True\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"test\"] = 42\n        flask.session.permanent = permanent\n        return \"\"\n\n    @app.route(\"\/test\")\n    def test():\n        return text_type(flask.session.permanent)\n\n    rv = client.get(\"\/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    expires = parse_date(match.group())\n    expected = datetime.utcnow() + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"\/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"\/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None\n\n\ndef test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"\/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"\/\").data == b\"None\"\n    assert client.get(\"\/\").data == b\"42\"\n\n\ndef test_session_special_types(app, client):\n    now = datetime.utcnow().replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.route(\"\/\")\n    def dump_session_contents():\n        flask.session[\"t\"] = (1, 2, 3)\n        flask.session[\"b\"] = b\"\\xff\"\n        flask.session[\"m\"] = flask.Markup(\"<html>\")\n        flask.session[\"u\"] = the_uuid\n        flask.session[\"d\"] = now\n        flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n        flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n        flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n        return \"\", 204\n\n    with client:\n        client.get(\"\/\")\n        s = flask.session\n        assert s[\"t\"] == (1, 2, 3)\n        assert type(s[\"b\"]) == bytes\n        assert s[\"b\"] == b\"\\xff\"\n        assert type(s[\"m\"]) == flask.Markup\n        assert s[\"m\"] == flask.Markup(\"<html>\")\n        assert s[\"u\"] == the_uuid\n        assert s[\"d\"] == now\n        assert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\n        assert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\n        assert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}\n\n\ndef test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"\/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"\/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"\/bump\").data == b\"1\"\n            assert c.get(\"\/bump\").data == b\"2\"\n            assert c.get(\"\/bump\").data == b\"3\"\n\n            rv = c.get(\"\/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n\ndef test_session_vary_cookie(app, client):\n    @app.route(\"\/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"\/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"\/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"\/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"\/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"\/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"\/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"\/set\")\n    expect(\"\/get\")\n    expect(\"\/getitem\")\n    expect(\"\/setdefault\")\n    expect(\"\/vary-cookie-header-set\")\n    expect(\"\/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"\/no-vary-header\", None)\n\n\ndef test_flashes(app, req_ctx):\n    assert not flask.session.modified\n    flask.flash(\"Zap\")\n    flask.session.modified = False\n    flask.flash(\"Zip\")\n    assert flask.session.modified\n    assert list(flask.get_flashed_messages()) == [\"Zap\", \"Zip\"]\n\n\ndef test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"\/\")\n    def index():\n        flask.flash(u\"Hello World\")\n        flask.flash(u\"Hello World\", \"error\")\n        flask.flash(flask.Markup(u\"<em>Testing<\/em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"\/test\/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            u\"Hello World\",\n            u\"Hello World\",\n            flask.Markup(u\"<em>Testing<\/em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"\/test_with_categories\/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", u\"Hello World\"),\n            (\"error\", u\"Hello World\"),\n            (\"warning\", flask.Markup(u\"<em>Testing<\/em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"\/test_filter\/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", u\"Hello World\")]\n        return \"\"\n\n    @app.route(\"\/test_filters\/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", u\"Hello World\"),\n            (\"warning\", flask.Markup(u\"<em>Testing<\/em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"\/test_filters_without_returning_categories\/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == u\"Hello World\"\n        assert messages[1] == flask.Markup(u\"<em>Testing<\/em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_with_categories\/\")\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_filter\/\")\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_filters\/\")\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_filters_without_returning_categories\/\")\n\n\ndef test_request_processing(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append(\"before\")\n\n    @app.after_request\n    def after_request(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @app.route(\"\/\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"\/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"\n\n\ndef test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"\/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"\/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]\n\n\ndef test_after_request_processing(app, client):\n    @app.route(\"\/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"\/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"\n\n\ndef test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"\/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"\/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except:\n            pass\n\n    @app.route(\"\/\")\n    def fails():\n        1 \/\/ 0\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert len(called) == 2\n\n\ndef test_before_after_request_order(app, client):\n    called = []\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"\/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]\n\n\ndef test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"\/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"\/error\")\n    def error():\n        1 \/\/ 0\n\n    @app.route(\"\/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"\/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"\/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data\n\n\ndef test_error_handler_unknown_code(app):\n    with pytest.raises(KeyError) as exc_info:\n        app.register_error_handler(999, lambda e: (\"999\", 999))\n\n    assert \"Use a subclass\" in exc_info.value.args[0]\n\n\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"\/\")\n    def broken_func():\n        1 \/\/ 0\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text\/x-special\"\n        return resp\n\n    resp = client.get(\"\/\")\n    assert resp.mimetype == \"text\/x-special\"\n    assert resp.data == b\"internal server error\"\n\n\ndef test_baseexception_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"\/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"\/\")\n\n        ctx = flask._request_ctx_stack.top\n        assert ctx.preserved\n        assert type(ctx._preserved_exc) is KeyboardInterrupt\n\n\ndef test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"\n\n\ndef test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"\/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"\/\").data == b\"42\"\n\n\ndef test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_forbidden_subclass(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"\/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"\/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"\/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"\/1\").data == b\"banana\"\n    assert client.get(\"\/2\").data == b\"apple\"\n    assert client.get(\"\/3\").data == b\"apple\"\n\n\ndef test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"\/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"\/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"\/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"\/E3\")\n    assert rv.data == b\"E2\"\n\n\ndef test_trapping_of_bad_request_key_errors(app, client):\n    @app.route(\"\/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"\/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    rv = client.get(\"\/key\")\n    assert rv.status_code == 400\n    assert b\"missing_key\" not in rv.data\n    rv = client.get(\"\/abort\")\n    assert rv.status_code == 400\n\n    app.debug = True\n    with pytest.raises(KeyError) as e:\n        client.get(\"\/key\")\n    assert e.errisinstance(BadRequest)\n    assert \"missing_key\" in e.value.get_description()\n    rv = client.get(\"\/abort\")\n    assert rv.status_code == 400\n\n    app.debug = False\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = True\n    with pytest.raises(KeyError):\n        client.get(\"\/key\")\n    with pytest.raises(BadRequest):\n        client.get(\"\/abort\")\n\n\ndef test_trapping_of_all_http_exceptions(app, client):\n    app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"\/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"\/fail\")\n\n\ndef test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if trigger == \"before\":\n            1 \/\/ 0\n\n    @app.after_request\n    def after_request(response):\n        if trigger == \"after\":\n            1 \/\/ 0\n        return response\n\n    @app.route(\"\/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for trigger in \"before\", \"after\":\n        rv = client.get(\"\/\")\n        assert rv.status_code == 500\n        assert rv.data == b\"Hello Server Error\"\n\n\ndef test_enctype_debug_helper(app, client):\n    from flask.debughelpers import DebugFilesKeyError\n\n    app.debug = True\n\n    @app.route(\"\/fail\", methods=[\"POST\"])\n    def index():\n        return flask.request.files[\"foo\"].filename\n\n    # with statement is important because we leave an exception on the\n    # stack otherwise and we want to ensure that this is not the case\n    # to not negatively affect other tests.\n    with client:\n        with pytest.raises(DebugFilesKeyError) as e:\n            client.post(\"\/fail\", data={\"foo\": \"index.txt\"})\n        assert \"no file contents were transmitted\" in str(e.value)\n        assert 'This was submitted: \"index.txt\"' in str(e.value)\n\n\ndef test_response_types(app, client):\n    @app.route(\"\/text\")\n    def from_text():\n        return u\"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"\/bytes\")\n    def from_bytes():\n        return u\"H\u00e4llo W\u00f6rld\".encode(\"utf-8\")\n\n    @app.route(\"\/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text\/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"\/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text\/plain; charset=utf-8\"}\n\n    @app.route(\"\/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"\/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\"Hello world\", 404, {\"X-Foo\": \"Baz\"}),\n            {\"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"\/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"\/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    assert client.get(\"\/text\").data == u\"H\u00e4llo W\u00f6rld\".encode(\"utf-8\")\n    assert client.get(\"\/bytes\").data == u\"H\u00e4llo W\u00f6rld\".encode(\"utf-8\")\n\n    rv = client.get(\"\/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text\/plain\"\n\n    rv = client.get(\"\/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text\/plain\"\n\n    rv = client.get(\"\/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text\/html\"\n\n    rv = client.get(\"\/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Baz\", \"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"\/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"\/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n\ndef test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"\/none\")\n    def from_none():\n        pass\n\n    @app.route(\"\/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"\/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"\/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"\/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"\/none\")\n        assert \"returned None\" in str(e)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"\/small_tuple\")\n        assert \"tuple must have the form\" in str(e)\n\n    pytest.raises(TypeError, c.get, \"\/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"\/bad_type\")\n        assert \"it was a bool\" in str(e)\n\n    pytest.raises(TypeError, c.get, \"\/bad_wsgi\")\n\n\ndef test_make_response(app, req_ctx):\n    rv = flask.make_response()\n    assert rv.status_code == 200\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text\/html\"\n\n    rv = flask.make_response(\"Awesome\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Awesome\"\n    assert rv.mimetype == \"text\/html\"\n\n    rv = flask.make_response(\"W00t\", 404)\n    assert rv.status_code == 404\n    assert rv.data == b\"W00t\"\n    assert rv.mimetype == \"text\/html\"\n\n\ndef test_make_response_with_response_instance(app, req_ctx):\n    rv = flask.make_response(flask.jsonify({\"msg\": \"W00t\"}), 400)\n    assert rv.status_code == 400\n    assert rv.data == b'{\"msg\":\"W00t\"}\\n'\n    assert rv.mimetype == \"application\/json\"\n\n    rv = flask.make_response(flask.Response(\"\"), 400)\n    assert rv.status_code == 400\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text\/html\"\n\n    rv = flask.make_response(\n        flask.Response(\"\", headers={\"Content-Type\": \"text\/html\"}),\n        400,\n        [(\"X-Foo\", \"bar\")],\n    )\n    assert rv.status_code == 400\n    assert rv.headers[\"Content-Type\"] == \"text\/html\"\n    assert rv.headers[\"X-Foo\"] == \"bar\"\n\n\ndef test_jsonify_no_prettyprint(app, req_ctx):\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": False})\n    compressed_msg = b'{\"msg\":{\"submsg\":\"W00t\"},\"msg2\":\"foobar\"}\\n'\n    uncompressed_msg = {\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"}\n\n    rv = flask.make_response(flask.jsonify(uncompressed_msg), 200)\n    assert rv.data == compressed_msg\n\n\ndef test_jsonify_prettyprint(app, req_ctx):\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": True})\n    compressed_msg = {\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"}\n    pretty_response = (\n        b'{\\n  \"msg\": {\\n    \"submsg\": \"W00t\"\\n  }, \\n  \"msg2\": \"foobar\"\\n}\\n'\n    )\n\n    rv = flask.make_response(flask.jsonify(compressed_msg), 200)\n    assert rv.data == pretty_response\n\n\ndef test_jsonify_mimetype(app, req_ctx):\n    app.config.update({\"JSONIFY_MIMETYPE\": \"application\/vnd.api+json\"})\n    msg = {\"msg\": {\"submsg\": \"W00t\"}}\n    rv = flask.make_response(flask.jsonify(msg), 200)\n    assert rv.mimetype == \"application\/vnd.api+json\"\n\n\ndef test_jsonify_args_and_kwargs_check(app, req_ctx):\n    with pytest.raises(TypeError) as e:\n        flask.jsonify(\"fake args\", kwargs=\"fake\")\n    assert \"behavior undefined\" in str(e.value)\n\n\ndef test_url_generation(app, req_ctx):\n    @app.route(\"\/hello\/<name>\", methods=[\"POST\"])\n    def hello():\n        pass\n\n    assert flask.url_for(\"hello\", name=\"test x\") == \"\/hello\/test%20x\"\n    assert (\n        flask.url_for(\"hello\", name=\"test x\", _external=True)\n        == \"http:\/\/localhost\/hello\/test%20x\"\n    )\n\n\ndef test_build_error_handler(app):\n    # Test base case, a URL which results in a BuildError.\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"spam\")\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for(\"spam\")\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError(\"Test case where BuildError is not current.\")\n    except RuntimeError:\n        pytest.raises(BuildError, app.handle_url_build_error, error, \"spam\", {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return \"\/test_handler\/\"\n\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for(\"spam\") == \"\/test_handler\/\"\n\n\ndef test_build_error_handler_reraise(app):\n    # Test a custom handler which reraises the BuildError\n    def handler_raises_build_error(error, endpoint, values):\n        raise error\n\n    app.url_build_error_handlers.append(handler_raises_build_error)\n\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"not.existing\")\n\n\ndef test_url_for_passes_special_values_to_build_error_handler(app):\n    @app.url_build_error_handlers.append\n    def handler(error, endpoint, values):\n        assert values == {\n            \"_external\": False,\n            \"_anchor\": None,\n            \"_method\": None,\n            \"_scheme\": None,\n        }\n        return \"handled\"\n\n    with app.test_request_context():\n        flask.url_for(\"\/\")\n\n\ndef test_custom_converters(app, client):\n    from werkzeug.routing import BaseConverter\n\n    class ListConverter(BaseConverter):\n        def to_python(self, value):\n            return value.split(\",\")\n\n        def to_url(self, value):\n            base_to_url = super(ListConverter, self).to_url\n            return \",\".join(base_to_url(x) for x in value)\n\n    app.url_map.converters[\"list\"] = ListConverter\n\n    @app.route(\"\/<list:args>\")\n    def index(args):\n        return \"|\".join(args)\n\n    assert client.get(\"\/1,2,3\").data == b\"1|2|3\"\n\n\ndef test_static_files(app, client):\n    rv = client.get(\"\/static\/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!<\/h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"\/static\/index.html\"\n    rv.close()\n\n\ndef test_static_url_path():\n    app = flask.Flask(__name__, static_url_path=\"\/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"\/foo\/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"\/foo\/index.html\"\n\n\ndef test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http:\/\/example.com\/static\/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http:\/\/example.com\/static\/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(Exception):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder but without static_host should error.\n    with pytest.raises(Exception):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)\n\n\ndef test_request_locals():\n    assert repr(flask.g) == \"<LocalProxy unbound>\"\n    assert not flask.g\n\n\ndef test_test_app_proper_environ():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n    client = app.test_client()\n\n    @app.route(\"\/\")\n    def index():\n        return \"Foo\"\n\n    @app.route(\"\/\", subdomain=\"foo\")\n    def subdomain():\n        return \"Foo SubDomain\"\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"Foo\"\n\n    rv = client.get(\"\/\", \"http:\/\/localhost.localdomain:5000\")\n    assert rv.data == b\"Foo\"\n\n    rv = client.get(\"\/\", \"https:\/\/localhost.localdomain:5000\")\n    assert rv.data == b\"Foo\"\n\n    app.config.update(SERVER_NAME=\"localhost.localdomain\")\n    rv = client.get(\"\/\", \"https:\/\/localhost.localdomain\")\n    assert rv.data == b\"Foo\"\n\n    try:\n        app.config.update(SERVER_NAME=\"localhost.localdomain:443\")\n        rv = client.get(\"\/\", \"https:\/\/localhost.localdomain\")\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain:443') does not match the \"\n            \"server name from the WSGI environment ('localhost.localdomain')\"\n        )\n\n    try:\n        app.config.update(SERVER_NAME=\"localhost.localdomain\")\n        rv = client.get(\"\/\", \"http:\/\/foo.localhost\")\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain') does not match the \"\n            \"server name from the WSGI environment ('foo.localhost')\"\n        )\n\n    rv = client.get(\"\/\", \"http:\/\/foo.localhost.localdomain\")\n    assert rv.data == b\"Foo SubDomain\"\n\n\ndef test_exception_propagation(app, client):\n    def apprunner(config_key):\n        @app.route(\"\/\")\n        def index():\n            1 \/\/ 0\n\n        if config_key is not None:\n            app.config[config_key] = True\n            with pytest.raises(Exception):\n                client.get(\"\/\")\n        else:\n            assert client.get(\"\/\").status_code == 500\n\n    # we have to run this test in an isolated thread because if the\n    # debug flag is set to true and an exception happens the context is\n    # not torn down.  This causes other tests that run after this fail\n    # when they expect no exception on the stack.\n    for config_key in \"TESTING\", \"PROPAGATE_EXCEPTIONS\", \"DEBUG\", None:\n        t = Thread(target=apprunner, args=(config_key,))\n        t.start()\n        t.join()\n\n\n@pytest.mark.parametrize(\"debug\", [True, False])\n@pytest.mark.parametrize(\"use_debugger\", [True, False])\n@pytest.mark.parametrize(\"use_reloader\", [True, False])\n@pytest.mark.parametrize(\"propagate_exceptions\", [None, True, False])\ndef test_werkzeug_passthrough_errors(\n    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)\n\n\ndef test_max_content_length(app, client):\n    app.config[\"MAX_CONTENT_LENGTH\"] = 64\n\n    @app.before_request\n    def always_first():\n        flask.request.form[\"myfile\"]\n        assert False\n\n    @app.route(\"\/accept\", methods=[\"POST\"])\n    def accept_file():\n        flask.request.form[\"myfile\"]\n        assert False\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return \"42\"\n\n    rv = client.post(\"\/accept\", data={\"myfile\": \"foo\" * 100})\n    assert rv.data == b\"42\"\n\n\ndef test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"\/<lang_code>\/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"\/<lang_code>\/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"\/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"\/de\/\").data == b\"\/de\/about\"\n    assert client.get(\"\/de\/about\").data == b\"\/foo\"\n    assert client.get(\"\/foo\").data == b\"\/en\/about\"\n\n\ndef test_inject_blueprint_url_defaults(app):\n    bp = flask.Blueprint(\"foo.bar.baz\", __name__, template_folder=\"template\")\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values[\"page\"] = \"login\"\n\n    @bp.route(\"\/<page>\")\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults(\"foo.bar.baz.view\", values)\n    expected = dict(page=\"login\")\n    assert values == expected\n\n    with app.test_request_context(\"\/somepage\"):\n        url = flask.url_for(\"foo.bar.baz.view\")\n    expected = \"\/login\"\n    assert url == expected\n\n\ndef test_nonascii_pathinfo(app, client):\n    @app.route(u\"\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(u\"\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    assert rv.data == b\"Hello World!\"\n\n\ndef test_debug_mode_complains_after_first_request(app, client):\n    app.debug = True\n\n    @app.route(\"\/\")\n    def index():\n        return \"Awesome\"\n\n    assert not app.got_first_request\n    assert client.get(\"\/\").data == b\"Awesome\"\n    with pytest.raises(AssertionError) as e:\n\n        @app.route(\"\/foo\")\n        def broken():\n            return \"Meh\"\n\n    assert \"A setup function was called\" in str(e)\n\n    app.debug = False\n\n    @app.route(\"\/foo\")\n    def working():\n        return \"Meh\"\n\n    assert client.get(\"\/foo\").data == b\"Meh\"\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions(app, client):\n    got = []\n\n    @app.before_first_request\n    def foo():\n        got.append(42)\n\n    client.get(\"\/\")\n    assert got == [42]\n    client.get(\"\/\")\n    assert got == [42]\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions_concurrent(app, client):\n    got = []\n\n    @app.before_first_request\n    def foo():\n        time.sleep(0.2)\n        got.append(42)\n\n    def get_and_assert():\n        client.get(\"\/\")\n        assert got == [42]\n\n    t = Thread(target=get_and_assert)\n    t.start()\n    get_and_assert()\n    t.join()\n    assert app.got_first_request\n\n\ndef test_routing_redirect_debugging(app, client):\n    app.debug = True\n\n    @app.route(\"\/foo\/\", methods=[\"GET\", \"POST\"])\n    def foo():\n        return \"success\"\n\n    with client:\n        with pytest.raises(AssertionError) as e:\n            client.post(\"\/foo\", data={})\n        assert \"http:\/\/localhost\/foo\/\" in str(e)\n        assert (\"Make sure to directly send \" \"your POST-request to this URL\") in str(e)\n\n        rv = client.get(\"\/foo\", data={}, follow_redirects=True)\n        assert rv.data == b\"success\"\n\n    app.debug = False\n    with client:\n        rv = client.post(\"\/foo\", data={}, follow_redirects=True)\n        assert rv.data == b\"success\"\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route(\"\/foo\/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"\/bar\/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route(\"\/bar\/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"\/foo\/\"\n        assert flask.url_for(\"bar\") == \"\/bar\/\"\n        assert flask.url_for(\"123\") == \"\/bar\/123\"\n\n    assert client.get(\"\/foo\/\").data == b\"foo\"\n    assert client.get(\"\/bar\/\").data == b\"bar\"\n    assert client.get(\"\/bar\/123\").data == b\"123\"\n\n\ndef test_preserve_only_once(app, client):\n    app.debug = True\n\n    @app.route(\"\/fail\")\n    def fail_func():\n        1 \/\/ 0\n\n    for x in range(3):\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"\/fail\")\n\n    assert flask._request_ctx_stack.top is not None\n    assert flask._app_ctx_stack.top is not None\n    # implicit appctx disappears too\n    flask._request_ctx_stack.top.pop()\n    assert flask._request_ctx_stack.top is None\n    assert flask._app_ctx_stack.top is None\n\n\ndef test_preserve_remembers_exception(app, client):\n    app.debug = True\n    errors = []\n\n    @app.route(\"\/fail\")\n    def fail_func():\n        1 \/\/ 0\n\n    @app.route(\"\/success\")\n    def success_func():\n        return \"Okay\"\n\n    @app.teardown_request\n    def teardown_handler(exc):\n        errors.append(exc)\n\n    # After this failure we did not yet call the teardown handler\n    with pytest.raises(ZeroDivisionError):\n        client.get(\"\/fail\")\n    assert errors == []\n\n    # But this request triggers it, and it's an error\n    client.get(\"\/success\")\n    assert len(errors) == 2\n    assert isinstance(errors[0], ZeroDivisionError)\n\n    # At this point another request does nothing.\n    client.get(\"\/success\")\n    assert len(errors) == 3\n    assert errors[1] is None\n\n\ndef test_get_method_on_g(app_ctx):\n    assert flask.g.get(\"x\") is None\n    assert flask.g.get(\"x\", 11) == 11\n    flask.g.x = 42\n    assert flask.g.get(\"x\") == 42\n    assert flask.g.x == 42\n\n\ndef test_g_iteration_protocol(app_ctx):\n    flask.g.foo = 23\n    flask.g.bar = 42\n    assert \"foo\" in flask.g\n    assert \"foos\" not in flask.g\n    assert sorted(flask.g) == [\"bar\", \"foo\"]\n\n\ndef test_subdomain_basic_support():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"\/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"\/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"\/\", \"http:\/\/localhost.localdomain\/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"\/\", \"http:\/\/test.localhost.localdomain\/\")\n    assert rv.data == b\"test index\"\n\n\ndef test_subdomain_matching():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n\n    @app.route(\"\/\", subdomain=\"<user>\")\n    def index(user):\n        return \"index for %s\" % user\n\n    rv = client.get(\"\/\", \"http:\/\/mitsuhiko.localhost.localdomain\/\")\n    assert rv.data == b\"index for mitsuhiko\"\n\n\ndef test_subdomain_matching_with_ports():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"\/\", subdomain=\"<user>\")\n    def index(user):\n        return \"index for %s\" % user\n\n    rv = client.get(\"\/\", \"http:\/\/mitsuhiko.localhost.localdomain:3000\/\")\n    assert rv.data == b\"index for mitsuhiko\"\n\n\n@pytest.mark.parametrize(\"matching\", (False, True))\ndef test_subdomain_matching_other_name(matching):\n    app = flask.Flask(__name__, subdomain_matching=matching)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"\/\")\n    def index():\n        return \"\", 204\n\n    # ip address can't match name\n    rv = client.get(\"\/\", \"http:\/\/127.0.0.1:3000\/\")\n    assert rv.status_code == 404 if matching else 204\n\n    # allow all subdomains if matching is disabled\n    rv = client.get(\"\/\", \"http:\/\/www.localhost.localdomain:3000\/\")\n    assert rv.status_code == 404 if matching else 204\n\n\ndef test_multi_route_rules(app, client):\n    @app.route(\"\/\")\n    @app.route(\"\/<test>\/\")\n    def index(test=\"a\"):\n        return test\n\n    rv = client.open(\"\/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"\/b\/\")\n    assert rv.data == b\"b\"\n\n\ndef test_multi_route_class_views(app, client):\n    class View(object):\n        def __init__(self, app):\n            app.add_url_rule(\"\/\", \"index\", self.index)\n            app.add_url_rule(\"\/<test>\/\", \"index\", self.index)\n\n        def index(self, test=\"a\"):\n            return test\n\n    _ = View(app)\n    rv = client.open(\"\/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"\/b\/\")\n    assert rv.data == b\"b\"\n\n\ndef test_run_defaults(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"result\"] = \"running...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.run()\n    assert rv[\"result\"] == \"running...\"\n\n\ndef test_run_server_port(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(hostname, port, application, *args, **kwargs):\n        rv[\"result\"] = \"running on %s:%s ...\" % (hostname, port)\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    hostname, port = \"localhost\", 8000\n    app.run(hostname, port, debug=True)\n    assert rv[\"result\"] == \"running on %s:%s ...\" % (hostname, port)\n\n\n@pytest.mark.parametrize(\n    \"host,port,expect_host,expect_port\",\n    (\n        (None, None, \"pocoo.org\", 8080),\n        (\"localhost\", None, \"localhost\", 8080),\n        (None, 80, \"pocoo.org\", 80),\n        (\"localhost\", 80, \"localhost\", 80),\n    ),\n)\ndef test_run_from_config(monkeypatch, host, port, expect_host, expect_port, app):\n    def run_simple_mock(hostname, port, *args, **kwargs):\n        assert hostname == expect_host\n        assert port == expect_port\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"SERVER_NAME\"] = \"pocoo.org:8080\"\n    app.run(host, port)\n\n\ndef test_max_cookie_size(app, client, recwarn):\n    app.config[\"MAX_COOKIE_SIZE\"] = 100\n\n    # outside app context, default to Werkzeug static value,\n    # which is also the default config\n    response = flask.Response()\n    default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\n    assert response.max_cookie_size == default\n\n    # inside app context, use app config\n    with app.app_context():\n        assert flask.Response().max_cookie_size == 100\n\n    @app.route(\"\/\")\n    def index():\n        r = flask.Response(\"\", status=204)\n        r.set_cookie(\"foo\", \"bar\" * 100)\n        return r\n\n    client.get(\"\/\")\n    assert len(recwarn) == 1\n    w = recwarn.pop()\n    assert \"cookie is too large\" in str(w.message)\n\n    app.config[\"MAX_COOKIE_SIZE\"] = 0\n\n    client.get(\"\/\")\n    assert len(recwarn) == 0\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.sessions\n    ~~~~~~~~~~~~~~\n\n    Implements cookie based sessions based on itsdangerous.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport hashlib\nimport warnings\nfrom datetime import datetime\n\nfrom itsdangerous import BadSignature, URLSafeTimedSerializer\nfrom werkzeug.datastructures import CallbackDict\n\nfrom flask._compat import collections_abc\nfrom flask.helpers import is_ip, total_seconds\nfrom flask.json.tag import TaggedJSONSerializer\n\n\nclass SessionMixin(collections_abc.MutableMapping):\n    \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n\n    @property\n    def permanent(self):\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)\n\n    @permanent.setter\n    def permanent(self, value):\n        self[\"_permanent\"] = bool(value)\n\n    #: Some implementations can detect whether a session is newly\n    #: created, but that is not guaranteed. Use with caution. The mixin\n    # default is hard-coded ``False``.\n    new = False\n\n    #: Some implementations can detect changes to the session and set\n    #: this when that happens. The mixin default is hard coded to\n    #: ``True``.\n    modified = True\n\n    #: Some implementations can detect when session data is read or\n    #: written and set this when that happens. The mixin default is hard\n    #: coded to ``True``.\n    accessed = True\n\n\nclass SecureCookieSession(CallbackDict, SessionMixin):\n    \"\"\"Base class for sessions based on signed cookies.\n\n    This session backend will set the :attr:`modified` and\n    :attr:`accessed` attributes. It cannot reliably track whether a\n    session is new (vs. empty), so :attr:`new` remains hard coded to\n    ``False``.\n    \"\"\"\n\n    #: When data is changed, this is set to ``True``. Only the session\n    #: dictionary itself is tracked; if the session contains mutable\n    #: data (for example a nested dict) then this must be set to\n    #: ``True`` manually when modifying that data. The session cookie\n    #: will only be written to the response if this is ``True``.\n    modified = False\n\n    #: When data is read or written, this is set to ``True``. Used by\n    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``\n    #: header, which allows caching proxies to cache different pages for\n    #: different users.\n    accessed = False\n\n    def __init__(self, initial=None):\n        def on_update(self):\n            self.modified = True\n            self.accessed = True\n\n        super(SecureCookieSession, self).__init__(initial, on_update)\n\n    def __getitem__(self, key):\n        self.accessed = True\n        return super(SecureCookieSession, self).__getitem__(key)\n\n    def get(self, key, default=None):\n        self.accessed = True\n        return super(SecureCookieSession, self).get(key, default)\n\n    def setdefault(self, key, default=None):\n        self.accessed = True\n        return super(SecureCookieSession, self).setdefault(key, default)\n\n\nclass NullSession(SecureCookieSession):\n    \"\"\"Class used to generate nicer error messages if sessions are not\n    available.  Will still allow read-only access to the empty session\n    but fail on setting.\n    \"\"\"\n\n    def _fail(self, *args, **kwargs):\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n\n    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail\n    del _fail\n\n\nclass SessionInterface(object):\n    \"\"\"The basic interface you have to implement in order to replace the\n    default session interface which uses werkzeug's securecookie\n    implementation.  The only methods you have to implement are\n    :meth:`open_session` and :meth:`save_session`, the others have\n    useful defaults which you don't need to change.\n\n    The session object returned by the :meth:`open_session` method has to\n    provide a dictionary like interface plus the properties and methods\n    from the :class:`SessionMixin`.  We recommend just subclassing a dict\n    and adding that mixin::\n\n        class Session(dict, SessionMixin):\n            pass\n\n    If :meth:`open_session` returns ``None`` Flask will call into\n    :meth:`make_null_session` to create a session that acts as replacement\n    if the session support cannot work because some requirement is not\n    fulfilled.  The default :class:`NullSession` class that is created\n    will complain that the secret key was not set.\n\n    To replace the session interface on an application all you have to do\n    is to assign :attr:`flask.Flask.session_interface`::\n\n        app = Flask(__name__)\n        app.session_interface = MySessionInterface()\n\n    .. versionadded:: 0.8\n    \"\"\"\n\n    #: :meth:`make_null_session` will look here for the class that should\n    #: be created when a null session is requested.  Likewise the\n    #: :meth:`is_null_session` method will perform a typecheck against\n    #: this type.\n    null_session_class = NullSession\n\n    #: A flag that indicates if the session interface is pickle based.\n    #: This can be used by Flask extensions to make a decision in regards\n    #: to how to deal with the session object.\n    #:\n    #: .. versionadded:: 0.10\n    pickle_based = False\n\n    def make_null_session(self, app):\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n\n    def is_null_session(self, obj):\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n\n    def get_cookie_domain(self, app):\n        \"\"\"Returns the domain that should be set for the session cookie.\n\n        Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise\n        falls back to detecting the domain based on ``SERVER_NAME``.\n\n        Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is\n        updated to avoid re-running the logic.\n        \"\"\"\n\n        rv = app.config[\"SESSION_COOKIE_DOMAIN\"]\n\n        # set explicitly, or cached from SERVER_NAME detection\n        # if False, return None\n        if rv is not None:\n            return rv if rv else None\n\n        rv = app.config[\"SERVER_NAME\"]\n\n        # server name not set, cache False to return none next time\n        if not rv:\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        # chop off the port which is usually not supported by browsers\n        # remove any leading '.' since we'll add that later\n        rv = rv.rsplit(\":\", 1)[0].lstrip(\".\")\n\n        if \".\" not in rv:\n            # Chrome doesn't allow names without a '.'\n            # this should only come up with localhost\n            # hack around this by not setting the name, and show a warning\n            warnings.warn(\n                '\"{rv}\" is not a valid cookie domain, it must contain a \".\".'\n                \" Add an entry to your hosts file, for example\"\n                ' \"{rv}.localdomain\", and use that instead.'.format(rv=rv)\n            )\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        ip = is_ip(rv)\n\n        if ip:\n            warnings.warn(\n                \"The session cookie domain is an IP address. This may not work\"\n                \" as intended in some browsers. Add an entry to your hosts\"\n                ' file, for example \"localhost.localdomain\", and use that'\n                \" instead.\"\n            )\n\n        # if this is not an ip and app is mounted at the root, allow subdomain\n        # matching by adding a '.' prefix\n        if self.get_cookie_path(app) == \"\/\" and not ip:\n            rv = \".\" + rv\n\n        app.config[\"SESSION_COOKIE_DOMAIN\"] = rv\n        return rv\n\n    def get_cookie_path(self, app):\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``\/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]\n\n    def get_cookie_httponly(self, app):\n        \"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_HTTPONLY\"]\n\n    def get_cookie_secure(self, app):\n        \"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SECURE\"]\n\n    def get_cookie_samesite(self, app):\n        \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SAMESITE\"]\n\n    def get_expiration_time(self, app, session):\n        \"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"\n        if session.permanent:\n            return datetime.utcnow() + app.permanent_session_lifetime\n\n    def should_set_cookie(self, app, session):\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n\n    def open_session(self, app, request):\n        \"\"\"This method has to be implemented and must either return ``None``\n        in case the loading failed because of a configuration error or an\n        instance of a session object which implements a dictionary like\n        interface + the methods and attributes on :class:`SessionMixin`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def save_session(self, app, session, response):\n        \"\"\"This is called for actual sessions returned by :meth:`open_session`\n        at the end of the request.  This is still called during a request\n        context so if you absolutely need access to the request you can do\n        that.\n        \"\"\"\n        raise NotImplementedError()\n\n\nsession_json_serializer = TaggedJSONSerializer()\n\n\nclass SecureCookieSessionInterface(SessionInterface):\n    \"\"\"The default session interface that stores sessions in signed cookies\n    through the :mod:`itsdangerous` module.\n    \"\"\"\n\n    #: the salt that should be applied on top of the secret key for the\n    #: signing of cookie based sessions.\n    salt = \"cookie-session\"\n    #: the hash function to use for the signature.  The default is sha1\n    digest_method = staticmethod(hashlib.sha1)\n    #: the name of the itsdangerous supported key derivation.  The default\n    #: is hmac.\n    key_derivation = \"hmac\"\n    #: A python serializer for the payload.  The default is a compact\n    #: JSON derived serializer with support for some extra Python types\n    #: such as datetime objects or tuples.\n    serializer = session_json_serializer\n    session_class = SecureCookieSession\n\n    def get_signing_serializer(self, app):\n        if not app.secret_key:\n            return None\n        signer_kwargs = dict(\n            key_derivation=self.key_derivation, digest_method=self.digest_method\n        )\n        return URLSafeTimedSerializer(\n            app.secret_key,\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs=signer_kwargs,\n        )\n\n    def open_session(self, app, request):\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(app.session_cookie_name)\n        if not val:\n            return self.session_class()\n        max_age = total_seconds(app.permanent_session_lifetime)\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(\n                    app.session_cookie_name, domain=domain, path=path\n                )\n\n            return\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        httponly = self.get_cookie_httponly(app)\n        secure = self.get_cookie_secure(app)\n        samesite = self.get_cookie_samesite(app)\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))\n        response.set_cookie(\n            app.session_cookie_name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            samesite=samesite,\n        )\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.helpers\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Various helpers.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport datetime\nimport io\nimport os\nimport uuid\n\nimport pytest\nfrom werkzeug.datastructures import Range\nfrom werkzeug.exceptions import BadRequest, NotFound\nfrom werkzeug.http import http_date, parse_cache_control_header, parse_options_header\n\nimport flask\nfrom flask import json\nfrom flask._compat import StringIO, text_type\nfrom flask.helpers import get_debug_flag, get_env\n\n\ndef has_encoding(name):\n    try:\n        import codecs\n\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n\n\nclass FakePath(object):\n    \"\"\"Fake object to represent a ``PathLike object``.\n\n    This represents a ``pathlib.Path`` object in python 3.\n    See: https:\/\/www.python.org\/dev\/peps\/pep-0519\/\n    \"\"\"\n\n    def __init__(self, path):\n        self.path = path\n\n    def __fspath__(self):\n        return self.path\n\n\nclass FixedOffset(datetime.tzinfo):\n    \"\"\"Fixed offset in hours east from UTC.\n\n    This is a slight adaptation of the ``FixedOffset`` example found in\n    https:\/\/docs.python.org\/2.7\/library\/datetime.html.\n    \"\"\"\n\n    def __init__(self, hours, name):\n        self.__offset = datetime.timedelta(hours=hours)\n        self.__name = name\n\n    def utcoffset(self, dt):\n        return self.__offset\n\n    def tzname(self, dt):\n        return self.__name\n\n    def dst(self, dt):\n        return datetime.timedelta()\n\n\nclass TestJSON(object):\n    @pytest.mark.parametrize(\n        \"value\", (1, \"t\", True, False, None, [], [1, 2, 3], {}, {\"foo\": u\"\ud83d\udc0d\"})\n    )\n    @pytest.mark.parametrize(\n        \"encoding\",\n        (\n            \"utf-8\",\n            \"utf-8-sig\",\n            \"utf-16-le\",\n            \"utf-16-be\",\n            \"utf-16\",\n            \"utf-32-le\",\n            \"utf-32-be\",\n            \"utf-32\",\n        ),\n    )\n    def test_detect_encoding(self, value, encoding):\n        data = json.dumps(value).encode(encoding)\n        assert json.detect_encoding(data) == encoding\n        assert json.loads(data) == value\n\n    def test_ignore_cached_json(self, app):\n        with app.test_request_context(\n            \"\/\", method=\"POST\", data=\"malformed\", content_type=\"application\/json\"\n        ):\n            assert flask.request.get_json(silent=True, cache=True) is None\n            with pytest.raises(BadRequest):\n                flask.request.get_json(silent=False, cache=False)\n\n    def test_different_silent_on_bad_request(self, app):\n        with app.test_request_context(\n            \"\/\", method=\"POST\", data=\"malformed\", content_type=\"application\/json\"\n        ):\n            assert flask.request.get_json(silent=True) is None\n            with pytest.raises(BadRequest):\n                flask.request.get_json(silent=False)\n\n    def test_different_silent_on_normal_request(self, app):\n        with app.test_request_context(\"\/\", method=\"POST\", json={\"foo\": \"bar\"}):\n            silent_rv = flask.request.get_json(silent=True)\n            normal_rv = flask.request.get_json(silent=False)\n            assert silent_rv is normal_rv\n            assert normal_rv[\"foo\"] == \"bar\"\n\n    def test_post_empty_json_adds_exception_to_response_content_in_debug(\n        self, app, client\n    ):\n        app.config[\"DEBUG\"] = True\n        app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def post_json():\n            flask.request.get_json()\n            return None\n\n        rv = client.post(\"\/json\", data=None, content_type=\"application\/json\")\n        assert rv.status_code == 400\n        assert b\"Failed to decode JSON object\" in rv.data\n\n    def test_post_empty_json_wont_add_exception_to_response_if_no_debug(\n        self, app, client\n    ):\n        app.config[\"DEBUG\"] = False\n        app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def post_json():\n            flask.request.get_json()\n            return None\n\n        rv = client.post(\"\/json\", data=None, content_type=\"application\/json\")\n        assert rv.status_code == 400\n        assert b\"Failed to decode JSON object\" not in rv.data\n\n    def test_json_bad_requests(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.jsonify(foo=text_type(flask.request.get_json()))\n\n        rv = client.post(\"\/json\", data=\"malformed\", content_type=\"application\/json\")\n        assert rv.status_code == 400\n\n    def test_json_custom_mimetypes(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.request.get_json()\n\n        rv = client.post(\"\/json\", data='\"foo\"', content_type=\"application\/x+json\")\n        assert rv.data == b\"foo\"\n\n    @pytest.mark.parametrize(\n        \"test_value,expected\", [(True, '\"\\\\u2603\"'), (False, u'\"\\u2603\"')]\n    )\n    def test_json_as_unicode(self, test_value, expected, app, app_ctx):\n\n        app.config[\"JSON_AS_ASCII\"] = test_value\n        rv = flask.json.dumps(u\"\\N{SNOWMAN}\")\n        assert rv == expected\n\n    def test_json_dump_to_file(self, app, app_ctx):\n        test_data = {\"name\": \"Flask\"}\n        out = StringIO()\n\n        flask.json.dump(test_data, out)\n        out.seek(0)\n        rv = flask.json.load(out)\n        assert rv == test_data\n\n    @pytest.mark.parametrize(\n        \"test_value\", [0, -1, 1, 23, 3.14, \"s\", \"longer string\", True, False, None]\n    )\n    def test_jsonify_basic_types(self, test_value, app, client):\n        \"\"\"Test jsonify with basic types.\"\"\"\n\n        url = \"\/jsonify_basic_types\"\n        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n        rv = client.get(url)\n        assert rv.mimetype == \"application\/json\"\n        assert flask.json.loads(rv.data) == test_value\n\n    def test_jsonify_dicts(self, app, client):\n        \"\"\"Test jsonify with dicts and kwargs unpacking.\"\"\"\n        d = {\n            \"a\": 0,\n            \"b\": 23,\n            \"c\": 3.14,\n            \"d\": \"t\",\n            \"e\": \"Hi\",\n            \"f\": True,\n            \"g\": False,\n            \"h\": [\"test list\", 10, False],\n            \"i\": {\"test\": \"dict\"},\n        }\n\n        @app.route(\"\/kw\")\n        def return_kwargs():\n            return flask.jsonify(**d)\n\n        @app.route(\"\/dict\")\n        def return_dict():\n            return flask.jsonify(d)\n\n        for url in \"\/kw\", \"\/dict\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == d\n\n    def test_jsonify_arrays(self, app, client):\n        \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n        l = [\n            0,\n            42,\n            3.14,\n            \"t\",\n            \"hello\",\n            True,\n            False,\n            [\"test list\", 2, False],\n            {\"test\": \"dict\"},\n        ]\n\n        @app.route(\"\/args_unpack\")\n        def return_args_unpack():\n            return flask.jsonify(*l)\n\n        @app.route(\"\/array\")\n        def return_array():\n            return flask.jsonify(l)\n\n        for url in \"\/args_unpack\", \"\/array\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == l\n\n    def test_jsonify_date_types(self, app, client):\n        \"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"\n        test_dates = (\n            datetime.datetime(1973, 3, 11, 6, 30, 45),\n            datetime.date(1975, 1, 5),\n        )\n\n        for i, d in enumerate(test_dates):\n            url = \"\/datetest{0}\".format(i)\n            app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data)[\"x\"] == http_date(d.timetuple())\n\n    @pytest.mark.parametrize(\"tz\", ((\"UTC\", 0), (\"PST\", -8), (\"KST\", 9)))\n    def test_jsonify_aware_datetimes(self, tz):\n        \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n        tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n        dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n        gmt = FixedOffset(hours=0, name=\"GMT\")\n        expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n        assert flask.json.JSONEncoder().encode(dt) == expected\n\n    def test_jsonify_uuid_types(self, app, client):\n        \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n        test_uuid = uuid.UUID(bytes=b\"\\xDE\\xAD\\xBE\\xEF\" * 4)\n        url = \"\/uuid_test\"\n        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n        rv = client.get(url)\n\n        rv_x = flask.json.loads(rv.data)[\"x\"]\n        assert rv_x == str(test_uuid)\n        rv_uuid = uuid.UUID(rv_x)\n        assert rv_uuid == test_uuid\n\n    def test_json_attr(self, app, client):\n        @app.route(\"\/add\", methods=[\"POST\"])\n        def add():\n            json = flask.request.get_json()\n            return text_type(json[\"a\"] + json[\"b\"])\n\n        rv = client.post(\n            \"\/add\",\n            data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b\"3\"\n\n    def test_template_escaping(self, app, req_ctx):\n        render = flask.render_template_string\n        rv = flask.json.htmlsafe_dumps(\"<\/script>\")\n        assert rv == u'\"\\\\u003c\/script\\\\u003e\"'\n        assert type(rv) == text_type\n        rv = render('{{ \"<\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n        rv = render('{{ \"<\\0\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\\\\u0000\/script\\\\u003e\"'\n        rv = render('{{ \"<!--<script>\"|tojson }}')\n        assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n        rv = render('{{ \"&\"|tojson }}')\n        assert rv == '\"\\\\u0026\"'\n        rv = render('{{ \"\\'\"|tojson }}')\n        assert rv == '\"\\\\u0027\"'\n        rv = render(\n            \"<a ng-data='{{ data|tojson }}'><\/a>\", data={\"x\": [\"foo\", \"bar\", \"baz'\"]}\n        )\n        assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'><\/a>'\n\n    def test_json_customization(self, app, client):\n        class X(object):\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return \"<%d>\" % o.val\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n                return obj\n\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n\n        @app.route(\"\/\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        rv = client.post(\n            \"\/\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    def test_blueprint_json_customization(self, app, client):\n        class X(object):\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return \"<%d>\" % o.val\n\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n\n                return obj\n\n        bp = flask.Blueprint(\"bp\", __name__)\n        bp.json_encoder = MyEncoder\n        bp.json_decoder = MyDecoder\n\n        @bp.route(\"\/bp\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        app.register_blueprint(bp)\n\n        rv = client.post(\n            \"\/bp\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    def test_modified_url_encoding(self, app, client):\n        class ModifiedRequest(flask.Request):\n            url_charset = \"euc-kr\"\n\n        app.request_class = ModifiedRequest\n        app.url_map.charset = \"euc-kr\"\n\n        @app.route(\"\/\")\n        def index():\n            return flask.request.args[\"foo\"]\n\n        rv = client.get(u\"\/?foo=\uc815\uc0c1\ucc98\ub9ac\".encode(\"euc-kr\"))\n        assert rv.status_code == 200\n        assert rv.data == u\"\uc815\uc0c1\ucc98\ub9ac\".encode(\"utf-8\")\n\n    if not has_encoding(\"euc-kr\"):\n        test_modified_url_encoding = None\n\n    def test_json_key_sorting(self, app, client):\n        app.debug = True\n\n        assert app.config[\"JSON_SORT_KEYS\"] == True\n        d = dict.fromkeys(range(20), \"foo\")\n\n        @app.route(\"\/\")\n        def index():\n            return flask.jsonify(values=d)\n\n        rv = client.get(\"\/\")\n        lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n        sorted_by_str = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n        sorted_by_int = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n\n        try:\n            assert lines == sorted_by_int\n        except AssertionError:\n            assert lines == sorted_by_str\n\n\nclass TestSendfile(object):\n    def test_send_file_regular(self, app, req_ctx):\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    def test_send_file_xsendfile(self, app, req_ctx, catch_deprecation_warnings):\n        app.use_x_sendfile = True\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert \"x-sendfile\" in rv.headers\n        assert rv.headers[\"x-sendfile\"] == os.path.join(\n            app.root_path, \"static\/index.html\"\n        )\n        assert rv.mimetype == \"text\/html\"\n        rv.close()\n\n    def test_send_file_last_modified(self, app, client):\n        last_modified = datetime.datetime(1999, 1, 1)\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\n                StringIO(\"party like it's\"),\n                last_modified=last_modified,\n                mimetype=\"text\/plain\",\n            )\n\n        rv = client.get(\"\/\")\n        assert rv.last_modified == last_modified\n\n    def test_send_file_object_without_mimetype(self, app, req_ctx):\n        with pytest.raises(ValueError) as excinfo:\n            flask.send_file(StringIO(\"LOL\"))\n        assert \"Unable to infer MIME-type\" in str(excinfo)\n        assert \"no filename is available\" in str(excinfo)\n\n        flask.send_file(StringIO(\"LOL\"), attachment_filename=\"filename\")\n\n    def test_send_file_object(self, app, req_ctx):\n        with open(os.path.join(app.root_path, \"static\/index.html\"), mode=\"rb\") as f:\n            rv = flask.send_file(f, mimetype=\"text\/html\")\n            rv.direct_passthrough = False\n            with app.open_resource(\"static\/index.html\") as f:\n                assert rv.data == f.read()\n            assert rv.mimetype == \"text\/html\"\n            rv.close()\n\n        app.use_x_sendfile = True\n\n        with open(os.path.join(app.root_path, \"static\/index.html\")) as f:\n            rv = flask.send_file(f, mimetype=\"text\/html\")\n            assert rv.mimetype == \"text\/html\"\n            assert \"x-sendfile\" not in rv.headers\n            rv.close()\n\n        app.use_x_sendfile = False\n        f = StringIO(\"Test\")\n        rv = flask.send_file(f, mimetype=\"application\/octet-stream\")\n        rv.direct_passthrough = False\n        assert rv.data == b\"Test\"\n        assert rv.mimetype == \"application\/octet-stream\"\n        rv.close()\n\n        class PyStringIO(object):\n            def __init__(self, *args, **kwargs):\n                self._io = StringIO(*args, **kwargs)\n\n            def __getattr__(self, name):\n                return getattr(self._io, name)\n\n        f = PyStringIO(\"Test\")\n        f.name = \"test.txt\"\n        rv = flask.send_file(f, attachment_filename=f.name)\n        rv.direct_passthrough = False\n        assert rv.data == b\"Test\"\n        assert rv.mimetype == \"text\/plain\"\n        rv.close()\n\n        f = StringIO(\"Test\")\n        rv = flask.send_file(f, mimetype=\"text\/plain\")\n        rv.direct_passthrough = False\n        assert rv.data == b\"Test\"\n        assert rv.mimetype == \"text\/plain\"\n        rv.close()\n\n        app.use_x_sendfile = True\n\n        f = StringIO(\"Test\")\n        rv = flask.send_file(f, mimetype=\"text\/html\")\n        assert \"x-sendfile\" not in rv.headers\n        rv.close()\n\n    def test_send_file_pathlike(self, app, req_ctx):\n        rv = flask.send_file(FakePath(\"static\/index.html\"))\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, \"to_content_range_header\", None)),\n        reason=\"not implemented within werkzeug\",\n    )\n    def test_send_file_range_request(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:16]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-1000\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-10\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[-10:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"somethingsomething\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        last_modified = datetime.datetime.utcfromtimestamp(\n            os.path.getmtime(os.path.join(app.root_path, \"static\/index.html\"))\n        ).replace(microsecond=0)\n\n        rv = client.get(\n            \"\/\", headers={\"Range\": \"bytes=4-15\", \"If-Range\": http_date(last_modified)}\n        )\n        assert rv.status_code == 206\n        rv.close()\n\n        rv = client.get(\n            \"\/\",\n            headers={\n                \"Range\": \"bytes=4-15\",\n                \"If-Range\": http_date(datetime.datetime(1999, 1, 1)),\n            },\n        )\n        assert rv.status_code == 200\n        rv.close()\n\n    def test_send_file_range_request_bytesio(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            file = io.BytesIO(b\"somethingsomething\")\n            return flask.send_file(\n                file, attachment_filename=\"filename\", conditional=True\n            )\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        assert rv.data == b\"somethingsomething\"[4:16]\n        rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, \"to_content_range_header\", None)),\n        reason=\"not implemented within werkzeug\",\n    )\n    def test_send_file_range_request_xsendfile_invalid(self, app, client):\n        # https:\/\/github.com\/pallets\/flask\/issues\/2526\n        app.use_x_sendfile = True\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n    def test_attachment(self, app, req_ctx):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            with open(os.path.join(app.root_path, \"static\/index.html\")) as f:\n                rv = flask.send_file(\n                    f, as_attachment=True, attachment_filename=\"index.html\"\n                )\n                value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n                assert value == \"attachment\"\n                rv.close()\n\n        with open(os.path.join(app.root_path, \"static\/index.html\")) as f:\n            rv = flask.send_file(\n                f, as_attachment=True, attachment_filename=\"index.html\"\n            )\n            value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n            assert value == \"attachment\"\n            assert options[\"filename\"] == \"index.html\"\n            assert \"filename*\" not in rv.headers[\"Content-Disposition\"]\n            rv.close()\n\n        rv = flask.send_file(\"static\/index.html\", as_attachment=True)\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.html\"\n        rv.close()\n\n        rv = flask.send_file(\n            StringIO(\"Test\"),\n            as_attachment=True,\n            attachment_filename=\"index.txt\",\n            add_etags=False,\n        )\n        assert rv.mimetype == \"text\/plain\"\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.txt\"\n        rv.close()\n\n    @pytest.mark.usefixtures(\"req_ctx\")\n    @pytest.mark.parametrize(\n        (\"filename\", \"ascii\", \"utf8\"),\n        (\n            (\"index.html\", \"index.html\", False),\n            (\n                u\"\u00d1and\u00fa\uff0fping\u00fcino.txt\",\n                '\"Nandu\/pinguino.txt\"',\n                \"%C3%91and%C3%BA%EF%BC%8Fping%C3%BCino.txt\",\n            ),\n            (u\"V\u00f6gel.txt\", \"Vogel.txt\", \"V%C3%B6gel.txt\"),\n            # Native string not marked as Unicode on Python 2\n            (\"t\u00e9st.txt\", \"test.txt\", \"t%C3%A9st.txt\"),\n        ),\n    )\n    def test_attachment_filename_encoding(self, filename, ascii, utf8):\n        rv = flask.send_file(\n            \"static\/index.html\", as_attachment=True, attachment_filename=filename\n        )\n        rv.close()\n        content_disposition = rv.headers[\"Content-Disposition\"]\n        assert \"filename=%s\" % ascii in content_disposition\n        if utf8:\n            assert \"filename*=UTF-8''\" + utf8 in content_disposition\n        else:\n            assert \"filename*=UTF-8''\" not in content_disposition\n\n    def test_static_file(self, app, req_ctx):\n        # default cache timeout is 12 hours\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        # Test with static file handler.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file(\"static\/index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n\n    def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_pathlike(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(FakePath(\"static\"), FakePath(\"hello.txt\"))\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_bad_request(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n\n        with pytest.raises(BadRequest):\n            flask.send_from_directory(\"static\", \"bad\\x00\")\n\n\nclass TestUrlFor(object):\n    def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"\/#x%20y\"\n\n    def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n\n    def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        pytest.raises(ValueError, flask.url_for, \"index\", _scheme=\"https\")\n\n    def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n\n    def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return \"Get %d\" % id\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"\/myview\/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"\/myview\/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"\/myview\/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"\/myview\/create\"\n\n\nclass TestNoImports(object):\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self, modules_tmpdir):\n        modules_tmpdir.join(\"importerror.py\").write(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            assert False, \"Flask(import_name) is importing import_name.\"\n\n\nclass TestStreaming(object):\n    def test_streaming_with_context(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper(object):\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]\n\n    def test_stream_keeps_session(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"\/\")\n        assert rv.data == b\"flask\"\n\n\nclass TestSafeJoin(object):\n    def test_safe_join(self):\n        # Valid combinations of *args and expected joined paths.\n        passing = (\n            ((\"a\/b\/c\",), \"a\/b\/c\"),\n            ((\"\/\", \"a\/\", \"b\/\", \"c\/\"), \"\/a\/b\/c\"),\n            ((\"a\", \"b\", \"c\"), \"a\/b\/c\"),\n            ((\"\/a\", \"b\/c\"), \"\/a\/b\/c\"),\n            ((\"a\/b\", \"X\/..\/c\"), \"a\/b\/c\"),\n            ((\"\/a\/b\", \"c\/X\/..\"), \"\/a\/b\/c\"),\n            # If last path is '' add a slash\n            ((\"\/a\/b\/c\", \"\"), \"\/a\/b\/c\/\"),\n            # Preserve dot slash\n            ((\"\/a\/b\/c\", \".\/\"), \"\/a\/b\/c\/.\"),\n            ((\"a\/b\/c\", \"X\/..\"), \"a\/b\/c\/.\"),\n            # Base directory is always considered safe\n            ((\"..\/\", \"a\/b\/c\"), \"..\/a\/b\/c\"),\n            ((\"\/..\",), \"\/..\"),\n        )\n\n        for args, expected in passing:\n            assert flask.safe_join(*args) == expected\n\n    def test_safe_join_exceptions(self):\n        # Should raise werkzeug.exceptions.NotFound on unsafe joins.\n        failing = (\n            # path.isabs and ``..'' checks\n            (\"\/a\", \"b\", \"\/c\"),\n            (\"\/a\", \"..\/b\/c\"),\n            (\"\/a\", \"..\", \"b\/c\"),\n            # Boundaries violations after path normalization\n            (\"\/a\", \"b\/..\/b\/..\/..\/c\"),\n            (\"\/a\", \"b\", \"c\/..\/..\"),\n            (\"\/a\", \"b\/..\/..\/c\"),\n        )\n\n        for args in failing:\n            with pytest.raises(NotFound):\n                print(flask.safe_join(*args))\n\n\nclass TestHelpers(object):\n    @pytest.mark.parametrize(\n        \"debug, expected_flag, expected_default_flag\",\n        [\n            (\"\", False, False),\n            (\"0\", False, False),\n            (\"False\", False, False),\n            (\"No\", False, False),\n            (\"True\", True, True),\n        ],\n    )\n    def test_get_debug_flag(\n        self, monkeypatch, debug, expected_flag, expected_default_flag\n    ):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        if expected_flag is None:\n            assert get_debug_flag() is None\n        else:\n            assert get_debug_flag() == expected_flag\n        assert get_debug_flag() == expected_default_flag\n\n    @pytest.mark.parametrize(\n        \"env, ref_env, debug\",\n        [\n            (\"\", \"production\", False),\n            (\"production\", \"production\", False),\n            (\"development\", \"development\", True),\n            (\"other\", \"other\", False),\n        ],\n    )\n    def test_get_env(self, monkeypatch, env, ref_env, debug):\n        monkeypatch.setenv(\"FLASK_ENV\", env)\n        assert get_debug_flag() == debug\n        assert get_env() == ref_env\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text\/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text\/html\"\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(\"flask.app\")\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\ntests.test_logging\n~~~~~~~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport logging\nimport sys\n\nimport pytest\n\nfrom flask._compat import StringIO\nfrom flask.logging import default_handler, has_level_handler, wsgi_errors_stream\n\n\n@pytest.fixture(autouse=True)\ndef reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger(\"flask.app\")\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")\n\n\ndef test_logger(app):\n    assert app.logger.name == \"flask.app\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n\n\ndef test_wsgi_errors_stream(app, client):\n    @app.route(\"\/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"\/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n\n\ndef test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n\n\ndef test_log_view_exception(app, client):\n    @app.route(\"\/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"\/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on \/ [GET]\" in err\n    assert \"Exception: test\" in err\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(\"flask.app\")\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: Reformat with black\n\nhttps:\/\/github.com\/python\/black\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.templating\n    ~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport pytest\n\nimport flask\nimport logging\nfrom jinja2 import TemplateNotFound\nimport werkzeug.serving\n\n\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"<p>23|42\"\n\n\ndef test_original_win(app, client):\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"42\"\n\n\ndef test_request_less_rendering(app, app_ctx):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} \" \"{{ foo }}\")\n    assert rv == \"Hello Special World 42\"\n\n\ndef test_standard_context(app, client):\n    @app.route(\"\/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"\/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]\n\n\ndef test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"\/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"\/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"\n\n\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\"\n\n\ndef test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):\n    @app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_name(app):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"\/\")\n    assert rv.data == b\"Hello Custom World!\"\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"<h1>Jameson<\/h1>\"\n\n\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True\n\n\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n\n    app.run()\n    assert app.templates_auto_reload == False\n    assert app.jinja_env.auto_reload == False\n\n    app.run(debug=True)\n    assert app.templates_auto_reload == True\n    assert app.jinja_env.auto_reload == True\n\n\ndef test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(x, record):\n            called.append(True)\n            text = str(record.msg)\n            assert '1: trying loader of application \"blueprintapp\"' in text\n            assert (\n                '2: trying loader of blueprint \"admin\" ' \"(blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                'trying loader of blueprint \"frontend\" ' \"(blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to \" 'the blueprint \"frontend\"'\n            ) in text\n            assert \"See http:\/\/flask.pocoo.org\/docs\/blueprints\/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(logging.getLogger(\"flask\"), \"handlers\", [_TestHandler()])\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"\/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1\n\n\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.app\n    ~~~~~~~~~\n\n    This module implements the central WSGI application object.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nimport warnings\nfrom datetime import timedelta\nfrom functools import update_wrapper\nfrom itertools import chain\nfrom threading import Lock\n\nfrom werkzeug.datastructures import Headers, ImmutableDict\nfrom werkzeug.exceptions import (\n    BadRequest,\n    BadRequestKeyError,\n    HTTPException,\n    InternalServerError,\n    MethodNotAllowed,\n    default_exceptions,\n)\nfrom werkzeug.routing import BuildError, Map, RequestRedirect, RoutingException, Rule\nfrom werkzeug.wrappers import BaseResponse\n\nfrom . import cli, json\nfrom ._compat import integer_types, reraise, string_types, text_type\nfrom .config import Config, ConfigAttribute\nfrom .ctx import AppContext, RequestContext, _AppCtxGlobals\nfrom .globals import _request_ctx_stack, g, request, session\nfrom .helpers import (\n    _PackageBoundObject,\n    _endpoint_from_view_func,\n    find_package,\n    get_env,\n    get_debug_flag,\n    get_flashed_messages,\n    locked_cached_property,\n    url_for,\n    get_load_dotenv,\n)\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import (\n    appcontext_tearing_down,\n    got_request_exception,\n    request_finished,\n    request_started,\n    request_tearing_down,\n)\nfrom .templating import (\n    DispatchingJinjaLoader,\n    Environment,\n    _default_template_ctx_processor,\n)\nfrom .wrappers import Request, Response\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\n\n\ndef setupmethod(f):\n    \"\"\"Wraps a method so that it performs a check in debug mode if the\n    first request was already handled.\n    \"\"\"\n\n    def wrapper_func(self, *args, **kwargs):\n        if self.debug and self._got_first_request:\n            raise AssertionError(\n                \"A setup function was called after the \"\n                \"first request was handled.  This usually indicates a bug \"\n                \"in the application where a module was not imported \"\n                \"and decorators or other functionality was called too late.\\n\"\n                \"To fix this make sure to import all your view modules, \"\n                \"database models and everything related at a central place \"\n                \"before the application starts serving requests.\"\n            )\n        return f(self, *args, **kwargs)\n\n    return update_wrapper(wrapper_func, f)\n\n\nclass Flask(_PackageBoundObject):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication\/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: the folder with static files that should be served\n                          at `static_url_path`.  Defaults to the ``'static'``\n                          folder in the root path of the application.\n    :param static_host: the host to use when adding the static route.\n        Defaults to None. Required when using ``host_matching=True``\n        with a ``static_folder`` configured.\n    :param host_matching: set ``url_map.host_matching`` attribute.\n        Defaults to False.\n    :param subdomain_matching: consider the subdomain relative to\n        :data:`SERVER_NAME` when matching routes. Defaults to False.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to ``True`` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    :param root_path: Flask by default will automatically calculate the path\n                      to the root of the application.  In certain situations\n                      this cannot be achieved (for instance if the package\n                      is a Python 3 namespace package) and needs to be\n                      manually defined.\n    \"\"\"\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class = Response\n\n    #: The class that is used for the Jinja environment.\n    #:\n    #: .. versionadded:: 0.11\n    jinja_environment = Environment\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on unexpected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is now application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    #: The class that is used for the ``config`` attribute of this app.\n    #: Defaults to :class:`~flask.Config`.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Default values for certain config options.\n    #: 2. Access to config values through attributes in addition to keys.\n    #:\n    #: .. versionadded:: 0.11\n    config_class = Config\n\n    #: The testing flag.  Set this to ``True`` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate test helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``TESTING`` configuration key.  Defaults to ``False``.\n    testing = ConfigAttribute(\"TESTING\")\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and other things. Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n\n    #: The secure cookie uses this for the name of the session cookie.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``SESSION_COOKIE_NAME`` configuration key.  Defaults to ``'session'``\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n\n    #: A :class:`~datetime.timedelta` which is used as default cache_timeout\n    #: for the :func:`send_file` functions. The default is 12 hours.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``SEND_FILE_MAX_AGE_DEFAULT`` configuration key. This configuration\n    #: variable can also be set with an integer value used as seconds.\n    #: Defaults to ``timedelta(hours=12)``\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n\n    #: Enable this if you want to use the X-Sendfile feature.  Keep in\n    #: mind that the server has to support this.  This only affects files\n    #: sent with the :func:`send_file` method.\n    #:\n    #: .. versionadded:: 0.2\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n\n    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_encoder = json.JSONEncoder\n\n    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_decoder = json.JSONDecoder\n\n    #: Options that are passed to the Jinja environment in\n    #: :meth:`create_jinja_environment`. Changing these options after\n    #: the environment is created (accessing :attr:`jinja_env`) will\n    #: have no effect.\n    #:\n    #: .. versionchanged:: 1.1.0\n    #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow\n    #:     easier configuration.\n    #:\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n\n    #: Default configuration parameters.\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"\/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application\/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: The map object to use for storing the URL rules and routing\n    #: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.\n    #:\n    #: .. versionadded:: 1.1.0\n    url_map_class = Map\n\n    #: the test client that is used with when `test_client` is used.\n    #:\n    #: .. versionadded:: 0.7\n    test_client_class = None\n\n    #: The :class:`~click.testing.CliRunner` subclass, by default\n    #: :class:`~flask.testing.FlaskCliRunner` that is used by\n    #: :meth:`test_cli_runner`. Its ``__init__`` method should take a\n    #: Flask app object as the first argument.\n    #:\n    #: .. versionadded:: 1.0\n    test_cli_runner_class = None\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface = SecureCookieSessionInterface()\n\n    # TODO remove the next three attrs when Sphinx :inherited-members: works\n    # https:\/\/github.com\/sphinx-doc\/sphinx\/issues\/741\n\n    #: The name of the package or module that this app belongs to. Do not\n    #: change this once it is set by the constructor.\n    import_name = None\n\n    #: Location of the template files to be added to the template lookup.\n    #: ``None`` if templates should not be added.\n    template_folder = None\n\n    #: Absolute path to the package on the filesystem. Used to look up\n    #: resources contained in the package.\n    root_path = None\n\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        _PackageBoundObject.__init__(\n            self, import_name, template_folder=template_folder, root_path=root_path\n        )\n\n        self.static_url_path = static_url_path\n        self.static_folder = static_folder\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: A dictionary of all view functions registered.  The keys will\n        #: be function names which are also used to generate URLs and\n        #: the values are the function objects themselves.\n        #: To register a view function, use the :meth:`route` decorator.\n        self.view_functions = {}\n\n        #: A dictionary of all registered error handlers.  The key is ``None``\n        #: for error handlers active on the application, otherwise the key is\n        #: the name of the blueprint.  Each key points to another dictionary\n        #: where the key is the status code of the http exception.  The\n        #: special key ``None`` points to a list of tuples where the first item\n        #: is the class for the instance check and the second the error handler\n        #: function.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        self.error_handler_spec = {}\n\n        #: A list of functions that are called when :meth:`url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n        #: is called with `error`, `endpoint` and `values`.  If a function\n        #: returns ``None`` or raises a :exc:`BuildError` the next function is\n        #: tried.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers = []\n\n        #: A dictionary with lists of functions that will be called at the\n        #: beginning of each request. The key of the dictionary is the name of\n        #: the blueprint this function is active for, or ``None`` for all\n        #: requests. To register a function, use the :meth:`before_request`\n        #: decorator.\n        self.before_request_funcs = {}\n\n        #: A list of functions that will be called at the beginning of the\n        #: first request to this instance. To register a function, use the\n        #: :meth:`before_first_request` decorator.\n        #:\n        #: .. versionadded:: 0.8\n        self.before_first_request_funcs = []\n\n        #: A dictionary with lists of functions that should be called after\n        #: each request.  The key of the dictionary is the name of the blueprint\n        #: this function is active for, ``None`` for all requests.  This can for\n        #: example be used to close database connections. To register a function\n        #: here, use the :meth:`after_request` decorator.\n        self.after_request_funcs = {}\n\n        #: A dictionary with lists of functions that are called after\n        #: each request, even if an exception has occurred. The key of the\n        #: dictionary is the name of the blueprint this function is active for,\n        #: ``None`` for all requests. These functions are not allowed to modify\n        #: the request, and their return values are ignored. If an exception\n        #: occurred while processing the request, it gets passed to each\n        #: teardown_request function. To register a function here, use the\n        #: :meth:`teardown_request` decorator.\n        #:\n        #: .. versionadded:: 0.7\n        self.teardown_request_funcs = {}\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs = []\n\n        #: A dictionary with lists of functions that are called before the\n        #: :attr:`before_request_funcs` functions. The key of the dictionary is\n        #: the name of the blueprint this function is active for, or ``None``\n        #: for all requests. To register a function, use\n        #: :meth:`url_value_preprocessor`.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_value_preprocessors = {}\n\n        #: A dictionary with lists of functions that can be used as URL value\n        #: preprocessors.  The key ``None`` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #: of URL values before they are used as the keyword arguments of the\n        #: view function.  For each function registered this one should also\n        #: provide a :meth:`url_defaults` function that adds the parameters\n        #: automatically again that were removed that way.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_default_functions = {}\n\n        #: A dictionary with list of functions that are called without argument\n        #: to populate the template context.  The key of the dictionary is the\n        #: name of the blueprint this function is active for, ``None`` for all\n        #: requests.  Each returns a dictionary that the template context is\n        #: updated with.  To register a function here, use the\n        #: :meth:`context_processor` decorator.\n        self.template_context_processors = {None: [_default_template_ctx_processor]}\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors = []\n\n        #: all the attached blueprints in a dictionary by name.  Blueprints\n        #: can be attached multiple times so this dictionary does not tell\n        #: you how often they got attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints = {}\n        self._blueprint_order = []\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.  For backwards compatibility extensions should register\n        #: themselves like this::\n        #:\n        #:      if not hasattr(app, 'extensions'):\n        #:          app.extensions = {}\n        #:      app.extensions['extensionname'] = SomeObject()\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class()\n\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host\/host_matching combination\"\n            self.add_url_rule(\n                self.static_url_path + \"\/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name\n\n    @locked_cached_property\n    def name(self):\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @property\n    def propagate_exceptions(self):\n        \"\"\"Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration\n        value in case it's set, otherwise a sensible default is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n\n    @property\n    def preserve_context_on_exception(self):\n        \"\"\"Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION``\n        configuration value in case it's set, otherwise a sensible default\n        is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n\n    @locked_cached_property\n    def logger(self):\n        \"\"\"The ``'flask.app'`` logger, a standard Python\n        :class:`~logging.Logger`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will be set\n        to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be added.\n        See :ref:`logging` for more information.\n\n        .. versionchanged:: 1.0\n            Behavior was simplified. The logger is always named\n            ``flask.app``. The level is only set during configuration, it\n            doesn't check ``app.debug`` each time. Only one format is used,\n            not different ones depending on ``app.debug``. No handlers are\n            removed, and a handler is only added if no handlers are already\n            configured.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        return create_logger(self)\n\n    @locked_cached_property\n    def jinja_env(self):\n        \"\"\"The Jinja environment used to load templates.\n\n        The environment is created the first time this property is\n        accessed. Changing :attr:`jinja_options` after that will have no\n        effect.\n        \"\"\"\n        return self.create_jinja_environment()\n\n    @property\n    def got_first_request(self):\n        \"\"\"This attribute is set to ``True`` if the application started\n        handling the first request.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        return self._got_first_request\n\n    def make_config(self, instance_relative=False):\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n\n    def auto_find_instance_path(self):\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, \"instance\")\n        return os.path.join(prefix, \"var\", self.name + \"-instance\")\n\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        \"\"\"Opens a resource from the application's instance folder\n        (:attr:`instance_path`).  Otherwise works like\n        :meth:`open_resource`.  Instance resources can also be opened for\n        writing.\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        :param mode: resource file opening mode, default is 'rb'.\n        \"\"\"\n        return open(os.path.join(self.instance_path, resource), mode)\n\n    @property\n    def templates_auto_reload(self):\n        \"\"\"Reload templates when they are changed. Used by\n        :meth:`create_jinja_environment`.\n\n        This attribute can be configured with :data:`TEMPLATES_AUTO_RELOAD`. If\n        not set, it will be enabled in debug mode.\n\n        .. versionadded:: 1.0\n            This property was added but the underlying config and behavior\n            already existed.\n        \"\"\"\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n\n    def create_jinja_environment(self):\n        \"\"\"Create the Jinja environment based on :attr:`jinja_options`\n        and the various Jinja-related methods of the app. Changing\n        :attr:`jinja_options` after this will have no effect. Also adds\n        Flask-related globals and filters to the environment.\n\n        .. versionchanged:: 0.11\n           ``Environment.auto_reload`` set in accordance with\n           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        options = dict(self.jinja_options)\n\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n\n    def create_global_jinja_loader(self):\n        \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n\n    def select_jinja_autoescape(self, filename):\n        \"\"\"Returns ``True`` if autoescaping should be active for the given\n        template name. If no template name is given, returns `True`.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n\n    def update_template_context(self, context):\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        # make sure the original values win.  This makes it possible to\n        # easier add new variables in context processors without breaking\n        # existing views.\n        context.update(orig_ctx)\n\n    def make_shell_context(self):\n        \"\"\"Returns the shell context for an interactive shell for this\n        application.  This runs all the registered shell context\n        processors.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n\n    #: What environment the app is running in. Flask and extensions may\n    #: enable behaviors based on the environment, such as enabling debug\n    #: mode. This maps to the :data:`ENV` config key. This is set by the\n    #: :envvar:`FLASK_ENV` environment variable and may not behave as\n    #: expected if set in code.\n    #:\n    #: **Do not enable development when deploying in production.**\n    #:\n    #: Default: ``'production'``\n    env = ConfigAttribute(\"ENV\")\n\n    @property\n    def debug(self):\n        \"\"\"Whether debug mode is enabled. When using ``flask run`` to start\n        the development server, an interactive debugger will be shown for\n        unhandled exceptions, and the server will be reloaded when code\n        changes. This maps to the :data:`DEBUG` config key. This is\n        enabled when :attr:`env` is ``'development'`` and is overridden\n        by the ``FLASK_DEBUG`` environment variable. It may not behave as\n        expected if set in code.\n\n        **Do not enable debug mode when deploying in production.**\n\n        Default: ``True`` if :attr:`env` is ``'development'``, or\n        ``False`` otherwise.\n        \"\"\"\n        return self.config[\"DEBUG\"]\n\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        \"\"\"Runs the application on a local development server.\n\n        Do not use ``run()`` in a production setting. It is not intended to\n        meet security and performance requirements for a production server.\n        Instead, see :ref:`deployment` for WSGI server recommendations.\n\n        If the :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        It is not recommended to use this function for development with\n        automatic reloading as this is badly supported.  Instead you should\n        be using the :command:`flask` command line script's ``run`` support.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to ``True`` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n            have the server available externally as well. Defaults to\n            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n            if present.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n            port defined in the ``SERVER_NAME`` config variable if present.\n        :param debug: if given, enable or disable debug mode. See\n            :attr:`debug`.\n        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n            files to set environment variables. Will also change the working\n            directory to the directory containing the first file found.\n        :param options: the options to be forwarded to the underlying Werkzeug\n            server. See :func:`werkzeug.serving.run_simple` for more\n            information.\n\n        .. versionchanged:: 1.0\n            If installed, python-dotenv will be used to load environment\n            variables from :file:`.env` and :file:`.flaskenv` files.\n\n            If set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG`\n            environment variables will override :attr:`env` and\n            :attr:`debug`.\n\n            Threaded mode is enabled by default.\n\n        .. versionchanged:: 0.10\n            The default port is now picked from the ``SERVER_NAME``\n            variable.\n        \"\"\"\n        # Change this into a no-op if the server is invoked from the\n        # command line. Have a look at cli.py for more information.\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n\n            explain_ignored_app_run()\n            return\n\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n\n            # if set, let env vars override previous values\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n\n        # debug passed to method overrides all other sources\n        if debug is not None:\n            self.debug = bool(debug)\n\n        _host = \"127.0.0.1\"\n        _port = 5000\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host, sn_port = None, None\n\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n\n        host = host or sn_host or _host\n        # pick the first value that's not None (0 is allowed)\n        port = int(next((p for p in (port, sn_port) if p is not None), _port))\n\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n\n        from werkzeug.serving import run_simple\n\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # reset normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False\n\n    def test_client(self, use_cookies=True, **kwargs):\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :ref:`testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a ``with`` block to defer the closing down\n        of the context until the end of the ``with`` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('\/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        Additionally, you may pass optional keyword arguments that will then\n        be passed to the application's :attr:`test_client_class` constructor.\n        For example::\n\n            from flask.testing import FlaskClient\n\n            class CustomClient(FlaskClient):\n                def __init__(self, *args, **kwargs):\n                    self._authentication = kwargs.pop(\"authentication\")\n                    super(CustomClient,self).__init__( *args, **kwargs)\n\n            app.test_client_class = CustomClient\n            client = app.test_client(authentication='Basic ....')\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for ``with`` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n\n        .. versionchanged:: 0.11\n           Added `**kwargs` to support passing additional keyword arguments to\n           the constructor of :attr:`test_client_class`.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from flask.testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n\n    def test_cli_runner(self, **kwargs):\n        \"\"\"Create a CLI runner for testing CLI commands.\n        See :ref:`testing-cli`.\n\n        Returns an instance of :attr:`test_cli_runner_class`, by default\n        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is\n        passed as the first argument.\n\n        .. versionadded:: 1.0\n        \"\"\"\n        cls = self.test_cli_runner_class\n\n        if cls is None:\n            from flask.testing import FlaskCliRunner as cls\n\n        return cls(self, **kwargs)\n\n    def open_session(self, request):\n        \"\"\"Creates or opens a new session.  Default implementation stores all\n        session data in a signed cookie.  This requires that the\n        :attr:`secret_key` is set.  Instead of overriding this method\n        we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.open_session``\n            instead.\n\n        :param request: an instance of :attr:`request_class`.\n        \"\"\"\n\n        warnings.warn(\n            DeprecationWarning(\n                '\"open_session\" is deprecated and will be removed in 1.1. Use'\n                ' \"session_interface.open_session\" instead.'\n            )\n        )\n        return self.session_interface.open_session(self, request)\n\n    def save_session(self, session, response):\n        \"\"\"Saves the session if it needs updates.  For the default\n        implementation, check :meth:`open_session`.  Instead of overriding this\n        method we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.save_session``\n            instead.\n\n        :param session: the session to be saved (a\n                        :class:`~werkzeug.contrib.securecookie.SecureCookie`\n                        object)\n        :param response: an instance of :attr:`response_class`\n        \"\"\"\n\n        warnings.warn(\n            DeprecationWarning(\n                '\"save_session\" is deprecated and will be removed in 1.1. Use'\n                ' \"session_interface.save_session\" instead.'\n            )\n        )\n        return self.session_interface.save_session(self, session, response)\n\n    def make_null_session(self):\n        \"\"\"Creates a new instance of a missing session.  Instead of overriding\n        this method we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.make_null_session``\n            instead.\n\n        .. versionadded:: 0.7\n        \"\"\"\n\n        warnings.warn(\n            DeprecationWarning(\n                '\"make_null_session\" is deprecated and will be removed in 1.1. Use'\n                ' \"session_interface.make_null_session\" instead.'\n            )\n        )\n        return self.session_interface.make_null_session(self)\n\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n        arguments passed to this method will override the defaults set on the\n        blueprint.\n\n        Calls the blueprint's :meth:`~flask.Blueprint.register` method after\n        recording the blueprint in the application's :attr:`blueprints`.\n\n        :param blueprint: The blueprint to register.\n        :param url_prefix: Blueprint routes will be prefixed with this.\n        :param subdomain: Blueprint routes will match on this subdomain.\n        :param url_defaults: Blueprint routes will use these default values for\n            view arguments.\n        :param options: Additional keyword arguments are passed to\n            :class:`~flask.blueprints.BlueprintSetupState`. They can be\n            accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        first_registration = False\n\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints %r and %r. Both\"\n                ' share the same name \"%s\". Blueprints that are created on the'\n                \" fly need unique names.\"\n                % (blueprint, self.blueprints[blueprint.name], blueprint.name)\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n\n        blueprint.register(self, options, first_registration)\n\n    def iter_blueprints(self):\n        \"\"\"Iterates over all blueprints by the order they were registered.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return iter(self._blueprint_order)\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options\n    ):\n        \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n        decorator.  If a view_func is provided it will be registered with the\n        endpoint.\n\n        Basically this example::\n\n            @app.route('\/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('\/', 'index', index)\n\n        If the view_func is not provided you will need to connect the endpoint\n        to a view function like so::\n\n            app.view_functions['index'] = index\n\n        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n        to customize the behavior via subclassing you only need to change\n        this method.\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        .. versionchanged:: 0.2\n           `view_func` parameter added.\n\n        .. versionchanged:: 0.6\n           ``OPTIONS`` is added automatically as method.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param provide_automatic_options: controls whether the ``OPTIONS``\n            method should be added automatically. This can also be controlled\n            by setting the ``view_func.provide_automatic_options = False``\n            before adding the rule.\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, string_types):\n            raise TypeError(\n                \"Allowed methods have to be iterables of strings, \"\n                'for example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = set(item.upper() for item in methods)\n\n        # Methods that should always be added\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an \"\n                    \"existing endpoint function: %s\" % endpoint\n                )\n            self.view_functions[endpoint] = view_func\n\n    def route(self, rule, **options):\n        \"\"\"A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as :meth:`add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('\/')\n            def index():\n                return 'Hello World'\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n\n        def decorator(f):\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def endpoint(self, endpoint):\n        \"\"\"A decorator to register a function as an endpoint.\n        Example::\n\n            @app.endpoint('example.endpoint')\n            def example():\n                return \"example\"\n\n        :param endpoint: the name of the endpoint\n        \"\"\"\n\n        def decorator(f):\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator\n\n    @staticmethod\n    def _get_exc_class_and_code(exc_class_or_code):\n        \"\"\"Ensure that we register only exceptions as handler keys\"\"\"\n        if isinstance(exc_class_or_code, integer_types):\n            exc_class = default_exceptions[exc_class_or_code]\n        else:\n            exc_class = exc_class_or_code\n\n        assert issubclass(exc_class, Exception)\n\n        if issubclass(exc_class, HTTPException):\n            return exc_class, exc_class.code\n        else:\n            return exc_class, None\n\n    @setupmethod\n    def errorhandler(self, code_or_exception):\n        \"\"\"Register a function to handle errors by code or exception class.\n\n        A decorator that is used to register a function given an\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        .. versionadded:: 0.7\n            Use :meth:`register_error_handler` instead of modifying\n            :attr:`error_handler_spec` directly, for application wide error\n            handlers.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code_or_exception: the code as integer for the handler, or\n                                  an arbitrary exception\n        \"\"\"\n\n        def decorator(f):\n            self._register_error_handler(None, code_or_exception, f)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def register_error_handler(self, code_or_exception, f):\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._register_error_handler(None, code_or_exception, f)\n\n    @setupmethod\n    def _register_error_handler(self, key, code_or_exception, f):\n        \"\"\"\n        :type key: None|str\n        :type code_or_exception: int|T<=Exception\n        :type f: callable\n        \"\"\"\n        if isinstance(code_or_exception, HTTPException):  # old broken behavior\n            raise ValueError(\n                \"Tried to register a handler for an exception instance {0!r}.\"\n                \" Handlers can only be registered for exception classes or\"\n                \" HTTP error codes.\".format(code_or_exception)\n            )\n\n        try:\n            exc_class, code = self._get_exc_class_and_code(code_or_exception)\n        except KeyError:\n            raise KeyError(\n                \"'{0}' is not a recognized HTTP error code. Use a subclass of\"\n                \" HTTPException with that code instead.\".format(code_or_exception)\n            )\n\n        handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})\n        handlers[exc_class] = f\n\n    @setupmethod\n    def template_filter(self, name=None):\n        \"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        \"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f\n\n    @setupmethod\n    def template_test(self, name=None):\n        \"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        \"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f\n\n    @setupmethod\n    def template_global(self, name=None):\n        \"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        \"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f\n\n    @setupmethod\n    def before_request(self, f):\n        \"\"\"Registers a function to run before each request.\n\n        For example, this can be used to open a database connection, or to load\n        the logged in user from the session.\n\n        The function will be called without any arguments. If it returns a\n        non-None value, the value is handled as if it was the return value from\n        the view, and further request handling is stopped.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def before_first_request(self, f):\n        \"\"\"Registers a function to be run before the first request to this\n        instance of the application.\n\n        The function will be called without any arguments and its return\n        value is ignored.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.before_first_request_funcs.append(f)\n        return f\n\n    @setupmethod\n    def after_request(self, f):\n        \"\"\"Register a function to be run after each request.\n\n        Your function must take one parameter, an instance of\n        :attr:`response_class` and return a new response object or the\n        same (see :meth:`process_response`).\n\n        As of Flask 0.7 this function might not be executed at the end of the\n        request in case an unhandled exception occurred.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_request(self, f):\n        \"\"\"Register a function to be run at the end of each request,\n        regardless of whether there was an exception or not.  These functions\n        are executed when the request context is popped, even if not an\n        actual request was performed.\n\n        Example::\n\n            ctx = app.test_request_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the request context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Generally teardown functions must take every necessary step to avoid\n        that they will fail.  If they do execute code that might fail they\n        will have to surround the execution of these code by try\/except\n        statements and log occurring errors.\n\n        When a teardown function was called because of an exception it will\n        be passed an error object.\n\n        The return values of teardown functions are ignored.\n\n        .. admonition:: Debug Note\n\n           In debug mode Flask will not tear down a request on an exception\n           immediately.  Instead it will keep it alive so that the interactive\n           debugger can still access it.  This behavior can be controlled\n           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_appcontext(self, f):\n        \"\"\"Registers a function to be called when the application context\n        ends.  These functions are typically also called when the request\n        context is popped.\n\n        Example::\n\n            ctx = app.app_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the app context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Since a request context typically also manages an application\n        context it would also be called when you pop a request context.\n\n        When a teardown function was called because of an unhandled exception\n        it will be passed an error object. If an :meth:`errorhandler` is\n        registered, it will handle the exception and the teardown will not\n        receive it.\n\n        The return values of teardown functions are ignored.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n\n    @setupmethod\n    def context_processor(self, f):\n        \"\"\"Registers a template context processor function.\"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n\n    @setupmethod\n    def shell_context_processor(self, f):\n        \"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        self.shell_context_processors.append(f)\n        return f\n\n    @setupmethod\n    def url_value_preprocessor(self, f):\n        \"\"\"Register a URL value preprocessor function for all view\n        functions in the application. These functions will be called before the\n        :meth:`before_request` functions.\n\n        The function can modify the values captured from the matched url before\n        they are passed to the view. For example, this can be used to pop a\n        common language code value and place it in ``g`` rather than pass it to\n        every view.\n\n        The function is passed the endpoint name and values dict. The return\n        value is ignored.\n        \"\"\"\n        self.url_value_preprocessors.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def url_defaults(self, f):\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n        \"\"\"\n        self.url_default_functions.setdefault(None, []).append(f)\n        return f\n\n    def _find_error_handler(self, e):\n        \"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(type(e))\n\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n\n            if not handler_map:\n                continue\n\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n\n                if handler is not None:\n                    return handler\n\n    def handle_http_exception(self, e):\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionchanged:: 1.0.3\n            ``RoutingException``, used internally for actions such as\n             slash redirects during routing, is not passed to error\n             handlers.\n\n        .. versionchanged:: 1.0\n            Exceptions are looked up by code *and* by MRO, so\n            ``HTTPExcpetion`` subclasses can be handled with a catch-all\n            handler for the base ``HTTPException``.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        # RoutingExceptions are used internally to trigger routing\n        # actions, such as slash redirects raising RequestRedirect. They\n        # are not raised or handled in user code.\n        if isinstance(e, RoutingException):\n            return e\n\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n\n    def trap_http_exception(self, e):\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n\n        # if unset, trap key errors in debug mode\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False\n\n    def handle_user_exception(self, e):\n        \"\"\"This method is called whenever an exception occurs that\n        should be handled. A special case is :class:`~werkzeug\n        .exceptions.HTTPException` which is forwarded to the\n        :meth:`handle_http_exception` method. This function will either\n        return a response value or reraise the exception with the same\n        traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the\n            bad key in debug mode rather than a generic bad request\n            message.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        assert exc_value is e\n        # ensure not to trash sys.exc_info() at that point in case someone\n        # wants the traceback preserved in handle_http_exception.  Of course\n        # we cannot prevent users from trashing it themselves in a custom\n        # trap_http_exception method so that's their fault then.\n\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                # Werkzeug < 0.15 doesn't add the KeyError to the 400\n                # message, add it in manually.\n                description = e.get_description()\n\n                if e.args[0] not in description:\n                    e.description = \"KeyError: '{}'\".format(*e.args)\n            else:\n                # Werkzeug >= 0.15 does add it, remove it in production\n                e.args = ()\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        handler = self._find_error_handler(e)\n\n        if handler is None:\n            reraise(exc_type, exc_value, tb)\n        return handler(e)\n\n    def handle_exception(self, e):\n        \"\"\"Default exception handling that kicks in when an exception\n        occurs that is not caught.  In debug mode the exception will\n        be re-raised immediately, otherwise it is logged and the handler\n        for a 500 internal server error is used.  If no such handler\n        exists, a default 500 internal server error message is displayed.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        got_request_exception.send(self, exception=e)\n\n        if self.propagate_exceptions:\n            # if we want to repropagate the exception, we can attempt to\n            # raise it with the whole traceback in case we can do that\n            # (the function was actually called from the except part)\n            # otherwise, we just raise the error again\n            if exc_value is e:\n                reraise(exc_type, exc_value, tb)\n            else:\n                raise e\n\n        self.log_exception((exc_type, exc_value, tb))\n        handler = self._find_error_handler(InternalServerError())\n        if handler is None:\n            return InternalServerError()\n        return self.finalize_request(handler(e), from_error_handler=True)\n\n    def log_exception(self, exc_info):\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error(\n            \"Exception on %s [%s]\" % (request.path, request.method), exc_info=exc_info\n        )\n\n    def raise_routing_exception(self, request):\n        \"\"\"Exceptions that are recording during routing are reraised with\n        this method.  During debug we are not reraising redirect requests\n        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n        a different error instead to help debug situations.\n\n        :internal:\n        \"\"\"\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n\n        from .debughelpers import FormDataRoutingRedirect\n\n        raise FormDataRoutingRedirect(request)\n\n    def dispatch_request(self):\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        return self.view_functions[rule.endpoint](**req.view_args)\n\n    def full_dispatch_request(self):\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n\n    def finalize_request(self, rv, from_error_handler=False):\n        \"\"\"Given the return value from a view function this finalizes\n        the request by converting it into a response and invoking the\n        postprocessing functions.  This is invoked for both normal\n        request dispatching as well as error handlers.\n\n        Because this means that it might be called as a result of a\n        failure a special safe mode is available which can be enabled\n        with the `from_error_handler` flag.  If enabled, failures in\n        response processing will be logged and otherwise ignored.\n\n        :internal:\n        \"\"\"\n        response = self.make_response(rv)\n        try:\n            response = self.process_response(response)\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an \" \"error while handling an error\"\n            )\n        return response\n\n    def try_trigger_before_first_request_functions(self):\n        \"\"\"Called before each request and will ensure that it triggers\n        the :attr:`before_first_request_funcs` and only exactly once per\n        application instance (which means process usually).\n\n        :internal:\n        \"\"\"\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n\n    def make_default_options_response(self):\n        \"\"\"This method is called to create the default ``OPTIONS`` response.\n        This can be changed through subclassing to change the default\n        behavior of ``OPTIONS`` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        adapter = _request_ctx_stack.top.url_adapter\n        if hasattr(adapter, \"allowed_methods\"):\n            methods = adapter.allowed_methods()\n        else:\n            # fallback for Werkzeug < 0.7\n            methods = []\n            try:\n                adapter.match(method=\"--\")\n            except MethodNotAllowed as e:\n                methods = e.valid_methods\n            except HTTPException:\n                pass\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n\n    def should_ignore_error(self, error):\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns ``True`` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False\n\n    def make_response(self, rv):\n        \"\"\"Convert the return value from a view function to an instance of\n        :attr:`response_class`.\n\n        :param rv: the return value from the view function. The view function\n            must return a response. Returning ``None``, or the view ending\n            without returning, is not allowed. The following types are allowed\n            for ``view_rv``:\n\n            ``str`` (``unicode`` in Python 2)\n                A response object is created with the string encoded to UTF-8\n                as the body.\n\n            ``bytes`` (``str`` in Python 2)\n                A response object is created with the bytes as the body.\n\n            ``dict``\n                A dictionary that will be jsonify'd before being returned.\n\n            ``tuple``\n                Either ``(body, status, headers)``, ``(body, status)``, or\n                ``(body, headers)``, where ``body`` is any of the other types\n                allowed here, ``status`` is a string or an integer, and\n                ``headers`` is a dictionary or a list of ``(key, value)``\n                tuples. If ``body`` is a :attr:`response_class` instance,\n                ``status`` overwrites the exiting value and ``headers`` are\n                extended.\n\n            :attr:`response_class`\n                The object is returned unchanged.\n\n            other :class:`~werkzeug.wrappers.Response` class\n                The object is coerced to :attr:`response_class`.\n\n            :func:`callable`\n                The function is called as a WSGI application. The result is\n                used to create a response object.\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n\n        status = headers = None\n\n        # unpack tuple returns\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n\n            # a 3-tuple is unpacked directly\n            if len_rv == 3:\n                rv, status, headers = rv\n            # decide if a 2-tuple has status or headers\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            # other sized tuples are not allowed\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n\n        # the body must not be None\n        if rv is None:\n            raise TypeError(\n                \"The view function did not return a valid response. The\"\n                \" function either returned None or ended without a return\"\n                \" statement.\"\n            )\n\n        # make sure the body is an instance of the response class\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (text_type, bytes, bytearray)):\n                # let the response class set the status and headers instead of\n                # waiting to do it manually, so that the class can handle any\n                # special logic\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            elif isinstance(rv, dict):\n                rv = jsonify(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                # evaluate a WSGI callable, or coerce a different response\n                # class to the correct type\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    new_error = TypeError(\n                        \"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string, dict, tuple,\"\n                        \" Response instance, or WSGI callable, but it was a\"\n                        \" {rv.__class__.__name__}.\".format(e=e, rv=rv)\n                    )\n                    reraise(TypeError, new_error, sys.exc_info()[2])\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string, dict, tuple,\"\n                    \" Response instance, or WSGI callable, but it was a\"\n                    \" {rv.__class__.__name__}.\".format(rv=rv)\n                )\n\n        # prefer the status if it was provided\n        if status is not None:\n            if isinstance(status, (text_type, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n\n        # extend existing headers with provided headers\n        if headers:\n            rv.headers.extend(headers)\n\n        return rv\n\n    def create_url_adapter(self, request):\n        \"\"\"Creates a URL adapter for the given request. The URL adapter\n        is created at a point where the request context is not yet set\n        up so the request is passed explicitly.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n           This can now also be called without a request object when the\n           URL adapter is created for the application context.\n\n        .. versionchanged:: 1.0\n            :data:`SERVER_NAME` no longer implicitly enables subdomain\n            matching. Use :attr:`subdomain_matching` instead.\n        \"\"\"\n        if request is not None:\n            # If subdomain matching is disabled (the default), use the\n            # default subdomain in all cases. This should be the default\n            # in Werkzeug but it currently does not have that feature.\n            subdomain = (\n                (self.url_map.default_subdomain or None)\n                if not self.subdomain_matching\n                else None\n            )\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        # We need at the very least the server name to be set for this\n        # to work.\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n\n    def inject_url_defaults(self, endpoint, values):\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n\n    def handle_url_build_error(self, error, endpoint, values):\n        \"\"\"Handle :class:`~werkzeug.routing.BuildError` on :meth:`url_for`.\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n                if rv is not None:\n                    return rv\n            except BuildError as e:\n                # make error available outside except block (py3)\n                error = e\n\n        # At this point we want to reraise the exception.  If the error is\n        # still the same one we can reraise it with the original traceback,\n        # otherwise we raise it from here.\n        if error is exc_value:\n            reraise(exc_type, exc_value, tb)\n        raise error\n\n    def preprocess_request(self):\n        \"\"\"Called before the request is dispatched. Calls\n        :attr:`url_value_preprocessors` registered with the app and the\n        current blueprint (if any). Then calls :attr:`before_request_funcs`\n        registered with the app and the blueprint.\n\n        If any :meth:`before_request` handler returns a non-None value, the\n        value is handled as if it was the return value from the view, and\n        further request handling is stopped.\n        \"\"\"\n\n        bp = _request_ctx_stack.top.request.blueprint\n\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n\n    def process_response(self, response):\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n\n    def do_teardown_request(self, exc=_sentinel):\n        \"\"\"Called after the request is dispatched and the response is\n        returned, right before the request context is popped.\n\n        This calls all functions decorated with\n        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`\n        if a blueprint handled the request. Finally, the\n        :data:`request_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,\n        which may be delayed during testing to maintain access to\n        resources.\n\n        :param exc: An unhandled exception raised while dispatching the\n            request. Detected from the current exception information if\n            not passed. Passed to each teardown function.\n\n        .. versionchanged:: 0.9\n            Added the ``exc`` argument.\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n\n    def do_teardown_appcontext(self, exc=_sentinel):\n        \"\"\"Called right before the application context is popped.\n\n        When handling a request, the application context is popped\n        after the request context. See :meth:`do_teardown_request`.\n\n        This calls all functions decorated with\n        :meth:`teardown_appcontext`. Then the\n        :data:`appcontext_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n\n    def app_context(self):\n        \"\"\"Create an :class:`~flask.ctx.AppContext`. Use as a ``with``\n        block to push the context, which will make :data:`current_app`\n        point at this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`\/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ):\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`\/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args, **kwargs):\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`\/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop()\n\n        Takes the same arguments as Werkzeug's\n        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from\n        the application. See the linked Werkzeug docs for most of the\n        available arguments. Flask-specific behavior is listed here.\n\n        :param path: URL path being requested.\n        :param base_url: Base URL where the app is being served, which\n            ``path`` is relative to. If not given, built from\n            :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n        :param subdomain: Subdomain name to append to\n            :data:`SERVER_NAME`.\n        :param url_scheme: Scheme to use instead of\n            :data:`PREFERRED_URL_SCHEME`.\n        :param data: The request body, either as a string or a dict of\n            form keys and values.\n        :param json: If given, this is serialized as JSON and passed as\n            ``data``. Also defaults ``content_type`` to\n            ``application\/json``.\n        :param args: other positional arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        :param kwargs: other keyword arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        \"\"\"\n        from flask.testing import EnvironBuilder\n\n        builder = EnvironBuilder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(self, environ, start_response):\n        \"\"\"The actual WSGI application. This is not implemented in\n        :meth:`__call__` so that middlewares can be applied without\n        losing a reference to the app object. Instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            ctx.auto_pop(error)\n\n    def __call__(self, environ, start_response):\n        \"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app` which can be\n        wrapped to applying middleware.\"\"\"\n        return self.wsgi_app(environ, start_response)\n\n    def __repr__(self):\n        return \"<%s %r>\" % (self.__class__.__name__, self.name)\n\n\"\"\"\nGenerate tests which test: address flake8 issues\n\"\"\"\n","completion":" from hello import app  # noqa: F401\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.wrappers\n    ~~~~~~~~~~~~~~\n\n    Implements the WSGI wrappers (request and response).\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.wrappers import Request as RequestBase, Response as ResponseBase\nfrom werkzeug.wrappers.json import JSONMixin as _JSONMixin\n\nfrom flask import json\nfrom flask.globals import current_app\n\n\nclass JSONMixin(_JSONMixin):\n    json_module = json\n\n    def on_json_loading_failed(self, e):\n        if current_app and current_app.debug:\n            raise BadRequest(\"Failed to decode JSON object: {0}\".format(e))\n\n        raise BadRequest()\n\n\nclass Request(RequestBase, JSONMixin):\n    \"\"\"The request object used by default in Flask.  Remembers the\n    matched endpoint and view arguments.\n\n    It is what ends up as :class:`~flask.request`.  If you want to replace\n    the request object used you can subclass this and set\n    :attr:`~flask.Flask.request_class` to your subclass.\n\n    The request object is a :class:`~werkzeug.wrappers.Request` subclass and\n    provides all of the attributes Werkzeug defines plus a few Flask\n    specific ones.\n    \"\"\"\n\n    #: The internal URL rule that matched the request.  This can be\n    #: useful to inspect which methods are allowed for the URL from\n    #: a before\/after handler (``request.url_rule.methods``) etc.\n    #: Though if the request's method was invalid for the URL rule,\n    #: the valid list is available in ``routing_exception.valid_methods``\n    #: instead (an attribute of the Werkzeug exception\n    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)\n    #: because the request was never internally bound.\n    #:\n    #: .. versionadded:: 0.6\n    url_rule = None\n\n    #: A dict of view arguments that matched the request.  If an exception\n    #: happened when matching, this will be ``None``.\n    view_args = None\n\n    #: If matching the URL failed, this is the exception that will be\n    #: raised \/ was raised as part of the request handling.  This is\n    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n    #: something similar.\n    routing_exception = None\n\n    @property\n    def max_content_length(self):\n        \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"\n        if current_app:\n            return current_app.config[\"MAX_CONTENT_LENGTH\"]\n\n    @property\n    def endpoint(self):\n        \"\"\"The endpoint that matched the request.  This in combination with\n        :attr:`view_args` can be used to reconstruct the same or a\n        modified URL.  If an exception happened when matching, this will\n        be ``None``.\n        \"\"\"\n        if self.url_rule is not None:\n            return self.url_rule.endpoint\n\n    @property\n    def blueprint(self):\n        \"\"\"The name of the current blueprint\"\"\"\n        if self.url_rule and \".\" in self.url_rule.endpoint:\n            return self.url_rule.endpoint.rsplit(\".\", 1)[0]\n\n    def _load_form_data(self):\n        RequestBase._load_form_data(self)\n\n        # In debug mode we're replacing the files multidict with an ad-hoc\n        # subclass that raises a different error for key errors.\n        if (\n            current_app\n            and current_app.debug\n            and self.mimetype != \"multipart\/form-data\"\n            and not self.files\n        ):\n            from .debughelpers import attach_enctype_error_multidict\n\n            attach_enctype_error_multidict(self)\n\n\nclass Response(ResponseBase, JSONMixin):\n    \"\"\"The response object that is used by default in Flask.  Works like the\n    response object from Werkzeug but is set to have an HTML mimetype by\n    default.  Quite often you don't have to create this object yourself because\n    :meth:`~flask.Flask.make_response` will take care of that for you.\n\n    If you want to replace the response object used you can subclass this and\n    set :attr:`~flask.Flask.response_class` to your subclass.\n\n    .. versionchanged:: 1.0\n        JSON support is added to the response, like the request. This is useful\n        when testing to get the test client response data as JSON.\n\n    .. versionchanged:: 1.0\n\n        Added :attr:`max_cookie_size`.\n    \"\"\"\n\n    default_mimetype = \"text\/html\"\n\n    def _get_data_for_json(self, cache):\n        return self.get_data()\n\n    @property\n    def max_cookie_size(self):\n        \"\"\"Read-only view of the :data:`MAX_COOKIE_SIZE` config key.\n\n        See :attr:`~werkzeug.wrappers.BaseResponse.max_cookie_size` in\n        Werkzeug's docs.\n        \"\"\"\n        if current_app:\n            return current_app.config[\"MAX_COOKIE_SIZE\"]\n\n        # return Werkzeug's default when not in an app context\n        return super(Response, self).max_cookie_size\n\n\"\"\"\nGenerate tests which test: address flake8 issues\n\"\"\"\n","completion":" from hello import app  # noqa: F401\n"}
{"prompt":"Python3\n#!\/usr\/bin\/env python\nfrom __future__ import print_function\n\nimport os\nimport re\nimport sys\nfrom datetime import date, datetime\nfrom subprocess import PIPE, Popen\n\n_date_strip_re = re.compile(r\"(?<=\\d)(st|nd|rd|th)\")\n\n\ndef parse_changelog():\n    with open(\"CHANGES.rst\") as f:\n        lineiter = iter(f)\n        for line in lineiter:\n            match = re.search(r\"^Version\\s+(.*)\", line.strip())\n\n            if match is None:\n                continue\n\n            version = match.group(1).strip()\n\n            if next(lineiter).count(\"-\") != len(match.group(0)):\n                continue\n\n            while 1:\n                change_info = next(lineiter).strip()\n\n                if change_info:\n                    break\n\n            match = re.search(\n                r\"released on (\\w+\\s+\\d+\\w+\\s+\\d+)(?:, codename (.*))?\",\n                change_info,\n                flags=re.IGNORECASE,\n            )\n\n            if match is None:\n                continue\n\n            datestr, codename = match.groups()\n            return version, parse_date(datestr), codename\n\n\ndef bump_version(version):\n    try:\n        parts = [int(i) for i in version.split(\".\")]\n    except ValueError:\n        fail(\"Current version is not numeric\")\n\n    parts[-1] += 1\n    return \".\".join(map(str, parts))\n\n\ndef parse_date(string):\n    string = _date_strip_re.sub(\"\", string)\n    return datetime.strptime(string, \"%B %d %Y\")\n\n\ndef set_filename_version(filename, version_number, pattern):\n    changed = []\n\n    def inject_version(match):\n        before, old, after = match.groups()\n        changed.append(True)\n        return before + version_number + after\n\n    with open(filename) as f:\n        contents = re.sub(\n            r\"^(\\s*%s\\s*=\\s*')(.+?)(')\" % pattern,\n            inject_version,\n            f.read(),\n            flags=re.DOTALL | re.MULTILINE,\n        )\n\n    if not changed:\n        fail(\"Could not find %s in %s\", pattern, filename)\n\n    with open(filename, \"w\") as f:\n        f.write(contents)\n\n\ndef set_init_version(version):\n    info(\"Setting __init__.py version to %s\", version)\n    set_filename_version(\"flask\/__init__.py\", version, \"__version__\")\n\n\ndef build():\n    cmd = [sys.executable, \"setup.py\", \"sdist\", \"bdist_wheel\"]\n    Popen(cmd).wait()\n\n\ndef fail(message, *args):\n    print(\"Error:\", message % args, file=sys.stderr)\n    sys.exit(1)\n\n\ndef info(message, *args):\n    print(message % args, file=sys.stderr)\n\n\ndef get_git_tags():\n    return set(Popen([\"git\", \"tag\"], stdout=PIPE).communicate()[0].splitlines())\n\n\ndef git_is_clean():\n    return Popen([\"git\", \"diff\", \"--quiet\"]).wait() == 0\n\n\ndef make_git_commit(message, *args):\n    message = message % args\n    Popen([\"git\", \"commit\", \"-am\", message]).wait()\n\n\ndef make_git_tag(tag):\n    info('Tagging \"%s\"', tag)\n    Popen([\"git\", \"tag\", tag]).wait()\n\n\ndef main():\n    os.chdir(os.path.join(os.path.dirname(__file__), \"..\"))\n\n    rv = parse_changelog()\n\n    if rv is None:\n        fail(\"Could not parse changelog\")\n\n    version, release_date, codename = rv\n    dev_version = bump_version(version) + \".dev\"\n\n    info(\n        \"Releasing %s (codename %s, release date %s)\",\n        version,\n        codename,\n        release_date.strftime(\"%d\/%m\/%Y\"),\n    )\n    tags = get_git_tags()\n\n    if version in tags:\n        fail('Version \"%s\" is already tagged', version)\n\n    if release_date.date() != date.today():\n        fail(\"Release date is not today (%s != %s)\", release_date.date(), date.today())\n\n    if not git_is_clean():\n        fail(\"You have uncommitted changes in git\")\n\n    try:\n        import wheel  # noqa: F401\n    except ImportError:\n        fail(\"You need to install the wheel package.\")\n\n    set_init_version(version)\n    make_git_commit(\"Bump version number to %s\", version)\n    make_git_tag(version)\n    build()\n    set_init_version(dev_version)\n\n\nif __name__ == \"__main__\":\n    main()\n\n\"\"\"\nGenerate tests which test: address flake8 issues\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.basic\n    ~~~~~~~~~~~~~~~~~~~~~\n\n    The basic functionality.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport re\nimport sys\nimport time\nimport uuid\nfrom datetime import datetime\nfrom threading import Thread\n\nimport pytest\nimport werkzeug.serving\nfrom werkzeug.exceptions import BadRequest, Forbidden, NotFound\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\n\nimport flask\nfrom flask._compat import text_type\n\n\ndef test_options_work(app, client):\n    @app.route(\"\/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"\/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"\n\n\ndef test_options_on_multiple_rules(app, client):\n    @app.route(\"\/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"\/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"\/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]\n\n\ndef test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"\/\")(index)\n    rv = app.test_client().open(\"\/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return \"Hello World!\"\n\n    index2.provide_automatic_options = True\n    app.route(\"\/\", methods=[\"OPTIONS\"])(index2)\n    rv = app.test_client().open(\"\/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n\n\ndef test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"\/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"\/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"\/\").data == b\"GET\"\n\n    rv = client.post(\"\/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    # Older versions of Werkzeug.test.Client don't have an options method\n    if hasattr(client, \"options\"):\n        rv = client.options(\"\/\")\n    else:\n        rv = client.open(\"\/\", method=\"OPTIONS\")\n\n    assert rv.status_code == 405\n\n    rv = client.head(\"\/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"\/more\").data == b\"POST\"\n    assert client.get(\"\/more\").data == b\"GET\"\n\n    rv = client.delete(\"\/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    if hasattr(client, \"options\"):\n        rv = client.options(\"\/more\")\n    else:\n        rv = client.open(\"\/more\", method=\"OPTIONS\")\n\n    assert rv.status_code == 405\n\n\ndef test_request_dispatching(app, client):\n    @app.route(\"\/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"\/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"\/\").data == b\"GET\"\n    rv = client.post(\"\/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"\/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"\/more\").data == b\"POST\"\n    assert client.get(\"\/more\").data == b\"GET\"\n    rv = client.delete(\"\/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n\n\ndef test_disallow_string_for_allowed_methods(app):\n    with pytest.raises(TypeError):\n\n        @app.route(\"\/\", methods=\"GET POST\")\n        def index():\n            return \"Hey\"\n\n\ndef test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"\/\", \"index\", index)\n    app.add_url_rule(\"\/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"\/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"\/\").data == b\"GET\"\n    rv = client.post(\"\/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"\/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"\/more\").data == b\"POST\"\n    assert client.get(\"\/more\").data == b\"GET\"\n    rv = client.delete(\"\/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"\/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")\n\n\ndef test_werkzeug_routing(app, client):\n    from werkzeug.routing import Submount, Rule\n\n    app.url_map.add(\n        Submount(\"\/foo\", [Rule(\"\/bar\", endpoint=\"bar\"), Rule(\"\/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"\/foo\/\").data == b\"index\"\n    assert client.get(\"\/foo\/bar\").data == b\"bar\"\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Submount, Rule\n\n    app.url_map.add(\n        Submount(\"\/foo\", [Rule(\"\/bar\", endpoint=\"bar\"), Rule(\"\/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"\/foo\/\").data == b\"index\"\n    assert client.get(\"\/foo\/bar\").data == b\"bar\"\n\n\ndef test_session(app, client):\n    @app.route(\"\/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"\/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"\/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"\/get\").data == b\"42\"\n\n\ndef test_session_using_server_name(app, client):\n    app.config.update(SERVER_NAME=\"example.com\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com\/\")\n    assert \"domain=.example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_server_name_and_port(app, client):\n    app.config.update(SERVER_NAME=\"example.com:8080\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com:8080\/\")\n    assert \"domain=.example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_server_name_port_and_path(app, client):\n    app.config.update(SERVER_NAME=\"example.com:8080\", APPLICATION_ROOT=\"\/foo\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com:8080\/foo\")\n    assert \"domain=example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"path=\/foo\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_application_root(app, client):\n    class PrefixPathMiddleware(object):\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"\/bar\")\n    app.config.update(APPLICATION_ROOT=\"\/bar\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com:8080\/\")\n    assert \"path=\/bar\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_session_settings(app, client):\n    app.config.update(\n        SERVER_NAME=\"www.example.com:8080\",\n        APPLICATION_ROOT=\"\/test\",\n        SESSION_COOKIE_DOMAIN=\".example.com\",\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_SAMESITE=\"Lax\",\n        SESSION_COOKIE_PATH=\"\/\",\n    )\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/www.example.com:8080\/test\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"domain=.example.com\" in cookie\n    assert \"path=\/\" in cookie\n    assert \"secure\" in cookie\n    assert \"httponly\" not in cookie\n    assert \"samesite\" in cookie\n\n\ndef test_session_using_samesite_attribute(app, client):\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"\/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie\n\n\ndef test_session_localhost_warning(recwarn, app, client):\n    app.config.update(SERVER_NAME=\"localhost:5000\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"testing\"\n\n    rv = client.get(\"\/\", \"http:\/\/localhost:5000\/\")\n    assert \"domain\" not in rv.headers[\"set-cookie\"].lower()\n    w = recwarn.pop(UserWarning)\n    assert '\"localhost\" is not a valid cookie domain' in str(w.message)\n\n\ndef test_session_ip_warning(recwarn, app, client):\n    app.config.update(SERVER_NAME=\"127.0.0.1:5000\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"testing\"\n\n    rv = client.get(\"\/\", \"http:\/\/127.0.0.1:5000\/\")\n    assert \"domain=127.0.0.1\" in rv.headers[\"set-cookie\"].lower()\n    w = recwarn.pop(UserWarning)\n    assert \"cookie domain is an IP\" in str(w.message)\n\n\ndef test_missing_session(app):\n    app.secret_key = None\n\n    def expect_exception(f, *args, **kwargs):\n        e = pytest.raises(RuntimeError, f, *args, **kwargs)\n        assert e.value.args and \"session is unavailable\" in e.value.args[0]\n\n    with app.test_request_context():\n        assert flask.session.get(\"missing_key\") is None\n        expect_exception(flask.session.__setitem__, \"foo\", 42)\n        expect_exception(flask.session.pop, \"foo\")\n\n\ndef test_session_expiration(app, client):\n    permanent = True\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"test\"] = 42\n        flask.session.permanent = permanent\n        return \"\"\n\n    @app.route(\"\/test\")\n    def test():\n        return text_type(flask.session.permanent)\n\n    rv = client.get(\"\/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    expires = parse_date(match.group())\n    expected = datetime.utcnow() + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"\/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"\/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None\n\n\ndef test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"\/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"\/\").data == b\"None\"\n    assert client.get(\"\/\").data == b\"42\"\n\n\ndef test_session_special_types(app, client):\n    now = datetime.utcnow().replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.route(\"\/\")\n    def dump_session_contents():\n        flask.session[\"t\"] = (1, 2, 3)\n        flask.session[\"b\"] = b\"\\xff\"\n        flask.session[\"m\"] = flask.Markup(\"<html>\")\n        flask.session[\"u\"] = the_uuid\n        flask.session[\"d\"] = now\n        flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n        flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n        flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n        return \"\", 204\n\n    with client:\n        client.get(\"\/\")\n        s = flask.session\n        assert s[\"t\"] == (1, 2, 3)\n        assert type(s[\"b\"]) == bytes\n        assert s[\"b\"] == b\"\\xff\"\n        assert type(s[\"m\"]) == flask.Markup\n        assert s[\"m\"] == flask.Markup(\"<html>\")\n        assert s[\"u\"] == the_uuid\n        assert s[\"d\"] == now\n        assert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\n        assert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\n        assert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}\n\n\ndef test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"\/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"\/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"\/bump\").data == b\"1\"\n            assert c.get(\"\/bump\").data == b\"2\"\n            assert c.get(\"\/bump\").data == b\"3\"\n\n            rv = c.get(\"\/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n\ndef test_session_vary_cookie(app, client):\n    @app.route(\"\/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"\/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"\/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"\/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"\/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"\/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"\/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"\/set\")\n    expect(\"\/get\")\n    expect(\"\/getitem\")\n    expect(\"\/setdefault\")\n    expect(\"\/vary-cookie-header-set\")\n    expect(\"\/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"\/no-vary-header\", None)\n\n\ndef test_flashes(app, req_ctx):\n    assert not flask.session.modified\n    flask.flash(\"Zap\")\n    flask.session.modified = False\n    flask.flash(\"Zip\")\n    assert flask.session.modified\n    assert list(flask.get_flashed_messages()) == [\"Zap\", \"Zip\"]\n\n\ndef test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"\/\")\n    def index():\n        flask.flash(u\"Hello World\")\n        flask.flash(u\"Hello World\", \"error\")\n        flask.flash(flask.Markup(u\"<em>Testing<\/em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"\/test\/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            u\"Hello World\",\n            u\"Hello World\",\n            flask.Markup(u\"<em>Testing<\/em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"\/test_with_categories\/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", u\"Hello World\"),\n            (\"error\", u\"Hello World\"),\n            (\"warning\", flask.Markup(u\"<em>Testing<\/em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"\/test_filter\/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", u\"Hello World\")]\n        return \"\"\n\n    @app.route(\"\/test_filters\/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", u\"Hello World\"),\n            (\"warning\", flask.Markup(u\"<em>Testing<\/em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"\/test_filters_without_returning_categories\/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == u\"Hello World\"\n        assert messages[1] == flask.Markup(u\"<em>Testing<\/em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_with_categories\/\")\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_filter\/\")\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_filters\/\")\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_filters_without_returning_categories\/\")\n\n\ndef test_request_processing(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append(\"before\")\n\n    @app.after_request\n    def after_request(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @app.route(\"\/\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"\/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"\n\n\ndef test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"\/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"\/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]\n\n\ndef test_after_request_processing(app, client):\n    @app.route(\"\/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"\/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"\n\n\ndef test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"\/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"\/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.route(\"\/\")\n    def fails():\n        1 \/\/ 0\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert len(called) == 2\n\n\ndef test_before_after_request_order(app, client):\n    called = []\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"\/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]\n\n\ndef test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"\/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"\/error\")\n    def error():\n        1 \/\/ 0\n\n    @app.route(\"\/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"\/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"\/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data\n\n\ndef test_error_handler_unknown_code(app):\n    with pytest.raises(KeyError) as exc_info:\n        app.register_error_handler(999, lambda e: (\"999\", 999))\n\n    assert \"Use a subclass\" in exc_info.value.args[0]\n\n\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"\/\")\n    def broken_func():\n        1 \/\/ 0\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text\/x-special\"\n        return resp\n\n    resp = client.get(\"\/\")\n    assert resp.mimetype == \"text\/x-special\"\n    assert resp.data == b\"internal server error\"\n\n\ndef test_baseexception_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"\/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"\/\")\n\n        ctx = flask._request_ctx_stack.top\n        assert ctx.preserved\n        assert type(ctx._preserved_exc) is KeyboardInterrupt\n\n\ndef test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"\n\n\ndef test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"\/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"\/\").data == b\"42\"\n\n\ndef test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"\/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"\/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"\/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"\/1\").data == b\"banana\"\n    assert client.get(\"\/2\").data == b\"apple\"\n    assert client.get(\"\/3\").data == b\"apple\"\n\n\ndef test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"\/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"\/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"\/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"\/E3\")\n    assert rv.data == b\"E2\"\n\n\ndef test_trapping_of_bad_request_key_errors(app, client):\n    @app.route(\"\/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"\/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    rv = client.get(\"\/key\")\n    assert rv.status_code == 400\n    assert b\"missing_key\" not in rv.data\n    rv = client.get(\"\/abort\")\n    assert rv.status_code == 400\n\n    app.debug = True\n    with pytest.raises(KeyError) as e:\n        client.get(\"\/key\")\n    assert e.errisinstance(BadRequest)\n    assert \"missing_key\" in e.value.get_description()\n    rv = client.get(\"\/abort\")\n    assert rv.status_code == 400\n\n    app.debug = False\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = True\n    with pytest.raises(KeyError):\n        client.get(\"\/key\")\n    with pytest.raises(BadRequest):\n        client.get(\"\/abort\")\n\n\ndef test_trapping_of_all_http_exceptions(app, client):\n    app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"\/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"\/fail\")\n\n\ndef test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if _trigger == \"before\":\n            1 \/\/ 0\n\n    @app.after_request\n    def after_request(response):\n        if _trigger == \"after\":\n            1 \/\/ 0\n        return response\n\n    @app.route(\"\/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for _trigger in \"before\", \"after\":\n        rv = client.get(\"\/\")\n        assert rv.status_code == 500\n        assert rv.data == b\"Hello Server Error\"\n\n\ndef test_enctype_debug_helper(app, client):\n    from flask.debughelpers import DebugFilesKeyError\n\n    app.debug = True\n\n    @app.route(\"\/fail\", methods=[\"POST\"])\n    def index():\n        return flask.request.files[\"foo\"].filename\n\n    # with statement is important because we leave an exception on the\n    # stack otherwise and we want to ensure that this is not the case\n    # to not negatively affect other tests.\n    with client:\n        with pytest.raises(DebugFilesKeyError) as e:\n            client.post(\"\/fail\", data={\"foo\": \"index.txt\"})\n        assert \"no file contents were transmitted\" in str(e.value)\n        assert 'This was submitted: \"index.txt\"' in str(e.value)\n\n\ndef test_response_types(app, client):\n    @app.route(\"\/text\")\n    def from_text():\n        return u\"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"\/bytes\")\n    def from_bytes():\n        return u\"H\u00e4llo W\u00f6rld\".encode(\"utf-8\")\n\n    @app.route(\"\/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text\/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"\/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text\/plain; charset=utf-8\"}\n\n    @app.route(\"\/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"\/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\"Hello world\", 404, {\"X-Foo\": \"Baz\"}),\n            {\"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"\/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"\/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"\/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    assert client.get(\"\/text\").data == u\"H\u00e4llo W\u00f6rld\".encode(\"utf-8\")\n    assert client.get(\"\/bytes\").data == u\"H\u00e4llo W\u00f6rld\".encode(\"utf-8\")\n\n    rv = client.get(\"\/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text\/plain\"\n\n    rv = client.get(\"\/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text\/plain\"\n\n    rv = client.get(\"\/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text\/html\"\n\n    rv = client.get(\"\/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Baz\", \"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"\/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"\/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"\/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n\ndef test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"\/none\")\n    def from_none():\n        pass\n\n    @app.route(\"\/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"\/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"\/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"\/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"\/none\")\n\n    assert \"returned None\" in str(e)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"\/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e)\n\n    pytest.raises(TypeError, c.get, \"\/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"\/bad_type\")\n\n    assert \"object is not callable\" not in str(e)\n    assert \"it was a bool\" in str(e)\n\n    pytest.raises(TypeError, c.get, \"\/bad_wsgi\")\n\n\ndef test_make_response(app, req_ctx):\n    rv = flask.make_response()\n    assert rv.status_code == 200\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text\/html\"\n\n    rv = flask.make_response(\"Awesome\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Awesome\"\n    assert rv.mimetype == \"text\/html\"\n\n    rv = flask.make_response(\"W00t\", 404)\n    assert rv.status_code == 404\n    assert rv.data == b\"W00t\"\n    assert rv.mimetype == \"text\/html\"\n\n\ndef test_make_response_with_response_instance(app, req_ctx):\n    rv = flask.make_response(flask.jsonify({\"msg\": \"W00t\"}), 400)\n    assert rv.status_code == 400\n    assert rv.data == b'{\"msg\":\"W00t\"}\\n'\n    assert rv.mimetype == \"application\/json\"\n\n    rv = flask.make_response(flask.Response(\"\"), 400)\n    assert rv.status_code == 400\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text\/html\"\n\n    rv = flask.make_response(\n        flask.Response(\"\", headers={\"Content-Type\": \"text\/html\"}),\n        400,\n        [(\"X-Foo\", \"bar\")],\n    )\n    assert rv.status_code == 400\n    assert rv.headers[\"Content-Type\"] == \"text\/html\"\n    assert rv.headers[\"X-Foo\"] == \"bar\"\n\n\ndef test_jsonify_no_prettyprint(app, req_ctx):\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": False})\n    compressed_msg = b'{\"msg\":{\"submsg\":\"W00t\"},\"msg2\":\"foobar\"}\\n'\n    uncompressed_msg = {\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"}\n\n    rv = flask.make_response(flask.jsonify(uncompressed_msg), 200)\n    assert rv.data == compressed_msg\n\n\ndef test_jsonify_prettyprint(app, req_ctx):\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": True})\n    compressed_msg = {\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"}\n    pretty_response = (\n        b'{\\n  \"msg\": {\\n    \"submsg\": \"W00t\"\\n  }, \\n  \"msg2\": \"foobar\"\\n}\\n'\n    )\n\n    rv = flask.make_response(flask.jsonify(compressed_msg), 200)\n    assert rv.data == pretty_response\n\n\ndef test_jsonify_mimetype(app, req_ctx):\n    app.config.update({\"JSONIFY_MIMETYPE\": \"application\/vnd.api+json\"})\n    msg = {\"msg\": {\"submsg\": \"W00t\"}}\n    rv = flask.make_response(flask.jsonify(msg), 200)\n    assert rv.mimetype == \"application\/vnd.api+json\"\n\n\n@pytest.mark.skipif(sys.version_info < (3, 7), reason=\"requires Python >= 3.7\")\ndef test_json_dump_dataclass(app, req_ctx):\n    from dataclasses import make_dataclass\n\n    Data = make_dataclass(\"Data\", [(\"name\", str)])\n    value = flask.json.dumps(Data(\"Flask\"), app=app)\n    value = flask.json.loads(value, app=app)\n    assert value == {\"name\": \"Flask\"}\n\n\ndef test_jsonify_args_and_kwargs_check(app, req_ctx):\n    with pytest.raises(TypeError) as e:\n        flask.jsonify(\"fake args\", kwargs=\"fake\")\n    assert \"behavior undefined\" in str(e.value)\n\n\ndef test_url_generation(app, req_ctx):\n    @app.route(\"\/hello\/<name>\", methods=[\"POST\"])\n    def hello():\n        pass\n\n    assert flask.url_for(\"hello\", name=\"test x\") == \"\/hello\/test%20x\"\n    assert (\n        flask.url_for(\"hello\", name=\"test x\", _external=True)\n        == \"http:\/\/localhost\/hello\/test%20x\"\n    )\n\n\ndef test_build_error_handler(app):\n    # Test base case, a URL which results in a BuildError.\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"spam\")\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for(\"spam\")\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError(\"Test case where BuildError is not current.\")\n    except RuntimeError:\n        pytest.raises(BuildError, app.handle_url_build_error, error, \"spam\", {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return \"\/test_handler\/\"\n\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for(\"spam\") == \"\/test_handler\/\"\n\n\ndef test_build_error_handler_reraise(app):\n    # Test a custom handler which reraises the BuildError\n    def handler_raises_build_error(error, endpoint, values):\n        raise error\n\n    app.url_build_error_handlers.append(handler_raises_build_error)\n\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"not.existing\")\n\n\ndef test_url_for_passes_special_values_to_build_error_handler(app):\n    @app.url_build_error_handlers.append\n    def handler(error, endpoint, values):\n        assert values == {\n            \"_external\": False,\n            \"_anchor\": None,\n            \"_method\": None,\n            \"_scheme\": None,\n        }\n        return \"handled\"\n\n    with app.test_request_context():\n        flask.url_for(\"\/\")\n\n\ndef test_custom_converters(app, client):\n    from werkzeug.routing import BaseConverter\n\n    class ListConverter(BaseConverter):\n        def to_python(self, value):\n            return value.split(\",\")\n\n        def to_url(self, value):\n            base_to_url = super(ListConverter, self).to_url\n            return \",\".join(base_to_url(x) for x in value)\n\n    app.url_map.converters[\"list\"] = ListConverter\n\n    @app.route(\"\/<list:args>\")\n    def index(args):\n        return \"|\".join(args)\n\n    assert client.get(\"\/1,2,3\").data == b\"1|2|3\"\n\n\ndef test_static_files(app, client):\n    rv = client.get(\"\/static\/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!<\/h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"\/static\/index.html\"\n    rv.close()\n\n\ndef test_static_url_path():\n    app = flask.Flask(__name__, static_url_path=\"\/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"\/foo\/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"\/foo\/index.html\"\n\n\ndef test_static_url_path_with_ending_slash():\n    app = flask.Flask(__name__, static_url_path=\"\/foo\/\")\n    app.testing = True\n    rv = app.test_client().get(\"\/foo\/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"\/foo\/index.html\"\n\n\ndef test_static_url_empty_path(app):\n    app = flask.Flask(__name__, static_folder=\"\", static_url_path=\"\")\n    rv = app.test_client().open(\"\/static\/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()\n\n\ndef test_static_url_empty_path_default(app):\n    app = flask.Flask(__name__, static_folder=\"\")\n    rv = app.test_client().open(\"\/static\/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()\n\n\ndef test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http:\/\/example.com\/static\/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http:\/\/example.com\/static\/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(Exception):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(Exception):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)\n\n\ndef test_request_locals():\n    assert repr(flask.g) == \"<LocalProxy unbound>\"\n    assert not flask.g\n\n\ndef test_test_app_proper_environ():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n    client = app.test_client()\n\n    @app.route(\"\/\")\n    def index():\n        return \"Foo\"\n\n    @app.route(\"\/\", subdomain=\"foo\")\n    def subdomain():\n        return \"Foo SubDomain\"\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"Foo\"\n\n    rv = client.get(\"\/\", \"http:\/\/localhost.localdomain:5000\")\n    assert rv.data == b\"Foo\"\n\n    rv = client.get(\"\/\", \"https:\/\/localhost.localdomain:5000\")\n    assert rv.data == b\"Foo\"\n\n    app.config.update(SERVER_NAME=\"localhost.localdomain\")\n    rv = client.get(\"\/\", \"https:\/\/localhost.localdomain\")\n    assert rv.data == b\"Foo\"\n\n    try:\n        app.config.update(SERVER_NAME=\"localhost.localdomain:443\")\n        rv = client.get(\"\/\", \"https:\/\/localhost.localdomain\")\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain:443') does not match the \"\n            \"server name from the WSGI environment ('localhost.localdomain')\"\n        )\n\n    try:\n        app.config.update(SERVER_NAME=\"localhost.localdomain\")\n        rv = client.get(\"\/\", \"http:\/\/foo.localhost\")\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain') does not match the \"\n            \"server name from the WSGI environment ('foo.localhost')\"\n        )\n\n    rv = client.get(\"\/\", \"http:\/\/foo.localhost.localdomain\")\n    assert rv.data == b\"Foo SubDomain\"\n\n\ndef test_exception_propagation(app, client):\n    def apprunner(config_key):\n        @app.route(\"\/\")\n        def index():\n            1 \/\/ 0\n\n        if config_key is not None:\n            app.config[config_key] = True\n            with pytest.raises(Exception):\n                client.get(\"\/\")\n        else:\n            assert client.get(\"\/\").status_code == 500\n\n    # we have to run this test in an isolated thread because if the\n    # debug flag is set to true and an exception happens the context is\n    # not torn down.  This causes other tests that run after this fail\n    # when they expect no exception on the stack.\n    for config_key in \"TESTING\", \"PROPAGATE_EXCEPTIONS\", \"DEBUG\", None:\n        t = Thread(target=apprunner, args=(config_key,))\n        t.start()\n        t.join()\n\n\n@pytest.mark.parametrize(\"debug\", [True, False])\n@pytest.mark.parametrize(\"use_debugger\", [True, False])\n@pytest.mark.parametrize(\"use_reloader\", [True, False])\n@pytest.mark.parametrize(\"propagate_exceptions\", [None, True, False])\ndef test_werkzeug_passthrough_errors(\n    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)\n\n\ndef test_max_content_length(app, client):\n    app.config[\"MAX_CONTENT_LENGTH\"] = 64\n\n    @app.before_request\n    def always_first():\n        flask.request.form[\"myfile\"]\n        AssertionError()\n\n    @app.route(\"\/accept\", methods=[\"POST\"])\n    def accept_file():\n        flask.request.form[\"myfile\"]\n        AssertionError()\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return \"42\"\n\n    rv = client.post(\"\/accept\", data={\"myfile\": \"foo\" * 100})\n    assert rv.data == b\"42\"\n\n\ndef test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"\/<lang_code>\/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"\/<lang_code>\/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"\/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"\/de\/\").data == b\"\/de\/about\"\n    assert client.get(\"\/de\/about\").data == b\"\/foo\"\n    assert client.get(\"\/foo\").data == b\"\/en\/about\"\n\n\ndef test_inject_blueprint_url_defaults(app):\n    bp = flask.Blueprint(\"foo.bar.baz\", __name__, template_folder=\"template\")\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values[\"page\"] = \"login\"\n\n    @bp.route(\"\/<page>\")\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults(\"foo.bar.baz.view\", values)\n    expected = dict(page=\"login\")\n    assert values == expected\n\n    with app.test_request_context(\"\/somepage\"):\n        url = flask.url_for(\"foo.bar.baz.view\")\n    expected = \"\/login\"\n    assert url == expected\n\n\ndef test_nonascii_pathinfo(app, client):\n    @app.route(u\"\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(u\"\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    assert rv.data == b\"Hello World!\"\n\n\ndef test_debug_mode_complains_after_first_request(app, client):\n    app.debug = True\n\n    @app.route(\"\/\")\n    def index():\n        return \"Awesome\"\n\n    assert not app.got_first_request\n    assert client.get(\"\/\").data == b\"Awesome\"\n    with pytest.raises(AssertionError) as e:\n\n        @app.route(\"\/foo\")\n        def broken():\n            return \"Meh\"\n\n    assert \"A setup function was called\" in str(e)\n\n    app.debug = False\n\n    @app.route(\"\/foo\")\n    def working():\n        return \"Meh\"\n\n    assert client.get(\"\/foo\").data == b\"Meh\"\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions(app, client):\n    got = []\n\n    @app.before_first_request\n    def foo():\n        got.append(42)\n\n    client.get(\"\/\")\n    assert got == [42]\n    client.get(\"\/\")\n    assert got == [42]\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions_concurrent(app, client):\n    got = []\n\n    @app.before_first_request\n    def foo():\n        time.sleep(0.2)\n        got.append(42)\n\n    def get_and_assert():\n        client.get(\"\/\")\n        assert got == [42]\n\n    t = Thread(target=get_and_assert)\n    t.start()\n    get_and_assert()\n    t.join()\n    assert app.got_first_request\n\n\ndef test_routing_redirect_debugging(app, client):\n    app.debug = True\n\n    @app.route(\"\/foo\/\", methods=[\"GET\", \"POST\"])\n    def foo():\n        return \"success\"\n\n    with client:\n        with pytest.raises(AssertionError) as e:\n            client.post(\"\/foo\", data={})\n        assert \"http:\/\/localhost\/foo\/\" in str(e)\n        assert (\"Make sure to directly send \" \"your POST-request to this URL\") in str(e)\n\n        rv = client.get(\"\/foo\", data={}, follow_redirects=True)\n        assert rv.data == b\"success\"\n\n    app.debug = False\n    with client:\n        rv = client.post(\"\/foo\", data={}, follow_redirects=True)\n        assert rv.data == b\"success\"\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route(\"\/foo\/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"\/bar\/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route(\"\/bar\/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"\/foo\/\"\n        assert flask.url_for(\"bar\") == \"\/bar\/\"\n        assert flask.url_for(\"123\") == \"\/bar\/123\"\n\n    assert client.get(\"\/foo\/\").data == b\"foo\"\n    assert client.get(\"\/bar\/\").data == b\"bar\"\n    assert client.get(\"\/bar\/123\").data == b\"123\"\n\n\ndef test_preserve_only_once(app, client):\n    app.debug = True\n\n    @app.route(\"\/fail\")\n    def fail_func():\n        1 \/\/ 0\n\n    for _x in range(3):\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"\/fail\")\n\n    assert flask._request_ctx_stack.top is not None\n    assert flask._app_ctx_stack.top is not None\n    # implicit appctx disappears too\n    flask._request_ctx_stack.top.pop()\n    assert flask._request_ctx_stack.top is None\n    assert flask._app_ctx_stack.top is None\n\n\ndef test_preserve_remembers_exception(app, client):\n    app.debug = True\n    errors = []\n\n    @app.route(\"\/fail\")\n    def fail_func():\n        1 \/\/ 0\n\n    @app.route(\"\/success\")\n    def success_func():\n        return \"Okay\"\n\n    @app.teardown_request\n    def teardown_handler(exc):\n        errors.append(exc)\n\n    # After this failure we did not yet call the teardown handler\n    with pytest.raises(ZeroDivisionError):\n        client.get(\"\/fail\")\n    assert errors == []\n\n    # But this request triggers it, and it's an error\n    client.get(\"\/success\")\n    assert len(errors) == 2\n    assert isinstance(errors[0], ZeroDivisionError)\n\n    # At this point another request does nothing.\n    client.get(\"\/success\")\n    assert len(errors) == 3\n    assert errors[1] is None\n\n\ndef test_get_method_on_g(app_ctx):\n    assert flask.g.get(\"x\") is None\n    assert flask.g.get(\"x\", 11) == 11\n    flask.g.x = 42\n    assert flask.g.get(\"x\") == 42\n    assert flask.g.x == 42\n\n\ndef test_g_iteration_protocol(app_ctx):\n    flask.g.foo = 23\n    flask.g.bar = 42\n    assert \"foo\" in flask.g\n    assert \"foos\" not in flask.g\n    assert sorted(flask.g) == [\"bar\", \"foo\"]\n\n\ndef test_subdomain_basic_support():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"\/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"\/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"\/\", \"http:\/\/localhost.localdomain\/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"\/\", \"http:\/\/test.localhost.localdomain\/\")\n    assert rv.data == b\"test index\"\n\n\ndef test_subdomain_matching():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n\n    @app.route(\"\/\", subdomain=\"<user>\")\n    def index(user):\n        return \"index for %s\" % user\n\n    rv = client.get(\"\/\", \"http:\/\/mitsuhiko.localhost.localdomain\/\")\n    assert rv.data == b\"index for mitsuhiko\"\n\n\ndef test_subdomain_matching_with_ports():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"\/\", subdomain=\"<user>\")\n    def index(user):\n        return \"index for %s\" % user\n\n    rv = client.get(\"\/\", \"http:\/\/mitsuhiko.localhost.localdomain:3000\/\")\n    assert rv.data == b\"index for mitsuhiko\"\n\n\n@pytest.mark.parametrize(\"matching\", (False, True))\ndef test_subdomain_matching_other_name(matching):\n    app = flask.Flask(__name__, subdomain_matching=matching)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"\/\")\n    def index():\n        return \"\", 204\n\n    # ip address can't match name\n    rv = client.get(\"\/\", \"http:\/\/127.0.0.1:3000\/\")\n    assert rv.status_code == 404 if matching else 204\n\n    # allow all subdomains if matching is disabled\n    rv = client.get(\"\/\", \"http:\/\/www.localhost.localdomain:3000\/\")\n    assert rv.status_code == 404 if matching else 204\n\n\ndef test_multi_route_rules(app, client):\n    @app.route(\"\/\")\n    @app.route(\"\/<test>\/\")\n    def index(test=\"a\"):\n        return test\n\n    rv = client.open(\"\/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"\/b\/\")\n    assert rv.data == b\"b\"\n\n\ndef test_multi_route_class_views(app, client):\n    class View(object):\n        def __init__(self, app):\n            app.add_url_rule(\"\/\", \"index\", self.index)\n            app.add_url_rule(\"\/<test>\/\", \"index\", self.index)\n\n        def index(self, test=\"a\"):\n            return test\n\n    _ = View(app)\n    rv = client.open(\"\/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"\/b\/\")\n    assert rv.data == b\"b\"\n\n\ndef test_run_defaults(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"result\"] = \"running...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.run()\n    assert rv[\"result\"] == \"running...\"\n\n\ndef test_run_server_port(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(hostname, port, application, *args, **kwargs):\n        rv[\"result\"] = \"running on %s:%s ...\" % (hostname, port)\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    hostname, port = \"localhost\", 8000\n    app.run(hostname, port, debug=True)\n    assert rv[\"result\"] == \"running on %s:%s ...\" % (hostname, port)\n\n\n@pytest.mark.parametrize(\n    \"host,port,server_name,expect_host,expect_port\",\n    (\n        (None, None, \"pocoo.org:8080\", \"pocoo.org\", 8080),\n        (\"localhost\", None, \"pocoo.org:8080\", \"localhost\", 8080),\n        (None, 80, \"pocoo.org:8080\", \"pocoo.org\", 80),\n        (\"localhost\", 80, \"pocoo.org:8080\", \"localhost\", 80),\n        (\"localhost\", 0, \"localhost:8080\", \"localhost\", 0),\n        (None, None, \"localhost:8080\", \"localhost\", 8080),\n        (None, None, \"localhost:0\", \"localhost\", 0),\n    ),\n)\ndef test_run_from_config(\n    monkeypatch, host, port, server_name, expect_host, expect_port, app\n):\n    def run_simple_mock(hostname, port, *args, **kwargs):\n        assert hostname == expect_host\n        assert port == expect_port\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"SERVER_NAME\"] = server_name\n    app.run(host, port)\n\n\ndef test_max_cookie_size(app, client, recwarn):\n    app.config[\"MAX_COOKIE_SIZE\"] = 100\n\n    # outside app context, default to Werkzeug static value,\n    # which is also the default config\n    response = flask.Response()\n    default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\n    assert response.max_cookie_size == default\n\n    # inside app context, use app config\n    with app.app_context():\n        assert flask.Response().max_cookie_size == 100\n\n    @app.route(\"\/\")\n    def index():\n        r = flask.Response(\"\", status=204)\n        r.set_cookie(\"foo\", \"bar\" * 100)\n        return r\n\n    client.get(\"\/\")\n    assert len(recwarn) == 1\n    w = recwarn.pop()\n    assert \"cookie is too large\" in str(w.message)\n\n    app.config[\"MAX_COOKIE_SIZE\"] = 0\n\n    client.get(\"\/\")\n    assert len(recwarn) == 0\n"}
{"prompt":"Python3\nfrom flask import Blueprint\nfrom flask import flash\nfrom flask import g\nfrom flask import redirect\nfrom flask import render_template\nfrom flask import request\nfrom flask import url_for\nfrom werkzeug.exceptions import abort\n\nfrom flaskr.auth import login_required\nfrom flaskr.db import get_db\n\nbp = Blueprint(\"blog\", __name__)\n\n\n@bp.route(\"\/\")\ndef index():\n    \"\"\"Show all the posts, most recent first.\"\"\"\n    db = get_db()\n    posts = db.execute(\n        \"SELECT p.id, title, body, created, author_id, username\"\n        \" FROM post p JOIN user u ON p.author_id = u.id\"\n        \" ORDER BY created DESC\"\n    ).fetchall()\n    return render_template(\"blog\/index.html\", posts=posts)\n\n\ndef get_post(id, check_author=True):\n    \"\"\"Get a post and its author by id.\n\n    Checks that the id exists and optionally that the current user is\n    the author.\n\n    :param id: id of post to get\n    :param check_author: require the current user to be the author\n    :return: the post with author information\n    :raise 404: if a post with the given id doesn't exist\n    :raise 403: if the current user isn't the author\n    \"\"\"\n    post = (\n        get_db()\n        .execute(\n            \"SELECT p.id, title, body, created, author_id, username\"\n            \" FROM post p JOIN user u ON p.author_id = u.id\"\n            \" WHERE p.id = ?\",\n            (id,),\n        )\n        .fetchone()\n    )\n\n    if post is None:\n        abort(404, \"Post id {0} doesn't exist.\".format(id))\n\n    if check_author and post[\"author_id\"] != g.user[\"id\"]:\n        abort(403)\n\n    return post\n\n\n@bp.route(\"\/create\", methods=(\"GET\", \"POST\"))\n@login_required\ndef create():\n    \"\"\"Create a new post for the current user.\"\"\"\n    if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"INSERT INTO post (title, body, author_id)\" \" VALUES (?, ?, ?)\",\n                (title, body, g.user[\"id\"]),\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog\/create.html\")\n\n\n@bp.route(\"\/<int:id>\/update\", methods=(\"GET\", \"POST\"))\n@login_required\ndef update(id):\n    \"\"\"Update a post if the current user is the author.\"\"\"\n    post = get_post(id)\n\n    if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"UPDATE post SET title = ?, body = ? WHERE id = ?\", (title, body, id)\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog\/update.html\", post=post)\n\n\n@bp.route(\"\/<int:id>\/delete\", methods=(\"POST\",))\n@login_required\ndef delete(id):\n    \"\"\"Delete a post.\n\n    Ensures that the post exists and that the logged in user is the\n    author of the post.\n    \"\"\"\n    get_post(id)\n    db = get_db()\n    db.execute(\"DELETE FROM post WHERE id = ?\", (id,))\n    db.commit()\n    return redirect(url_for(\"blog.index\"))\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" import pytest\nfrom flask import g\nfrom flask import session\n\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.config\n    ~~~~~~~~~~~~\n\n    Implements the configuration related objects.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport errno\nimport os\nimport types\n\nfrom werkzeug.utils import import_string\n\nfrom . import json\nfrom ._compat import iteritems\nfrom ._compat import string_types\n\n\nclass ConfigAttribute(object):\n    \"\"\"Makes an attribute forward to the config\"\"\"\n\n    def __init__(self, name, get_converter=None):\n        self.__name__ = name\n        self.get_converter = get_converter\n\n    def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        rv = obj.config[self.__name__]\n        if self.get_converter is not None:\n            rv = self.get_converter(rv)\n        return rv\n\n    def __set__(self, obj, value):\n        obj.config[self.__name__] = value\n\n\nclass Config(dict):\n    \"\"\"Works exactly like a dict but provides ways to fill it from files\n    or special dictionaries.  There are two common patterns to populate the\n    config.\n\n    Either you can fill the config from a config file::\n\n        app.config.from_pyfile('yourconfig.cfg')\n\n    Or alternatively you can define the configuration options in the\n    module that calls :meth:`from_object` or provide an import path to\n    a module that should be loaded.  It is also possible to tell it to\n    use the same module and with that provide the configuration values\n    just before the call::\n\n        DEBUG = True\n        SECRET_KEY = 'development key'\n        app.config.from_object(__name__)\n\n    In both cases (loading from any Python file or loading from modules),\n    only uppercase keys are added to the config.  This makes it possible to use\n    lowercase values in the config file for temporary values that are not added\n    to the config or to define the config keys in the same file that implements\n    the application.\n\n    Probably the most interesting way to load configurations is from an\n    environment variable pointing to a file::\n\n        app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n\n    In this case before launching the application you have to set this\n    environment variable to the file you want to use.  On Linux and OS X\n    use the export statement::\n\n        export YOURAPPLICATION_SETTINGS='\/path\/to\/config\/file'\n\n    On windows use `set` instead.\n\n    :param root_path: path to which files are read relative from.  When the\n                      config object is created by the application, this is\n                      the application's :attr:`~flask.Flask.root_path`.\n    :param defaults: an optional dictionary of default values\n    \"\"\"\n\n    def __init__(self, root_path, defaults=None):\n        dict.__init__(self, defaults or {})\n        self.root_path = root_path\n\n    def from_envvar(self, variable_name, silent=False):\n        \"\"\"Loads a configuration from an environment variable pointing to\n        a configuration file.  This is basically just a shortcut with nicer\n        error messages for this line of code::\n\n            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n        :param variable_name: name of the environment variable\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: bool. ``True`` if able to load config, ``False`` otherwise.\n        \"\"\"\n        rv = os.environ.get(variable_name)\n        if not rv:\n            if silent:\n                return False\n            raise RuntimeError(\n                \"The environment variable %r is not set \"\n                \"and as such configuration could not be \"\n                \"loaded.  Set this variable and make it \"\n                \"point to a configuration file\" % variable_name\n            )\n        return self.from_pyfile(rv, silent=silent)\n\n    def from_pyfile(self, filename, silent=False):\n        \"\"\"Updates the values in the config from a Python file.  This function\n        behaves as if the file was imported as module with the\n        :meth:`from_object` function.\n\n        :param filename: the filename of the config.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n\n        .. versionadded:: 0.7\n           `silent` parameter.\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n        d = types.ModuleType(\"config\")\n        d.__file__ = filename\n        try:\n            with open(filename, mode=\"rb\") as config_file:\n                exec(compile(config_file.read(), filename, \"exec\"), d.__dict__)\n        except IOError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):\n                return False\n            e.strerror = \"Unable to load configuration file (%s)\" % e.strerror\n            raise\n        self.from_object(d)\n        return True\n\n    def from_object(self, obj):\n        \"\"\"Updates the values from the given object.  An object can be of one\n        of the following two types:\n\n        -   a string: in this case the object with that name will be imported\n        -   an actual object reference: that object is used directly\n\n        Objects are usually either modules or classes. :meth:`from_object`\n        loads only the uppercase attributes of the module\/class. A ``dict``\n        object will not work with :meth:`from_object` because the keys of a\n        ``dict`` are not attributes of the ``dict`` class.\n\n        Example of module-based configuration::\n\n            app.config.from_object('yourapplication.default_config')\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n        Nothing is done to the object before loading. If the object is a\n        class and has ``@property`` attributes, it needs to be\n        instantiated before being passed to this method.\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults.  The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        See :ref:`config-dev-prod` for an example of class-based configuration\n        using :meth:`from_object`.\n\n        :param obj: an import name or object\n        \"\"\"\n        if isinstance(obj, string_types):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)\n\n    def from_json(self, filename, silent=False):\n        \"\"\"Updates the values in the config from a JSON file. This function\n        behaves as if the JSON object was a dictionary and passed to the\n        :meth:`from_mapping` function.\n\n        :param filename: the filename of the JSON file.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename) as json_file:\n                obj = json.loads(json_file.read())\n        except IOError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n            e.strerror = \"Unable to load configuration file (%s)\" % e.strerror\n            raise\n        return self.from_mapping(obj)\n\n    def from_mapping(self, *mapping, **kwargs):\n        \"\"\"Updates the config like :meth:`update` ignoring items with non-upper\n        keys.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        mappings = []\n        if len(mapping) == 1:\n            if hasattr(mapping[0], \"items\"):\n                mappings.append(mapping[0].items())\n            else:\n                mappings.append(mapping[0])\n        elif len(mapping) > 1:\n            raise TypeError(\n                \"expected at most 1 positional argument, got %d\" % len(mapping)\n            )\n        mappings.append(kwargs.items())\n        for mapping in mappings:\n            for (key, value) in mapping:\n                if key.isupper():\n                    self[key] = value\n        return True\n\n    def get_namespace(self, namespace, lowercase=True, trim_namespace=True):\n        \"\"\"Returns a dictionary containing a subset of configuration options\n        that match the specified namespace\/prefix. Example usage::\n\n            app.config['IMAGE_STORE_TYPE'] = 'fs'\n            app.config['IMAGE_STORE_PATH'] = '\/var\/app\/images'\n            app.config['IMAGE_STORE_BASE_URL'] = 'http:\/\/img.website.com'\n            image_store_config = app.config.get_namespace('IMAGE_STORE_')\n\n        The resulting dictionary `image_store_config` would look like::\n\n            {\n                'type': 'fs',\n                'path': '\/var\/app\/images',\n                'base_url': 'http:\/\/img.website.com'\n            }\n\n        This is often useful when configuration options map directly to\n        keyword arguments in functions or class constructors.\n\n        :param namespace: a configuration namespace\n        :param lowercase: a flag indicating if the keys of the resulting\n                          dictionary should be lowercase\n        :param trim_namespace: a flag indicating if the keys of the resulting\n                          dictionary should not include the namespace\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {}\n        for k, v in iteritems(self):\n            if not k.startswith(namespace):\n                continue\n            if trim_namespace:\n                key = k[len(namespace) :]\n            else:\n                key = k\n            if lowercase:\n                key = key.lower()\n            rv[key] = v\n        return rv\n\n    def __repr__(self):\n        return \"<%s %s>\" % (self.__class__.__name__, dict.__repr__(self))\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" import pytest\nfrom flask import g\nfrom flask import session\n\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.debughelpers\n    ~~~~~~~~~~~~~~~~~~\n\n    Various helpers to make the development experience better.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport os\nfrom warnings import warn\n\nfrom ._compat import implements_to_string\nfrom ._compat import text_type\nfrom .app import Flask\nfrom .blueprints import Blueprint\nfrom .globals import _request_ctx_stack\n\n\nclass UnexpectedUnicodeError(AssertionError, UnicodeError):\n    \"\"\"Raised in places where we want some better error reporting for\n    unexpected unicode or binary data.\n    \"\"\"\n\n\n@implements_to_string\nclass DebugFilesKeyError(KeyError, AssertionError):\n    \"\"\"Raised from request.files during debugging.  The idea is that it can\n    provide a better error message than just a generic KeyError\/BadRequest.\n    \"\"\"\n\n    def __init__(self, request, key):\n        form_matches = request.form.getlist(key)\n        buf = [\n            'You tried to access the file \"%s\" in the request.files '\n            \"dictionary but it does not exist.  The mimetype for the request \"\n            'is \"%s\" instead of \"multipart\/form-data\" which means that no '\n            \"file contents were transmitted.  To fix this error you should \"\n            'provide enctype=\"multipart\/form-data\" in your form.'\n            % (key, request.mimetype)\n        ]\n        if form_matches:\n            buf.append(\n                \"\\n\\nThe browser instead transmitted some file names. \"\n                \"This was submitted: %s\" % \", \".join('\"%s\"' % x for x in form_matches)\n            )\n        self.msg = \"\".join(buf)\n\n    def __str__(self):\n        return self.msg\n\n\nclass FormDataRoutingRedirect(AssertionError):\n    \"\"\"This exception is raised by Flask in debug mode if it detects a\n    redirect caused by the routing system when the request method is not\n    GET, HEAD or OPTIONS.  Reasoning: form data will be dropped.\n    \"\"\"\n\n    def __init__(self, request):\n        exc = request.routing_exception\n        buf = [\n            \"A request was sent to this URL (%s) but a redirect was \"\n            'issued automatically by the routing system to \"%s\".'\n            % (request.url, exc.new_url)\n        ]\n\n        # In case just a slash was appended we can be extra helpful\n        if request.base_url + \"\/\" == exc.new_url.split(\"?\")[0]:\n            buf.append(\n                \"  The URL was defined with a trailing slash so \"\n                \"Flask will automatically redirect to the URL \"\n                \"with the trailing slash if it was accessed \"\n                \"without one.\"\n            )\n\n        buf.append(\n            \"  Make sure to directly send your %s-request to this URL \"\n            \"since we can't make browsers or HTTP clients redirect \"\n            \"with form data reliably or without user interaction.\" % request.method\n        )\n        buf.append(\"\\n\\nNote: this exception is only raised in debug mode\")\n        AssertionError.__init__(self, \"\".join(buf).encode(\"utf-8\"))\n\n\ndef attach_enctype_error_multidict(request):\n    \"\"\"Since Flask 0.8 we're monkeypatching the files object in case a\n    request is detected that does not use multipart form data but the files\n    object is accessed.\n    \"\"\"\n    oldcls = request.files.__class__\n\n    class newcls(oldcls):\n        def __getitem__(self, key):\n            try:\n                return oldcls.__getitem__(self, key)\n            except KeyError:\n                if key not in request.form:\n                    raise\n                raise DebugFilesKeyError(request, key)\n\n    newcls.__name__ = oldcls.__name__\n    newcls.__module__ = oldcls.__module__\n    request.files.__class__ = newcls\n\n\ndef _dump_loader_info(loader):\n    yield \"class: %s.%s\" % (type(loader).__module__, type(loader).__name__)\n    for key, value in sorted(loader.__dict__.items()):\n        if key.startswith(\"_\"):\n            continue\n        if isinstance(value, (tuple, list)):\n            if not all(isinstance(x, (str, text_type)) for x in value):\n                continue\n            yield \"%s:\" % key\n            for item in value:\n                yield \"  - %s\" % item\n            continue\n        elif not isinstance(value, (str, text_type, int, float, bool)):\n            continue\n        yield \"%s: %r\" % (key, value)\n\n\ndef explain_template_loading_attempts(app, template, attempts):\n    \"\"\"This should help developers understand what failed\"\"\"\n    info = ['Locating template \"%s\":' % template]\n    total_found = 0\n    blueprint = None\n    reqctx = _request_ctx_stack.top\n    if reqctx is not None and reqctx.request.blueprint is not None:\n        blueprint = reqctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, Flask):\n            src_info = 'application \"%s\"' % srcobj.import_name\n        elif isinstance(srcobj, Blueprint):\n            src_info = 'blueprint \"%s\" (%s)' % (srcobj.name, srcobj.import_name)\n        else:\n            src_info = repr(srcobj)\n\n        info.append(\"% 5d: trying loader of %s\" % (idx + 1, src_info))\n\n        for line in _dump_loader_info(loader):\n            info.append(\"       %s\" % line)\n\n        if triple is None:\n            detail = \"no match\"\n        else:\n            detail = \"found (%r)\" % (triple[1] or \"<string>\")\n            total_found += 1\n        info.append(\"       -> %s\" % detail)\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(\"Error: the template could not be found.\")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(\"Warning: multiple loaders returned a match for the template.\")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            \"  The template was looked up from an endpoint that \"\n            'belongs to the blueprint \"%s\".' % blueprint\n        )\n        info.append(\"  Maybe you did not place a template in the right folder?\")\n        info.append(\"  See http:\/\/flask.pocoo.org\/docs\/blueprints\/#templates\")\n\n    app.logger.info(\"\\n\".join(info))\n\n\ndef explain_ignored_app_run():\n    if os.environ.get(\"WERKZEUG_RUN_MAIN\") != \"true\":\n        warn(\n            Warning(\n                \"Silently ignoring app.run() because the \"\n                \"application is run from the flask command line \"\n                \"executable.  Consider putting app.run() behind an \"\n                'if __name__ == \"__main__\" guard to silence this '\n                \"warning.\"\n            ),\n            stacklevel=3,\n        )\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" import pytest\nfrom flask import g\nfrom flask import session\n\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.globals\n    ~~~~~~~~~~~~~\n\n    Defines all the global objects that are proxies to the current\n    active context.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nfrom functools import partial\n\nfrom werkzeug.local import LocalProxy\nfrom werkzeug.local import LocalStack\n\n\n_request_ctx_err_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request.  Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_app_ctx_err_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nto interface with the current application object in some way. To solve\nthis, set up an application context with app.app_context().  See the\ndocumentation for more information.\\\n\"\"\"\n\n\ndef _lookup_req_object(name):\n    top = _request_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_request_ctx_err_msg)\n    return getattr(top, name)\n\n\ndef _lookup_app_object(name):\n    top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n    return getattr(top, name)\n\n\ndef _find_app():\n    top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n    return top.app\n\n\n# context locals\n_request_ctx_stack = LocalStack()\n_app_ctx_stack = LocalStack()\ncurrent_app = LocalProxy(_find_app)\nrequest = LocalProxy(partial(_lookup_req_object, \"request\"))\nsession = LocalProxy(partial(_lookup_req_object, \"session\"))\ng = LocalProxy(partial(_lookup_app_object, \"g\"))\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" import pytest\nfrom flask import g\nfrom flask import session\n\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nTagged JSON\n~~~~~~~~~~~\n\nA compact representation for lossless serialization of non-standard JSON types.\n:class:`~flask.sessions.SecureCookieSessionInterface` uses this to serialize\nthe session data, but it may be useful in other places. It can be extended to\nsupport other types.\n\n.. autoclass:: TaggedJSONSerializer\n    :members:\n\n.. autoclass:: JSONTag\n    :members:\n\nLet's seen an example that adds support for :class:`~collections.OrderedDict`.\nDicts don't have an order in Python or JSON, so to handle this we will dump\nthe items as a list of ``[key, value]`` pairs. Subclass :class:`JSONTag` and\ngive it the new key ``' od'`` to identify the type. The session serializer\nprocesses dicts first, so insert the new tag at the front of the order since\n``OrderedDict`` must be processed before ``dict``. ::\n\n    from flask.json.tag import JSONTag\n\n    class TagOrderedDict(JSONTag):\n        __slots__ = ('serializer',)\n        key = ' od'\n\n        def check(self, value):\n            return isinstance(value, OrderedDict)\n\n        def to_json(self, value):\n            return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]\n\n        def to_python(self, value):\n            return OrderedDict(value)\n\n    app.session_interface.serializer.register(TagOrderedDict, index=0)\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\nfrom base64 import b64decode\nfrom base64 import b64encode\nfrom datetime import datetime\nfrom uuid import UUID\n\nfrom jinja2 import Markup\nfrom werkzeug.http import http_date\nfrom werkzeug.http import parse_date\n\nfrom .._compat import iteritems\nfrom .._compat import text_type\nfrom ..json import dumps\nfrom ..json import loads\n\n\nclass JSONTag(object):\n    \"\"\"Base class for defining type tags for :class:`TaggedJSONSerializer`.\"\"\"\n\n    __slots__ = (\"serializer\",)\n\n    #: The tag to mark the serialized object with. If ``None``, this tag is\n    #: only used as an intermediate step during tagging.\n    key = None\n\n    def __init__(self, serializer):\n        \"\"\"Create a tagger for the given serializer.\"\"\"\n        self.serializer = serializer\n\n    def check(self, value):\n        \"\"\"Check if the given value should be tagged by this tag.\"\"\"\n        raise NotImplementedError\n\n    def to_json(self, value):\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n\n    def to_python(self, value):\n        \"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"\n        raise NotImplementedError\n\n    def tag(self, value):\n        \"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"\n        return {self.key: self.to_json(value)}\n\n\nclass TagDict(JSONTag):\n    \"\"\"Tag for 1-item dicts whose only key matches a registered tag.\n\n    Internally, the dict key is suffixed with `__`, and the suffix is removed\n    when deserializing.\n    \"\"\"\n\n    __slots__ = ()\n    key = \" di\"\n\n    def check(self, value):\n        return (\n            isinstance(value, dict)\n            and len(value) == 1\n            and next(iter(value)) in self.serializer.tags\n        )\n\n    def to_json(self, value):\n        key = next(iter(value))\n        return {key + \"__\": self.serializer.tag(value[key])}\n\n    def to_python(self, value):\n        key = next(iter(value))\n        return {key[:-2]: value[key]}\n\n\nclass PassDict(JSONTag):\n    __slots__ = ()\n\n    def check(self, value):\n        return isinstance(value, dict)\n\n    def to_json(self, value):\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return dict((k, self.serializer.tag(v)) for k, v in iteritems(value))\n\n    tag = to_json\n\n\nclass TagTuple(JSONTag):\n    __slots__ = ()\n    key = \" t\"\n\n    def check(self, value):\n        return isinstance(value, tuple)\n\n    def to_json(self, value):\n        return [self.serializer.tag(item) for item in value]\n\n    def to_python(self, value):\n        return tuple(value)\n\n\nclass PassList(JSONTag):\n    __slots__ = ()\n\n    def check(self, value):\n        return isinstance(value, list)\n\n    def to_json(self, value):\n        return [self.serializer.tag(item) for item in value]\n\n    tag = to_json\n\n\nclass TagBytes(JSONTag):\n    __slots__ = ()\n    key = \" b\"\n\n    def check(self, value):\n        return isinstance(value, bytes)\n\n    def to_json(self, value):\n        return b64encode(value).decode(\"ascii\")\n\n    def to_python(self, value):\n        return b64decode(value)\n\n\nclass TagMarkup(JSONTag):\n    \"\"\"Serialize anything matching the :class:`~flask.Markup` API by\n    having a ``__html__`` method to the result of that method. Always\n    deserializes to an instance of :class:`~flask.Markup`.\"\"\"\n\n    __slots__ = ()\n    key = \" m\"\n\n    def check(self, value):\n        return callable(getattr(value, \"__html__\", None))\n\n    def to_json(self, value):\n        return text_type(value.__html__())\n\n    def to_python(self, value):\n        return Markup(value)\n\n\nclass TagUUID(JSONTag):\n    __slots__ = ()\n    key = \" u\"\n\n    def check(self, value):\n        return isinstance(value, UUID)\n\n    def to_json(self, value):\n        return value.hex\n\n    def to_python(self, value):\n        return UUID(value)\n\n\nclass TagDateTime(JSONTag):\n    __slots__ = ()\n    key = \" d\"\n\n    def check(self, value):\n        return isinstance(value, datetime)\n\n    def to_json(self, value):\n        return http_date(value)\n\n    def to_python(self, value):\n        return parse_date(value)\n\n\nclass TaggedJSONSerializer(object):\n    \"\"\"Serializer that uses a tag system to compactly represent objects that\n    are not JSON types. Passed as the intermediate serializer to\n    :class:`itsdangerous.Serializer`.\n\n    The following extra types are supported:\n\n    * :class:`dict`\n    * :class:`tuple`\n    * :class:`bytes`\n    * :class:`~flask.Markup`\n    * :class:`~uuid.UUID`\n    * :class:`~datetime.datetime`\n    \"\"\"\n\n    __slots__ = (\"tags\", \"order\")\n\n    #: Tag classes to bind when creating the serializer. Other tags can be\n    #: added later using :meth:`~register`.\n    default_tags = [\n        TagDict,\n        PassDict,\n        TagTuple,\n        PassList,\n        TagBytes,\n        TagMarkup,\n        TagUUID,\n        TagDateTime,\n    ]\n\n    def __init__(self):\n        self.tags = {}\n        self.order = []\n\n        for cls in self.default_tags:\n            self.register(cls)\n\n    def register(self, tag_class, force=False, index=None):\n        \"\"\"Register a new tag with this serializer.\n\n        :param tag_class: tag class to register. Will be instantiated with this\n            serializer instance.\n        :param force: overwrite an existing tag. If false (default), a\n            :exc:`KeyError` is raised.\n        :param index: index to insert the new tag in the tag order. Useful when\n            the new tag is a special case of an existing tag. If ``None``\n            (default), the tag is appended to the end of the order.\n\n        :raise KeyError: if the tag key is already registered and ``force`` is\n            not true.\n        \"\"\"\n        tag = tag_class(self)\n        key = tag.key\n\n        if key is not None:\n            if not force and key in self.tags:\n                raise KeyError(\"Tag '{0}' is already registered.\".format(key))\n\n            self.tags[key] = tag\n\n        if index is None:\n            self.order.append(tag)\n        else:\n            self.order.insert(index, tag)\n\n    def tag(self, value):\n        \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n        for tag in self.order:\n            if tag.check(value):\n                return tag.tag(value)\n\n        return value\n\n    def untag(self, value):\n        \"\"\"Convert a tagged representation back to the original type.\"\"\"\n        if len(value) != 1:\n            return value\n\n        key = next(iter(value))\n\n        if key not in self.tags:\n            return value\n\n        return self.tags[key].to_python(value[key])\n\n    def dumps(self, value):\n        \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n        return dumps(self.tag(value), separators=(\",\", \":\"))\n\n    def loads(self, value):\n        \"\"\"Load data from a JSON string and deserialized any tagged objects.\"\"\"\n        return loads(value, object_hook=self.untag)\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" import pytest\nfrom flask import g\nfrom flask import session\n\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(\"flask.app\")\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" import pytest\nfrom flask import g\nfrom flask import session\n\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.signals\n    ~~~~~~~~~~~~~\n\n    Implements signals based on blinker if available, otherwise\n    falls silently back to a noop.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\ntry:\n    from blinker import Namespace\n\n    signals_available = True\nexcept ImportError:\n    signals_available = False\n\n    class Namespace(object):\n        def signal(self, name, doc=None):\n            return _FakeSignal(name, doc)\n\n    class _FakeSignal(object):\n        \"\"\"If blinker is unavailable, create a fake class with the same\n        interface that allows sending of signals but will fail with an\n        error on anything else.  Instead of doing anything on send, it\n        will just ignore the arguments and do nothing instead.\n        \"\"\"\n\n        def __init__(self, name, doc=None):\n            self.name = name\n            self.__doc__ = doc\n\n        def send(self, *args, **kwargs):\n            pass\n\n        def _fail(self, *args, **kwargs):\n            raise RuntimeError(\n                \"Signalling support is unavailable because the blinker\"\n                \" library is not installed.\"\n            )\n\n        connect = connect_via = connected_to = temporarily_connected_to = _fail\n        disconnect = _fail\n        has_receivers_for = receivers_for = _fail\n        del _fail\n\n\n# The namespace for code signals.  If you are not Flask code, do\n# not put signals in here.  Create your own namespace instead.\n_signals = Namespace()\n\n\n# Core signals.  For usage examples grep the source code or consult\n# the API documentation in docs\/api.rst as well as docs\/signals.rst\ntemplate_rendered = _signals.signal(\"template-rendered\")\nbefore_render_template = _signals.signal(\"before-render-template\")\nrequest_started = _signals.signal(\"request-started\")\nrequest_finished = _signals.signal(\"request-finished\")\nrequest_tearing_down = _signals.signal(\"request-tearing-down\")\ngot_request_exception = _signals.signal(\"got-request-exception\")\nappcontext_tearing_down = _signals.signal(\"appcontext-tearing-down\")\nappcontext_pushed = _signals.signal(\"appcontext-pushed\")\nappcontext_popped = _signals.signal(\"appcontext-popped\")\nmessage_flashed = _signals.signal(\"message-flashed\")\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" import pytest\nfrom flask import g\nfrom flask import session\n\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.templating\n    ~~~~~~~~~~~~~~~~\n\n    Implements the bridge to Jinja2.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nfrom jinja2 import BaseLoader\nfrom jinja2 import Environment as BaseEnvironment\nfrom jinja2 import TemplateNotFound\n\nfrom .globals import _app_ctx_stack\nfrom .globals import _request_ctx_stack\nfrom .signals import before_render_template\nfrom .signals import template_rendered\n\n\ndef _default_template_ctx_processor():\n    \"\"\"Default template context processor.  Injects `request`,\n    `session` and `g`.\n    \"\"\"\n    reqctx = _request_ctx_stack.top\n    appctx = _app_ctx_stack.top\n    rv = {}\n    if appctx is not None:\n        rv[\"g\"] = appctx.g\n    if reqctx is not None:\n        rv[\"request\"] = reqctx.request\n        rv[\"session\"] = reqctx.session\n    return rv\n\n\nclass Environment(BaseEnvironment):\n    \"\"\"Works like a regular Jinja2 environment but has some additional\n    knowledge of how Flask's blueprint works so that it can prepend the\n    name of the blueprint to referenced templates if necessary.\n    \"\"\"\n\n    def __init__(self, app, **options):\n        if \"loader\" not in options:\n            options[\"loader\"] = app.create_global_jinja_loader()\n        BaseEnvironment.__init__(self, **options)\n        self.app = app\n\n\nclass DispatchingJinjaLoader(BaseLoader):\n    \"\"\"A loader that looks for templates in the application and all\n    the blueprint folders.\n    \"\"\"\n\n    def __init__(self, app):\n        self.app = app\n\n    def get_source(self, environment, template):\n        if self.app.config[\"EXPLAIN_TEMPLATE_LOADING\"]:\n            return self._get_source_explained(environment, template)\n        return self._get_source_fast(environment, template)\n\n    def _get_source_explained(self, environment, template):\n        attempts = []\n        trv = None\n\n        for srcobj, loader in self._iter_loaders(template):\n            try:\n                rv = loader.get_source(environment, template)\n                if trv is None:\n                    trv = rv\n            except TemplateNotFound:\n                rv = None\n            attempts.append((loader, srcobj, rv))\n\n        from .debughelpers import explain_template_loading_attempts\n\n        explain_template_loading_attempts(self.app, template, attempts)\n\n        if trv is not None:\n            return trv\n        raise TemplateNotFound(template)\n\n    def _get_source_fast(self, environment, template):\n        for _srcobj, loader in self._iter_loaders(template):\n            try:\n                return loader.get_source(environment, template)\n            except TemplateNotFound:\n                continue\n        raise TemplateNotFound(template)\n\n    def _iter_loaders(self, template):\n        loader = self.app.jinja_loader\n        if loader is not None:\n            yield self.app, loader\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                yield blueprint, loader\n\n    def list_templates(self):\n        result = set()\n        loader = self.app.jinja_loader\n        if loader is not None:\n            result.update(loader.list_templates())\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                for template in loader.list_templates():\n                    result.add(template)\n\n        return list(result)\n\n\ndef _render(template, context, app):\n    \"\"\"Renders the template and fires the signal\"\"\"\n\n    before_render_template.send(app, template=template, context=context)\n    rv = template.render(context)\n    template_rendered.send(app, template=template, context=context)\n    return rv\n\n\ndef render_template(template_name_or_list, **context):\n    \"\"\"Renders a template from the template folder with the given\n    context.\n\n    :param template_name_or_list: the name of the template to be\n                                  rendered, or an iterable with template names\n                                  the first one existing will be rendered\n    :param context: the variables that should be available in the\n                    context of the template.\n    \"\"\"\n    ctx = _app_ctx_stack.top\n    ctx.app.update_template_context(context)\n    return _render(\n        ctx.app.jinja_env.get_or_select_template(template_name_or_list),\n        context,\n        ctx.app,\n    )\n\n\ndef render_template_string(source, **context):\n    \"\"\"Renders a template from the given template source string\n    with the given context. Template variables will be autoescaped.\n\n    :param source: the source code of the template to be\n                   rendered\n    :param context: the variables that should be available in the\n                    context of the template.\n    \"\"\"\n    ctx = _app_ctx_stack.top\n    ctx.app.update_template_context(context)\n    return _render(ctx.app.jinja_env.from_string(source), context, ctx.app)\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" import pytest\nfrom flask import g\nfrom flask import session\n\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.sessions\n    ~~~~~~~~~~~~~~\n\n    Implements cookie based sessions based on itsdangerous.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport hashlib\nimport warnings\nfrom datetime import datetime\n\nfrom itsdangerous import BadSignature\nfrom itsdangerous import URLSafeTimedSerializer\nfrom werkzeug.datastructures import CallbackDict\n\nfrom ._compat import collections_abc\nfrom .helpers import is_ip\nfrom .helpers import total_seconds\nfrom .json.tag import TaggedJSONSerializer\n\n\nclass SessionMixin(collections_abc.MutableMapping):\n    \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n\n    @property\n    def permanent(self):\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)\n\n    @permanent.setter\n    def permanent(self, value):\n        self[\"_permanent\"] = bool(value)\n\n    #: Some implementations can detect whether a session is newly\n    #: created, but that is not guaranteed. Use with caution. The mixin\n    # default is hard-coded ``False``.\n    new = False\n\n    #: Some implementations can detect changes to the session and set\n    #: this when that happens. The mixin default is hard coded to\n    #: ``True``.\n    modified = True\n\n    #: Some implementations can detect when session data is read or\n    #: written and set this when that happens. The mixin default is hard\n    #: coded to ``True``.\n    accessed = True\n\n\nclass SecureCookieSession(CallbackDict, SessionMixin):\n    \"\"\"Base class for sessions based on signed cookies.\n\n    This session backend will set the :attr:`modified` and\n    :attr:`accessed` attributes. It cannot reliably track whether a\n    session is new (vs. empty), so :attr:`new` remains hard coded to\n    ``False``.\n    \"\"\"\n\n    #: When data is changed, this is set to ``True``. Only the session\n    #: dictionary itself is tracked; if the session contains mutable\n    #: data (for example a nested dict) then this must be set to\n    #: ``True`` manually when modifying that data. The session cookie\n    #: will only be written to the response if this is ``True``.\n    modified = False\n\n    #: When data is read or written, this is set to ``True``. Used by\n    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``\n    #: header, which allows caching proxies to cache different pages for\n    #: different users.\n    accessed = False\n\n    def __init__(self, initial=None):\n        def on_update(self):\n            self.modified = True\n            self.accessed = True\n\n        super(SecureCookieSession, self).__init__(initial, on_update)\n\n    def __getitem__(self, key):\n        self.accessed = True\n        return super(SecureCookieSession, self).__getitem__(key)\n\n    def get(self, key, default=None):\n        self.accessed = True\n        return super(SecureCookieSession, self).get(key, default)\n\n    def setdefault(self, key, default=None):\n        self.accessed = True\n        return super(SecureCookieSession, self).setdefault(key, default)\n\n\nclass NullSession(SecureCookieSession):\n    \"\"\"Class used to generate nicer error messages if sessions are not\n    available.  Will still allow read-only access to the empty session\n    but fail on setting.\n    \"\"\"\n\n    def _fail(self, *args, **kwargs):\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n\n    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail\n    del _fail\n\n\nclass SessionInterface(object):\n    \"\"\"The basic interface you have to implement in order to replace the\n    default session interface which uses werkzeug's securecookie\n    implementation.  The only methods you have to implement are\n    :meth:`open_session` and :meth:`save_session`, the others have\n    useful defaults which you don't need to change.\n\n    The session object returned by the :meth:`open_session` method has to\n    provide a dictionary like interface plus the properties and methods\n    from the :class:`SessionMixin`.  We recommend just subclassing a dict\n    and adding that mixin::\n\n        class Session(dict, SessionMixin):\n            pass\n\n    If :meth:`open_session` returns ``None`` Flask will call into\n    :meth:`make_null_session` to create a session that acts as replacement\n    if the session support cannot work because some requirement is not\n    fulfilled.  The default :class:`NullSession` class that is created\n    will complain that the secret key was not set.\n\n    To replace the session interface on an application all you have to do\n    is to assign :attr:`flask.Flask.session_interface`::\n\n        app = Flask(__name__)\n        app.session_interface = MySessionInterface()\n\n    .. versionadded:: 0.8\n    \"\"\"\n\n    #: :meth:`make_null_session` will look here for the class that should\n    #: be created when a null session is requested.  Likewise the\n    #: :meth:`is_null_session` method will perform a typecheck against\n    #: this type.\n    null_session_class = NullSession\n\n    #: A flag that indicates if the session interface is pickle based.\n    #: This can be used by Flask extensions to make a decision in regards\n    #: to how to deal with the session object.\n    #:\n    #: .. versionadded:: 0.10\n    pickle_based = False\n\n    def make_null_session(self, app):\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n\n    def is_null_session(self, obj):\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n\n    def get_cookie_domain(self, app):\n        \"\"\"Returns the domain that should be set for the session cookie.\n\n        Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise\n        falls back to detecting the domain based on ``SERVER_NAME``.\n\n        Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is\n        updated to avoid re-running the logic.\n        \"\"\"\n\n        rv = app.config[\"SESSION_COOKIE_DOMAIN\"]\n\n        # set explicitly, or cached from SERVER_NAME detection\n        # if False, return None\n        if rv is not None:\n            return rv if rv else None\n\n        rv = app.config[\"SERVER_NAME\"]\n\n        # server name not set, cache False to return none next time\n        if not rv:\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        # chop off the port which is usually not supported by browsers\n        # remove any leading '.' since we'll add that later\n        rv = rv.rsplit(\":\", 1)[0].lstrip(\".\")\n\n        if \".\" not in rv:\n            # Chrome doesn't allow names without a '.'\n            # this should only come up with localhost\n            # hack around this by not setting the name, and show a warning\n            warnings.warn(\n                '\"{rv}\" is not a valid cookie domain, it must contain a \".\".'\n                \" Add an entry to your hosts file, for example\"\n                ' \"{rv}.localdomain\", and use that instead.'.format(rv=rv)\n            )\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        ip = is_ip(rv)\n\n        if ip:\n            warnings.warn(\n                \"The session cookie domain is an IP address. This may not work\"\n                \" as intended in some browsers. Add an entry to your hosts\"\n                ' file, for example \"localhost.localdomain\", and use that'\n                \" instead.\"\n            )\n\n        # if this is not an ip and app is mounted at the root, allow subdomain\n        # matching by adding a '.' prefix\n        if self.get_cookie_path(app) == \"\/\" and not ip:\n            rv = \".\" + rv\n\n        app.config[\"SESSION_COOKIE_DOMAIN\"] = rv\n        return rv\n\n    def get_cookie_path(self, app):\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``\/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]\n\n    def get_cookie_httponly(self, app):\n        \"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_HTTPONLY\"]\n\n    def get_cookie_secure(self, app):\n        \"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SECURE\"]\n\n    def get_cookie_samesite(self, app):\n        \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SAMESITE\"]\n\n    def get_expiration_time(self, app, session):\n        \"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"\n        if session.permanent:\n            return datetime.utcnow() + app.permanent_session_lifetime\n\n    def should_set_cookie(self, app, session):\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n\n    def open_session(self, app, request):\n        \"\"\"This method has to be implemented and must either return ``None``\n        in case the loading failed because of a configuration error or an\n        instance of a session object which implements a dictionary like\n        interface + the methods and attributes on :class:`SessionMixin`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def save_session(self, app, session, response):\n        \"\"\"This is called for actual sessions returned by :meth:`open_session`\n        at the end of the request.  This is still called during a request\n        context so if you absolutely need access to the request you can do\n        that.\n        \"\"\"\n        raise NotImplementedError()\n\n\nsession_json_serializer = TaggedJSONSerializer()\n\n\nclass SecureCookieSessionInterface(SessionInterface):\n    \"\"\"The default session interface that stores sessions in signed cookies\n    through the :mod:`itsdangerous` module.\n    \"\"\"\n\n    #: the salt that should be applied on top of the secret key for the\n    #: signing of cookie based sessions.\n    salt = \"cookie-session\"\n    #: the hash function to use for the signature.  The default is sha1\n    digest_method = staticmethod(hashlib.sha1)\n    #: the name of the itsdangerous supported key derivation.  The default\n    #: is hmac.\n    key_derivation = \"hmac\"\n    #: A python serializer for the payload.  The default is a compact\n    #: JSON derived serializer with support for some extra Python types\n    #: such as datetime objects or tuples.\n    serializer = session_json_serializer\n    session_class = SecureCookieSession\n\n    def get_signing_serializer(self, app):\n        if not app.secret_key:\n            return None\n        signer_kwargs = dict(\n            key_derivation=self.key_derivation, digest_method=self.digest_method\n        )\n        return URLSafeTimedSerializer(\n            app.secret_key,\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs=signer_kwargs,\n        )\n\n    def open_session(self, app, request):\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(app.session_cookie_name)\n        if not val:\n            return self.session_class()\n        max_age = total_seconds(app.permanent_session_lifetime)\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(\n                    app.session_cookie_name, domain=domain, path=path\n                )\n\n            return\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        httponly = self.get_cookie_httponly(app)\n        secure = self.get_cookie_secure(app)\n        samesite = self.get_cookie_samesite(app)\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))\n        response.set_cookie(\n            app.session_cookie_name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            samesite=samesite,\n        )\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" import pytest\nfrom flask import g\nfrom flask import session\n\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"\/auth\/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert \"http:\/\/localhost\/auth\/login\" == response.headers[\"Location\"]\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"select * from user where username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"\/auth\/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"\/auth\/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"http:\/\/localhost\/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"\/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n"}
{"prompt":"Python3\n#!\/usr\/bin\/env python\nfrom __future__ import print_function\n\nimport os\nimport re\nimport sys\nfrom datetime import date\nfrom datetime import datetime\nfrom subprocess import PIPE\nfrom subprocess import Popen\n\n_date_strip_re = re.compile(r\"(?<=\\d)(st|nd|rd|th)\")\n\n\ndef parse_changelog():\n    with open(\"CHANGES.rst\") as f:\n        lineiter = iter(f)\n        for line in lineiter:\n            match = re.search(r\"^Version\\s+(.*)\", line.strip())\n\n            if match is None:\n                continue\n\n            version = match.group(1).strip()\n\n            if next(lineiter).count(\"-\") != len(match.group(0)):\n                continue\n\n            while 1:\n                change_info = next(lineiter).strip()\n\n                if change_info:\n                    break\n\n            match = re.search(\n                r\"released on (\\w+\\s+\\d+\\w+\\s+\\d+)(?:, codename (.*))?\",\n                change_info,\n                flags=re.IGNORECASE,\n            )\n\n            if match is None:\n                continue\n\n            datestr, codename = match.groups()\n            return version, parse_date(datestr), codename\n\n\ndef bump_version(version):\n    try:\n        parts = [int(i) for i in version.split(\".\")]\n    except ValueError:\n        fail(\"Current version is not numeric\")\n\n    parts[-1] += 1\n    return \".\".join(map(str, parts))\n\n\ndef parse_date(string):\n    string = _date_strip_re.sub(\"\", string)\n    return datetime.strptime(string, \"%B %d %Y\")\n\n\ndef set_filename_version(filename, version_number, pattern):\n    changed = []\n\n    def inject_version(match):\n        before, old, after = match.groups()\n        changed.append(True)\n        return before + version_number + after\n\n    with open(filename) as f:\n        contents = re.sub(\n            r\"^(\\s*%s\\s*=\\s*')(.+?)(')\" % pattern,\n            inject_version,\n            f.read(),\n            flags=re.DOTALL | re.MULTILINE,\n        )\n\n    if not changed:\n        fail(\"Could not find %s in %s\", pattern, filename)\n\n    with open(filename, \"w\") as f:\n        f.write(contents)\n\n\ndef set_init_version(version):\n    info(\"Setting __init__.py version to %s\", version)\n    set_filename_version(\"flask\/__init__.py\", version, \"__version__\")\n\n\ndef build():\n    cmd = [sys.executable, \"setup.py\", \"sdist\", \"bdist_wheel\"]\n    Popen(cmd).wait()\n\n\ndef fail(message, *args):\n    print(\"Error:\", message % args, file=sys.stderr)\n    sys.exit(1)\n\n\ndef info(message, *args):\n    print(message % args, file=sys.stderr)\n\n\ndef get_git_tags():\n    return set(Popen([\"git\", \"tag\"], stdout=PIPE).communicate()[0].splitlines())\n\n\ndef git_is_clean():\n    return Popen([\"git\", \"diff\", \"--quiet\"]).wait() == 0\n\n\ndef make_git_commit(message, *args):\n    message = message % args\n    Popen([\"git\", \"commit\", \"-am\", message]).wait()\n\n\ndef make_git_tag(tag):\n    info('Tagging \"%s\"', tag)\n    Popen([\"git\", \"tag\", tag]).wait()\n\n\ndef main():\n    os.chdir(os.path.join(os.path.dirname(__file__), \"..\"))\n\n    rv = parse_changelog()\n\n    if rv is None:\n        fail(\"Could not parse changelog\")\n\n    version, release_date, codename = rv\n    dev_version = bump_version(version) + \".dev\"\n\n    info(\n        \"Releasing %s (codename %s, release date %s)\",\n        version,\n        codename,\n        release_date.strftime(\"%d\/%m\/%Y\"),\n    )\n    tags = get_git_tags()\n\n    if version in tags:\n        fail('Version \"%s\" is already tagged', version)\n\n    if release_date.date() != date.today():\n        fail(\"Release date is not today (%s != %s)\", release_date.date(), date.today())\n\n    if not git_is_clean():\n        fail(\"You have uncommitted changes in git\")\n\n    try:\n        import wheel  # noqa: F401\n    except ImportError:\n        fail(\"You need to install the wheel package.\")\n\n    set_init_version(version)\n    make_git_commit(\"Bump version number to %s\", version)\n    make_git_tag(version)\n    build()\n    set_init_version(dev_version)\n\n\nif __name__ == \"__main__\":\n    main()\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.basic\n    ~~~~~~~~~~~~~~~~~~~~~\n\n    The basic functionality.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport re\nimport sys\nimport time\nimport uuid\nfrom datetime import datetime\nfrom threading import Thread\n\nimport pytest\nimport werkzeug.serving\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import Forbidden\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\n\nimport flask\nfrom flask._compat import text_type\n\n\ndef test_options_work(app, client):\n    @app.route(\"\/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"\/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"\n\n\ndef test_options_on_multiple_rules(app, client):\n    @app.route(\"\/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"\/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"\/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]\n\n\ndef test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"\/\")(index)\n    rv = app.test_client().open(\"\/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return \"Hello World!\"\n\n    index2.provide_automatic_options = True\n    app.route(\"\/\", methods=[\"OPTIONS\"])(index2)\n    rv = app.test_client().open(\"\/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n\n\ndef test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"\/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"\/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"\/\").data == b\"GET\"\n\n    rv = client.post(\"\/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    # Older versions of Werkzeug.test.Client don't have an options method\n    if hasattr(client, \"options\"):\n        rv = client.options(\"\/\")\n    else:\n        rv = client.open(\"\/\", method=\"OPTIONS\")\n\n    assert rv.status_code == 405\n\n    rv = client.head(\"\/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"\/more\").data == b\"POST\"\n    assert client.get(\"\/more\").data == b\"GET\"\n\n    rv = client.delete(\"\/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    if hasattr(client, \"options\"):\n        rv = client.options(\"\/more\")\n    else:\n        rv = client.open(\"\/more\", method=\"OPTIONS\")\n\n    assert rv.status_code == 405\n\n\ndef test_request_dispatching(app, client):\n    @app.route(\"\/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"\/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"\/\").data == b\"GET\"\n    rv = client.post(\"\/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"\/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"\/more\").data == b\"POST\"\n    assert client.get(\"\/more\").data == b\"GET\"\n    rv = client.delete(\"\/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n\n\ndef test_disallow_string_for_allowed_methods(app):\n    with pytest.raises(TypeError):\n\n        @app.route(\"\/\", methods=\"GET POST\")\n        def index():\n            return \"Hey\"\n\n\ndef test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"\/\", \"index\", index)\n    app.add_url_rule(\"\/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"\/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"\/\").data == b\"GET\"\n    rv = client.post(\"\/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"\/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"\/more\").data == b\"POST\"\n    assert client.get(\"\/more\").data == b\"GET\"\n    rv = client.delete(\"\/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"\/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")\n\n\ndef test_werkzeug_routing(app, client):\n    from werkzeug.routing import Submount, Rule\n\n    app.url_map.add(\n        Submount(\"\/foo\", [Rule(\"\/bar\", endpoint=\"bar\"), Rule(\"\/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"\/foo\/\").data == b\"index\"\n    assert client.get(\"\/foo\/bar\").data == b\"bar\"\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Submount, Rule\n\n    app.url_map.add(\n        Submount(\"\/foo\", [Rule(\"\/bar\", endpoint=\"bar\"), Rule(\"\/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"\/foo\/\").data == b\"index\"\n    assert client.get(\"\/foo\/bar\").data == b\"bar\"\n\n\ndef test_session(app, client):\n    @app.route(\"\/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"\/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"\/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"\/get\").data == b\"42\"\n\n\ndef test_session_using_server_name(app, client):\n    app.config.update(SERVER_NAME=\"example.com\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com\/\")\n    assert \"domain=.example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_server_name_and_port(app, client):\n    app.config.update(SERVER_NAME=\"example.com:8080\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com:8080\/\")\n    assert \"domain=.example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_server_name_port_and_path(app, client):\n    app.config.update(SERVER_NAME=\"example.com:8080\", APPLICATION_ROOT=\"\/foo\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com:8080\/foo\")\n    assert \"domain=example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"path=\/foo\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_application_root(app, client):\n    class PrefixPathMiddleware(object):\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"\/bar\")\n    app.config.update(APPLICATION_ROOT=\"\/bar\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/example.com:8080\/\")\n    assert \"path=\/bar\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_session_settings(app, client):\n    app.config.update(\n        SERVER_NAME=\"www.example.com:8080\",\n        APPLICATION_ROOT=\"\/test\",\n        SESSION_COOKIE_DOMAIN=\".example.com\",\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_SAMESITE=\"Lax\",\n        SESSION_COOKIE_PATH=\"\/\",\n    )\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"\/\", \"http:\/\/www.example.com:8080\/test\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"domain=.example.com\" in cookie\n    assert \"path=\/\" in cookie\n    assert \"secure\" in cookie\n    assert \"httponly\" not in cookie\n    assert \"samesite\" in cookie\n\n\ndef test_session_using_samesite_attribute(app, client):\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"\/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"\/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie\n\n\ndef test_session_localhost_warning(recwarn, app, client):\n    app.config.update(SERVER_NAME=\"localhost:5000\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"testing\"\n\n    rv = client.get(\"\/\", \"http:\/\/localhost:5000\/\")\n    assert \"domain\" not in rv.headers[\"set-cookie\"].lower()\n    w = recwarn.pop(UserWarning)\n    assert '\"localhost\" is not a valid cookie domain' in str(w.message)\n\n\ndef test_session_ip_warning(recwarn, app, client):\n    app.config.update(SERVER_NAME=\"127.0.0.1:5000\")\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"testing\"\n\n    rv = client.get(\"\/\", \"http:\/\/127.0.0.1:5000\/\")\n    assert \"domain=127.0.0.1\" in rv.headers[\"set-cookie\"].lower()\n    w = recwarn.pop(UserWarning)\n    assert \"cookie domain is an IP\" in str(w.message)\n\n\ndef test_missing_session(app):\n    app.secret_key = None\n\n    def expect_exception(f, *args, **kwargs):\n        e = pytest.raises(RuntimeError, f, *args, **kwargs)\n        assert e.value.args and \"session is unavailable\" in e.value.args[0]\n\n    with app.test_request_context():\n        assert flask.session.get(\"missing_key\") is None\n        expect_exception(flask.session.__setitem__, \"foo\", 42)\n        expect_exception(flask.session.pop, \"foo\")\n\n\ndef test_session_expiration(app, client):\n    permanent = True\n\n    @app.route(\"\/\")\n    def index():\n        flask.session[\"test\"] = 42\n        flask.session.permanent = permanent\n        return \"\"\n\n    @app.route(\"\/test\")\n    def test():\n        return text_type(flask.session.permanent)\n\n    rv = client.get(\"\/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    expires = parse_date(match.group())\n    expected = datetime.utcnow() + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"\/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"\/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None\n\n\ndef test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"\/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"\/\").data == b\"None\"\n    assert client.get(\"\/\").data == b\"42\"\n\n\ndef test_session_special_types(app, client):\n    now = datetime.utcnow().replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.route(\"\/\")\n    def dump_session_contents():\n        flask.session[\"t\"] = (1, 2, 3)\n        flask.session[\"b\"] = b\"\\xff\"\n        flask.session[\"m\"] = flask.Markup(\"<html>\")\n        flask.session[\"u\"] = the_uuid\n        flask.session[\"d\"] = now\n        flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n        flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n        flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n        return \"\", 204\n\n    with client:\n        client.get(\"\/\")\n        s = flask.session\n        assert s[\"t\"] == (1, 2, 3)\n        assert type(s[\"b\"]) == bytes\n        assert s[\"b\"] == b\"\\xff\"\n        assert type(s[\"m\"]) == flask.Markup\n        assert s[\"m\"] == flask.Markup(\"<html>\")\n        assert s[\"u\"] == the_uuid\n        assert s[\"d\"] == now\n        assert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\n        assert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\n        assert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}\n\n\ndef test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"\/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"\/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"\/bump\").data == b\"1\"\n            assert c.get(\"\/bump\").data == b\"2\"\n            assert c.get(\"\/bump\").data == b\"3\"\n\n            rv = c.get(\"\/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n\ndef test_session_vary_cookie(app, client):\n    @app.route(\"\/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"\/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"\/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"\/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"\/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"\/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"\/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"\/set\")\n    expect(\"\/get\")\n    expect(\"\/getitem\")\n    expect(\"\/setdefault\")\n    expect(\"\/vary-cookie-header-set\")\n    expect(\"\/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"\/no-vary-header\", None)\n\n\ndef test_flashes(app, req_ctx):\n    assert not flask.session.modified\n    flask.flash(\"Zap\")\n    flask.session.modified = False\n    flask.flash(\"Zip\")\n    assert flask.session.modified\n    assert list(flask.get_flashed_messages()) == [\"Zap\", \"Zip\"]\n\n\ndef test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"\/\")\n    def index():\n        flask.flash(u\"Hello World\")\n        flask.flash(u\"Hello World\", \"error\")\n        flask.flash(flask.Markup(u\"<em>Testing<\/em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"\/test\/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            u\"Hello World\",\n            u\"Hello World\",\n            flask.Markup(u\"<em>Testing<\/em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"\/test_with_categories\/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", u\"Hello World\"),\n            (\"error\", u\"Hello World\"),\n            (\"warning\", flask.Markup(u\"<em>Testing<\/em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"\/test_filter\/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", u\"Hello World\")]\n        return \"\"\n\n    @app.route(\"\/test_filters\/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", u\"Hello World\"),\n            (\"warning\", flask.Markup(u\"<em>Testing<\/em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"\/test_filters_without_returning_categories\/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == u\"Hello World\"\n        assert messages[1] == flask.Markup(u\"<em>Testing<\/em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_with_categories\/\")\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_filter\/\")\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_filters\/\")\n\n    client = app.test_client()\n    client.get(\"\/\")\n    client.get(\"\/test_filters_without_returning_categories\/\")\n\n\ndef test_request_processing(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append(\"before\")\n\n    @app.after_request\n    def after_request(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @app.route(\"\/\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"\/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"\n\n\ndef test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"\/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"\/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]\n\n\ndef test_after_request_processing(app, client):\n    @app.route(\"\/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"\/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"\n\n\ndef test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"\/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"\/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.route(\"\/\")\n    def fails():\n        1 \/\/ 0\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert len(called) == 2\n\n\ndef test_before_after_request_order(app, client):\n    called = []\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"\/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]\n\n\ndef test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"\/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"\/error\")\n    def error():\n        1 \/\/ 0\n\n    @app.route(\"\/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"\/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"\/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data\n\n\ndef test_error_handler_unknown_code(app):\n    with pytest.raises(KeyError) as exc_info:\n        app.register_error_handler(999, lambda e: (\"999\", 999))\n\n    assert \"Use a subclass\" in exc_info.value.args[0]\n\n\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"\/\")\n    def broken_func():\n        1 \/\/ 0\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text\/x-special\"\n        return resp\n\n    resp = client.get(\"\/\")\n    assert resp.mimetype == \"text\/x-special\"\n    assert resp.data == b\"internal server error\"\n\n\ndef test_baseexception_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"\/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"\/\")\n\n        ctx = flask._request_ctx_stack.top\n        assert ctx.preserved\n        assert type(ctx._preserved_exc) is KeyboardInterrupt\n\n\ndef test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"\/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"\n\n\ndef test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"\/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"\/\").data == b\"42\"\n\n\ndef test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"\/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"\/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"\/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"\/1\").data == b\"banana\"\n    assert client.get(\"\/2\").data == b\"apple\"\n    assert client.get(\"\/3\").data == b\"apple\"\n\n\ndef test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"\/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"\/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"\/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"\/E3\")\n    assert rv.data == b\"E2\"\n\n\ndef test_trapping_of_bad_request_key_errors(app, client):\n    @app.route(\"\/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"\/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    rv = client.get(\"\/key\")\n    assert rv.status_code == 400\n    assert b\"missing_key\" not in rv.data\n    rv = client.get(\"\/abort\")\n    assert rv.status_code == 400\n\n    app.debug = True\n    with pytest.raises(KeyError) as e:\n        client.get(\"\/key\")\n    assert e.errisinstance(BadRequest)\n    assert \"missing_key\" in e.value.get_description()\n    rv = client.get(\"\/abort\")\n    assert rv.status_code == 400\n\n    app.debug = False\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = True\n    with pytest.raises(KeyError):\n        client.get(\"\/key\")\n    with pytest.raises(BadRequest):\n        client.get(\"\/abort\")\n\n\ndef test_trapping_of_all_http_exceptions(app, client):\n    app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"\/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"\/fail\")\n\n\ndef test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if _trigger == \"before\":\n            1 \/\/ 0\n\n    @app.after_request\n    def after_request(response):\n        if _trigger == \"after\":\n            1 \/\/ 0\n        return response\n\n    @app.route(\"\/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for _trigger in \"before\", \"after\":\n        rv = client.get(\"\/\")\n        assert rv.status_code == 500\n        assert rv.data == b\"Hello Server Error\"\n\n\ndef test_enctype_debug_helper(app, client):\n    from flask.debughelpers import DebugFilesKeyError\n\n    app.debug = True\n\n    @app.route(\"\/fail\", methods=[\"POST\"])\n    def index():\n        return flask.request.files[\"foo\"].filename\n\n    # with statement is important because we leave an exception on the\n    # stack otherwise and we want to ensure that this is not the case\n    # to not negatively affect other tests.\n    with client:\n        with pytest.raises(DebugFilesKeyError) as e:\n            client.post(\"\/fail\", data={\"foo\": \"index.txt\"})\n        assert \"no file contents were transmitted\" in str(e.value)\n        assert 'This was submitted: \"index.txt\"' in str(e.value)\n\n\ndef test_response_types(app, client):\n    @app.route(\"\/text\")\n    def from_text():\n        return u\"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"\/bytes\")\n    def from_bytes():\n        return u\"H\u00e4llo W\u00f6rld\".encode(\"utf-8\")\n\n    @app.route(\"\/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text\/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"\/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text\/plain; charset=utf-8\"}\n\n    @app.route(\"\/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"\/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\"Hello world\", 404, {\"X-Foo\": \"Baz\"}),\n            {\"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"\/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"\/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"\/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    assert client.get(\"\/text\").data == u\"H\u00e4llo W\u00f6rld\".encode(\"utf-8\")\n    assert client.get(\"\/bytes\").data == u\"H\u00e4llo W\u00f6rld\".encode(\"utf-8\")\n\n    rv = client.get(\"\/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text\/plain\"\n\n    rv = client.get(\"\/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text\/plain\"\n\n    rv = client.get(\"\/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text\/html\"\n\n    rv = client.get(\"\/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Baz\", \"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"\/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"\/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"\/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n\ndef test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"\/none\")\n    def from_none():\n        pass\n\n    @app.route(\"\/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"\/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"\/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"\/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"\/none\")\n\n    assert \"returned None\" in str(e)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"\/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e)\n\n    pytest.raises(TypeError, c.get, \"\/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"\/bad_type\")\n\n    assert \"object is not callable\" not in str(e)\n    assert \"it was a bool\" in str(e)\n\n    pytest.raises(TypeError, c.get, \"\/bad_wsgi\")\n\n\ndef test_make_response(app, req_ctx):\n    rv = flask.make_response()\n    assert rv.status_code == 200\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text\/html\"\n\n    rv = flask.make_response(\"Awesome\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Awesome\"\n    assert rv.mimetype == \"text\/html\"\n\n    rv = flask.make_response(\"W00t\", 404)\n    assert rv.status_code == 404\n    assert rv.data == b\"W00t\"\n    assert rv.mimetype == \"text\/html\"\n\n\ndef test_make_response_with_response_instance(app, req_ctx):\n    rv = flask.make_response(flask.jsonify({\"msg\": \"W00t\"}), 400)\n    assert rv.status_code == 400\n    assert rv.data == b'{\"msg\":\"W00t\"}\\n'\n    assert rv.mimetype == \"application\/json\"\n\n    rv = flask.make_response(flask.Response(\"\"), 400)\n    assert rv.status_code == 400\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text\/html\"\n\n    rv = flask.make_response(\n        flask.Response(\"\", headers={\"Content-Type\": \"text\/html\"}),\n        400,\n        [(\"X-Foo\", \"bar\")],\n    )\n    assert rv.status_code == 400\n    assert rv.headers[\"Content-Type\"] == \"text\/html\"\n    assert rv.headers[\"X-Foo\"] == \"bar\"\n\n\ndef test_jsonify_no_prettyprint(app, req_ctx):\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": False})\n    compressed_msg = b'{\"msg\":{\"submsg\":\"W00t\"},\"msg2\":\"foobar\"}\\n'\n    uncompressed_msg = {\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"}\n\n    rv = flask.make_response(flask.jsonify(uncompressed_msg), 200)\n    assert rv.data == compressed_msg\n\n\ndef test_jsonify_prettyprint(app, req_ctx):\n    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": True})\n    compressed_msg = {\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"}\n    pretty_response = (\n        b'{\\n  \"msg\": {\\n    \"submsg\": \"W00t\"\\n  }, \\n  \"msg2\": \"foobar\"\\n}\\n'\n    )\n\n    rv = flask.make_response(flask.jsonify(compressed_msg), 200)\n    assert rv.data == pretty_response\n\n\ndef test_jsonify_mimetype(app, req_ctx):\n    app.config.update({\"JSONIFY_MIMETYPE\": \"application\/vnd.api+json\"})\n    msg = {\"msg\": {\"submsg\": \"W00t\"}}\n    rv = flask.make_response(flask.jsonify(msg), 200)\n    assert rv.mimetype == \"application\/vnd.api+json\"\n\n\n@pytest.mark.skipif(sys.version_info < (3, 7), reason=\"requires Python >= 3.7\")\ndef test_json_dump_dataclass(app, req_ctx):\n    from dataclasses import make_dataclass\n\n    Data = make_dataclass(\"Data\", [(\"name\", str)])\n    value = flask.json.dumps(Data(\"Flask\"), app=app)\n    value = flask.json.loads(value, app=app)\n    assert value == {\"name\": \"Flask\"}\n\n\ndef test_jsonify_args_and_kwargs_check(app, req_ctx):\n    with pytest.raises(TypeError) as e:\n        flask.jsonify(\"fake args\", kwargs=\"fake\")\n    assert \"behavior undefined\" in str(e.value)\n\n\ndef test_url_generation(app, req_ctx):\n    @app.route(\"\/hello\/<name>\", methods=[\"POST\"])\n    def hello():\n        pass\n\n    assert flask.url_for(\"hello\", name=\"test x\") == \"\/hello\/test%20x\"\n    assert (\n        flask.url_for(\"hello\", name=\"test x\", _external=True)\n        == \"http:\/\/localhost\/hello\/test%20x\"\n    )\n\n\ndef test_build_error_handler(app):\n    # Test base case, a URL which results in a BuildError.\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"spam\")\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for(\"spam\")\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError(\"Test case where BuildError is not current.\")\n    except RuntimeError:\n        pytest.raises(BuildError, app.handle_url_build_error, error, \"spam\", {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return \"\/test_handler\/\"\n\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for(\"spam\") == \"\/test_handler\/\"\n\n\ndef test_build_error_handler_reraise(app):\n    # Test a custom handler which reraises the BuildError\n    def handler_raises_build_error(error, endpoint, values):\n        raise error\n\n    app.url_build_error_handlers.append(handler_raises_build_error)\n\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"not.existing\")\n\n\ndef test_url_for_passes_special_values_to_build_error_handler(app):\n    @app.url_build_error_handlers.append\n    def handler(error, endpoint, values):\n        assert values == {\n            \"_external\": False,\n            \"_anchor\": None,\n            \"_method\": None,\n            \"_scheme\": None,\n        }\n        return \"handled\"\n\n    with app.test_request_context():\n        flask.url_for(\"\/\")\n\n\ndef test_custom_converters(app, client):\n    from werkzeug.routing import BaseConverter\n\n    class ListConverter(BaseConverter):\n        def to_python(self, value):\n            return value.split(\",\")\n\n        def to_url(self, value):\n            base_to_url = super(ListConverter, self).to_url\n            return \",\".join(base_to_url(x) for x in value)\n\n    app.url_map.converters[\"list\"] = ListConverter\n\n    @app.route(\"\/<list:args>\")\n    def index(args):\n        return \"|\".join(args)\n\n    assert client.get(\"\/1,2,3\").data == b\"1|2|3\"\n\n\ndef test_static_files(app, client):\n    rv = client.get(\"\/static\/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!<\/h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"\/static\/index.html\"\n    rv.close()\n\n\ndef test_static_url_path():\n    app = flask.Flask(__name__, static_url_path=\"\/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"\/foo\/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"\/foo\/index.html\"\n\n\ndef test_static_url_path_with_ending_slash():\n    app = flask.Flask(__name__, static_url_path=\"\/foo\/\")\n    app.testing = True\n    rv = app.test_client().get(\"\/foo\/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"\/foo\/index.html\"\n\n\ndef test_static_url_empty_path(app):\n    app = flask.Flask(__name__, static_folder=\"\", static_url_path=\"\")\n    rv = app.test_client().open(\"\/static\/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()\n\n\ndef test_static_url_empty_path_default(app):\n    app = flask.Flask(__name__, static_folder=\"\")\n    rv = app.test_client().open(\"\/static\/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()\n\n\ndef test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http:\/\/example.com\/static\/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http:\/\/example.com\/static\/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(Exception):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(Exception):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)\n\n\ndef test_request_locals():\n    assert repr(flask.g) == \"<LocalProxy unbound>\"\n    assert not flask.g\n\n\ndef test_test_app_proper_environ():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n    client = app.test_client()\n\n    @app.route(\"\/\")\n    def index():\n        return \"Foo\"\n\n    @app.route(\"\/\", subdomain=\"foo\")\n    def subdomain():\n        return \"Foo SubDomain\"\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"Foo\"\n\n    rv = client.get(\"\/\", \"http:\/\/localhost.localdomain:5000\")\n    assert rv.data == b\"Foo\"\n\n    rv = client.get(\"\/\", \"https:\/\/localhost.localdomain:5000\")\n    assert rv.data == b\"Foo\"\n\n    app.config.update(SERVER_NAME=\"localhost.localdomain\")\n    rv = client.get(\"\/\", \"https:\/\/localhost.localdomain\")\n    assert rv.data == b\"Foo\"\n\n    try:\n        app.config.update(SERVER_NAME=\"localhost.localdomain:443\")\n        rv = client.get(\"\/\", \"https:\/\/localhost.localdomain\")\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain:443') does not match the \"\n            \"server name from the WSGI environment ('localhost.localdomain')\"\n        )\n\n    try:\n        app.config.update(SERVER_NAME=\"localhost.localdomain\")\n        rv = client.get(\"\/\", \"http:\/\/foo.localhost\")\n        # Werkzeug 0.8\n        assert rv.status_code == 404\n    except ValueError as e:\n        # Werkzeug 0.7\n        assert str(e) == (\n            \"the server name provided \"\n            \"('localhost.localdomain') does not match the \"\n            \"server name from the WSGI environment ('foo.localhost')\"\n        )\n\n    rv = client.get(\"\/\", \"http:\/\/foo.localhost.localdomain\")\n    assert rv.data == b\"Foo SubDomain\"\n\n\ndef test_exception_propagation(app, client):\n    def apprunner(config_key):\n        @app.route(\"\/\")\n        def index():\n            1 \/\/ 0\n\n        if config_key is not None:\n            app.config[config_key] = True\n            with pytest.raises(Exception):\n                client.get(\"\/\")\n        else:\n            assert client.get(\"\/\").status_code == 500\n\n    # we have to run this test in an isolated thread because if the\n    # debug flag is set to true and an exception happens the context is\n    # not torn down.  This causes other tests that run after this fail\n    # when they expect no exception on the stack.\n    for config_key in \"TESTING\", \"PROPAGATE_EXCEPTIONS\", \"DEBUG\", None:\n        t = Thread(target=apprunner, args=(config_key,))\n        t.start()\n        t.join()\n\n\n@pytest.mark.parametrize(\"debug\", [True, False])\n@pytest.mark.parametrize(\"use_debugger\", [True, False])\n@pytest.mark.parametrize(\"use_reloader\", [True, False])\n@pytest.mark.parametrize(\"propagate_exceptions\", [None, True, False])\ndef test_werkzeug_passthrough_errors(\n    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)\n\n\ndef test_max_content_length(app, client):\n    app.config[\"MAX_CONTENT_LENGTH\"] = 64\n\n    @app.before_request\n    def always_first():\n        flask.request.form[\"myfile\"]\n        AssertionError()\n\n    @app.route(\"\/accept\", methods=[\"POST\"])\n    def accept_file():\n        flask.request.form[\"myfile\"]\n        AssertionError()\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return \"42\"\n\n    rv = client.post(\"\/accept\", data={\"myfile\": \"foo\" * 100})\n    assert rv.data == b\"42\"\n\n\ndef test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"\/<lang_code>\/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"\/<lang_code>\/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"\/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"\/de\/\").data == b\"\/de\/about\"\n    assert client.get(\"\/de\/about\").data == b\"\/foo\"\n    assert client.get(\"\/foo\").data == b\"\/en\/about\"\n\n\ndef test_inject_blueprint_url_defaults(app):\n    bp = flask.Blueprint(\"foo.bar.baz\", __name__, template_folder=\"template\")\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values[\"page\"] = \"login\"\n\n    @bp.route(\"\/<page>\")\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults(\"foo.bar.baz.view\", values)\n    expected = dict(page=\"login\")\n    assert values == expected\n\n    with app.test_request_context(\"\/somepage\"):\n        url = flask.url_for(\"foo.bar.baz.view\")\n    expected = \"\/login\"\n    assert url == expected\n\n\ndef test_nonascii_pathinfo(app, client):\n    @app.route(u\"\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(u\"\/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    assert rv.data == b\"Hello World!\"\n\n\ndef test_debug_mode_complains_after_first_request(app, client):\n    app.debug = True\n\n    @app.route(\"\/\")\n    def index():\n        return \"Awesome\"\n\n    assert not app.got_first_request\n    assert client.get(\"\/\").data == b\"Awesome\"\n    with pytest.raises(AssertionError) as e:\n\n        @app.route(\"\/foo\")\n        def broken():\n            return \"Meh\"\n\n    assert \"A setup function was called\" in str(e)\n\n    app.debug = False\n\n    @app.route(\"\/foo\")\n    def working():\n        return \"Meh\"\n\n    assert client.get(\"\/foo\").data == b\"Meh\"\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions(app, client):\n    got = []\n\n    @app.before_first_request\n    def foo():\n        got.append(42)\n\n    client.get(\"\/\")\n    assert got == [42]\n    client.get(\"\/\")\n    assert got == [42]\n    assert app.got_first_request\n\n\ndef test_before_first_request_functions_concurrent(app, client):\n    got = []\n\n    @app.before_first_request\n    def foo():\n        time.sleep(0.2)\n        got.append(42)\n\n    def get_and_assert():\n        client.get(\"\/\")\n        assert got == [42]\n\n    t = Thread(target=get_and_assert)\n    t.start()\n    get_and_assert()\n    t.join()\n    assert app.got_first_request\n\n\ndef test_routing_redirect_debugging(app, client):\n    app.debug = True\n\n    @app.route(\"\/foo\/\", methods=[\"GET\", \"POST\"])\n    def foo():\n        return \"success\"\n\n    with client:\n        with pytest.raises(AssertionError) as e:\n            client.post(\"\/foo\", data={})\n        assert \"http:\/\/localhost\/foo\/\" in str(e)\n        assert (\"Make sure to directly send \" \"your POST-request to this URL\") in str(e)\n\n        rv = client.get(\"\/foo\", data={}, follow_redirects=True)\n        assert rv.data == b\"success\"\n\n    app.debug = False\n    with client:\n        rv = client.post(\"\/foo\", data={}, follow_redirects=True)\n        assert rv.data == b\"success\"\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route(\"\/foo\/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"\/bar\/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route(\"\/bar\/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"\/foo\/\"\n        assert flask.url_for(\"bar\") == \"\/bar\/\"\n        assert flask.url_for(\"123\") == \"\/bar\/123\"\n\n    assert client.get(\"\/foo\/\").data == b\"foo\"\n    assert client.get(\"\/bar\/\").data == b\"bar\"\n    assert client.get(\"\/bar\/123\").data == b\"123\"\n\n\ndef test_preserve_only_once(app, client):\n    app.debug = True\n\n    @app.route(\"\/fail\")\n    def fail_func():\n        1 \/\/ 0\n\n    for _x in range(3):\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"\/fail\")\n\n    assert flask._request_ctx_stack.top is not None\n    assert flask._app_ctx_stack.top is not None\n    # implicit appctx disappears too\n    flask._request_ctx_stack.top.pop()\n    assert flask._request_ctx_stack.top is None\n    assert flask._app_ctx_stack.top is None\n\n\ndef test_preserve_remembers_exception(app, client):\n    app.debug = True\n    errors = []\n\n    @app.route(\"\/fail\")\n    def fail_func():\n        1 \/\/ 0\n\n    @app.route(\"\/success\")\n    def success_func():\n        return \"Okay\"\n\n    @app.teardown_request\n    def teardown_handler(exc):\n        errors.append(exc)\n\n    # After this failure we did not yet call the teardown handler\n    with pytest.raises(ZeroDivisionError):\n        client.get(\"\/fail\")\n    assert errors == []\n\n    # But this request triggers it, and it's an error\n    client.get(\"\/success\")\n    assert len(errors) == 2\n    assert isinstance(errors[0], ZeroDivisionError)\n\n    # At this point another request does nothing.\n    client.get(\"\/success\")\n    assert len(errors) == 3\n    assert errors[1] is None\n\n\ndef test_get_method_on_g(app_ctx):\n    assert flask.g.get(\"x\") is None\n    assert flask.g.get(\"x\", 11) == 11\n    flask.g.x = 42\n    assert flask.g.get(\"x\") == 42\n    assert flask.g.x == 42\n\n\ndef test_g_iteration_protocol(app_ctx):\n    flask.g.foo = 23\n    flask.g.bar = 42\n    assert \"foo\" in flask.g\n    assert \"foos\" not in flask.g\n    assert sorted(flask.g) == [\"bar\", \"foo\"]\n\n\ndef test_subdomain_basic_support():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"\/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"\/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"\/\", \"http:\/\/localhost.localdomain\/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"\/\", \"http:\/\/test.localhost.localdomain\/\")\n    assert rv.data == b\"test index\"\n\n\ndef test_subdomain_matching():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n\n    @app.route(\"\/\", subdomain=\"<user>\")\n    def index(user):\n        return \"index for %s\" % user\n\n    rv = client.get(\"\/\", \"http:\/\/mitsuhiko.localhost.localdomain\/\")\n    assert rv.data == b\"index for mitsuhiko\"\n\n\ndef test_subdomain_matching_with_ports():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"\/\", subdomain=\"<user>\")\n    def index(user):\n        return \"index for %s\" % user\n\n    rv = client.get(\"\/\", \"http:\/\/mitsuhiko.localhost.localdomain:3000\/\")\n    assert rv.data == b\"index for mitsuhiko\"\n\n\n@pytest.mark.parametrize(\"matching\", (False, True))\ndef test_subdomain_matching_other_name(matching):\n    app = flask.Flask(__name__, subdomain_matching=matching)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"\/\")\n    def index():\n        return \"\", 204\n\n    # ip address can't match name\n    rv = client.get(\"\/\", \"http:\/\/127.0.0.1:3000\/\")\n    assert rv.status_code == 404 if matching else 204\n\n    # allow all subdomains if matching is disabled\n    rv = client.get(\"\/\", \"http:\/\/www.localhost.localdomain:3000\/\")\n    assert rv.status_code == 404 if matching else 204\n\n\ndef test_multi_route_rules(app, client):\n    @app.route(\"\/\")\n    @app.route(\"\/<test>\/\")\n    def index(test=\"a\"):\n        return test\n\n    rv = client.open(\"\/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"\/b\/\")\n    assert rv.data == b\"b\"\n\n\ndef test_multi_route_class_views(app, client):\n    class View(object):\n        def __init__(self, app):\n            app.add_url_rule(\"\/\", \"index\", self.index)\n            app.add_url_rule(\"\/<test>\/\", \"index\", self.index)\n\n        def index(self, test=\"a\"):\n            return test\n\n    _ = View(app)\n    rv = client.open(\"\/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"\/b\/\")\n    assert rv.data == b\"b\"\n\n\ndef test_run_defaults(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"result\"] = \"running...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.run()\n    assert rv[\"result\"] == \"running...\"\n\n\ndef test_run_server_port(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(hostname, port, application, *args, **kwargs):\n        rv[\"result\"] = \"running on %s:%s ...\" % (hostname, port)\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    hostname, port = \"localhost\", 8000\n    app.run(hostname, port, debug=True)\n    assert rv[\"result\"] == \"running on %s:%s ...\" % (hostname, port)\n\n\n@pytest.mark.parametrize(\n    \"host,port,server_name,expect_host,expect_port\",\n    (\n        (None, None, \"pocoo.org:8080\", \"pocoo.org\", 8080),\n        (\"localhost\", None, \"pocoo.org:8080\", \"localhost\", 8080),\n        (None, 80, \"pocoo.org:8080\", \"pocoo.org\", 80),\n        (\"localhost\", 80, \"pocoo.org:8080\", \"localhost\", 80),\n        (\"localhost\", 0, \"localhost:8080\", \"localhost\", 0),\n        (None, None, \"localhost:8080\", \"localhost\", 8080),\n        (None, None, \"localhost:0\", \"localhost\", 0),\n    ),\n)\ndef test_run_from_config(\n    monkeypatch, host, port, server_name, expect_host, expect_port, app\n):\n    def run_simple_mock(hostname, port, *args, **kwargs):\n        assert hostname == expect_host\n        assert port == expect_port\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"SERVER_NAME\"] = server_name\n    app.run(host, port)\n\n\ndef test_max_cookie_size(app, client, recwarn):\n    app.config[\"MAX_COOKIE_SIZE\"] = 100\n\n    # outside app context, default to Werkzeug static value,\n    # which is also the default config\n    response = flask.Response()\n    default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\n    assert response.max_cookie_size == default\n\n    # inside app context, use app config\n    with app.app_context():\n        assert flask.Response().max_cookie_size == 100\n\n    @app.route(\"\/\")\n    def index():\n        r = flask.Response(\"\", status=204)\n        r.set_cookie(\"foo\", \"bar\" * 100)\n        return r\n\n    client.get(\"\/\")\n    assert len(recwarn) == 1\n    w = recwarn.pop()\n    assert \"cookie is too large\" in str(w.message)\n\n    app.config[\"MAX_COOKIE_SIZE\"] = 0\n\n    client.get(\"\/\")\n    assert len(recwarn) == 0\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.sessions\n    ~~~~~~~~~~~~~~\n\n    Implements cookie based sessions based on itsdangerous.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport hashlib\nimport warnings\nfrom datetime import datetime\n\nfrom itsdangerous import BadSignature\nfrom itsdangerous import URLSafeTimedSerializer\nfrom werkzeug.datastructures import CallbackDict\n\nfrom ._compat import collections_abc\nfrom .helpers import is_ip\nfrom .helpers import total_seconds\nfrom .json.tag import TaggedJSONSerializer\n\n\nclass SessionMixin(collections_abc.MutableMapping):\n    \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n\n    @property\n    def permanent(self):\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)\n\n    @permanent.setter\n    def permanent(self, value):\n        self[\"_permanent\"] = bool(value)\n\n    #: Some implementations can detect whether a session is newly\n    #: created, but that is not guaranteed. Use with caution. The mixin\n    # default is hard-coded ``False``.\n    new = False\n\n    #: Some implementations can detect changes to the session and set\n    #: this when that happens. The mixin default is hard coded to\n    #: ``True``.\n    modified = True\n\n    #: Some implementations can detect when session data is read or\n    #: written and set this when that happens. The mixin default is hard\n    #: coded to ``True``.\n    accessed = True\n\n\nclass SecureCookieSession(CallbackDict, SessionMixin):\n    \"\"\"Base class for sessions based on signed cookies.\n\n    This session backend will set the :attr:`modified` and\n    :attr:`accessed` attributes. It cannot reliably track whether a\n    session is new (vs. empty), so :attr:`new` remains hard coded to\n    ``False``.\n    \"\"\"\n\n    #: When data is changed, this is set to ``True``. Only the session\n    #: dictionary itself is tracked; if the session contains mutable\n    #: data (for example a nested dict) then this must be set to\n    #: ``True`` manually when modifying that data. The session cookie\n    #: will only be written to the response if this is ``True``.\n    modified = False\n\n    #: When data is read or written, this is set to ``True``. Used by\n    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``\n    #: header, which allows caching proxies to cache different pages for\n    #: different users.\n    accessed = False\n\n    def __init__(self, initial=None):\n        def on_update(self):\n            self.modified = True\n            self.accessed = True\n\n        super(SecureCookieSession, self).__init__(initial, on_update)\n\n    def __getitem__(self, key):\n        self.accessed = True\n        return super(SecureCookieSession, self).__getitem__(key)\n\n    def get(self, key, default=None):\n        self.accessed = True\n        return super(SecureCookieSession, self).get(key, default)\n\n    def setdefault(self, key, default=None):\n        self.accessed = True\n        return super(SecureCookieSession, self).setdefault(key, default)\n\n\nclass NullSession(SecureCookieSession):\n    \"\"\"Class used to generate nicer error messages if sessions are not\n    available.  Will still allow read-only access to the empty session\n    but fail on setting.\n    \"\"\"\n\n    def _fail(self, *args, **kwargs):\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n\n    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail\n    del _fail\n\n\nclass SessionInterface(object):\n    \"\"\"The basic interface you have to implement in order to replace the\n    default session interface which uses werkzeug's securecookie\n    implementation.  The only methods you have to implement are\n    :meth:`open_session` and :meth:`save_session`, the others have\n    useful defaults which you don't need to change.\n\n    The session object returned by the :meth:`open_session` method has to\n    provide a dictionary like interface plus the properties and methods\n    from the :class:`SessionMixin`.  We recommend just subclassing a dict\n    and adding that mixin::\n\n        class Session(dict, SessionMixin):\n            pass\n\n    If :meth:`open_session` returns ``None`` Flask will call into\n    :meth:`make_null_session` to create a session that acts as replacement\n    if the session support cannot work because some requirement is not\n    fulfilled.  The default :class:`NullSession` class that is created\n    will complain that the secret key was not set.\n\n    To replace the session interface on an application all you have to do\n    is to assign :attr:`flask.Flask.session_interface`::\n\n        app = Flask(__name__)\n        app.session_interface = MySessionInterface()\n\n    .. versionadded:: 0.8\n    \"\"\"\n\n    #: :meth:`make_null_session` will look here for the class that should\n    #: be created when a null session is requested.  Likewise the\n    #: :meth:`is_null_session` method will perform a typecheck against\n    #: this type.\n    null_session_class = NullSession\n\n    #: A flag that indicates if the session interface is pickle based.\n    #: This can be used by Flask extensions to make a decision in regards\n    #: to how to deal with the session object.\n    #:\n    #: .. versionadded:: 0.10\n    pickle_based = False\n\n    def make_null_session(self, app):\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n\n    def is_null_session(self, obj):\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n\n    def get_cookie_domain(self, app):\n        \"\"\"Returns the domain that should be set for the session cookie.\n\n        Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise\n        falls back to detecting the domain based on ``SERVER_NAME``.\n\n        Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is\n        updated to avoid re-running the logic.\n        \"\"\"\n\n        rv = app.config[\"SESSION_COOKIE_DOMAIN\"]\n\n        # set explicitly, or cached from SERVER_NAME detection\n        # if False, return None\n        if rv is not None:\n            return rv if rv else None\n\n        rv = app.config[\"SERVER_NAME\"]\n\n        # server name not set, cache False to return none next time\n        if not rv:\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        # chop off the port which is usually not supported by browsers\n        # remove any leading '.' since we'll add that later\n        rv = rv.rsplit(\":\", 1)[0].lstrip(\".\")\n\n        if \".\" not in rv:\n            # Chrome doesn't allow names without a '.'\n            # this should only come up with localhost\n            # hack around this by not setting the name, and show a warning\n            warnings.warn(\n                '\"{rv}\" is not a valid cookie domain, it must contain a \".\".'\n                \" Add an entry to your hosts file, for example\"\n                ' \"{rv}.localdomain\", and use that instead.'.format(rv=rv)\n            )\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        ip = is_ip(rv)\n\n        if ip:\n            warnings.warn(\n                \"The session cookie domain is an IP address. This may not work\"\n                \" as intended in some browsers. Add an entry to your hosts\"\n                ' file, for example \"localhost.localdomain\", and use that'\n                \" instead.\"\n            )\n\n        # if this is not an ip and app is mounted at the root, allow subdomain\n        # matching by adding a '.' prefix\n        if self.get_cookie_path(app) == \"\/\" and not ip:\n            rv = \".\" + rv\n\n        app.config[\"SESSION_COOKIE_DOMAIN\"] = rv\n        return rv\n\n    def get_cookie_path(self, app):\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``\/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]\n\n    def get_cookie_httponly(self, app):\n        \"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_HTTPONLY\"]\n\n    def get_cookie_secure(self, app):\n        \"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SECURE\"]\n\n    def get_cookie_samesite(self, app):\n        \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SAMESITE\"]\n\n    def get_expiration_time(self, app, session):\n        \"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"\n        if session.permanent:\n            return datetime.utcnow() + app.permanent_session_lifetime\n\n    def should_set_cookie(self, app, session):\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n\n    def open_session(self, app, request):\n        \"\"\"This method has to be implemented and must either return ``None``\n        in case the loading failed because of a configuration error or an\n        instance of a session object which implements a dictionary like\n        interface + the methods and attributes on :class:`SessionMixin`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def save_session(self, app, session, response):\n        \"\"\"This is called for actual sessions returned by :meth:`open_session`\n        at the end of the request.  This is still called during a request\n        context so if you absolutely need access to the request you can do\n        that.\n        \"\"\"\n        raise NotImplementedError()\n\n\nsession_json_serializer = TaggedJSONSerializer()\n\n\nclass SecureCookieSessionInterface(SessionInterface):\n    \"\"\"The default session interface that stores sessions in signed cookies\n    through the :mod:`itsdangerous` module.\n    \"\"\"\n\n    #: the salt that should be applied on top of the secret key for the\n    #: signing of cookie based sessions.\n    salt = \"cookie-session\"\n    #: the hash function to use for the signature.  The default is sha1\n    digest_method = staticmethod(hashlib.sha1)\n    #: the name of the itsdangerous supported key derivation.  The default\n    #: is hmac.\n    key_derivation = \"hmac\"\n    #: A python serializer for the payload.  The default is a compact\n    #: JSON derived serializer with support for some extra Python types\n    #: such as datetime objects or tuples.\n    serializer = session_json_serializer\n    session_class = SecureCookieSession\n\n    def get_signing_serializer(self, app):\n        if not app.secret_key:\n            return None\n        signer_kwargs = dict(\n            key_derivation=self.key_derivation, digest_method=self.digest_method\n        )\n        return URLSafeTimedSerializer(\n            app.secret_key,\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs=signer_kwargs,\n        )\n\n    def open_session(self, app, request):\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(app.session_cookie_name)\n        if not val:\n            return self.session_class()\n        max_age = total_seconds(app.permanent_session_lifetime)\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(\n                    app.session_cookie_name, domain=domain, path=path\n                )\n\n            return\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        httponly = self.get_cookie_httponly(app)\n        secure = self.get_cookie_secure(app)\n        samesite = self.get_cookie_samesite(app)\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))\n        response.set_cookie(\n            app.session_cookie_name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            samesite=samesite,\n        )\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.helpers\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Various helpers.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport datetime\nimport io\nimport os\nimport uuid\n\nimport pytest\nfrom werkzeug.datastructures import Range\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import http_date\nfrom werkzeug.http import parse_cache_control_header\nfrom werkzeug.http import parse_options_header\n\nimport flask\nfrom flask import json\nfrom flask._compat import StringIO\nfrom flask._compat import text_type\nfrom flask.helpers import get_debug_flag\nfrom flask.helpers import get_env\n\n\ndef has_encoding(name):\n    try:\n        import codecs\n\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n\n\nclass FakePath(object):\n    \"\"\"Fake object to represent a ``PathLike object``.\n\n    This represents a ``pathlib.Path`` object in python 3.\n    See: https:\/\/www.python.org\/dev\/peps\/pep-0519\/\n    \"\"\"\n\n    def __init__(self, path):\n        self.path = path\n\n    def __fspath__(self):\n        return self.path\n\n\nclass FixedOffset(datetime.tzinfo):\n    \"\"\"Fixed offset in hours east from UTC.\n\n    This is a slight adaptation of the ``FixedOffset`` example found in\n    https:\/\/docs.python.org\/2.7\/library\/datetime.html.\n    \"\"\"\n\n    def __init__(self, hours, name):\n        self.__offset = datetime.timedelta(hours=hours)\n        self.__name = name\n\n    def utcoffset(self, dt):\n        return self.__offset\n\n    def tzname(self, dt):\n        return self.__name\n\n    def dst(self, dt):\n        return datetime.timedelta()\n\n\nclass TestJSON(object):\n    @pytest.mark.parametrize(\n        \"value\", (1, \"t\", True, False, None, [], [1, 2, 3], {}, {\"foo\": u\"\ud83d\udc0d\"})\n    )\n    @pytest.mark.parametrize(\n        \"encoding\",\n        (\n            \"utf-8\",\n            \"utf-8-sig\",\n            \"utf-16-le\",\n            \"utf-16-be\",\n            \"utf-16\",\n            \"utf-32-le\",\n            \"utf-32-be\",\n            \"utf-32\",\n        ),\n    )\n    def test_detect_encoding(self, value, encoding):\n        data = json.dumps(value).encode(encoding)\n        assert json.detect_encoding(data) == encoding\n        assert json.loads(data) == value\n\n    @pytest.mark.parametrize(\"debug\", (True, False))\n    def test_bad_request_debug_message(self, app, client, debug):\n        app.config[\"DEBUG\"] = debug\n        app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def post_json():\n            flask.request.get_json()\n            return None\n\n        rv = client.post(\"\/json\", data=None, content_type=\"application\/json\")\n        assert rv.status_code == 400\n        contains = b\"Failed to decode JSON object\" in rv.data\n        assert contains == debug\n\n    def test_json_bad_requests(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.jsonify(foo=text_type(flask.request.get_json()))\n\n        rv = client.post(\"\/json\", data=\"malformed\", content_type=\"application\/json\")\n        assert rv.status_code == 400\n\n    def test_json_custom_mimetypes(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.request.get_json()\n\n        rv = client.post(\"\/json\", data='\"foo\"', content_type=\"application\/x+json\")\n        assert rv.data == b\"foo\"\n\n    @pytest.mark.parametrize(\n        \"test_value,expected\", [(True, '\"\\\\u2603\"'), (False, u'\"\\u2603\"')]\n    )\n    def test_json_as_unicode(self, test_value, expected, app, app_ctx):\n\n        app.config[\"JSON_AS_ASCII\"] = test_value\n        rv = flask.json.dumps(u\"\\N{SNOWMAN}\")\n        assert rv == expected\n\n    def test_json_dump_to_file(self, app, app_ctx):\n        test_data = {\"name\": \"Flask\"}\n        out = StringIO()\n\n        flask.json.dump(test_data, out)\n        out.seek(0)\n        rv = flask.json.load(out)\n        assert rv == test_data\n\n    @pytest.mark.parametrize(\n        \"test_value\", [0, -1, 1, 23, 3.14, \"s\", \"longer string\", True, False, None]\n    )\n    def test_jsonify_basic_types(self, test_value, app, client):\n        \"\"\"Test jsonify with basic types.\"\"\"\n\n        url = \"\/jsonify_basic_types\"\n        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n        rv = client.get(url)\n        assert rv.mimetype == \"application\/json\"\n        assert flask.json.loads(rv.data) == test_value\n\n    def test_jsonify_dicts(self, app, client):\n        \"\"\"Test jsonify with dicts and kwargs unpacking.\"\"\"\n        d = {\n            \"a\": 0,\n            \"b\": 23,\n            \"c\": 3.14,\n            \"d\": \"t\",\n            \"e\": \"Hi\",\n            \"f\": True,\n            \"g\": False,\n            \"h\": [\"test list\", 10, False],\n            \"i\": {\"test\": \"dict\"},\n        }\n\n        @app.route(\"\/kw\")\n        def return_kwargs():\n            return flask.jsonify(**d)\n\n        @app.route(\"\/dict\")\n        def return_dict():\n            return flask.jsonify(d)\n\n        for url in \"\/kw\", \"\/dict\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == d\n\n    def test_jsonify_arrays(self, app, client):\n        \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n        a_list = [\n            0,\n            42,\n            3.14,\n            \"t\",\n            \"hello\",\n            True,\n            False,\n            [\"test list\", 2, False],\n            {\"test\": \"dict\"},\n        ]\n\n        @app.route(\"\/args_unpack\")\n        def return_args_unpack():\n            return flask.jsonify(*a_list)\n\n        @app.route(\"\/array\")\n        def return_array():\n            return flask.jsonify(a_list)\n\n        for url in \"\/args_unpack\", \"\/array\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == a_list\n\n    def test_jsonify_date_types(self, app, client):\n        \"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"\n        test_dates = (\n            datetime.datetime(1973, 3, 11, 6, 30, 45),\n            datetime.date(1975, 1, 5),\n        )\n\n        for i, d in enumerate(test_dates):\n            url = \"\/datetest{0}\".format(i)\n            app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data)[\"x\"] == http_date(d.timetuple())\n\n    @pytest.mark.parametrize(\"tz\", ((\"UTC\", 0), (\"PST\", -8), (\"KST\", 9)))\n    def test_jsonify_aware_datetimes(self, tz):\n        \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n        tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n        dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n        gmt = FixedOffset(hours=0, name=\"GMT\")\n        expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n        assert flask.json.JSONEncoder().encode(dt) == expected\n\n    def test_jsonify_uuid_types(self, app, client):\n        \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n        test_uuid = uuid.UUID(bytes=b\"\\xDE\\xAD\\xBE\\xEF\" * 4)\n        url = \"\/uuid_test\"\n        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n        rv = client.get(url)\n\n        rv_x = flask.json.loads(rv.data)[\"x\"]\n        assert rv_x == str(test_uuid)\n        rv_uuid = uuid.UUID(rv_x)\n        assert rv_uuid == test_uuid\n\n    def test_json_attr(self, app, client):\n        @app.route(\"\/add\", methods=[\"POST\"])\n        def add():\n            json = flask.request.get_json()\n            return text_type(json[\"a\"] + json[\"b\"])\n\n        rv = client.post(\n            \"\/add\",\n            data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b\"3\"\n\n    def test_template_escaping(self, app, req_ctx):\n        render = flask.render_template_string\n        rv = flask.json.htmlsafe_dumps(\"<\/script>\")\n        assert rv == u'\"\\\\u003c\/script\\\\u003e\"'\n        assert type(rv) == text_type\n        rv = render('{{ \"<\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n        rv = render('{{ \"<\\0\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\\\\u0000\/script\\\\u003e\"'\n        rv = render('{{ \"<!--<script>\"|tojson }}')\n        assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n        rv = render('{{ \"&\"|tojson }}')\n        assert rv == '\"\\\\u0026\"'\n        rv = render('{{ \"\\'\"|tojson }}')\n        assert rv == '\"\\\\u0027\"'\n        rv = render(\n            \"<a ng-data='{{ data|tojson }}'><\/a>\", data={\"x\": [\"foo\", \"bar\", \"baz'\"]}\n        )\n        assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'><\/a>'\n\n    def test_json_customization(self, app, client):\n        class X(object):  # noqa: B903, for Python2 compatibility\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return \"<%d>\" % o.val\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n                return obj\n\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n\n        @app.route(\"\/\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        rv = client.post(\n            \"\/\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    def test_blueprint_json_customization(self, app, client):\n        class X(object):  # noqa: B903, for Python2 compatibility\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return \"<%d>\" % o.val\n\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n\n                return obj\n\n        bp = flask.Blueprint(\"bp\", __name__)\n        bp.json_encoder = MyEncoder\n        bp.json_decoder = MyDecoder\n\n        @bp.route(\"\/bp\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        app.register_blueprint(bp)\n\n        rv = client.post(\n            \"\/bp\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    @pytest.mark.skipif(\n        not has_encoding(\"euc-kr\"), reason=\"The euc-kr encoding is required.\"\n    )\n    def test_modified_url_encoding(self, app, client):\n        class ModifiedRequest(flask.Request):\n            url_charset = \"euc-kr\"\n\n        app.request_class = ModifiedRequest\n        app.url_map.charset = \"euc-kr\"\n\n        @app.route(\"\/\")\n        def index():\n            return flask.request.args[\"foo\"]\n\n        rv = client.get(u\"\/?foo=\uc815\uc0c1\ucc98\ub9ac\".encode(\"euc-kr\"))\n        assert rv.status_code == 200\n        assert rv.data == u\"\uc815\uc0c1\ucc98\ub9ac\".encode(\"utf-8\")\n\n    def test_json_key_sorting(self, app, client):\n        app.debug = True\n\n        assert app.config[\"JSON_SORT_KEYS\"]\n        d = dict.fromkeys(range(20), \"foo\")\n\n        @app.route(\"\/\")\n        def index():\n            return flask.jsonify(values=d)\n\n        rv = client.get(\"\/\")\n        lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n        sorted_by_str = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n        sorted_by_int = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n\n        try:\n            assert lines == sorted_by_int\n        except AssertionError:\n            assert lines == sorted_by_str\n\n\nclass TestSendfile(object):\n    def test_send_file_regular(self, app, req_ctx):\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    def test_send_file_xsendfile(self, app, req_ctx, catch_deprecation_warnings):\n        app.use_x_sendfile = True\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert \"x-sendfile\" in rv.headers\n        assert rv.headers[\"x-sendfile\"] == os.path.join(\n            app.root_path, \"static\/index.html\"\n        )\n        assert rv.mimetype == \"text\/html\"\n        rv.close()\n\n    def test_send_file_last_modified(self, app, client):\n        last_modified = datetime.datetime(1999, 1, 1)\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\n                StringIO(\"party like it's\"),\n                last_modified=last_modified,\n                mimetype=\"text\/plain\",\n            )\n\n        rv = client.get(\"\/\")\n        assert rv.last_modified == last_modified\n\n    def test_send_file_object_without_mimetype(self, app, req_ctx):\n        with pytest.raises(ValueError) as excinfo:\n            flask.send_file(StringIO(\"LOL\"))\n        assert \"Unable to infer MIME-type\" in str(excinfo)\n        assert \"no filename is available\" in str(excinfo)\n\n        flask.send_file(StringIO(\"LOL\"), attachment_filename=\"filename\")\n\n    def test_send_file_object(self, app, req_ctx):\n        with open(os.path.join(app.root_path, \"static\/index.html\"), mode=\"rb\") as f:\n            rv = flask.send_file(f, mimetype=\"text\/html\")\n            rv.direct_passthrough = False\n            with app.open_resource(\"static\/index.html\") as f:\n                assert rv.data == f.read()\n            assert rv.mimetype == \"text\/html\"\n            rv.close()\n\n        app.use_x_sendfile = True\n\n        with open(os.path.join(app.root_path, \"static\/index.html\")) as f:\n            rv = flask.send_file(f, mimetype=\"text\/html\")\n            assert rv.mimetype == \"text\/html\"\n            assert \"x-sendfile\" not in rv.headers\n            rv.close()\n\n        app.use_x_sendfile = False\n        f = StringIO(\"Test\")\n        rv = flask.send_file(f, mimetype=\"application\/octet-stream\")\n        rv.direct_passthrough = False\n        assert rv.data == b\"Test\"\n        assert rv.mimetype == \"application\/octet-stream\"\n        rv.close()\n\n        class PyStringIO(object):\n            def __init__(self, *args, **kwargs):\n                self._io = StringIO(*args, **kwargs)\n\n            def __getattr__(self, name):\n                return getattr(self._io, name)\n\n        f = PyStringIO(\"Test\")\n        f.name = \"test.txt\"\n        rv = flask.send_file(f, attachment_filename=f.name)\n        rv.direct_passthrough = False\n        assert rv.data == b\"Test\"\n        assert rv.mimetype == \"text\/plain\"\n        rv.close()\n\n        f = StringIO(\"Test\")\n        rv = flask.send_file(f, mimetype=\"text\/plain\")\n        rv.direct_passthrough = False\n        assert rv.data == b\"Test\"\n        assert rv.mimetype == \"text\/plain\"\n        rv.close()\n\n        app.use_x_sendfile = True\n\n        f = StringIO(\"Test\")\n        rv = flask.send_file(f, mimetype=\"text\/html\")\n        assert \"x-sendfile\" not in rv.headers\n        rv.close()\n\n    def test_send_file_pathlike(self, app, req_ctx):\n        rv = flask.send_file(FakePath(\"static\/index.html\"))\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, \"to_content_range_header\", None)),\n        reason=\"not implemented within werkzeug\",\n    )\n    def test_send_file_range_request(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:16]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-1000\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-10\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[-10:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"somethingsomething\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        last_modified = datetime.datetime.utcfromtimestamp(\n            os.path.getmtime(os.path.join(app.root_path, \"static\/index.html\"))\n        ).replace(microsecond=0)\n\n        rv = client.get(\n            \"\/\", headers={\"Range\": \"bytes=4-15\", \"If-Range\": http_date(last_modified)}\n        )\n        assert rv.status_code == 206\n        rv.close()\n\n        rv = client.get(\n            \"\/\",\n            headers={\n                \"Range\": \"bytes=4-15\",\n                \"If-Range\": http_date(datetime.datetime(1999, 1, 1)),\n            },\n        )\n        assert rv.status_code == 200\n        rv.close()\n\n    def test_send_file_range_request_bytesio(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            file = io.BytesIO(b\"somethingsomething\")\n            return flask.send_file(\n                file, attachment_filename=\"filename\", conditional=True\n            )\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        assert rv.data == b\"somethingsomething\"[4:16]\n        rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, \"to_content_range_header\", None)),\n        reason=\"not implemented within werkzeug\",\n    )\n    def test_send_file_range_request_xsendfile_invalid(self, app, client):\n        # https:\/\/github.com\/pallets\/flask\/issues\/2526\n        app.use_x_sendfile = True\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n    def test_attachment(self, app, req_ctx):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            with open(os.path.join(app.root_path, \"static\/index.html\")) as f:\n                rv = flask.send_file(\n                    f, as_attachment=True, attachment_filename=\"index.html\"\n                )\n                value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n                assert value == \"attachment\"\n                rv.close()\n\n        with open(os.path.join(app.root_path, \"static\/index.html\")) as f:\n            rv = flask.send_file(\n                f, as_attachment=True, attachment_filename=\"index.html\"\n            )\n            value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n            assert value == \"attachment\"\n            assert options[\"filename\"] == \"index.html\"\n            assert \"filename*\" not in rv.headers[\"Content-Disposition\"]\n            rv.close()\n\n        rv = flask.send_file(\"static\/index.html\", as_attachment=True)\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.html\"\n        rv.close()\n\n        rv = flask.send_file(\n            StringIO(\"Test\"),\n            as_attachment=True,\n            attachment_filename=\"index.txt\",\n            add_etags=False,\n        )\n        assert rv.mimetype == \"text\/plain\"\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.txt\"\n        rv.close()\n\n    @pytest.mark.usefixtures(\"req_ctx\")\n    @pytest.mark.parametrize(\n        (\"filename\", \"ascii\", \"utf8\"),\n        (\n            (\"index.html\", \"index.html\", False),\n            (\n                u\"\u00d1and\u00fa\uff0fping\u00fcino.txt\",\n                '\"Nandu\/pinguino.txt\"',\n                \"%C3%91and%C3%BA%EF%BC%8Fping%C3%BCino.txt\",\n            ),\n            (u\"V\u00f6gel.txt\", \"Vogel.txt\", \"V%C3%B6gel.txt\"),\n            # Native string not marked as Unicode on Python 2\n            (\"t\u00e9st.txt\", \"test.txt\", \"t%C3%A9st.txt\"),\n        ),\n    )\n    def test_attachment_filename_encoding(self, filename, ascii, utf8):\n        rv = flask.send_file(\n            \"static\/index.html\", as_attachment=True, attachment_filename=filename\n        )\n        rv.close()\n        content_disposition = rv.headers[\"Content-Disposition\"]\n        assert \"filename=%s\" % ascii in content_disposition\n        if utf8:\n            assert \"filename*=UTF-8''\" + utf8 in content_disposition\n        else:\n            assert \"filename*=UTF-8''\" not in content_disposition\n\n    def test_static_file(self, app, req_ctx):\n        # default cache timeout is 12 hours\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        # Test with static file handler.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file(\"static\/index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n\n    def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_pathlike(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(FakePath(\"static\"), FakePath(\"hello.txt\"))\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_bad_request(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n\n        with pytest.raises(BadRequest):\n            flask.send_from_directory(\"static\", \"bad\\x00\")\n\n\nclass TestUrlFor(object):\n    def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"\/#x%20y\"\n\n    def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n\n    def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        pytest.raises(ValueError, flask.url_for, \"index\", _scheme=\"https\")\n\n    def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n\n    def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return \"Get %d\" % id\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"\/myview\/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"\/myview\/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"\/myview\/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"\/myview\/create\"\n\n\nclass TestNoImports(object):\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self, modules_tmpdir):\n        modules_tmpdir.join(\"importerror.py\").write(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")\n\n\nclass TestStreaming(object):\n    def test_streaming_with_context(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper(object):\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]\n\n    def test_stream_keeps_session(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"\/\")\n        assert rv.data == b\"flask\"\n\n\nclass TestSafeJoin(object):\n    def test_safe_join(self):\n        # Valid combinations of *args and expected joined paths.\n        passing = (\n            ((\"a\/b\/c\",), \"a\/b\/c\"),\n            ((\"\/\", \"a\/\", \"b\/\", \"c\/\"), \"\/a\/b\/c\"),\n            ((\"a\", \"b\", \"c\"), \"a\/b\/c\"),\n            ((\"\/a\", \"b\/c\"), \"\/a\/b\/c\"),\n            ((\"a\/b\", \"X\/..\/c\"), \"a\/b\/c\"),\n            ((\"\/a\/b\", \"c\/X\/..\"), \"\/a\/b\/c\"),\n            # If last path is '' add a slash\n            ((\"\/a\/b\/c\", \"\"), \"\/a\/b\/c\/\"),\n            # Preserve dot slash\n            ((\"\/a\/b\/c\", \".\/\"), \"\/a\/b\/c\/.\"),\n            ((\"a\/b\/c\", \"X\/..\"), \"a\/b\/c\/.\"),\n            # Base directory is always considered safe\n            ((\"..\/\", \"a\/b\/c\"), \"..\/a\/b\/c\"),\n            ((\"\/..\",), \"\/..\"),\n        )\n\n        for args, expected in passing:\n            assert flask.safe_join(*args) == expected\n\n    def test_safe_join_exceptions(self):\n        # Should raise werkzeug.exceptions.NotFound on unsafe joins.\n        failing = (\n            # path.isabs and ``..'' checks\n            (\"\/a\", \"b\", \"\/c\"),\n            (\"\/a\", \"..\/b\/c\"),\n            (\"\/a\", \"..\", \"b\/c\"),\n            # Boundaries violations after path normalization\n            (\"\/a\", \"b\/..\/b\/..\/..\/c\"),\n            (\"\/a\", \"b\", \"c\/..\/..\"),\n            (\"\/a\", \"b\/..\/..\/c\"),\n        )\n\n        for args in failing:\n            with pytest.raises(NotFound):\n                print(flask.safe_join(*args))\n\n\nclass TestHelpers(object):\n    @pytest.mark.parametrize(\n        \"debug, expected_flag, expected_default_flag\",\n        [\n            (\"\", False, False),\n            (\"0\", False, False),\n            (\"False\", False, False),\n            (\"No\", False, False),\n            (\"True\", True, True),\n        ],\n    )\n    def test_get_debug_flag(\n        self, monkeypatch, debug, expected_flag, expected_default_flag\n    ):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        if expected_flag is None:\n            assert get_debug_flag() is None\n        else:\n            assert get_debug_flag() == expected_flag\n        assert get_debug_flag() == expected_default_flag\n\n    @pytest.mark.parametrize(\n        \"env, ref_env, debug\",\n        [\n            (\"\", \"production\", False),\n            (\"production\", \"production\", False),\n            (\"development\", \"development\", True),\n            (\"other\", \"other\", False),\n        ],\n    )\n    def test_get_env(self, monkeypatch, env, ref_env, debug):\n        monkeypatch.setenv(\"FLASK_ENV\", env)\n        assert get_debug_flag() == debug\n        assert get_env() == ref_env\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text\/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text\/html\"\n\n    @pytest.mark.parametrize(\"mode\", (\"r\", \"rb\", \"rt\"))\n    def test_open_resource(self, mode):\n        app = flask.Flask(__name__)\n\n        with app.open_resource(\"static\/index.html\", mode) as f:\n            assert \"<h1>Hello World!<\/h1>\" in str(f.read())\n\n    @pytest.mark.parametrize(\"mode\", (\"w\", \"x\", \"a\", \"r+\"))\n    def test_open_resource_exceptions(self, mode):\n        app = flask.Flask(__name__)\n\n        with pytest.raises(ValueError):\n            app.open_resource(\"static\/index.html\", mode)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(\"flask.app\")\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\ntests.test_logging\n~~~~~~~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\nimport logging\nimport sys\n\nimport pytest\n\nfrom flask._compat import StringIO\nfrom flask.logging import default_handler\nfrom flask.logging import has_level_handler\nfrom flask.logging import wsgi_errors_stream\n\n\n@pytest.fixture(autouse=True)\ndef reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger(\"flask.app\")\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")\n\n\ndef test_logger(app):\n    assert app.logger.name == \"flask.app\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n\n\ndef test_wsgi_errors_stream(app, client):\n    @app.route(\"\/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"\/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n\n\ndef test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n\n\ndef test_log_view_exception(app, client):\n    @app.route(\"\/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"\/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on \/ [GET]\" in err\n    assert \"Exception: test\" in err\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(\"flask.app\")\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: apply reorder-python-imports pre-commit config\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.templating\n    ~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport logging\n\nimport pytest\nimport werkzeug.serving\nfrom jinja2 import TemplateNotFound\n\nimport flask\n\n\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"<p>23|42\"\n\n\ndef test_original_win(app, client):\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"42\"\n\n\ndef test_request_less_rendering(app, app_ctx):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} \" \"{{ foo }}\")\n    assert rv == \"Hello Special World 42\"\n\n\ndef test_standard_context(app, client):\n    @app.route(\"\/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"\/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]\n\n\ndef test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"\/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"\/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"\n\n\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\"\n\n\ndef test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):\n    @app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_name(app):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"\/\")\n    assert rv.data == b\"Hello Custom World!\"\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"<h1>Jameson<\/h1>\"\n\n\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True\n\n\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n\n    app.run()\n    assert not app.templates_auto_reload\n    assert not app.jinja_env.auto_reload\n\n    app.run(debug=True)\n    assert app.templates_auto_reload\n    assert app.jinja_env.auto_reload\n\n\ndef test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(self, record):\n            called.append(True)\n            text = str(record.msg)\n            assert '1: trying loader of application \"blueprintapp\"' in text\n            assert (\n                '2: trying loader of blueprint \"admin\" ' \"(blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                'trying loader of blueprint \"frontend\" ' \"(blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to \" 'the blueprint \"frontend\"'\n            ) in text\n            assert \"See http:\/\/flask.pocoo.org\/docs\/blueprints\/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(logging.getLogger(\"flask\"), \"handlers\", [_TestHandler()])\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"\/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1\n\n\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ['wsgi.errors'] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(logging.Formatter(\n    '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n))\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger('flask.app')\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: standardize license and copyright\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\ntests.test_logging\n~~~~~~~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\n\nimport logging\nimport sys\n\nimport pytest\n\nfrom flask._compat import StringIO\nfrom flask.logging import default_handler, has_level_handler, \\\n    wsgi_errors_stream\n\n\n@pytest.fixture(autouse=True)\ndef reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger('flask.app')\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(\n        name='logging-plugin')\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, 'logging-plugin')\n\n\ndef test_logger(app):\n    assert app.logger.name == 'flask.app'\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n\n\ndef test_wsgi_errors_stream(app, client):\n    @app.route('\/')\n    def index():\n        app.logger.error('test')\n        return ''\n\n    stream = StringIO()\n    client.get('\/', errors_stream=stream)\n    assert 'ERROR in test_logging: test' in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n\n\ndef test_has_level_handler():\n    logger = logging.getLogger('flask.app')\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n\n\ndef test_log_view_exception(app, client):\n    @app.route('\/')\n    def index():\n        raise Exception('test')\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get('\/', errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert 'Exception on \/ [GET]' in err\n    assert 'Exception: test' in err\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ['wsgi.errors'] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(logging.Formatter(\n    '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n))\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger('flask.app')\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: standardize license and copyright\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.templating\n    ~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: 2010 Pallets\n    :license: BSD-3-Clause\n\"\"\"\n\nimport pytest\n\nimport flask\nimport logging\nfrom jinja2 import TemplateNotFound\nimport werkzeug.serving\n\n\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {'injected_value': 42}\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('context_template.html', value=23)\n\n    rv = client.get('\/')\n    assert rv.data == b'<p>23|42'\n\n\ndef test_original_win(app, client):\n    @app.route('\/')\n    def index():\n        return flask.render_template_string('{{ config }}', config=42)\n\n    rv = client.get('\/')\n    assert rv.data == b'42'\n\n\ndef test_request_less_rendering(app, app_ctx):\n    app.config['WORLD_NAME'] = 'Special World'\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string('Hello {{ config.WORLD_NAME }} '\n                                      '{{ foo }}')\n    assert rv == 'Hello Special World 42'\n\n\ndef test_standard_context(app, client):\n    @app.route('\/')\n    def index():\n        flask.g.foo = 23\n        flask.session['test'] = 'aha'\n        return flask.render_template_string('''\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        ''')\n\n    rv = client.get('\/?foo=42')\n    assert rv.data.split() == [b'42', b'23', b'False', b'aha']\n\n\ndef test_escaping(app, client):\n    text = '<p>Hello World!'\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('escaping_template.html', text=text,\n                                     html=flask.Markup(text))\n\n    lines = client.get('\/').data.splitlines()\n    assert lines == [\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!'\n    ]\n\n\ndef test_no_escaping(app, client):\n    text = '<p>Hello World!'\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('non_escaping_template.txt', text=text,\n                                     html=flask.Markup(text))\n\n    lines = client.get('\/').data.splitlines()\n    assert lines == [\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'&lt;p&gt;Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!',\n        b'<p>Hello World!'\n    ]\n\n\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\n        '{{ foo }}', foo='<test>') == '&lt;test&gt;'\n    assert flask.render_template('mail.txt', foo='<test>') == '<test> Mail'\n\n\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute('_macro.html', 'hello')\n    assert macro('World') == 'Hello World!'\n\n\ndef test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\n\ndef test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert 'my_reverse' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['my_reverse'] == my_reverse\n    assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'\n\n\ndef test_template_filter_with_name(app):\n    @app.template_filter('strrev')\n    def my_reverse(s):\n        return s[::-1]\n\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\n\ndef test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, 'strrev')\n    assert 'strrev' in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters['strrev'] == my_reverse\n    assert app.jinja_env.filters['strrev']('abcd') == 'dcba'\n\n\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter('super_reverse')\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, 'super_reverse')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_filter.html', value='abcd')\n\n    rv = client.get('\/')\n    assert rv.data == b'dcba'\n\n\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_template_test_with_name(app):\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, 'boolean')\n    assert 'boolean' in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests['boolean'] == is_boolean\n    assert app.jinja_env.tests['boolean'](False)\n\n\ndef test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test('boolean')\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, 'boolean')\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('template_test.html', value=False)\n\n    rv = client.get('\/')\n    assert b'Success!' in rv.data\n\n\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert 'get_stuff' in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals['get_stuff'] == get_stuff\n    assert app.jinja_env.globals['get_stuff'](), 42\n\n    rv = flask.render_template_string('{{ get_stuff() }}')\n    assert rv == '42'\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n            return DictLoader({'index.html': 'Hello Custom World!'})\n\n    app = MyFlask(__name__)\n\n    @app.route('\/')\n    def index():\n        return flask.render_template('index.html')\n\n    c = app.test_client()\n    rv = c.get('\/')\n    assert rv.data == b'Hello Custom World!'\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {'whiskey': 'Jameson'}\n\n    @app.route('\/')\n    def index():\n        return flask.render_template(\n            ['no_template.xml',  # should skip this one\n             'simple_template.html',  # should render this\n             'context_template.html'],\n            value=23)\n\n    rv = client.get('\/')\n    assert rv.data == b'<h1>Jameson<\/h1>'\n\n\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    assert app.config['TEMPLATES_AUTO_RELOAD'] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config['DEBUG'] = True\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    assert app.jinja_env.auto_reload is True\n\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, 'run_simple', run_simple_mock)\n\n    app.run()\n    assert app.templates_auto_reload == False\n    assert app.jinja_env.auto_reload == False\n\n    app.run(debug=True)\n    assert app.templates_auto_reload == True\n    assert app.jinja_env.auto_reload == True\n\n\ndef test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(x, record):\n            called.append(True)\n            text = str(record.msg)\n            assert '1: trying loader of application \"blueprintapp\"' in text\n            assert ('2: trying loader of blueprint \"admin\" '\n                    '(blueprintapp.apps.admin)') in text\n            assert ('trying loader of blueprint \"frontend\" '\n                    '(blueprintapp.apps.frontend)') in text\n            assert 'Error: the template could not be found' in text\n            assert ('looked up from an endpoint that belongs to '\n                    'the blueprint \"frontend\"') in text\n            assert 'See http:\/\/flask.pocoo.org\/docs\/blueprints\/#templates' in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, 'EXPLAIN_TEMPLATE_LOADING', True)\n        monkeypatch.setattr(\n            logging.getLogger('flask'), 'handlers', [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get('\/missing')\n\n        assert 'missing_template.html' in str(excinfo.value)\n\n    assert len(called) == 1\n\n\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the the Flask apps's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: use app.name as app.logger name\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\ntests.test_logging\n~~~~~~~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\nimport logging\nimport sys\n\nimport pytest\n\nfrom flask._compat import StringIO\nfrom flask.logging import default_handler\nfrom flask.logging import has_level_handler\nfrom flask.logging import wsgi_errors_stream\n\n\n@pytest.fixture(autouse=True)\ndef reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger(\"flask_test\")\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")\n\n\ndef test_logger(app):\n    assert app.logger.name == \"flask_test\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n\n\ndef test_wsgi_errors_stream(app, client):\n    @app.route(\"\/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"\/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n\n\ndef test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n\n\ndef test_log_view_exception(app, client):\n    @app.route(\"\/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"\/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on \/ [GET]\" in err\n    assert \"Exception: test\" in err\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the the Flask apps's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: use app.name as app.logger name\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.templating\n    ~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: 2010 Pallets\n    :license: BSD-3-Clause\n\"\"\"\nimport logging\n\nimport pytest\nimport werkzeug.serving\nfrom jinja2 import TemplateNotFound\n\nimport flask\n\n\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"<p>23|42\"\n\n\ndef test_original_win(app, client):\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"42\"\n\n\ndef test_request_less_rendering(app, app_ctx):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\"\n\n\ndef test_standard_context(app, client):\n    @app.route(\"\/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"\/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]\n\n\ndef test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"\/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"\/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"\n\n\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\"\n\n\ndef test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):\n    @app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_name(app):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"\/\")\n    assert rv.data == b\"Hello Custom World!\"\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"<h1>Jameson<\/h1>\"\n\n\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True\n\n\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n\n    app.run()\n    assert not app.templates_auto_reload\n    assert not app.jinja_env.auto_reload\n\n    app.run(debug=True)\n    assert app.templates_auto_reload\n    assert app.jinja_env.auto_reload\n\n\ndef test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(self, record):\n            called.append(True)\n            text = str(record.msg)\n            assert '1: trying loader of application \"blueprintapp\"' in text\n            assert (\n                '2: trying loader of blueprint \"admin\" ' \"(blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                'trying loader of blueprint \"frontend\" ' \"(blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to \" 'the blueprint \"frontend\"'\n            ) in text\n            assert \"See http:\/\/flask.pocoo.org\/docs\/blueprints\/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(\n            logging.getLogger(\"blueprintapp\"), \"handlers\", [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"\/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1\n\n\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\nimport warnings\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef _has_config(logger):\n    \"\"\"Decide if a logger has direct configuration applied by checking\n    its properties against the defaults.\n\n    :param logger: The :class:`~logging.Logger` to inspect.\n    \"\"\"\n    return (\n        logger.level != logging.NOTSET\n        or logger.handlers\n        or logger.filters\n        or not logger.propagate\n    )\n\n\ndef create_logger(app):\n    \"\"\"Get the the Flask apps's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    # 1.1.0 changes name of logger, warn if config is detected for old\n    # name and not new name\n    for old_name in (\"flask.app\", \"flask\"):\n        old_logger = logging.getLogger(old_name)\n\n        if _has_config(old_logger) and not _has_config(logger):\n            warnings.warn(\n                \"'app.logger' is named '{name}' for this application,\"\n                \" but configuration was found for '{old_name}', which\"\n                \" no longer has an effect. The logging configuration\"\n                \" should be moved to '{name}'.\".format(name=app.name, old_name=old_name)\n            )\n            break\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: show warning for old logger config\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\ntests.test_logging\n~~~~~~~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\nimport logging\nimport sys\n\nimport pytest\n\nfrom flask._compat import StringIO\nfrom flask.logging import default_handler\nfrom flask.logging import has_level_handler\nfrom flask.logging import wsgi_errors_stream\n\n\n@pytest.fixture(autouse=True)\ndef reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger(\"flask_test\")\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")\n\n\ndef test_logger(app):\n    assert app.logger.name == \"flask_test\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n\n\ndef test_wsgi_errors_stream(app, client):\n    @app.route(\"\/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"\/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n\n\ndef test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n\n\ndef test_log_view_exception(app, client):\n    @app.route(\"\/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"\/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on \/ [GET]\" in err\n    assert \"Exception: test\" in err\n\n\ndef test_warn_old_config(app, request):\n    old_logger = logging.getLogger(\"flask.app\")\n    old_logger.setLevel(logging.DEBUG)\n    request.addfinalizer(lambda: old_logger.setLevel(logging.NOTSET))\n\n    with pytest.warns(UserWarning):\n        assert app.logger.getEffectiveLevel() == logging.WARNING\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: remove deprecated code\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\ntests.test_logging\n~~~~~~~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\nimport logging\nimport sys\n\nimport pytest\n\nfrom flask._compat import StringIO\nfrom flask.logging import default_handler\nfrom flask.logging import has_level_handler\nfrom flask.logging import wsgi_errors_stream\n\n\n@pytest.fixture(autouse=True)\ndef reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger(\"flask_test\")\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")\n\n\ndef test_logger(app):\n    assert app.logger.name == \"flask_test\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n\n\ndef test_wsgi_errors_stream(app, client):\n    @app.route(\"\/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"\/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n\n\ndef test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n\n\ndef test_log_view_exception(app, client):\n    @app.route(\"\/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"\/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on \/ [GET]\" in err\n    assert \"Exception: test\" in err\n"}
{"prompt":"Python3\n# -*- coding: utf-8 -*-\n\"\"\"\n    flask.sessions\n    ~~~~~~~~~~~~~~\n\n    Implements cookie based sessions based on itsdangerous.\n\n    :copyright: 2010 Pallets\n    :license: BSD-3-Clause\n\"\"\"\nimport hashlib\nimport warnings\nfrom collections.abc import MutableMapping\nfrom datetime import datetime\n\nfrom itsdangerous import BadSignature\nfrom itsdangerous import URLSafeTimedSerializer\nfrom werkzeug.datastructures import CallbackDict\n\nfrom .helpers import is_ip\nfrom .helpers import total_seconds\nfrom .json.tag import TaggedJSONSerializer\n\n\nclass SessionMixin(MutableMapping):\n    \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n\n    @property\n    def permanent(self):\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)\n\n    @permanent.setter\n    def permanent(self, value):\n        self[\"_permanent\"] = bool(value)\n\n    #: Some implementations can detect whether a session is newly\n    #: created, but that is not guaranteed. Use with caution. The mixin\n    # default is hard-coded ``False``.\n    new = False\n\n    #: Some implementations can detect changes to the session and set\n    #: this when that happens. The mixin default is hard coded to\n    #: ``True``.\n    modified = True\n\n    #: Some implementations can detect when session data is read or\n    #: written and set this when that happens. The mixin default is hard\n    #: coded to ``True``.\n    accessed = True\n\n\nclass SecureCookieSession(CallbackDict, SessionMixin):\n    \"\"\"Base class for sessions based on signed cookies.\n\n    This session backend will set the :attr:`modified` and\n    :attr:`accessed` attributes. It cannot reliably track whether a\n    session is new (vs. empty), so :attr:`new` remains hard coded to\n    ``False``.\n    \"\"\"\n\n    #: When data is changed, this is set to ``True``. Only the session\n    #: dictionary itself is tracked; if the session contains mutable\n    #: data (for example a nested dict) then this must be set to\n    #: ``True`` manually when modifying that data. The session cookie\n    #: will only be written to the response if this is ``True``.\n    modified = False\n\n    #: When data is read or written, this is set to ``True``. Used by\n    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``\n    #: header, which allows caching proxies to cache different pages for\n    #: different users.\n    accessed = False\n\n    def __init__(self, initial=None):\n        def on_update(self):\n            self.modified = True\n            self.accessed = True\n\n        super(SecureCookieSession, self).__init__(initial, on_update)\n\n    def __getitem__(self, key):\n        self.accessed = True\n        return super(SecureCookieSession, self).__getitem__(key)\n\n    def get(self, key, default=None):\n        self.accessed = True\n        return super(SecureCookieSession, self).get(key, default)\n\n    def setdefault(self, key, default=None):\n        self.accessed = True\n        return super(SecureCookieSession, self).setdefault(key, default)\n\n\nclass NullSession(SecureCookieSession):\n    \"\"\"Class used to generate nicer error messages if sessions are not\n    available.  Will still allow read-only access to the empty session\n    but fail on setting.\n    \"\"\"\n\n    def _fail(self, *args, **kwargs):\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n\n    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail\n    del _fail\n\n\nclass SessionInterface(object):\n    \"\"\"The basic interface you have to implement in order to replace the\n    default session interface which uses werkzeug's securecookie\n    implementation.  The only methods you have to implement are\n    :meth:`open_session` and :meth:`save_session`, the others have\n    useful defaults which you don't need to change.\n\n    The session object returned by the :meth:`open_session` method has to\n    provide a dictionary like interface plus the properties and methods\n    from the :class:`SessionMixin`.  We recommend just subclassing a dict\n    and adding that mixin::\n\n        class Session(dict, SessionMixin):\n            pass\n\n    If :meth:`open_session` returns ``None`` Flask will call into\n    :meth:`make_null_session` to create a session that acts as replacement\n    if the session support cannot work because some requirement is not\n    fulfilled.  The default :class:`NullSession` class that is created\n    will complain that the secret key was not set.\n\n    To replace the session interface on an application all you have to do\n    is to assign :attr:`flask.Flask.session_interface`::\n\n        app = Flask(__name__)\n        app.session_interface = MySessionInterface()\n\n    .. versionadded:: 0.8\n    \"\"\"\n\n    #: :meth:`make_null_session` will look here for the class that should\n    #: be created when a null session is requested.  Likewise the\n    #: :meth:`is_null_session` method will perform a typecheck against\n    #: this type.\n    null_session_class = NullSession\n\n    #: A flag that indicates if the session interface is pickle based.\n    #: This can be used by Flask extensions to make a decision in regards\n    #: to how to deal with the session object.\n    #:\n    #: .. versionadded:: 0.10\n    pickle_based = False\n\n    def make_null_session(self, app):\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n\n    def is_null_session(self, obj):\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n\n    def get_cookie_name(self, app):\n        \"\"\"Returns the name of the session cookie.\n\n        Uses ``app.session_cookie_name`` which is set to ``SESSION_COOKIE_NAME``\n        \"\"\"\n        return app.session_cookie_name\n\n    def get_cookie_domain(self, app):\n        \"\"\"Returns the domain that should be set for the session cookie.\n\n        Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise\n        falls back to detecting the domain based on ``SERVER_NAME``.\n\n        Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is\n        updated to avoid re-running the logic.\n        \"\"\"\n\n        rv = app.config[\"SESSION_COOKIE_DOMAIN\"]\n\n        # set explicitly, or cached from SERVER_NAME detection\n        # if False, return None\n        if rv is not None:\n            return rv if rv else None\n\n        rv = app.config[\"SERVER_NAME\"]\n\n        # server name not set, cache False to return none next time\n        if not rv:\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        # chop off the port which is usually not supported by browsers\n        # remove any leading '.' since we'll add that later\n        rv = rv.rsplit(\":\", 1)[0].lstrip(\".\")\n\n        if \".\" not in rv:\n            # Chrome doesn't allow names without a '.'\n            # this should only come up with localhost\n            # hack around this by not setting the name, and show a warning\n            warnings.warn(\n                '\"{rv}\" is not a valid cookie domain, it must contain a \".\".'\n                \" Add an entry to your hosts file, for example\"\n                ' \"{rv}.localdomain\", and use that instead.'.format(rv=rv)\n            )\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        ip = is_ip(rv)\n\n        if ip:\n            warnings.warn(\n                \"The session cookie domain is an IP address. This may not work\"\n                \" as intended in some browsers. Add an entry to your hosts\"\n                ' file, for example \"localhost.localdomain\", and use that'\n                \" instead.\"\n            )\n\n        # if this is not an ip and app is mounted at the root, allow subdomain\n        # matching by adding a '.' prefix\n        if self.get_cookie_path(app) == \"\/\" and not ip:\n            rv = \".\" + rv\n\n        app.config[\"SESSION_COOKIE_DOMAIN\"] = rv\n        return rv\n\n    def get_cookie_path(self, app):\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``\/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]\n\n    def get_cookie_httponly(self, app):\n        \"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_HTTPONLY\"]\n\n    def get_cookie_secure(self, app):\n        \"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SECURE\"]\n\n    def get_cookie_samesite(self, app):\n        \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SAMESITE\"]\n\n    def get_expiration_time(self, app, session):\n        \"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"\n        if session.permanent:\n            return datetime.utcnow() + app.permanent_session_lifetime\n\n    def should_set_cookie(self, app, session):\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n\n    def open_session(self, app, request):\n        \"\"\"This method has to be implemented and must either return ``None``\n        in case the loading failed because of a configuration error or an\n        instance of a session object which implements a dictionary like\n        interface + the methods and attributes on :class:`SessionMixin`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def save_session(self, app, session, response):\n        \"\"\"This is called for actual sessions returned by :meth:`open_session`\n        at the end of the request.  This is still called during a request\n        context so if you absolutely need access to the request you can do\n        that.\n        \"\"\"\n        raise NotImplementedError()\n\n\nsession_json_serializer = TaggedJSONSerializer()\n\n\nclass SecureCookieSessionInterface(SessionInterface):\n    \"\"\"The default session interface that stores sessions in signed cookies\n    through the :mod:`itsdangerous` module.\n    \"\"\"\n\n    #: the salt that should be applied on top of the secret key for the\n    #: signing of cookie based sessions.\n    salt = \"cookie-session\"\n    #: the hash function to use for the signature.  The default is sha1\n    digest_method = staticmethod(hashlib.sha1)\n    #: the name of the itsdangerous supported key derivation.  The default\n    #: is hmac.\n    key_derivation = \"hmac\"\n    #: A python serializer for the payload.  The default is a compact\n    #: JSON derived serializer with support for some extra Python types\n    #: such as datetime objects or tuples.\n    serializer = session_json_serializer\n    session_class = SecureCookieSession\n\n    def get_signing_serializer(self, app):\n        if not app.secret_key:\n            return None\n        signer_kwargs = dict(\n            key_derivation=self.key_derivation, digest_method=self.digest_method\n        )\n        return URLSafeTimedSerializer(\n            app.secret_key,\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs=signer_kwargs,\n        )\n\n    def open_session(self, app, request):\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = total_seconds(app.permanent_session_lifetime)\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n\n    def save_session(self, app, session, response):\n        name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(name, domain=domain, path=path)\n\n            return\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        httponly = self.get_cookie_httponly(app)\n        secure = self.get_cookie_secure(app)\n        samesite = self.get_cookie_samesite(app)\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))\n        response.set_cookie(\n            name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            samesite=samesite,\n        )\n\n\"\"\"\nGenerate tests which test: remove _compat module\n\"\"\"\n","completion":" # -*- coding: utf-8 -*-\n\"\"\"\n    tests.helpers\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Various helpers.\n\n    :copyright: 2010 Pallets\n    :license: BSD-3-Clause\n\"\"\"\nimport datetime\nimport io\nimport os\nimport sys\nimport uuid\n\nimport pytest\nfrom werkzeug.datastructures import Range\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import http_date\nfrom werkzeug.http import parse_cache_control_header\nfrom werkzeug.http import parse_options_header\n\nimport flask\nfrom flask import json\nfrom flask.helpers import get_debug_flag\nfrom flask.helpers import get_env\n\n\ndef has_encoding(name):\n    try:\n        import codecs\n\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n\n\nclass FakePath(object):\n    \"\"\"Fake object to represent a ``PathLike object``.\n\n    This represents a ``pathlib.Path`` object in python 3.\n    See: https:\/\/www.python.org\/dev\/peps\/pep-0519\/\n    \"\"\"\n\n    def __init__(self, path):\n        self.path = path\n\n    def __fspath__(self):\n        return self.path\n\n\nclass FixedOffset(datetime.tzinfo):\n    \"\"\"Fixed offset in hours east from UTC.\n\n    This is a slight adaptation of the ``FixedOffset`` example found in\n    https:\/\/docs.python.org\/2.7\/library\/datetime.html.\n    \"\"\"\n\n    def __init__(self, hours, name):\n        self.__offset = datetime.timedelta(hours=hours)\n        self.__name = name\n\n    def utcoffset(self, dt):\n        return self.__offset\n\n    def tzname(self, dt):\n        return self.__name\n\n    def dst(self, dt):\n        return datetime.timedelta()\n\n\nclass TestJSON(object):\n    @pytest.mark.parametrize(\n        \"value\", (1, \"t\", True, False, None, [], [1, 2, 3], {}, {\"foo\": u\"\ud83d\udc0d\"})\n    )\n    @pytest.mark.parametrize(\n        \"encoding\",\n        (\n            \"utf-8\",\n            \"utf-8-sig\",\n            \"utf-16-le\",\n            \"utf-16-be\",\n            \"utf-16\",\n            \"utf-32-le\",\n            \"utf-32-be\",\n            \"utf-32\",\n        ),\n    )\n    def test_detect_encoding(self, value, encoding):\n        data = json.dumps(value).encode(encoding)\n        assert json.detect_encoding(data) == encoding\n        assert json.loads(data) == value\n\n    @pytest.mark.parametrize(\"debug\", (True, False))\n    def test_bad_request_debug_message(self, app, client, debug):\n        app.config[\"DEBUG\"] = debug\n        app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def post_json():\n            flask.request.get_json()\n            return None\n\n        rv = client.post(\"\/json\", data=None, content_type=\"application\/json\")\n        assert rv.status_code == 400\n        contains = b\"Failed to decode JSON object\" in rv.data\n        assert contains == debug\n\n    def test_json_bad_requests(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.jsonify(foo=str(flask.request.get_json()))\n\n        rv = client.post(\"\/json\", data=\"malformed\", content_type=\"application\/json\")\n        assert rv.status_code == 400\n\n    def test_json_custom_mimetypes(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.request.get_json()\n\n        rv = client.post(\"\/json\", data='\"foo\"', content_type=\"application\/x+json\")\n        assert rv.data == b\"foo\"\n\n    @pytest.mark.parametrize(\n        \"test_value,expected\", [(True, '\"\\\\u2603\"'), (False, u'\"\\u2603\"')]\n    )\n    def test_json_as_unicode(self, test_value, expected, app, app_ctx):\n\n        app.config[\"JSON_AS_ASCII\"] = test_value\n        rv = flask.json.dumps(u\"\\N{SNOWMAN}\")\n        assert rv == expected\n\n    def test_json_dump_to_file(self, app, app_ctx):\n        test_data = {\"name\": \"Flask\"}\n        out = io.StringIO()\n\n        flask.json.dump(test_data, out)\n        out.seek(0)\n        rv = flask.json.load(out)\n        assert rv == test_data\n\n    @pytest.mark.parametrize(\n        \"test_value\", [0, -1, 1, 23, 3.14, \"s\", \"longer string\", True, False, None]\n    )\n    def test_jsonify_basic_types(self, test_value, app, client):\n        \"\"\"Test jsonify with basic types.\"\"\"\n\n        url = \"\/jsonify_basic_types\"\n        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n        rv = client.get(url)\n        assert rv.mimetype == \"application\/json\"\n        assert flask.json.loads(rv.data) == test_value\n\n    def test_jsonify_dicts(self, app, client):\n        \"\"\"Test jsonify with dicts and kwargs unpacking.\"\"\"\n        d = {\n            \"a\": 0,\n            \"b\": 23,\n            \"c\": 3.14,\n            \"d\": \"t\",\n            \"e\": \"Hi\",\n            \"f\": True,\n            \"g\": False,\n            \"h\": [\"test list\", 10, False],\n            \"i\": {\"test\": \"dict\"},\n        }\n\n        @app.route(\"\/kw\")\n        def return_kwargs():\n            return flask.jsonify(**d)\n\n        @app.route(\"\/dict\")\n        def return_dict():\n            return flask.jsonify(d)\n\n        for url in \"\/kw\", \"\/dict\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == d\n\n    def test_jsonify_arrays(self, app, client):\n        \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n        a_list = [\n            0,\n            42,\n            3.14,\n            \"t\",\n            \"hello\",\n            True,\n            False,\n            [\"test list\", 2, False],\n            {\"test\": \"dict\"},\n        ]\n\n        @app.route(\"\/args_unpack\")\n        def return_args_unpack():\n            return flask.jsonify(*a_list)\n\n        @app.route(\"\/array\")\n        def return_array():\n            return flask.jsonify(a_list)\n\n        for url in \"\/args_unpack\", \"\/array\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == a_list\n\n    def test_jsonify_date_types(self, app, client):\n        \"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"\n        test_dates = (\n            datetime.datetime(1973, 3, 11, 6, 30, 45),\n            datetime.date(1975, 1, 5),\n        )\n\n        for i, d in enumerate(test_dates):\n            url = \"\/datetest{0}\".format(i)\n            app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data)[\"x\"] == http_date(d.timetuple())\n\n    @pytest.mark.parametrize(\"tz\", ((\"UTC\", 0), (\"PST\", -8), (\"KST\", 9)))\n    def test_jsonify_aware_datetimes(self, tz):\n        \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n        tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n        dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n        gmt = FixedOffset(hours=0, name=\"GMT\")\n        expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n        assert flask.json.JSONEncoder().encode(dt) == expected\n\n    def test_jsonify_uuid_types(self, app, client):\n        \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n        test_uuid = uuid.UUID(bytes=b\"\\xDE\\xAD\\xBE\\xEF\" * 4)\n        url = \"\/uuid_test\"\n        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n        rv = client.get(url)\n\n        rv_x = flask.json.loads(rv.data)[\"x\"]\n        assert rv_x == str(test_uuid)\n        rv_uuid = uuid.UUID(rv_x)\n        assert rv_uuid == test_uuid\n\n    def test_json_attr(self, app, client):\n        @app.route(\"\/add\", methods=[\"POST\"])\n        def add():\n            json = flask.request.get_json()\n            return str(json[\"a\"] + json[\"b\"])\n\n        rv = client.post(\n            \"\/add\",\n            data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b\"3\"\n\n    def test_template_escaping(self, app, req_ctx):\n        render = flask.render_template_string\n        rv = flask.json.htmlsafe_dumps(\"<\/script>\")\n        assert rv == u'\"\\\\u003c\/script\\\\u003e\"'\n        assert type(rv) is str\n        rv = render('{{ \"<\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n        rv = render('{{ \"<\\0\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\\\\u0000\/script\\\\u003e\"'\n        rv = render('{{ \"<!--<script>\"|tojson }}')\n        assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n        rv = render('{{ \"&\"|tojson }}')\n        assert rv == '\"\\\\u0026\"'\n        rv = render('{{ \"\\'\"|tojson }}')\n        assert rv == '\"\\\\u0027\"'\n        rv = render(\n            \"<a ng-data='{{ data|tojson }}'><\/a>\", data={\"x\": [\"foo\", \"bar\", \"baz'\"]}\n        )\n        assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'><\/a>'\n\n    def test_json_customization(self, app, client):\n        class X(object):  # noqa: B903, for Python2 compatibility\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return \"<%d>\" % o.val\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n                return obj\n\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n\n        @app.route(\"\/\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        rv = client.post(\n            \"\/\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    def test_blueprint_json_customization(self, app, client):\n        class X(object):  # noqa: B903, for Python2 compatibility\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return \"<%d>\" % o.val\n\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n\n                return obj\n\n        bp = flask.Blueprint(\"bp\", __name__)\n        bp.json_encoder = MyEncoder\n        bp.json_decoder = MyDecoder\n\n        @bp.route(\"\/bp\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        app.register_blueprint(bp)\n\n        rv = client.post(\n            \"\/bp\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    @pytest.mark.skipif(\n        not has_encoding(\"euc-kr\"), reason=\"The euc-kr encoding is required.\"\n    )\n    def test_modified_url_encoding(self, app, client):\n        class ModifiedRequest(flask.Request):\n            url_charset = \"euc-kr\"\n\n        app.request_class = ModifiedRequest\n        app.url_map.charset = \"euc-kr\"\n\n        @app.route(\"\/\")\n        def index():\n            return flask.request.args[\"foo\"]\n\n        rv = client.get(u\"\/?foo=\uc815\uc0c1\ucc98\ub9ac\".encode(\"euc-kr\"))\n        assert rv.status_code == 200\n        assert rv.data == u\"\uc815\uc0c1\ucc98\ub9ac\".encode(\"utf-8\")\n\n    def test_json_key_sorting(self, app, client):\n        app.debug = True\n\n        assert app.config[\"JSON_SORT_KEYS\"]\n        d = dict.fromkeys(range(20), \"foo\")\n\n        @app.route(\"\/\")\n        def index():\n            return flask.jsonify(values=d)\n\n        rv = client.get(\"\/\")\n        lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n        sorted_by_str = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n        sorted_by_int = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n\n        try:\n            assert lines == sorted_by_int\n        except AssertionError:\n            assert lines == sorted_by_str\n\n\nclass PyBytesIO(object):\n    def __init__(self, *args, **kwargs):\n        self._io = io.BytesIO(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._io, name)\n\n\nclass TestSendfile(object):\n    def test_send_file_regular(self, app, req_ctx):\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    def test_send_file_xsendfile(self, app, req_ctx):\n        app.use_x_sendfile = True\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert \"x-sendfile\" in rv.headers\n        assert rv.headers[\"x-sendfile\"] == os.path.join(\n            app.root_path, \"static\/index.html\"\n        )\n        assert rv.mimetype == \"text\/html\"\n        rv.close()\n\n    def test_send_file_last_modified(self, app, client):\n        last_modified = datetime.datetime(1999, 1, 1)\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\n                io.BytesIO(b\"party like it's\"),\n                last_modified=last_modified,\n                mimetype=\"text\/plain\",\n            )\n\n        rv = client.get(\"\/\")\n        assert rv.last_modified == last_modified\n\n    def test_send_file_object_without_mimetype(self, app, req_ctx):\n        with pytest.raises(ValueError) as excinfo:\n            flask.send_file(io.BytesIO(b\"LOL\"))\n        assert \"Unable to infer MIME-type\" in str(excinfo.value)\n        assert \"no filename is available\" in str(excinfo.value)\n\n        flask.send_file(io.BytesIO(b\"LOL\"), attachment_filename=\"filename\")\n\n    @pytest.mark.parametrize(\n        \"opener\",\n        [\n            lambda app: open(os.path.join(app.static_folder, \"index.html\"), \"rb\"),\n            lambda app: io.BytesIO(b\"Test\"),\n            lambda app: PyBytesIO(b\"Test\"),\n        ],\n    )\n    @pytest.mark.usefixtures(\"req_ctx\")\n    def test_send_file_object(self, app, opener):\n        file = opener(app)\n        app.use_x_sendfile = True\n        rv = flask.send_file(file, mimetype=\"text\/plain\")\n        rv.direct_passthrough = False\n        assert rv.data\n        assert rv.mimetype == \"text\/plain\"\n        assert \"x-sendfile\" not in rv.headers\n        rv.close()\n\n    @pytest.mark.parametrize(\n        \"opener\",\n        [\n            lambda app: io.StringIO(u\"Test\"),\n            lambda app: open(os.path.join(app.static_folder, \"index.html\")),\n        ],\n    )\n    @pytest.mark.usefixtures(\"req_ctx\")\n    def test_send_file_text_fails(self, app, opener):\n        file = opener(app)\n\n        with pytest.raises(ValueError):\n            flask.send_file(file, mimetype=\"text\/plain\")\n\n        file.close()\n\n    def test_send_file_pathlike(self, app, req_ctx):\n        rv = flask.send_file(FakePath(\"static\/index.html\"))\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, \"to_content_range_header\", None)),\n        reason=\"not implemented within werkzeug\",\n    )\n    def test_send_file_range_request(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:16]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-1000\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-10\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[-10:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"somethingsomething\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        last_modified = datetime.datetime.utcfromtimestamp(\n            os.path.getmtime(os.path.join(app.root_path, \"static\/index.html\"))\n        ).replace(microsecond=0)\n\n        rv = client.get(\n            \"\/\", headers={\"Range\": \"bytes=4-15\", \"If-Range\": http_date(last_modified)}\n        )\n        assert rv.status_code == 206\n        rv.close()\n\n        rv = client.get(\n            \"\/\",\n            headers={\n                \"Range\": \"bytes=4-15\",\n                \"If-Range\": http_date(datetime.datetime(1999, 1, 1)),\n            },\n        )\n        assert rv.status_code == 200\n        rv.close()\n\n    def test_send_file_range_request_bytesio(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            file = io.BytesIO(b\"somethingsomething\")\n            return flask.send_file(\n                file, attachment_filename=\"filename\", conditional=True\n            )\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        assert rv.data == b\"somethingsomething\"[4:16]\n        rv.close()\n\n    def test_send_file_range_request_xsendfile_invalid(self, app, client):\n        # https:\/\/github.com\/pallets\/flask\/issues\/2526\n        app.use_x_sendfile = True\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n    def test_attachment(self, app, req_ctx):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            with open(os.path.join(app.root_path, \"static\/index.html\"), \"rb\") as f:\n                rv = flask.send_file(\n                    f, as_attachment=True, attachment_filename=\"index.html\"\n                )\n                value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n                assert value == \"attachment\"\n                rv.close()\n\n        with open(os.path.join(app.root_path, \"static\/index.html\"), \"rb\") as f:\n            rv = flask.send_file(\n                f, as_attachment=True, attachment_filename=\"index.html\"\n            )\n            value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n            assert value == \"attachment\"\n            assert options[\"filename\"] == \"index.html\"\n            assert \"filename*\" not in rv.headers[\"Content-Disposition\"]\n            rv.close()\n\n        rv = flask.send_file(\"static\/index.html\", as_attachment=True)\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.html\"\n        rv.close()\n\n        rv = flask.send_file(\n            io.BytesIO(b\"Test\"),\n            as_attachment=True,\n            attachment_filename=\"index.txt\",\n            add_etags=False,\n        )\n        assert rv.mimetype == \"text\/plain\"\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.txt\"\n        rv.close()\n\n    @pytest.mark.usefixtures(\"req_ctx\")\n    @pytest.mark.parametrize(\n        (\"filename\", \"ascii\", \"utf8\"),\n        (\n            (\"index.html\", \"index.html\", False),\n            (\n                u\"\u00d1and\u00fa\uff0fping\u00fcino.txt\",\n                '\"Nandu\/pinguino.txt\"',\n                \"%C3%91and%C3%BA%EF%BC%8Fping%C3%BCino.txt\",\n            ),\n            (u\"V\u00f6gel.txt\", \"Vogel.txt\", \"V%C3%B6gel.txt\"),\n            # Native string not marked as Unicode on Python 2\n            (\"t\u00e9st.txt\", \"test.txt\", \"t%C3%A9st.txt\"),\n            # \":\/\" are not safe in filename* value\n            (u\"\u0442\u0435:\/\u0441\u0442\", '\":\/\"', \"%D1%82%D0%B5%3A%2F%D1%81%D1%82\"),\n        ),\n    )\n    def test_attachment_filename_encoding(self, filename, ascii, utf8):\n        rv = flask.send_file(\n            \"static\/index.html\", as_attachment=True, attachment_filename=filename\n        )\n        rv.close()\n        content_disposition = rv.headers[\"Content-Disposition\"]\n        assert \"filename=%s\" % ascii in content_disposition\n        if utf8:\n            assert \"filename*=UTF-8''\" + utf8 in content_disposition\n        else:\n            assert \"filename*=UTF-8''\" not in content_disposition\n\n    def test_static_file(self, app, req_ctx):\n        # default cache timeout is 12 hours\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        # Test with static file handler.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file(\"static\/index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n\n    def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_pathlike(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(FakePath(\"static\"), FakePath(\"hello.txt\"))\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_null_character(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n\n        if sys.version_info >= (3, 8):\n            exception = NotFound\n        else:\n            exception = BadRequest\n\n        with pytest.raises(exception):\n            flask.send_from_directory(\"static\", \"bad\\x00\")\n\n\nclass TestUrlFor(object):\n    def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"\/#x%20y\"\n\n    def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n\n    def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        pytest.raises(ValueError, flask.url_for, \"index\", _scheme=\"https\")\n\n    def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n\n    def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return \"Get %d\" % id\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"\/myview\/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"\/myview\/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"\/myview\/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"\/myview\/create\"\n\n\nclass TestNoImports(object):\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self, modules_tmpdir):\n        modules_tmpdir.join(\"importerror.py\").write(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")\n\n\nclass TestStreaming(object):\n    def test_streaming_with_context(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper(object):\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]\n\n    def test_stream_keeps_session(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"\/\")\n        assert rv.data == b\"flask\"\n\n\nclass TestSafeJoin(object):\n    def test_safe_join(self):\n        # Valid combinations of *args and expected joined paths.\n        passing = (\n            ((\"a\/b\/c\",), \"a\/b\/c\"),\n            ((\"\/\", \"a\/\", \"b\/\", \"c\/\"), \"\/a\/b\/c\"),\n            ((\"a\", \"b\", \"c\"), \"a\/b\/c\"),\n            ((\"\/a\", \"b\/c\"), \"\/a\/b\/c\"),\n            ((\"a\/b\", \"X\/..\/c\"), \"a\/b\/c\"),\n            ((\"\/a\/b\", \"c\/X\/..\"), \"\/a\/b\/c\"),\n            # If last path is '' add a slash\n            ((\"\/a\/b\/c\", \"\"), \"\/a\/b\/c\/\"),\n            # Preserve dot slash\n            ((\"\/a\/b\/c\", \".\/\"), \"\/a\/b\/c\/.\"),\n            ((\"a\/b\/c\", \"X\/..\"), \"a\/b\/c\/.\"),\n            # Base directory is always considered safe\n            ((\"..\/\", \"a\/b\/c\"), \"..\/a\/b\/c\"),\n            ((\"\/..\",), \"\/..\"),\n        )\n\n        for args, expected in passing:\n            assert flask.safe_join(*args) == expected\n\n    def test_safe_join_exceptions(self):\n        # Should raise werkzeug.exceptions.NotFound on unsafe joins.\n        failing = (\n            # path.isabs and ``..'' checks\n            (\"\/a\", \"b\", \"\/c\"),\n            (\"\/a\", \"..\/b\/c\"),\n            (\"\/a\", \"..\", \"b\/c\"),\n            # Boundaries violations after path normalization\n            (\"\/a\", \"b\/..\/b\/..\/..\/c\"),\n            (\"\/a\", \"b\", \"c\/..\/..\"),\n            (\"\/a\", \"b\/..\/..\/c\"),\n        )\n\n        for args in failing:\n            with pytest.raises(NotFound):\n                print(flask.safe_join(*args))\n\n\nclass TestHelpers(object):\n    @pytest.mark.parametrize(\n        \"debug, expected_flag, expected_default_flag\",\n        [\n            (\"\", False, False),\n            (\"0\", False, False),\n            (\"False\", False, False),\n            (\"No\", False, False),\n            (\"True\", True, True),\n        ],\n    )\n    def test_get_debug_flag(\n        self, monkeypatch, debug, expected_flag, expected_default_flag\n    ):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        if expected_flag is None:\n            assert get_debug_flag() is None\n        else:\n            assert get_debug_flag() == expected_flag\n        assert get_debug_flag() == expected_default_flag\n\n    @pytest.mark.parametrize(\n        \"env, ref_env, debug\",\n        [\n            (\"\", \"production\", False),\n            (\"production\", \"production\", False),\n            (\"development\", \"development\", True),\n            (\"other\", \"other\", False),\n        ],\n    )\n    def test_get_env(self, monkeypatch, env, ref_env, debug):\n        monkeypatch.setenv(\"FLASK_ENV\", env)\n        assert get_debug_flag() == debug\n        assert get_env() == ref_env\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text\/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text\/html\"\n\n    @pytest.mark.parametrize(\"mode\", (\"r\", \"rb\", \"rt\"))\n    def test_open_resource(self, mode):\n        app = flask.Flask(__name__)\n\n        with app.open_resource(\"static\/index.html\", mode) as f:\n            assert \"<h1>Hello World!<\/h1>\" in str(f.read())\n\n    @pytest.mark.parametrize(\"mode\", (\"w\", \"x\", \"a\", \"r+\"))\n    def test_open_resource_exceptions(self, mode):\n        app = flask.Flask(__name__)\n\n        with pytest.raises(ValueError):\n            app.open_resource(\"static\/index.html\", mode)\n"}
{"prompt":"Python3\n\"\"\"\n    flask.sessions\n    ~~~~~~~~~~~~~~\n\n    Implements cookie based sessions based on itsdangerous.\n\n    :copyright: 2010 Pallets\n    :license: BSD-3-Clause\n\"\"\"\nimport hashlib\nimport warnings\nfrom collections.abc import MutableMapping\nfrom datetime import datetime\n\nfrom itsdangerous import BadSignature\nfrom itsdangerous import URLSafeTimedSerializer\nfrom werkzeug.datastructures import CallbackDict\n\nfrom .helpers import is_ip\nfrom .helpers import total_seconds\nfrom .json.tag import TaggedJSONSerializer\n\n\nclass SessionMixin(MutableMapping):\n    \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n\n    @property\n    def permanent(self):\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)\n\n    @permanent.setter\n    def permanent(self, value):\n        self[\"_permanent\"] = bool(value)\n\n    #: Some implementations can detect whether a session is newly\n    #: created, but that is not guaranteed. Use with caution. The mixin\n    # default is hard-coded ``False``.\n    new = False\n\n    #: Some implementations can detect changes to the session and set\n    #: this when that happens. The mixin default is hard coded to\n    #: ``True``.\n    modified = True\n\n    #: Some implementations can detect when session data is read or\n    #: written and set this when that happens. The mixin default is hard\n    #: coded to ``True``.\n    accessed = True\n\n\nclass SecureCookieSession(CallbackDict, SessionMixin):\n    \"\"\"Base class for sessions based on signed cookies.\n\n    This session backend will set the :attr:`modified` and\n    :attr:`accessed` attributes. It cannot reliably track whether a\n    session is new (vs. empty), so :attr:`new` remains hard coded to\n    ``False``.\n    \"\"\"\n\n    #: When data is changed, this is set to ``True``. Only the session\n    #: dictionary itself is tracked; if the session contains mutable\n    #: data (for example a nested dict) then this must be set to\n    #: ``True`` manually when modifying that data. The session cookie\n    #: will only be written to the response if this is ``True``.\n    modified = False\n\n    #: When data is read or written, this is set to ``True``. Used by\n    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``\n    #: header, which allows caching proxies to cache different pages for\n    #: different users.\n    accessed = False\n\n    def __init__(self, initial=None):\n        def on_update(self):\n            self.modified = True\n            self.accessed = True\n\n        super().__init__(initial, on_update)\n\n    def __getitem__(self, key):\n        self.accessed = True\n        return super().__getitem__(key)\n\n    def get(self, key, default=None):\n        self.accessed = True\n        return super().get(key, default)\n\n    def setdefault(self, key, default=None):\n        self.accessed = True\n        return super().setdefault(key, default)\n\n\nclass NullSession(SecureCookieSession):\n    \"\"\"Class used to generate nicer error messages if sessions are not\n    available.  Will still allow read-only access to the empty session\n    but fail on setting.\n    \"\"\"\n\n    def _fail(self, *args, **kwargs):\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n\n    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail\n    del _fail\n\n\nclass SessionInterface:\n    \"\"\"The basic interface you have to implement in order to replace the\n    default session interface which uses werkzeug's securecookie\n    implementation.  The only methods you have to implement are\n    :meth:`open_session` and :meth:`save_session`, the others have\n    useful defaults which you don't need to change.\n\n    The session object returned by the :meth:`open_session` method has to\n    provide a dictionary like interface plus the properties and methods\n    from the :class:`SessionMixin`.  We recommend just subclassing a dict\n    and adding that mixin::\n\n        class Session(dict, SessionMixin):\n            pass\n\n    If :meth:`open_session` returns ``None`` Flask will call into\n    :meth:`make_null_session` to create a session that acts as replacement\n    if the session support cannot work because some requirement is not\n    fulfilled.  The default :class:`NullSession` class that is created\n    will complain that the secret key was not set.\n\n    To replace the session interface on an application all you have to do\n    is to assign :attr:`flask.Flask.session_interface`::\n\n        app = Flask(__name__)\n        app.session_interface = MySessionInterface()\n\n    .. versionadded:: 0.8\n    \"\"\"\n\n    #: :meth:`make_null_session` will look here for the class that should\n    #: be created when a null session is requested.  Likewise the\n    #: :meth:`is_null_session` method will perform a typecheck against\n    #: this type.\n    null_session_class = NullSession\n\n    #: A flag that indicates if the session interface is pickle based.\n    #: This can be used by Flask extensions to make a decision in regards\n    #: to how to deal with the session object.\n    #:\n    #: .. versionadded:: 0.10\n    pickle_based = False\n\n    def make_null_session(self, app):\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n\n    def is_null_session(self, obj):\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n\n    def get_cookie_name(self, app):\n        \"\"\"Returns the name of the session cookie.\n\n        Uses ``app.session_cookie_name`` which is set to ``SESSION_COOKIE_NAME``\n        \"\"\"\n        return app.session_cookie_name\n\n    def get_cookie_domain(self, app):\n        \"\"\"Returns the domain that should be set for the session cookie.\n\n        Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise\n        falls back to detecting the domain based on ``SERVER_NAME``.\n\n        Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is\n        updated to avoid re-running the logic.\n        \"\"\"\n\n        rv = app.config[\"SESSION_COOKIE_DOMAIN\"]\n\n        # set explicitly, or cached from SERVER_NAME detection\n        # if False, return None\n        if rv is not None:\n            return rv if rv else None\n\n        rv = app.config[\"SERVER_NAME\"]\n\n        # server name not set, cache False to return none next time\n        if not rv:\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        # chop off the port which is usually not supported by browsers\n        # remove any leading '.' since we'll add that later\n        rv = rv.rsplit(\":\", 1)[0].lstrip(\".\")\n\n        if \".\" not in rv:\n            # Chrome doesn't allow names without a '.'\n            # this should only come up with localhost\n            # hack around this by not setting the name, and show a warning\n            warnings.warn(\n                '\"{rv}\" is not a valid cookie domain, it must contain a \".\".'\n                \" Add an entry to your hosts file, for example\"\n                ' \"{rv}.localdomain\", and use that instead.'.format(rv=rv)\n            )\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        ip = is_ip(rv)\n\n        if ip:\n            warnings.warn(\n                \"The session cookie domain is an IP address. This may not work\"\n                \" as intended in some browsers. Add an entry to your hosts\"\n                ' file, for example \"localhost.localdomain\", and use that'\n                \" instead.\"\n            )\n\n        # if this is not an ip and app is mounted at the root, allow subdomain\n        # matching by adding a '.' prefix\n        if self.get_cookie_path(app) == \"\/\" and not ip:\n            rv = \".\" + rv\n\n        app.config[\"SESSION_COOKIE_DOMAIN\"] = rv\n        return rv\n\n    def get_cookie_path(self, app):\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``\/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]\n\n    def get_cookie_httponly(self, app):\n        \"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_HTTPONLY\"]\n\n    def get_cookie_secure(self, app):\n        \"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SECURE\"]\n\n    def get_cookie_samesite(self, app):\n        \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SAMESITE\"]\n\n    def get_expiration_time(self, app, session):\n        \"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"\n        if session.permanent:\n            return datetime.utcnow() + app.permanent_session_lifetime\n\n    def should_set_cookie(self, app, session):\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n\n    def open_session(self, app, request):\n        \"\"\"This method has to be implemented and must either return ``None``\n        in case the loading failed because of a configuration error or an\n        instance of a session object which implements a dictionary like\n        interface + the methods and attributes on :class:`SessionMixin`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def save_session(self, app, session, response):\n        \"\"\"This is called for actual sessions returned by :meth:`open_session`\n        at the end of the request.  This is still called during a request\n        context so if you absolutely need access to the request you can do\n        that.\n        \"\"\"\n        raise NotImplementedError()\n\n\nsession_json_serializer = TaggedJSONSerializer()\n\n\nclass SecureCookieSessionInterface(SessionInterface):\n    \"\"\"The default session interface that stores sessions in signed cookies\n    through the :mod:`itsdangerous` module.\n    \"\"\"\n\n    #: the salt that should be applied on top of the secret key for the\n    #: signing of cookie based sessions.\n    salt = \"cookie-session\"\n    #: the hash function to use for the signature.  The default is sha1\n    digest_method = staticmethod(hashlib.sha1)\n    #: the name of the itsdangerous supported key derivation.  The default\n    #: is hmac.\n    key_derivation = \"hmac\"\n    #: A python serializer for the payload.  The default is a compact\n    #: JSON derived serializer with support for some extra Python types\n    #: such as datetime objects or tuples.\n    serializer = session_json_serializer\n    session_class = SecureCookieSession\n\n    def get_signing_serializer(self, app):\n        if not app.secret_key:\n            return None\n        signer_kwargs = dict(\n            key_derivation=self.key_derivation, digest_method=self.digest_method\n        )\n        return URLSafeTimedSerializer(\n            app.secret_key,\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs=signer_kwargs,\n        )\n\n    def open_session(self, app, request):\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = total_seconds(app.permanent_session_lifetime)\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n\n    def save_session(self, app, session, response):\n        name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(name, domain=domain, path=path)\n\n            return\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        httponly = self.get_cookie_httponly(app)\n        secure = self.get_cookie_secure(app)\n        samesite = self.get_cookie_samesite(app)\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))\n        response.set_cookie(\n            name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            samesite=samesite,\n        )\n\n\"\"\"\nGenerate tests which test: apply pyupgrade\n\"\"\"\n","completion":" \"\"\"\n    tests.helpers\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Various helpers.\n\n    :copyright: 2010 Pallets\n    :license: BSD-3-Clause\n\"\"\"\nimport datetime\nimport io\nimport os\nimport sys\nimport uuid\n\nimport pytest\nfrom werkzeug.datastructures import Range\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import http_date\nfrom werkzeug.http import parse_cache_control_header\nfrom werkzeug.http import parse_options_header\n\nimport flask\nfrom flask import json\nfrom flask.helpers import get_debug_flag\nfrom flask.helpers import get_env\n\n\ndef has_encoding(name):\n    try:\n        import codecs\n\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n\n\nclass FakePath:\n    \"\"\"Fake object to represent a ``PathLike object``.\n\n    This represents a ``pathlib.Path`` object in python 3.\n    See: https:\/\/www.python.org\/dev\/peps\/pep-0519\/\n    \"\"\"\n\n    def __init__(self, path):\n        self.path = path\n\n    def __fspath__(self):\n        return self.path\n\n\nclass FixedOffset(datetime.tzinfo):\n    \"\"\"Fixed offset in hours east from UTC.\n\n    This is a slight adaptation of the ``FixedOffset`` example found in\n    https:\/\/docs.python.org\/2.7\/library\/datetime.html.\n    \"\"\"\n\n    def __init__(self, hours, name):\n        self.__offset = datetime.timedelta(hours=hours)\n        self.__name = name\n\n    def utcoffset(self, dt):\n        return self.__offset\n\n    def tzname(self, dt):\n        return self.__name\n\n    def dst(self, dt):\n        return datetime.timedelta()\n\n\nclass TestJSON:\n    @pytest.mark.parametrize(\n        \"value\", (1, \"t\", True, False, None, [], [1, 2, 3], {}, {\"foo\": \"\ud83d\udc0d\"})\n    )\n    @pytest.mark.parametrize(\n        \"encoding\",\n        (\n            \"utf-8\",\n            \"utf-8-sig\",\n            \"utf-16-le\",\n            \"utf-16-be\",\n            \"utf-16\",\n            \"utf-32-le\",\n            \"utf-32-be\",\n            \"utf-32\",\n        ),\n    )\n    def test_detect_encoding(self, value, encoding):\n        data = json.dumps(value).encode(encoding)\n        assert json.loads(data) == value\n\n    @pytest.mark.parametrize(\"debug\", (True, False))\n    def test_bad_request_debug_message(self, app, client, debug):\n        app.config[\"DEBUG\"] = debug\n        app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def post_json():\n            flask.request.get_json()\n            return None\n\n        rv = client.post(\"\/json\", data=None, content_type=\"application\/json\")\n        assert rv.status_code == 400\n        contains = b\"Failed to decode JSON object\" in rv.data\n        assert contains == debug\n\n    def test_json_bad_requests(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.jsonify(foo=str(flask.request.get_json()))\n\n        rv = client.post(\"\/json\", data=\"malformed\", content_type=\"application\/json\")\n        assert rv.status_code == 400\n\n    def test_json_custom_mimetypes(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.request.get_json()\n\n        rv = client.post(\"\/json\", data='\"foo\"', content_type=\"application\/x+json\")\n        assert rv.data == b\"foo\"\n\n    @pytest.mark.parametrize(\n        \"test_value,expected\", [(True, '\"\\\\u2603\"'), (False, '\"\\u2603\"')]\n    )\n    def test_json_as_unicode(self, test_value, expected, app, app_ctx):\n\n        app.config[\"JSON_AS_ASCII\"] = test_value\n        rv = flask.json.dumps(\"\\N{SNOWMAN}\")\n        assert rv == expected\n\n    def test_json_dump_to_file(self, app, app_ctx):\n        test_data = {\"name\": \"Flask\"}\n        out = io.StringIO()\n\n        flask.json.dump(test_data, out)\n        out.seek(0)\n        rv = flask.json.load(out)\n        assert rv == test_data\n\n    @pytest.mark.parametrize(\n        \"test_value\", [0, -1, 1, 23, 3.14, \"s\", \"longer string\", True, False, None]\n    )\n    def test_jsonify_basic_types(self, test_value, app, client):\n        \"\"\"Test jsonify with basic types.\"\"\"\n\n        url = \"\/jsonify_basic_types\"\n        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n        rv = client.get(url)\n        assert rv.mimetype == \"application\/json\"\n        assert flask.json.loads(rv.data) == test_value\n\n    def test_jsonify_dicts(self, app, client):\n        \"\"\"Test jsonify with dicts and kwargs unpacking.\"\"\"\n        d = {\n            \"a\": 0,\n            \"b\": 23,\n            \"c\": 3.14,\n            \"d\": \"t\",\n            \"e\": \"Hi\",\n            \"f\": True,\n            \"g\": False,\n            \"h\": [\"test list\", 10, False],\n            \"i\": {\"test\": \"dict\"},\n        }\n\n        @app.route(\"\/kw\")\n        def return_kwargs():\n            return flask.jsonify(**d)\n\n        @app.route(\"\/dict\")\n        def return_dict():\n            return flask.jsonify(d)\n\n        for url in \"\/kw\", \"\/dict\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == d\n\n    def test_jsonify_arrays(self, app, client):\n        \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n        a_list = [\n            0,\n            42,\n            3.14,\n            \"t\",\n            \"hello\",\n            True,\n            False,\n            [\"test list\", 2, False],\n            {\"test\": \"dict\"},\n        ]\n\n        @app.route(\"\/args_unpack\")\n        def return_args_unpack():\n            return flask.jsonify(*a_list)\n\n        @app.route(\"\/array\")\n        def return_array():\n            return flask.jsonify(a_list)\n\n        for url in \"\/args_unpack\", \"\/array\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == a_list\n\n    def test_jsonify_date_types(self, app, client):\n        \"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"\n        test_dates = (\n            datetime.datetime(1973, 3, 11, 6, 30, 45),\n            datetime.date(1975, 1, 5),\n        )\n\n        for i, d in enumerate(test_dates):\n            url = f\"\/datetest{i}\"\n            app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data)[\"x\"] == http_date(d.timetuple())\n\n    @pytest.mark.parametrize(\"tz\", ((\"UTC\", 0), (\"PST\", -8), (\"KST\", 9)))\n    def test_jsonify_aware_datetimes(self, tz):\n        \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n        tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n        dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n        gmt = FixedOffset(hours=0, name=\"GMT\")\n        expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n        assert flask.json.JSONEncoder().encode(dt) == expected\n\n    def test_jsonify_uuid_types(self, app, client):\n        \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n        test_uuid = uuid.UUID(bytes=b\"\\xDE\\xAD\\xBE\\xEF\" * 4)\n        url = \"\/uuid_test\"\n        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n        rv = client.get(url)\n\n        rv_x = flask.json.loads(rv.data)[\"x\"]\n        assert rv_x == str(test_uuid)\n        rv_uuid = uuid.UUID(rv_x)\n        assert rv_uuid == test_uuid\n\n    def test_json_attr(self, app, client):\n        @app.route(\"\/add\", methods=[\"POST\"])\n        def add():\n            json = flask.request.get_json()\n            return str(json[\"a\"] + json[\"b\"])\n\n        rv = client.post(\n            \"\/add\",\n            data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b\"3\"\n\n    def test_template_escaping(self, app, req_ctx):\n        render = flask.render_template_string\n        rv = flask.json.htmlsafe_dumps(\"<\/script>\")\n        assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n        assert type(rv) is str\n        rv = render('{{ \"<\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n        rv = render('{{ \"<\\0\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\\\\u0000\/script\\\\u003e\"'\n        rv = render('{{ \"<!--<script>\"|tojson }}')\n        assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n        rv = render('{{ \"&\"|tojson }}')\n        assert rv == '\"\\\\u0026\"'\n        rv = render('{{ \"\\'\"|tojson }}')\n        assert rv == '\"\\\\u0027\"'\n        rv = render(\n            \"<a ng-data='{{ data|tojson }}'><\/a>\", data={\"x\": [\"foo\", \"bar\", \"baz'\"]}\n        )\n        assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'><\/a>'\n\n    def test_json_customization(self, app, client):\n        class X:  # noqa: B903, for Python2 compatibility\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return \"<%d>\" % o.val\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n                return obj\n\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n\n        @app.route(\"\/\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        rv = client.post(\n            \"\/\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    def test_blueprint_json_customization(self, app, client):\n        class X:  # noqa: B903, for Python2 compatibility\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return \"<%d>\" % o.val\n\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n\n                return obj\n\n        bp = flask.Blueprint(\"bp\", __name__)\n        bp.json_encoder = MyEncoder\n        bp.json_decoder = MyDecoder\n\n        @bp.route(\"\/bp\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        app.register_blueprint(bp)\n\n        rv = client.post(\n            \"\/bp\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    @pytest.mark.skipif(\n        not has_encoding(\"euc-kr\"), reason=\"The euc-kr encoding is required.\"\n    )\n    def test_modified_url_encoding(self, app, client):\n        class ModifiedRequest(flask.Request):\n            url_charset = \"euc-kr\"\n\n        app.request_class = ModifiedRequest\n        app.url_map.charset = \"euc-kr\"\n\n        @app.route(\"\/\")\n        def index():\n            return flask.request.args[\"foo\"]\n\n        rv = client.get(\"\/?foo=\uc815\uc0c1\ucc98\ub9ac\".encode(\"euc-kr\"))\n        assert rv.status_code == 200\n        assert rv.data == \"\uc815\uc0c1\ucc98\ub9ac\".encode()\n\n    def test_json_key_sorting(self, app, client):\n        app.debug = True\n\n        assert app.config[\"JSON_SORT_KEYS\"]\n        d = dict.fromkeys(range(20), \"foo\")\n\n        @app.route(\"\/\")\n        def index():\n            return flask.jsonify(values=d)\n\n        rv = client.get(\"\/\")\n        lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n        sorted_by_str = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n        sorted_by_int = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n\n        try:\n            assert lines == sorted_by_int\n        except AssertionError:\n            assert lines == sorted_by_str\n\n\nclass PyBytesIO:\n    def __init__(self, *args, **kwargs):\n        self._io = io.BytesIO(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._io, name)\n\n\nclass TestSendfile:\n    def test_send_file_regular(self, app, req_ctx):\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    def test_send_file_xsendfile(self, app, req_ctx):\n        app.use_x_sendfile = True\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert \"x-sendfile\" in rv.headers\n        assert rv.headers[\"x-sendfile\"] == os.path.join(\n            app.root_path, \"static\/index.html\"\n        )\n        assert rv.mimetype == \"text\/html\"\n        rv.close()\n\n    def test_send_file_last_modified(self, app, client):\n        last_modified = datetime.datetime(1999, 1, 1)\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\n                io.BytesIO(b\"party like it's\"),\n                last_modified=last_modified,\n                mimetype=\"text\/plain\",\n            )\n\n        rv = client.get(\"\/\")\n        assert rv.last_modified == last_modified\n\n    def test_send_file_object_without_mimetype(self, app, req_ctx):\n        with pytest.raises(ValueError) as excinfo:\n            flask.send_file(io.BytesIO(b\"LOL\"))\n        assert \"Unable to infer MIME-type\" in str(excinfo.value)\n        assert \"no filename is available\" in str(excinfo.value)\n\n        flask.send_file(io.BytesIO(b\"LOL\"), attachment_filename=\"filename\")\n\n    @pytest.mark.parametrize(\n        \"opener\",\n        [\n            lambda app: open(os.path.join(app.static_folder, \"index.html\"), \"rb\"),\n            lambda app: io.BytesIO(b\"Test\"),\n            lambda app: PyBytesIO(b\"Test\"),\n        ],\n    )\n    @pytest.mark.usefixtures(\"req_ctx\")\n    def test_send_file_object(self, app, opener):\n        file = opener(app)\n        app.use_x_sendfile = True\n        rv = flask.send_file(file, mimetype=\"text\/plain\")\n        rv.direct_passthrough = False\n        assert rv.data\n        assert rv.mimetype == \"text\/plain\"\n        assert \"x-sendfile\" not in rv.headers\n        rv.close()\n\n    @pytest.mark.parametrize(\n        \"opener\",\n        [\n            lambda app: io.StringIO(\"Test\"),\n            lambda app: open(os.path.join(app.static_folder, \"index.html\")),\n        ],\n    )\n    @pytest.mark.usefixtures(\"req_ctx\")\n    def test_send_file_text_fails(self, app, opener):\n        file = opener(app)\n\n        with pytest.raises(ValueError):\n            flask.send_file(file, mimetype=\"text\/plain\")\n\n        file.close()\n\n    def test_send_file_pathlike(self, app, req_ctx):\n        rv = flask.send_file(FakePath(\"static\/index.html\"))\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, \"to_content_range_header\", None)),\n        reason=\"not implemented within werkzeug\",\n    )\n    def test_send_file_range_request(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:16]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-1000\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-10\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[-10:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"somethingsomething\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        last_modified = datetime.datetime.utcfromtimestamp(\n            os.path.getmtime(os.path.join(app.root_path, \"static\/index.html\"))\n        ).replace(microsecond=0)\n\n        rv = client.get(\n            \"\/\", headers={\"Range\": \"bytes=4-15\", \"If-Range\": http_date(last_modified)}\n        )\n        assert rv.status_code == 206\n        rv.close()\n\n        rv = client.get(\n            \"\/\",\n            headers={\n                \"Range\": \"bytes=4-15\",\n                \"If-Range\": http_date(datetime.datetime(1999, 1, 1)),\n            },\n        )\n        assert rv.status_code == 200\n        rv.close()\n\n    def test_send_file_range_request_bytesio(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            file = io.BytesIO(b\"somethingsomething\")\n            return flask.send_file(\n                file, attachment_filename=\"filename\", conditional=True\n            )\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        assert rv.data == b\"somethingsomething\"[4:16]\n        rv.close()\n\n    def test_send_file_range_request_xsendfile_invalid(self, app, client):\n        # https:\/\/github.com\/pallets\/flask\/issues\/2526\n        app.use_x_sendfile = True\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n    def test_attachment(self, app, req_ctx):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            with open(os.path.join(app.root_path, \"static\/index.html\"), \"rb\") as f:\n                rv = flask.send_file(\n                    f, as_attachment=True, attachment_filename=\"index.html\"\n                )\n                value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n                assert value == \"attachment\"\n                rv.close()\n\n        with open(os.path.join(app.root_path, \"static\/index.html\"), \"rb\") as f:\n            rv = flask.send_file(\n                f, as_attachment=True, attachment_filename=\"index.html\"\n            )\n            value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n            assert value == \"attachment\"\n            assert options[\"filename\"] == \"index.html\"\n            assert \"filename*\" not in rv.headers[\"Content-Disposition\"]\n            rv.close()\n\n        rv = flask.send_file(\"static\/index.html\", as_attachment=True)\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.html\"\n        rv.close()\n\n        rv = flask.send_file(\n            io.BytesIO(b\"Test\"),\n            as_attachment=True,\n            attachment_filename=\"index.txt\",\n            add_etags=False,\n        )\n        assert rv.mimetype == \"text\/plain\"\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.txt\"\n        rv.close()\n\n    @pytest.mark.usefixtures(\"req_ctx\")\n    @pytest.mark.parametrize(\n        (\"filename\", \"ascii\", \"utf8\"),\n        (\n            (\"index.html\", \"index.html\", False),\n            (\n                \"\u00d1and\u00fa\uff0fping\u00fcino.txt\",\n                '\"Nandu\/pinguino.txt\"',\n                \"%C3%91and%C3%BA%EF%BC%8Fping%C3%BCino.txt\",\n            ),\n            (\"V\u00f6gel.txt\", \"Vogel.txt\", \"V%C3%B6gel.txt\"),\n            # \":\/\" are not safe in filename* value\n            (\"\u0442\u0435:\/\u0441\u0442\", '\":\/\"', \"%D1%82%D0%B5%3A%2F%D1%81%D1%82\"),\n        ),\n    )\n    def test_attachment_filename_encoding(self, filename, ascii, utf8):\n        rv = flask.send_file(\n            \"static\/index.html\", as_attachment=True, attachment_filename=filename\n        )\n        rv.close()\n        content_disposition = rv.headers[\"Content-Disposition\"]\n        assert \"filename=%s\" % ascii in content_disposition\n        if utf8:\n            assert \"filename*=UTF-8''\" + utf8 in content_disposition\n        else:\n            assert \"filename*=UTF-8''\" not in content_disposition\n\n    def test_static_file(self, app, req_ctx):\n        # default cache timeout is 12 hours\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        # Test with static file handler.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file(\"static\/index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n\n    def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_pathlike(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(FakePath(\"static\"), FakePath(\"hello.txt\"))\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_null_character(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n\n        if sys.version_info >= (3, 8):\n            exception = NotFound\n        else:\n            exception = BadRequest\n\n        with pytest.raises(exception):\n            flask.send_from_directory(\"static\", \"bad\\x00\")\n\n\nclass TestUrlFor:\n    def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"\/#x%20y\"\n\n    def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n\n    def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        pytest.raises(ValueError, flask.url_for, \"index\", _scheme=\"https\")\n\n    def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n\n    def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return \"Get %d\" % id\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"\/myview\/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"\/myview\/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"\/myview\/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"\/myview\/create\"\n\n\nclass TestNoImports:\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self, modules_tmpdir):\n        modules_tmpdir.join(\"importerror.py\").write(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")\n\n\nclass TestStreaming:\n    def test_streaming_with_context(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]\n\n    def test_stream_keeps_session(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"\/\")\n        assert rv.data == b\"flask\"\n\n\nclass TestSafeJoin:\n    def test_safe_join(self):\n        # Valid combinations of *args and expected joined paths.\n        passing = (\n            ((\"a\/b\/c\",), \"a\/b\/c\"),\n            ((\"\/\", \"a\/\", \"b\/\", \"c\/\"), \"\/a\/b\/c\"),\n            ((\"a\", \"b\", \"c\"), \"a\/b\/c\"),\n            ((\"\/a\", \"b\/c\"), \"\/a\/b\/c\"),\n            ((\"a\/b\", \"X\/..\/c\"), \"a\/b\/c\"),\n            ((\"\/a\/b\", \"c\/X\/..\"), \"\/a\/b\/c\"),\n            # If last path is '' add a slash\n            ((\"\/a\/b\/c\", \"\"), \"\/a\/b\/c\/\"),\n            # Preserve dot slash\n            ((\"\/a\/b\/c\", \".\/\"), \"\/a\/b\/c\/.\"),\n            ((\"a\/b\/c\", \"X\/..\"), \"a\/b\/c\/.\"),\n            # Base directory is always considered safe\n            ((\"..\/\", \"a\/b\/c\"), \"..\/a\/b\/c\"),\n            ((\"\/..\",), \"\/..\"),\n        )\n\n        for args, expected in passing:\n            assert flask.safe_join(*args) == expected\n\n    def test_safe_join_exceptions(self):\n        # Should raise werkzeug.exceptions.NotFound on unsafe joins.\n        failing = (\n            # path.isabs and ``..'' checks\n            (\"\/a\", \"b\", \"\/c\"),\n            (\"\/a\", \"..\/b\/c\"),\n            (\"\/a\", \"..\", \"b\/c\"),\n            # Boundaries violations after path normalization\n            (\"\/a\", \"b\/..\/b\/..\/..\/c\"),\n            (\"\/a\", \"b\", \"c\/..\/..\"),\n            (\"\/a\", \"b\/..\/..\/c\"),\n        )\n\n        for args in failing:\n            with pytest.raises(NotFound):\n                print(flask.safe_join(*args))\n\n\nclass TestHelpers:\n    @pytest.mark.parametrize(\n        \"debug, expected_flag, expected_default_flag\",\n        [\n            (\"\", False, False),\n            (\"0\", False, False),\n            (\"False\", False, False),\n            (\"No\", False, False),\n            (\"True\", True, True),\n        ],\n    )\n    def test_get_debug_flag(\n        self, monkeypatch, debug, expected_flag, expected_default_flag\n    ):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        if expected_flag is None:\n            assert get_debug_flag() is None\n        else:\n            assert get_debug_flag() == expected_flag\n        assert get_debug_flag() == expected_default_flag\n\n    @pytest.mark.parametrize(\n        \"env, ref_env, debug\",\n        [\n            (\"\", \"production\", False),\n            (\"production\", \"production\", False),\n            (\"development\", \"development\", True),\n            (\"other\", \"other\", False),\n        ],\n    )\n    def test_get_env(self, monkeypatch, env, ref_env, debug):\n        monkeypatch.setenv(\"FLASK_ENV\", env)\n        assert get_debug_flag() == debug\n        assert get_env() == ref_env\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text\/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text\/html\"\n\n    @pytest.mark.parametrize(\"mode\", (\"r\", \"rb\", \"rt\"))\n    def test_open_resource(self, mode):\n        app = flask.Flask(__name__)\n\n        with app.open_resource(\"static\/index.html\", mode) as f:\n            assert \"<h1>Hello World!<\/h1>\" in str(f.read())\n\n    @pytest.mark.parametrize(\"mode\", (\"w\", \"x\", \"a\", \"r+\"))\n    def test_open_resource_exceptions(self, mode):\n        app = flask.Flask(__name__)\n\n        with pytest.raises(ValueError):\n            app.open_resource(\"static\/index.html\", mode)\n"}
{"prompt":"Python3\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: apply pyupgrade\n\"\"\"\n","completion":" \"\"\"\ntests.test_logging\n~~~~~~~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\nimport logging\nimport sys\nfrom io import StringIO\n\nimport pytest\n\nfrom flask.logging import default_handler\nfrom flask.logging import has_level_handler\nfrom flask.logging import wsgi_errors_stream\n\n\n@pytest.fixture(autouse=True)\ndef reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger(\"flask_test\")\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")\n\n\ndef test_logger(app):\n    assert app.logger.name == \"flask_test\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n\n\ndef test_wsgi_errors_stream(app, client):\n    @app.route(\"\/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"\/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n\n\ndef test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n\n\ndef test_log_view_exception(app, client):\n    @app.route(\"\/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"\/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on \/ [GET]\" in err\n    assert \"Exception: test\" in err\n"}
{"prompt":"Python3\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: 2010 Pallets\n:license: BSD-3-Clause\n\"\"\"\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: apply pyupgrade\n\"\"\"\n","completion":" \"\"\"\n    tests.templating\n    ~~~~~~~~~~~~~~~~\n\n    Template functionality\n\n    :copyright: 2010 Pallets\n    :license: BSD-3-Clause\n\"\"\"\nimport logging\n\nimport pytest\nimport werkzeug.serving\nfrom jinja2 import TemplateNotFound\n\nimport flask\n\n\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"<p>23|42\"\n\n\ndef test_original_win(app, client):\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"42\"\n\n\ndef test_request_less_rendering(app, app_ctx):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\"\n\n\ndef test_standard_context(app, client):\n    @app.route(\"\/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"\/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]\n\n\ndef test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"\/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"\/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"\n\n\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\"\n\n\ndef test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):\n    @app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_name(app):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"\/\")\n    assert rv.data == b\"Hello Custom World!\"\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"<h1>Jameson<\/h1>\"\n\n\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True\n\n\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n\n    app.run()\n    assert not app.templates_auto_reload\n    assert not app.jinja_env.auto_reload\n\n    app.run(debug=True)\n    assert app.templates_auto_reload\n    assert app.jinja_env.auto_reload\n\n\ndef test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(self, record):\n            called.append(True)\n            text = str(record.msg)\n            assert '1: trying loader of application \"blueprintapp\"' in text\n            assert (\n                '2: trying loader of blueprint \"admin\" (blueprintapp.apps.admin)'\n            ) in text\n            assert (\n                'trying loader of blueprint \"frontend\" (blueprintapp.apps.frontend)'\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                'looked up from an endpoint that belongs to the blueprint \"frontend\"'\n            ) in text\n            assert \"See https:\/\/flask.palletsprojects.com\/blueprints\/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(\n            logging.getLogger(\"blueprintapp\"), \"handlers\", [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"\/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1\n\n\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n"}
{"prompt":"Python3\n\"\"\"\n    flask.sessions\n    ~~~~~~~~~~~~~~\n\n    Implements cookie based sessions based on itsdangerous.\n\n    :copyright: 2010 Pallets\n    :license: BSD-3-Clause\n\"\"\"\nimport hashlib\nimport warnings\nfrom collections.abc import MutableMapping\nfrom datetime import datetime\n\nfrom itsdangerous import BadSignature\nfrom itsdangerous import URLSafeTimedSerializer\nfrom werkzeug.datastructures import CallbackDict\n\nfrom .helpers import is_ip\nfrom .helpers import total_seconds\nfrom .json.tag import TaggedJSONSerializer\n\n\nclass SessionMixin(MutableMapping):\n    \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n\n    @property\n    def permanent(self):\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)\n\n    @permanent.setter\n    def permanent(self, value):\n        self[\"_permanent\"] = bool(value)\n\n    #: Some implementations can detect whether a session is newly\n    #: created, but that is not guaranteed. Use with caution. The mixin\n    # default is hard-coded ``False``.\n    new = False\n\n    #: Some implementations can detect changes to the session and set\n    #: this when that happens. The mixin default is hard coded to\n    #: ``True``.\n    modified = True\n\n    #: Some implementations can detect when session data is read or\n    #: written and set this when that happens. The mixin default is hard\n    #: coded to ``True``.\n    accessed = True\n\n\nclass SecureCookieSession(CallbackDict, SessionMixin):\n    \"\"\"Base class for sessions based on signed cookies.\n\n    This session backend will set the :attr:`modified` and\n    :attr:`accessed` attributes. It cannot reliably track whether a\n    session is new (vs. empty), so :attr:`new` remains hard coded to\n    ``False``.\n    \"\"\"\n\n    #: When data is changed, this is set to ``True``. Only the session\n    #: dictionary itself is tracked; if the session contains mutable\n    #: data (for example a nested dict) then this must be set to\n    #: ``True`` manually when modifying that data. The session cookie\n    #: will only be written to the response if this is ``True``.\n    modified = False\n\n    #: When data is read or written, this is set to ``True``. Used by\n    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``\n    #: header, which allows caching proxies to cache different pages for\n    #: different users.\n    accessed = False\n\n    def __init__(self, initial=None):\n        def on_update(self):\n            self.modified = True\n            self.accessed = True\n\n        super().__init__(initial, on_update)\n\n    def __getitem__(self, key):\n        self.accessed = True\n        return super().__getitem__(key)\n\n    def get(self, key, default=None):\n        self.accessed = True\n        return super().get(key, default)\n\n    def setdefault(self, key, default=None):\n        self.accessed = True\n        return super().setdefault(key, default)\n\n\nclass NullSession(SecureCookieSession):\n    \"\"\"Class used to generate nicer error messages if sessions are not\n    available.  Will still allow read-only access to the empty session\n    but fail on setting.\n    \"\"\"\n\n    def _fail(self, *args, **kwargs):\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n\n    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail\n    del _fail\n\n\nclass SessionInterface:\n    \"\"\"The basic interface you have to implement in order to replace the\n    default session interface which uses werkzeug's securecookie\n    implementation.  The only methods you have to implement are\n    :meth:`open_session` and :meth:`save_session`, the others have\n    useful defaults which you don't need to change.\n\n    The session object returned by the :meth:`open_session` method has to\n    provide a dictionary like interface plus the properties and methods\n    from the :class:`SessionMixin`.  We recommend just subclassing a dict\n    and adding that mixin::\n\n        class Session(dict, SessionMixin):\n            pass\n\n    If :meth:`open_session` returns ``None`` Flask will call into\n    :meth:`make_null_session` to create a session that acts as replacement\n    if the session support cannot work because some requirement is not\n    fulfilled.  The default :class:`NullSession` class that is created\n    will complain that the secret key was not set.\n\n    To replace the session interface on an application all you have to do\n    is to assign :attr:`flask.Flask.session_interface`::\n\n        app = Flask(__name__)\n        app.session_interface = MySessionInterface()\n\n    .. versionadded:: 0.8\n    \"\"\"\n\n    #: :meth:`make_null_session` will look here for the class that should\n    #: be created when a null session is requested.  Likewise the\n    #: :meth:`is_null_session` method will perform a typecheck against\n    #: this type.\n    null_session_class = NullSession\n\n    #: A flag that indicates if the session interface is pickle based.\n    #: This can be used by Flask extensions to make a decision in regards\n    #: to how to deal with the session object.\n    #:\n    #: .. versionadded:: 0.10\n    pickle_based = False\n\n    def make_null_session(self, app):\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n\n    def is_null_session(self, obj):\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n\n    def get_cookie_name(self, app):\n        \"\"\"Returns the name of the session cookie.\n\n        Uses ``app.session_cookie_name`` which is set to ``SESSION_COOKIE_NAME``\n        \"\"\"\n        return app.session_cookie_name\n\n    def get_cookie_domain(self, app):\n        \"\"\"Returns the domain that should be set for the session cookie.\n\n        Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise\n        falls back to detecting the domain based on ``SERVER_NAME``.\n\n        Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is\n        updated to avoid re-running the logic.\n        \"\"\"\n\n        rv = app.config[\"SESSION_COOKIE_DOMAIN\"]\n\n        # set explicitly, or cached from SERVER_NAME detection\n        # if False, return None\n        if rv is not None:\n            return rv if rv else None\n\n        rv = app.config[\"SERVER_NAME\"]\n\n        # server name not set, cache False to return none next time\n        if not rv:\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        # chop off the port which is usually not supported by browsers\n        # remove any leading '.' since we'll add that later\n        rv = rv.rsplit(\":\", 1)[0].lstrip(\".\")\n\n        if \".\" not in rv:\n            # Chrome doesn't allow names without a '.'. This should only\n            # come up with localhost. Hack around this by not setting\n            # the name, and show a warning.\n            warnings.warn(\n                f\"{rv!r} is not a valid cookie domain, it must contain\"\n                \" a '.'. Add an entry to your hosts file, for example\"\n                f\" '{rv}.localdomain', and use that instead.\"\n            )\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        ip = is_ip(rv)\n\n        if ip:\n            warnings.warn(\n                \"The session cookie domain is an IP address. This may not work\"\n                \" as intended in some browsers. Add an entry to your hosts\"\n                ' file, for example \"localhost.localdomain\", and use that'\n                \" instead.\"\n            )\n\n        # if this is not an ip and app is mounted at the root, allow subdomain\n        # matching by adding a '.' prefix\n        if self.get_cookie_path(app) == \"\/\" and not ip:\n            rv = f\".{rv}\"\n\n        app.config[\"SESSION_COOKIE_DOMAIN\"] = rv\n        return rv\n\n    def get_cookie_path(self, app):\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``\/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]\n\n    def get_cookie_httponly(self, app):\n        \"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_HTTPONLY\"]\n\n    def get_cookie_secure(self, app):\n        \"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SECURE\"]\n\n    def get_cookie_samesite(self, app):\n        \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SAMESITE\"]\n\n    def get_expiration_time(self, app, session):\n        \"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"\n        if session.permanent:\n            return datetime.utcnow() + app.permanent_session_lifetime\n\n    def should_set_cookie(self, app, session):\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n\n    def open_session(self, app, request):\n        \"\"\"This method has to be implemented and must either return ``None``\n        in case the loading failed because of a configuration error or an\n        instance of a session object which implements a dictionary like\n        interface + the methods and attributes on :class:`SessionMixin`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def save_session(self, app, session, response):\n        \"\"\"This is called for actual sessions returned by :meth:`open_session`\n        at the end of the request.  This is still called during a request\n        context so if you absolutely need access to the request you can do\n        that.\n        \"\"\"\n        raise NotImplementedError()\n\n\nsession_json_serializer = TaggedJSONSerializer()\n\n\nclass SecureCookieSessionInterface(SessionInterface):\n    \"\"\"The default session interface that stores sessions in signed cookies\n    through the :mod:`itsdangerous` module.\n    \"\"\"\n\n    #: the salt that should be applied on top of the secret key for the\n    #: signing of cookie based sessions.\n    salt = \"cookie-session\"\n    #: the hash function to use for the signature.  The default is sha1\n    digest_method = staticmethod(hashlib.sha1)\n    #: the name of the itsdangerous supported key derivation.  The default\n    #: is hmac.\n    key_derivation = \"hmac\"\n    #: A python serializer for the payload.  The default is a compact\n    #: JSON derived serializer with support for some extra Python types\n    #: such as datetime objects or tuples.\n    serializer = session_json_serializer\n    session_class = SecureCookieSession\n\n    def get_signing_serializer(self, app):\n        if not app.secret_key:\n            return None\n        signer_kwargs = dict(\n            key_derivation=self.key_derivation, digest_method=self.digest_method\n        )\n        return URLSafeTimedSerializer(\n            app.secret_key,\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs=signer_kwargs,\n        )\n\n    def open_session(self, app, request):\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = total_seconds(app.permanent_session_lifetime)\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n\n    def save_session(self, app, session, response):\n        name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(name, domain=domain, path=path)\n\n            return\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        httponly = self.get_cookie_httponly(app)\n        secure = self.get_cookie_secure(app)\n        samesite = self.get_cookie_samesite(app)\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))\n        response.set_cookie(\n            name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            samesite=samesite,\n        )\n\n\"\"\"\nGenerate tests which test: f-strings everywhere\n\"\"\"\n","completion":" \"\"\"\n    tests.helpers\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Various helpers.\n\n    :copyright: 2010 Pallets\n    :license: BSD-3-Clause\n\"\"\"\nimport datetime\nimport io\nimport os\nimport sys\nimport uuid\n\nimport pytest\nfrom werkzeug.datastructures import Range\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import http_date\nfrom werkzeug.http import parse_cache_control_header\nfrom werkzeug.http import parse_options_header\n\nimport flask\nfrom flask import json\nfrom flask.helpers import get_debug_flag\nfrom flask.helpers import get_env\n\n\ndef has_encoding(name):\n    try:\n        import codecs\n\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n\n\nclass FakePath:\n    \"\"\"Fake object to represent a ``PathLike object``.\n\n    This represents a ``pathlib.Path`` object in python 3.\n    See: https:\/\/www.python.org\/dev\/peps\/pep-0519\/\n    \"\"\"\n\n    def __init__(self, path):\n        self.path = path\n\n    def __fspath__(self):\n        return self.path\n\n\nclass FixedOffset(datetime.tzinfo):\n    \"\"\"Fixed offset in hours east from UTC.\n\n    This is a slight adaptation of the ``FixedOffset`` example found in\n    https:\/\/docs.python.org\/2.7\/library\/datetime.html.\n    \"\"\"\n\n    def __init__(self, hours, name):\n        self.__offset = datetime.timedelta(hours=hours)\n        self.__name = name\n\n    def utcoffset(self, dt):\n        return self.__offset\n\n    def tzname(self, dt):\n        return self.__name\n\n    def dst(self, dt):\n        return datetime.timedelta()\n\n\nclass TestJSON:\n    @pytest.mark.parametrize(\n        \"value\", (1, \"t\", True, False, None, [], [1, 2, 3], {}, {\"foo\": \"\ud83d\udc0d\"})\n    )\n    @pytest.mark.parametrize(\n        \"encoding\",\n        (\n            \"utf-8\",\n            \"utf-8-sig\",\n            \"utf-16-le\",\n            \"utf-16-be\",\n            \"utf-16\",\n            \"utf-32-le\",\n            \"utf-32-be\",\n            \"utf-32\",\n        ),\n    )\n    def test_detect_encoding(self, value, encoding):\n        data = json.dumps(value).encode(encoding)\n        assert json.loads(data) == value\n\n    @pytest.mark.parametrize(\"debug\", (True, False))\n    def test_bad_request_debug_message(self, app, client, debug):\n        app.config[\"DEBUG\"] = debug\n        app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def post_json():\n            flask.request.get_json()\n            return None\n\n        rv = client.post(\"\/json\", data=None, content_type=\"application\/json\")\n        assert rv.status_code == 400\n        contains = b\"Failed to decode JSON object\" in rv.data\n        assert contains == debug\n\n    def test_json_bad_requests(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.jsonify(foo=str(flask.request.get_json()))\n\n        rv = client.post(\"\/json\", data=\"malformed\", content_type=\"application\/json\")\n        assert rv.status_code == 400\n\n    def test_json_custom_mimetypes(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.request.get_json()\n\n        rv = client.post(\"\/json\", data='\"foo\"', content_type=\"application\/x+json\")\n        assert rv.data == b\"foo\"\n\n    @pytest.mark.parametrize(\n        \"test_value,expected\", [(True, '\"\\\\u2603\"'), (False, '\"\\u2603\"')]\n    )\n    def test_json_as_unicode(self, test_value, expected, app, app_ctx):\n\n        app.config[\"JSON_AS_ASCII\"] = test_value\n        rv = flask.json.dumps(\"\\N{SNOWMAN}\")\n        assert rv == expected\n\n    def test_json_dump_to_file(self, app, app_ctx):\n        test_data = {\"name\": \"Flask\"}\n        out = io.StringIO()\n\n        flask.json.dump(test_data, out)\n        out.seek(0)\n        rv = flask.json.load(out)\n        assert rv == test_data\n\n    @pytest.mark.parametrize(\n        \"test_value\", [0, -1, 1, 23, 3.14, \"s\", \"longer string\", True, False, None]\n    )\n    def test_jsonify_basic_types(self, test_value, app, client):\n        \"\"\"Test jsonify with basic types.\"\"\"\n\n        url = \"\/jsonify_basic_types\"\n        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n        rv = client.get(url)\n        assert rv.mimetype == \"application\/json\"\n        assert flask.json.loads(rv.data) == test_value\n\n    def test_jsonify_dicts(self, app, client):\n        \"\"\"Test jsonify with dicts and kwargs unpacking.\"\"\"\n        d = {\n            \"a\": 0,\n            \"b\": 23,\n            \"c\": 3.14,\n            \"d\": \"t\",\n            \"e\": \"Hi\",\n            \"f\": True,\n            \"g\": False,\n            \"h\": [\"test list\", 10, False],\n            \"i\": {\"test\": \"dict\"},\n        }\n\n        @app.route(\"\/kw\")\n        def return_kwargs():\n            return flask.jsonify(**d)\n\n        @app.route(\"\/dict\")\n        def return_dict():\n            return flask.jsonify(d)\n\n        for url in \"\/kw\", \"\/dict\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == d\n\n    def test_jsonify_arrays(self, app, client):\n        \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n        a_list = [\n            0,\n            42,\n            3.14,\n            \"t\",\n            \"hello\",\n            True,\n            False,\n            [\"test list\", 2, False],\n            {\"test\": \"dict\"},\n        ]\n\n        @app.route(\"\/args_unpack\")\n        def return_args_unpack():\n            return flask.jsonify(*a_list)\n\n        @app.route(\"\/array\")\n        def return_array():\n            return flask.jsonify(a_list)\n\n        for url in \"\/args_unpack\", \"\/array\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == a_list\n\n    def test_jsonify_date_types(self, app, client):\n        \"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"\n        test_dates = (\n            datetime.datetime(1973, 3, 11, 6, 30, 45),\n            datetime.date(1975, 1, 5),\n        )\n\n        for i, d in enumerate(test_dates):\n            url = f\"\/datetest{i}\"\n            app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data)[\"x\"] == http_date(d.timetuple())\n\n    @pytest.mark.parametrize(\"tz\", ((\"UTC\", 0), (\"PST\", -8), (\"KST\", 9)))\n    def test_jsonify_aware_datetimes(self, tz):\n        \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n        tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n        dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n        gmt = FixedOffset(hours=0, name=\"GMT\")\n        expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n        assert flask.json.JSONEncoder().encode(dt) == expected\n\n    def test_jsonify_uuid_types(self, app, client):\n        \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n        test_uuid = uuid.UUID(bytes=b\"\\xDE\\xAD\\xBE\\xEF\" * 4)\n        url = \"\/uuid_test\"\n        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n        rv = client.get(url)\n\n        rv_x = flask.json.loads(rv.data)[\"x\"]\n        assert rv_x == str(test_uuid)\n        rv_uuid = uuid.UUID(rv_x)\n        assert rv_uuid == test_uuid\n\n    def test_json_attr(self, app, client):\n        @app.route(\"\/add\", methods=[\"POST\"])\n        def add():\n            json = flask.request.get_json()\n            return str(json[\"a\"] + json[\"b\"])\n\n        rv = client.post(\n            \"\/add\",\n            data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b\"3\"\n\n    def test_template_escaping(self, app, req_ctx):\n        render = flask.render_template_string\n        rv = flask.json.htmlsafe_dumps(\"<\/script>\")\n        assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n        assert type(rv) is str\n        rv = render('{{ \"<\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n        rv = render('{{ \"<\\0\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\\\\u0000\/script\\\\u003e\"'\n        rv = render('{{ \"<!--<script>\"|tojson }}')\n        assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n        rv = render('{{ \"&\"|tojson }}')\n        assert rv == '\"\\\\u0026\"'\n        rv = render('{{ \"\\'\"|tojson }}')\n        assert rv == '\"\\\\u0027\"'\n        rv = render(\n            \"<a ng-data='{{ data|tojson }}'><\/a>\", data={\"x\": [\"foo\", \"bar\", \"baz'\"]}\n        )\n        assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'><\/a>'\n\n    def test_json_customization(self, app, client):\n        class X:  # noqa: B903, for Python2 compatibility\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return f\"<{o.val}>\"\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n                return obj\n\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n\n        @app.route(\"\/\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        rv = client.post(\n            \"\/\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    def test_blueprint_json_customization(self, app, client):\n        class X:\n            __slots__ = (\"val\",)\n\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return f\"<{o.val}>\"\n\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n\n                return obj\n\n        bp = flask.Blueprint(\"bp\", __name__)\n        bp.json_encoder = MyEncoder\n        bp.json_decoder = MyDecoder\n\n        @bp.route(\"\/bp\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        app.register_blueprint(bp)\n\n        rv = client.post(\n            \"\/bp\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    @pytest.mark.skipif(\n        not has_encoding(\"euc-kr\"), reason=\"The euc-kr encoding is required.\"\n    )\n    def test_modified_url_encoding(self, app, client):\n        class ModifiedRequest(flask.Request):\n            url_charset = \"euc-kr\"\n\n        app.request_class = ModifiedRequest\n        app.url_map.charset = \"euc-kr\"\n\n        @app.route(\"\/\")\n        def index():\n            return flask.request.args[\"foo\"]\n\n        rv = client.get(\"\/?foo=\uc815\uc0c1\ucc98\ub9ac\".encode(\"euc-kr\"))\n        assert rv.status_code == 200\n        assert rv.data == \"\uc815\uc0c1\ucc98\ub9ac\".encode()\n\n    def test_json_key_sorting(self, app, client):\n        app.debug = True\n\n        assert app.config[\"JSON_SORT_KEYS\"]\n        d = dict.fromkeys(range(20), \"foo\")\n\n        @app.route(\"\/\")\n        def index():\n            return flask.jsonify(values=d)\n\n        rv = client.get(\"\/\")\n        lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n        sorted_by_str = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n        sorted_by_int = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n\n        try:\n            assert lines == sorted_by_int\n        except AssertionError:\n            assert lines == sorted_by_str\n\n\nclass PyBytesIO:\n    def __init__(self, *args, **kwargs):\n        self._io = io.BytesIO(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._io, name)\n\n\nclass TestSendfile:\n    def test_send_file_regular(self, app, req_ctx):\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    def test_send_file_xsendfile(self, app, req_ctx):\n        app.use_x_sendfile = True\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert \"x-sendfile\" in rv.headers\n        assert rv.headers[\"x-sendfile\"] == os.path.join(\n            app.root_path, \"static\/index.html\"\n        )\n        assert rv.mimetype == \"text\/html\"\n        rv.close()\n\n    def test_send_file_last_modified(self, app, client):\n        last_modified = datetime.datetime(1999, 1, 1)\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\n                io.BytesIO(b\"party like it's\"),\n                last_modified=last_modified,\n                mimetype=\"text\/plain\",\n            )\n\n        rv = client.get(\"\/\")\n        assert rv.last_modified == last_modified\n\n    def test_send_file_object_without_mimetype(self, app, req_ctx):\n        with pytest.raises(ValueError) as excinfo:\n            flask.send_file(io.BytesIO(b\"LOL\"))\n        assert \"Unable to infer MIME-type\" in str(excinfo.value)\n        assert \"no filename is available\" in str(excinfo.value)\n\n        flask.send_file(io.BytesIO(b\"LOL\"), attachment_filename=\"filename\")\n\n    @pytest.mark.parametrize(\n        \"opener\",\n        [\n            lambda app: open(os.path.join(app.static_folder, \"index.html\"), \"rb\"),\n            lambda app: io.BytesIO(b\"Test\"),\n            lambda app: PyBytesIO(b\"Test\"),\n        ],\n    )\n    @pytest.mark.usefixtures(\"req_ctx\")\n    def test_send_file_object(self, app, opener):\n        file = opener(app)\n        app.use_x_sendfile = True\n        rv = flask.send_file(file, mimetype=\"text\/plain\")\n        rv.direct_passthrough = False\n        assert rv.data\n        assert rv.mimetype == \"text\/plain\"\n        assert \"x-sendfile\" not in rv.headers\n        rv.close()\n\n    @pytest.mark.parametrize(\n        \"opener\",\n        [\n            lambda app: io.StringIO(\"Test\"),\n            lambda app: open(os.path.join(app.static_folder, \"index.html\")),\n        ],\n    )\n    @pytest.mark.usefixtures(\"req_ctx\")\n    def test_send_file_text_fails(self, app, opener):\n        file = opener(app)\n\n        with pytest.raises(ValueError):\n            flask.send_file(file, mimetype=\"text\/plain\")\n\n        file.close()\n\n    def test_send_file_pathlike(self, app, req_ctx):\n        rv = flask.send_file(FakePath(\"static\/index.html\"))\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, \"to_content_range_header\", None)),\n        reason=\"not implemented within werkzeug\",\n    )\n    def test_send_file_range_request(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:16]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-1000\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-10\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[-10:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"somethingsomething\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        last_modified = datetime.datetime.utcfromtimestamp(\n            os.path.getmtime(os.path.join(app.root_path, \"static\/index.html\"))\n        ).replace(microsecond=0)\n\n        rv = client.get(\n            \"\/\", headers={\"Range\": \"bytes=4-15\", \"If-Range\": http_date(last_modified)}\n        )\n        assert rv.status_code == 206\n        rv.close()\n\n        rv = client.get(\n            \"\/\",\n            headers={\n                \"Range\": \"bytes=4-15\",\n                \"If-Range\": http_date(datetime.datetime(1999, 1, 1)),\n            },\n        )\n        assert rv.status_code == 200\n        rv.close()\n\n    def test_send_file_range_request_bytesio(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            file = io.BytesIO(b\"somethingsomething\")\n            return flask.send_file(\n                file, attachment_filename=\"filename\", conditional=True\n            )\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        assert rv.data == b\"somethingsomething\"[4:16]\n        rv.close()\n\n    def test_send_file_range_request_xsendfile_invalid(self, app, client):\n        # https:\/\/github.com\/pallets\/flask\/issues\/2526\n        app.use_x_sendfile = True\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n    def test_attachment(self, app, req_ctx):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            with open(os.path.join(app.root_path, \"static\/index.html\"), \"rb\") as f:\n                rv = flask.send_file(\n                    f, as_attachment=True, attachment_filename=\"index.html\"\n                )\n                value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n                assert value == \"attachment\"\n                rv.close()\n\n        with open(os.path.join(app.root_path, \"static\/index.html\"), \"rb\") as f:\n            rv = flask.send_file(\n                f, as_attachment=True, attachment_filename=\"index.html\"\n            )\n            value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n            assert value == \"attachment\"\n            assert options[\"filename\"] == \"index.html\"\n            assert \"filename*\" not in rv.headers[\"Content-Disposition\"]\n            rv.close()\n\n        rv = flask.send_file(\"static\/index.html\", as_attachment=True)\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.html\"\n        rv.close()\n\n        rv = flask.send_file(\n            io.BytesIO(b\"Test\"),\n            as_attachment=True,\n            attachment_filename=\"index.txt\",\n            add_etags=False,\n        )\n        assert rv.mimetype == \"text\/plain\"\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.txt\"\n        rv.close()\n\n    @pytest.mark.usefixtures(\"req_ctx\")\n    @pytest.mark.parametrize(\n        (\"filename\", \"ascii\", \"utf8\"),\n        (\n            (\"index.html\", \"index.html\", False),\n            (\n                \"\u00d1and\u00fa\uff0fping\u00fcino.txt\",\n                '\"Nandu\/pinguino.txt\"',\n                \"%C3%91and%C3%BA%EF%BC%8Fping%C3%BCino.txt\",\n            ),\n            (\"V\u00f6gel.txt\", \"Vogel.txt\", \"V%C3%B6gel.txt\"),\n            # \":\/\" are not safe in filename* value\n            (\"\u0442\u0435:\/\u0441\u0442\", '\":\/\"', \"%D1%82%D0%B5%3A%2F%D1%81%D1%82\"),\n        ),\n    )\n    def test_attachment_filename_encoding(self, filename, ascii, utf8):\n        rv = flask.send_file(\n            \"static\/index.html\", as_attachment=True, attachment_filename=filename\n        )\n        rv.close()\n        content_disposition = rv.headers[\"Content-Disposition\"]\n        assert f\"filename={ascii}\" in content_disposition\n        if utf8:\n            assert f\"filename*=UTF-8''{utf8}\" in content_disposition\n        else:\n            assert \"filename*=UTF-8''\" not in content_disposition\n\n    def test_static_file(self, app, req_ctx):\n        # default cache timeout is 12 hours\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        # Test with static file handler.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file(\"static\/index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n\n    def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_pathlike(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(FakePath(\"static\"), FakePath(\"hello.txt\"))\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_null_character(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n\n        if sys.version_info >= (3, 8):\n            exception = NotFound\n        else:\n            exception = BadRequest\n\n        with pytest.raises(exception):\n            flask.send_from_directory(\"static\", \"bad\\x00\")\n\n\nclass TestUrlFor:\n    def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"\/#x%20y\"\n\n    def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n\n    def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        pytest.raises(ValueError, flask.url_for, \"index\", _scheme=\"https\")\n\n    def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n\n    def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return f\"Get {id:d}\"\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"\/myview\/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"\/myview\/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"\/myview\/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"\/myview\/create\"\n\n\nclass TestNoImports:\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self, modules_tmpdir):\n        modules_tmpdir.join(\"importerror.py\").write(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")\n\n\nclass TestStreaming:\n    def test_streaming_with_context(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]\n\n    def test_stream_keeps_session(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"\/\")\n        assert rv.data == b\"flask\"\n\n\nclass TestSafeJoin:\n    def test_safe_join(self):\n        # Valid combinations of *args and expected joined paths.\n        passing = (\n            ((\"a\/b\/c\",), \"a\/b\/c\"),\n            ((\"\/\", \"a\/\", \"b\/\", \"c\/\"), \"\/a\/b\/c\"),\n            ((\"a\", \"b\", \"c\"), \"a\/b\/c\"),\n            ((\"\/a\", \"b\/c\"), \"\/a\/b\/c\"),\n            ((\"a\/b\", \"X\/..\/c\"), \"a\/b\/c\"),\n            ((\"\/a\/b\", \"c\/X\/..\"), \"\/a\/b\/c\"),\n            # If last path is '' add a slash\n            ((\"\/a\/b\/c\", \"\"), \"\/a\/b\/c\/\"),\n            # Preserve dot slash\n            ((\"\/a\/b\/c\", \".\/\"), \"\/a\/b\/c\/.\"),\n            ((\"a\/b\/c\", \"X\/..\"), \"a\/b\/c\/.\"),\n            # Base directory is always considered safe\n            ((\"..\/\", \"a\/b\/c\"), \"..\/a\/b\/c\"),\n            ((\"\/..\",), \"\/..\"),\n        )\n\n        for args, expected in passing:\n            assert flask.safe_join(*args) == expected\n\n    def test_safe_join_exceptions(self):\n        # Should raise werkzeug.exceptions.NotFound on unsafe joins.\n        failing = (\n            # path.isabs and ``..'' checks\n            (\"\/a\", \"b\", \"\/c\"),\n            (\"\/a\", \"..\/b\/c\"),\n            (\"\/a\", \"..\", \"b\/c\"),\n            # Boundaries violations after path normalization\n            (\"\/a\", \"b\/..\/b\/..\/..\/c\"),\n            (\"\/a\", \"b\", \"c\/..\/..\"),\n            (\"\/a\", \"b\/..\/..\/c\"),\n        )\n\n        for args in failing:\n            with pytest.raises(NotFound):\n                print(flask.safe_join(*args))\n\n\nclass TestHelpers:\n    @pytest.mark.parametrize(\n        \"debug, expected_flag, expected_default_flag\",\n        [\n            (\"\", False, False),\n            (\"0\", False, False),\n            (\"False\", False, False),\n            (\"No\", False, False),\n            (\"True\", True, True),\n        ],\n    )\n    def test_get_debug_flag(\n        self, monkeypatch, debug, expected_flag, expected_default_flag\n    ):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        if expected_flag is None:\n            assert get_debug_flag() is None\n        else:\n            assert get_debug_flag() == expected_flag\n        assert get_debug_flag() == expected_default_flag\n\n    @pytest.mark.parametrize(\n        \"env, ref_env, debug\",\n        [\n            (\"\", \"production\", False),\n            (\"production\", \"production\", False),\n            (\"development\", \"development\", True),\n            (\"other\", \"other\", False),\n        ],\n    )\n    def test_get_env(self, monkeypatch, env, ref_env, debug):\n        monkeypatch.setenv(\"FLASK_ENV\", env)\n        assert get_debug_flag() == debug\n        assert get_env() == ref_env\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text\/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text\/html\"\n\n    @pytest.mark.parametrize(\"mode\", (\"r\", \"rb\", \"rt\"))\n    def test_open_resource(self, mode):\n        app = flask.Flask(__name__)\n\n        with app.open_resource(\"static\/index.html\", mode) as f:\n            assert \"<h1>Hello World!<\/h1>\" in str(f.read())\n\n    @pytest.mark.parametrize(\"mode\", (\"w\", \"x\", \"a\", \"r+\"))\n    def test_open_resource_exceptions(self, mode):\n        app = flask.Flask(__name__)\n\n        with pytest.raises(ValueError):\n            app.open_resource(\"static\/index.html\", mode)\n"}
{"prompt":"Python3\nimport hashlib\nimport warnings\nfrom collections.abc import MutableMapping\nfrom datetime import datetime\n\nfrom itsdangerous import BadSignature\nfrom itsdangerous import URLSafeTimedSerializer\nfrom werkzeug.datastructures import CallbackDict\n\nfrom .helpers import is_ip\nfrom .helpers import total_seconds\nfrom .json.tag import TaggedJSONSerializer\n\n\nclass SessionMixin(MutableMapping):\n    \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n\n    @property\n    def permanent(self):\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)\n\n    @permanent.setter\n    def permanent(self, value):\n        self[\"_permanent\"] = bool(value)\n\n    #: Some implementations can detect whether a session is newly\n    #: created, but that is not guaranteed. Use with caution. The mixin\n    # default is hard-coded ``False``.\n    new = False\n\n    #: Some implementations can detect changes to the session and set\n    #: this when that happens. The mixin default is hard coded to\n    #: ``True``.\n    modified = True\n\n    #: Some implementations can detect when session data is read or\n    #: written and set this when that happens. The mixin default is hard\n    #: coded to ``True``.\n    accessed = True\n\n\nclass SecureCookieSession(CallbackDict, SessionMixin):\n    \"\"\"Base class for sessions based on signed cookies.\n\n    This session backend will set the :attr:`modified` and\n    :attr:`accessed` attributes. It cannot reliably track whether a\n    session is new (vs. empty), so :attr:`new` remains hard coded to\n    ``False``.\n    \"\"\"\n\n    #: When data is changed, this is set to ``True``. Only the session\n    #: dictionary itself is tracked; if the session contains mutable\n    #: data (for example a nested dict) then this must be set to\n    #: ``True`` manually when modifying that data. The session cookie\n    #: will only be written to the response if this is ``True``.\n    modified = False\n\n    #: When data is read or written, this is set to ``True``. Used by\n    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``\n    #: header, which allows caching proxies to cache different pages for\n    #: different users.\n    accessed = False\n\n    def __init__(self, initial=None):\n        def on_update(self):\n            self.modified = True\n            self.accessed = True\n\n        super().__init__(initial, on_update)\n\n    def __getitem__(self, key):\n        self.accessed = True\n        return super().__getitem__(key)\n\n    def get(self, key, default=None):\n        self.accessed = True\n        return super().get(key, default)\n\n    def setdefault(self, key, default=None):\n        self.accessed = True\n        return super().setdefault(key, default)\n\n\nclass NullSession(SecureCookieSession):\n    \"\"\"Class used to generate nicer error messages if sessions are not\n    available.  Will still allow read-only access to the empty session\n    but fail on setting.\n    \"\"\"\n\n    def _fail(self, *args, **kwargs):\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n\n    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail\n    del _fail\n\n\nclass SessionInterface:\n    \"\"\"The basic interface you have to implement in order to replace the\n    default session interface which uses werkzeug's securecookie\n    implementation.  The only methods you have to implement are\n    :meth:`open_session` and :meth:`save_session`, the others have\n    useful defaults which you don't need to change.\n\n    The session object returned by the :meth:`open_session` method has to\n    provide a dictionary like interface plus the properties and methods\n    from the :class:`SessionMixin`.  We recommend just subclassing a dict\n    and adding that mixin::\n\n        class Session(dict, SessionMixin):\n            pass\n\n    If :meth:`open_session` returns ``None`` Flask will call into\n    :meth:`make_null_session` to create a session that acts as replacement\n    if the session support cannot work because some requirement is not\n    fulfilled.  The default :class:`NullSession` class that is created\n    will complain that the secret key was not set.\n\n    To replace the session interface on an application all you have to do\n    is to assign :attr:`flask.Flask.session_interface`::\n\n        app = Flask(__name__)\n        app.session_interface = MySessionInterface()\n\n    .. versionadded:: 0.8\n    \"\"\"\n\n    #: :meth:`make_null_session` will look here for the class that should\n    #: be created when a null session is requested.  Likewise the\n    #: :meth:`is_null_session` method will perform a typecheck against\n    #: this type.\n    null_session_class = NullSession\n\n    #: A flag that indicates if the session interface is pickle based.\n    #: This can be used by Flask extensions to make a decision in regards\n    #: to how to deal with the session object.\n    #:\n    #: .. versionadded:: 0.10\n    pickle_based = False\n\n    def make_null_session(self, app):\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n\n    def is_null_session(self, obj):\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n\n    def get_cookie_name(self, app):\n        \"\"\"Returns the name of the session cookie.\n\n        Uses ``app.session_cookie_name`` which is set to ``SESSION_COOKIE_NAME``\n        \"\"\"\n        return app.session_cookie_name\n\n    def get_cookie_domain(self, app):\n        \"\"\"Returns the domain that should be set for the session cookie.\n\n        Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise\n        falls back to detecting the domain based on ``SERVER_NAME``.\n\n        Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is\n        updated to avoid re-running the logic.\n        \"\"\"\n\n        rv = app.config[\"SESSION_COOKIE_DOMAIN\"]\n\n        # set explicitly, or cached from SERVER_NAME detection\n        # if False, return None\n        if rv is not None:\n            return rv if rv else None\n\n        rv = app.config[\"SERVER_NAME\"]\n\n        # server name not set, cache False to return none next time\n        if not rv:\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        # chop off the port which is usually not supported by browsers\n        # remove any leading '.' since we'll add that later\n        rv = rv.rsplit(\":\", 1)[0].lstrip(\".\")\n\n        if \".\" not in rv:\n            # Chrome doesn't allow names without a '.'. This should only\n            # come up with localhost. Hack around this by not setting\n            # the name, and show a warning.\n            warnings.warn(\n                f\"{rv!r} is not a valid cookie domain, it must contain\"\n                \" a '.'. Add an entry to your hosts file, for example\"\n                f\" '{rv}.localdomain', and use that instead.\"\n            )\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        ip = is_ip(rv)\n\n        if ip:\n            warnings.warn(\n                \"The session cookie domain is an IP address. This may not work\"\n                \" as intended in some browsers. Add an entry to your hosts\"\n                ' file, for example \"localhost.localdomain\", and use that'\n                \" instead.\"\n            )\n\n        # if this is not an ip and app is mounted at the root, allow subdomain\n        # matching by adding a '.' prefix\n        if self.get_cookie_path(app) == \"\/\" and not ip:\n            rv = f\".{rv}\"\n\n        app.config[\"SESSION_COOKIE_DOMAIN\"] = rv\n        return rv\n\n    def get_cookie_path(self, app):\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``\/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]\n\n    def get_cookie_httponly(self, app):\n        \"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_HTTPONLY\"]\n\n    def get_cookie_secure(self, app):\n        \"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SECURE\"]\n\n    def get_cookie_samesite(self, app):\n        \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SAMESITE\"]\n\n    def get_expiration_time(self, app, session):\n        \"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"\n        if session.permanent:\n            return datetime.utcnow() + app.permanent_session_lifetime\n\n    def should_set_cookie(self, app, session):\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n\n    def open_session(self, app, request):\n        \"\"\"This method has to be implemented and must either return ``None``\n        in case the loading failed because of a configuration error or an\n        instance of a session object which implements a dictionary like\n        interface + the methods and attributes on :class:`SessionMixin`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def save_session(self, app, session, response):\n        \"\"\"This is called for actual sessions returned by :meth:`open_session`\n        at the end of the request.  This is still called during a request\n        context so if you absolutely need access to the request you can do\n        that.\n        \"\"\"\n        raise NotImplementedError()\n\n\nsession_json_serializer = TaggedJSONSerializer()\n\n\nclass SecureCookieSessionInterface(SessionInterface):\n    \"\"\"The default session interface that stores sessions in signed cookies\n    through the :mod:`itsdangerous` module.\n    \"\"\"\n\n    #: the salt that should be applied on top of the secret key for the\n    #: signing of cookie based sessions.\n    salt = \"cookie-session\"\n    #: the hash function to use for the signature.  The default is sha1\n    digest_method = staticmethod(hashlib.sha1)\n    #: the name of the itsdangerous supported key derivation.  The default\n    #: is hmac.\n    key_derivation = \"hmac\"\n    #: A python serializer for the payload.  The default is a compact\n    #: JSON derived serializer with support for some extra Python types\n    #: such as datetime objects or tuples.\n    serializer = session_json_serializer\n    session_class = SecureCookieSession\n\n    def get_signing_serializer(self, app):\n        if not app.secret_key:\n            return None\n        signer_kwargs = dict(\n            key_derivation=self.key_derivation, digest_method=self.digest_method\n        )\n        return URLSafeTimedSerializer(\n            app.secret_key,\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs=signer_kwargs,\n        )\n\n    def open_session(self, app, request):\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = total_seconds(app.permanent_session_lifetime)\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n\n    def save_session(self, app, session, response):\n        name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(name, domain=domain, path=path)\n\n            return\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        httponly = self.get_cookie_httponly(app)\n        secure = self.get_cookie_secure(app)\n        samesite = self.get_cookie_samesite(app)\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))\n        response.set_cookie(\n            name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            samesite=samesite,\n        )\n\n\"\"\"\nGenerate tests which test: remove unused module docstrings\n\"\"\"\n","completion":" import datetime\nimport io\nimport os\nimport sys\nimport uuid\n\nimport pytest\nfrom werkzeug.datastructures import Range\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import http_date\nfrom werkzeug.http import parse_cache_control_header\nfrom werkzeug.http import parse_options_header\n\nimport flask\nfrom flask import json\nfrom flask.helpers import get_debug_flag\nfrom flask.helpers import get_env\n\n\ndef has_encoding(name):\n    try:\n        import codecs\n\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n\n\nclass FakePath:\n    \"\"\"Fake object to represent a ``PathLike object``.\n\n    This represents a ``pathlib.Path`` object in python 3.\n    See: https:\/\/www.python.org\/dev\/peps\/pep-0519\/\n    \"\"\"\n\n    def __init__(self, path):\n        self.path = path\n\n    def __fspath__(self):\n        return self.path\n\n\nclass FixedOffset(datetime.tzinfo):\n    \"\"\"Fixed offset in hours east from UTC.\n\n    This is a slight adaptation of the ``FixedOffset`` example found in\n    https:\/\/docs.python.org\/2.7\/library\/datetime.html.\n    \"\"\"\n\n    def __init__(self, hours, name):\n        self.__offset = datetime.timedelta(hours=hours)\n        self.__name = name\n\n    def utcoffset(self, dt):\n        return self.__offset\n\n    def tzname(self, dt):\n        return self.__name\n\n    def dst(self, dt):\n        return datetime.timedelta()\n\n\nclass TestJSON:\n    @pytest.mark.parametrize(\n        \"value\", (1, \"t\", True, False, None, [], [1, 2, 3], {}, {\"foo\": \"\ud83d\udc0d\"})\n    )\n    @pytest.mark.parametrize(\n        \"encoding\",\n        (\n            \"utf-8\",\n            \"utf-8-sig\",\n            \"utf-16-le\",\n            \"utf-16-be\",\n            \"utf-16\",\n            \"utf-32-le\",\n            \"utf-32-be\",\n            \"utf-32\",\n        ),\n    )\n    def test_detect_encoding(self, value, encoding):\n        data = json.dumps(value).encode(encoding)\n        assert json.loads(data) == value\n\n    @pytest.mark.parametrize(\"debug\", (True, False))\n    def test_bad_request_debug_message(self, app, client, debug):\n        app.config[\"DEBUG\"] = debug\n        app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def post_json():\n            flask.request.get_json()\n            return None\n\n        rv = client.post(\"\/json\", data=None, content_type=\"application\/json\")\n        assert rv.status_code == 400\n        contains = b\"Failed to decode JSON object\" in rv.data\n        assert contains == debug\n\n    def test_json_bad_requests(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.jsonify(foo=str(flask.request.get_json()))\n\n        rv = client.post(\"\/json\", data=\"malformed\", content_type=\"application\/json\")\n        assert rv.status_code == 400\n\n    def test_json_custom_mimetypes(self, app, client):\n        @app.route(\"\/json\", methods=[\"POST\"])\n        def return_json():\n            return flask.request.get_json()\n\n        rv = client.post(\"\/json\", data='\"foo\"', content_type=\"application\/x+json\")\n        assert rv.data == b\"foo\"\n\n    @pytest.mark.parametrize(\n        \"test_value,expected\", [(True, '\"\\\\u2603\"'), (False, '\"\\u2603\"')]\n    )\n    def test_json_as_unicode(self, test_value, expected, app, app_ctx):\n\n        app.config[\"JSON_AS_ASCII\"] = test_value\n        rv = flask.json.dumps(\"\\N{SNOWMAN}\")\n        assert rv == expected\n\n    def test_json_dump_to_file(self, app, app_ctx):\n        test_data = {\"name\": \"Flask\"}\n        out = io.StringIO()\n\n        flask.json.dump(test_data, out)\n        out.seek(0)\n        rv = flask.json.load(out)\n        assert rv == test_data\n\n    @pytest.mark.parametrize(\n        \"test_value\", [0, -1, 1, 23, 3.14, \"s\", \"longer string\", True, False, None]\n    )\n    def test_jsonify_basic_types(self, test_value, app, client):\n        \"\"\"Test jsonify with basic types.\"\"\"\n\n        url = \"\/jsonify_basic_types\"\n        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n        rv = client.get(url)\n        assert rv.mimetype == \"application\/json\"\n        assert flask.json.loads(rv.data) == test_value\n\n    def test_jsonify_dicts(self, app, client):\n        \"\"\"Test jsonify with dicts and kwargs unpacking.\"\"\"\n        d = {\n            \"a\": 0,\n            \"b\": 23,\n            \"c\": 3.14,\n            \"d\": \"t\",\n            \"e\": \"Hi\",\n            \"f\": True,\n            \"g\": False,\n            \"h\": [\"test list\", 10, False],\n            \"i\": {\"test\": \"dict\"},\n        }\n\n        @app.route(\"\/kw\")\n        def return_kwargs():\n            return flask.jsonify(**d)\n\n        @app.route(\"\/dict\")\n        def return_dict():\n            return flask.jsonify(d)\n\n        for url in \"\/kw\", \"\/dict\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == d\n\n    def test_jsonify_arrays(self, app, client):\n        \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n        a_list = [\n            0,\n            42,\n            3.14,\n            \"t\",\n            \"hello\",\n            True,\n            False,\n            [\"test list\", 2, False],\n            {\"test\": \"dict\"},\n        ]\n\n        @app.route(\"\/args_unpack\")\n        def return_args_unpack():\n            return flask.jsonify(*a_list)\n\n        @app.route(\"\/array\")\n        def return_array():\n            return flask.jsonify(a_list)\n\n        for url in \"\/args_unpack\", \"\/array\":\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data) == a_list\n\n    def test_jsonify_date_types(self, app, client):\n        \"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"\n        test_dates = (\n            datetime.datetime(1973, 3, 11, 6, 30, 45),\n            datetime.date(1975, 1, 5),\n        )\n\n        for i, d in enumerate(test_dates):\n            url = f\"\/datetest{i}\"\n            app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n            rv = client.get(url)\n            assert rv.mimetype == \"application\/json\"\n            assert flask.json.loads(rv.data)[\"x\"] == http_date(d.timetuple())\n\n    @pytest.mark.parametrize(\"tz\", ((\"UTC\", 0), (\"PST\", -8), (\"KST\", 9)))\n    def test_jsonify_aware_datetimes(self, tz):\n        \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n        tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n        dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n        gmt = FixedOffset(hours=0, name=\"GMT\")\n        expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n        assert flask.json.JSONEncoder().encode(dt) == expected\n\n    def test_jsonify_uuid_types(self, app, client):\n        \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n        test_uuid = uuid.UUID(bytes=b\"\\xDE\\xAD\\xBE\\xEF\" * 4)\n        url = \"\/uuid_test\"\n        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n        rv = client.get(url)\n\n        rv_x = flask.json.loads(rv.data)[\"x\"]\n        assert rv_x == str(test_uuid)\n        rv_uuid = uuid.UUID(rv_x)\n        assert rv_uuid == test_uuid\n\n    def test_json_attr(self, app, client):\n        @app.route(\"\/add\", methods=[\"POST\"])\n        def add():\n            json = flask.request.get_json()\n            return str(json[\"a\"] + json[\"b\"])\n\n        rv = client.post(\n            \"\/add\",\n            data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b\"3\"\n\n    def test_template_escaping(self, app, req_ctx):\n        render = flask.render_template_string\n        rv = flask.json.htmlsafe_dumps(\"<\/script>\")\n        assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n        assert type(rv) is str\n        rv = render('{{ \"<\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\/script\\\\u003e\"'\n        rv = render('{{ \"<\\0\/script>\"|tojson }}')\n        assert rv == '\"\\\\u003c\\\\u0000\/script\\\\u003e\"'\n        rv = render('{{ \"<!--<script>\"|tojson }}')\n        assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n        rv = render('{{ \"&\"|tojson }}')\n        assert rv == '\"\\\\u0026\"'\n        rv = render('{{ \"\\'\"|tojson }}')\n        assert rv == '\"\\\\u0027\"'\n        rv = render(\n            \"<a ng-data='{{ data|tojson }}'><\/a>\", data={\"x\": [\"foo\", \"bar\", \"baz'\"]}\n        )\n        assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'><\/a>'\n\n    def test_json_customization(self, app, client):\n        class X:  # noqa: B903, for Python2 compatibility\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return f\"<{o.val}>\"\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n                return obj\n\n        app.json_encoder = MyEncoder\n        app.json_decoder = MyDecoder\n\n        @app.route(\"\/\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        rv = client.post(\n            \"\/\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    def test_blueprint_json_customization(self, app, client):\n        class X:\n            __slots__ = (\"val\",)\n\n            def __init__(self, val):\n                self.val = val\n\n        class MyEncoder(flask.json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, X):\n                    return f\"<{o.val}>\"\n\n                return flask.json.JSONEncoder.default(self, o)\n\n        class MyDecoder(flask.json.JSONDecoder):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"object_hook\", self.object_hook)\n                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n\n            def object_hook(self, obj):\n                if len(obj) == 1 and \"_foo\" in obj:\n                    return X(obj[\"_foo\"])\n\n                return obj\n\n        bp = flask.Blueprint(\"bp\", __name__)\n        bp.json_encoder = MyEncoder\n        bp.json_decoder = MyDecoder\n\n        @bp.route(\"\/bp\", methods=[\"POST\"])\n        def index():\n            return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n        app.register_blueprint(bp)\n\n        rv = client.post(\n            \"\/bp\",\n            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n            content_type=\"application\/json\",\n        )\n        assert rv.data == b'\"<42>\"'\n\n    @pytest.mark.skipif(\n        not has_encoding(\"euc-kr\"), reason=\"The euc-kr encoding is required.\"\n    )\n    def test_modified_url_encoding(self, app, client):\n        class ModifiedRequest(flask.Request):\n            url_charset = \"euc-kr\"\n\n        app.request_class = ModifiedRequest\n        app.url_map.charset = \"euc-kr\"\n\n        @app.route(\"\/\")\n        def index():\n            return flask.request.args[\"foo\"]\n\n        rv = client.get(\"\/?foo=\uc815\uc0c1\ucc98\ub9ac\".encode(\"euc-kr\"))\n        assert rv.status_code == 200\n        assert rv.data == \"\uc815\uc0c1\ucc98\ub9ac\".encode()\n\n    def test_json_key_sorting(self, app, client):\n        app.debug = True\n\n        assert app.config[\"JSON_SORT_KEYS\"]\n        d = dict.fromkeys(range(20), \"foo\")\n\n        @app.route(\"\/\")\n        def index():\n            return flask.jsonify(values=d)\n\n        rv = client.get(\"\/\")\n        lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n        sorted_by_str = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n        sorted_by_int = [\n            \"{\",\n            '\"values\": {',\n            '\"0\": \"foo\",',\n            '\"1\": \"foo\",',\n            '\"2\": \"foo\",',\n            '\"3\": \"foo\",',\n            '\"4\": \"foo\",',\n            '\"5\": \"foo\",',\n            '\"6\": \"foo\",',\n            '\"7\": \"foo\",',\n            '\"8\": \"foo\",',\n            '\"9\": \"foo\",',\n            '\"10\": \"foo\",',\n            '\"11\": \"foo\",',\n            '\"12\": \"foo\",',\n            '\"13\": \"foo\",',\n            '\"14\": \"foo\",',\n            '\"15\": \"foo\",',\n            '\"16\": \"foo\",',\n            '\"17\": \"foo\",',\n            '\"18\": \"foo\",',\n            '\"19\": \"foo\"',\n            \"}\",\n            \"}\",\n        ]\n\n        try:\n            assert lines == sorted_by_int\n        except AssertionError:\n            assert lines == sorted_by_str\n\n\nclass PyBytesIO:\n    def __init__(self, *args, **kwargs):\n        self._io = io.BytesIO(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._io, name)\n\n\nclass TestSendfile:\n    def test_send_file_regular(self, app, req_ctx):\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    def test_send_file_xsendfile(self, app, req_ctx):\n        app.use_x_sendfile = True\n        rv = flask.send_file(\"static\/index.html\")\n        assert rv.direct_passthrough\n        assert \"x-sendfile\" in rv.headers\n        assert rv.headers[\"x-sendfile\"] == os.path.join(\n            app.root_path, \"static\/index.html\"\n        )\n        assert rv.mimetype == \"text\/html\"\n        rv.close()\n\n    def test_send_file_last_modified(self, app, client):\n        last_modified = datetime.datetime(1999, 1, 1)\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\n                io.BytesIO(b\"party like it's\"),\n                last_modified=last_modified,\n                mimetype=\"text\/plain\",\n            )\n\n        rv = client.get(\"\/\")\n        assert rv.last_modified == last_modified\n\n    def test_send_file_object_without_mimetype(self, app, req_ctx):\n        with pytest.raises(ValueError) as excinfo:\n            flask.send_file(io.BytesIO(b\"LOL\"))\n        assert \"Unable to infer MIME-type\" in str(excinfo.value)\n        assert \"no filename is available\" in str(excinfo.value)\n\n        flask.send_file(io.BytesIO(b\"LOL\"), attachment_filename=\"filename\")\n\n    @pytest.mark.parametrize(\n        \"opener\",\n        [\n            lambda app: open(os.path.join(app.static_folder, \"index.html\"), \"rb\"),\n            lambda app: io.BytesIO(b\"Test\"),\n            lambda app: PyBytesIO(b\"Test\"),\n        ],\n    )\n    @pytest.mark.usefixtures(\"req_ctx\")\n    def test_send_file_object(self, app, opener):\n        file = opener(app)\n        app.use_x_sendfile = True\n        rv = flask.send_file(file, mimetype=\"text\/plain\")\n        rv.direct_passthrough = False\n        assert rv.data\n        assert rv.mimetype == \"text\/plain\"\n        assert \"x-sendfile\" not in rv.headers\n        rv.close()\n\n    @pytest.mark.parametrize(\n        \"opener\",\n        [\n            lambda app: io.StringIO(\"Test\"),\n            lambda app: open(os.path.join(app.static_folder, \"index.html\")),\n        ],\n    )\n    @pytest.mark.usefixtures(\"req_ctx\")\n    def test_send_file_text_fails(self, app, opener):\n        file = opener(app)\n\n        with pytest.raises(ValueError):\n            flask.send_file(file, mimetype=\"text\/plain\")\n\n        file.close()\n\n    def test_send_file_pathlike(self, app, req_ctx):\n        rv = flask.send_file(FakePath(\"static\/index.html\"))\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text\/html\"\n        with app.open_resource(\"static\/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n        rv.close()\n\n    @pytest.mark.skipif(\n        not callable(getattr(Range, \"to_content_range_header\", None)),\n        reason=\"not implemented within werkzeug\",\n    )\n    def test_send_file_range_request(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:16]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-1000\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[4:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-10\"})\n        assert rv.status_code == 206\n        with app.open_resource(\"static\/index.html\") as f:\n            assert rv.data == f.read()[-10:]\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        rv = client.get(\"\/\", headers={\"Range\": \"somethingsomething\"})\n        assert rv.status_code == 416\n        rv.close()\n\n        last_modified = datetime.datetime.utcfromtimestamp(\n            os.path.getmtime(os.path.join(app.root_path, \"static\/index.html\"))\n        ).replace(microsecond=0)\n\n        rv = client.get(\n            \"\/\", headers={\"Range\": \"bytes=4-15\", \"If-Range\": http_date(last_modified)}\n        )\n        assert rv.status_code == 206\n        rv.close()\n\n        rv = client.get(\n            \"\/\",\n            headers={\n                \"Range\": \"bytes=4-15\",\n                \"If-Range\": http_date(datetime.datetime(1999, 1, 1)),\n            },\n        )\n        assert rv.status_code == 200\n        rv.close()\n\n    def test_send_file_range_request_bytesio(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            file = io.BytesIO(b\"somethingsomething\")\n            return flask.send_file(\n                file, attachment_filename=\"filename\", conditional=True\n            )\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=4-15\"})\n        assert rv.status_code == 206\n        assert rv.data == b\"somethingsomething\"[4:16]\n        rv.close()\n\n    def test_send_file_range_request_xsendfile_invalid(self, app, client):\n        # https:\/\/github.com\/pallets\/flask\/issues\/2526\n        app.use_x_sendfile = True\n\n        @app.route(\"\/\")\n        def index():\n            return flask.send_file(\"static\/index.html\", conditional=True)\n\n        rv = client.get(\"\/\", headers={\"Range\": \"bytes=1000-\"})\n        assert rv.status_code == 416\n        rv.close()\n\n    def test_attachment(self, app, req_ctx):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            with open(os.path.join(app.root_path, \"static\/index.html\"), \"rb\") as f:\n                rv = flask.send_file(\n                    f, as_attachment=True, attachment_filename=\"index.html\"\n                )\n                value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n                assert value == \"attachment\"\n                rv.close()\n\n        with open(os.path.join(app.root_path, \"static\/index.html\"), \"rb\") as f:\n            rv = flask.send_file(\n                f, as_attachment=True, attachment_filename=\"index.html\"\n            )\n            value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n            assert value == \"attachment\"\n            assert options[\"filename\"] == \"index.html\"\n            assert \"filename*\" not in rv.headers[\"Content-Disposition\"]\n            rv.close()\n\n        rv = flask.send_file(\"static\/index.html\", as_attachment=True)\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.html\"\n        rv.close()\n\n        rv = flask.send_file(\n            io.BytesIO(b\"Test\"),\n            as_attachment=True,\n            attachment_filename=\"index.txt\",\n            add_etags=False,\n        )\n        assert rv.mimetype == \"text\/plain\"\n        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n        assert value == \"attachment\"\n        assert options[\"filename\"] == \"index.txt\"\n        rv.close()\n\n    @pytest.mark.usefixtures(\"req_ctx\")\n    @pytest.mark.parametrize(\n        (\"filename\", \"ascii\", \"utf8\"),\n        (\n            (\"index.html\", \"index.html\", False),\n            (\n                \"\u00d1and\u00fa\uff0fping\u00fcino.txt\",\n                '\"Nandu\/pinguino.txt\"',\n                \"%C3%91and%C3%BA%EF%BC%8Fping%C3%BCino.txt\",\n            ),\n            (\"V\u00f6gel.txt\", \"Vogel.txt\", \"V%C3%B6gel.txt\"),\n            # \":\/\" are not safe in filename* value\n            (\"\u0442\u0435:\/\u0441\u0442\", '\":\/\"', \"%D1%82%D0%B5%3A%2F%D1%81%D1%82\"),\n        ),\n    )\n    def test_attachment_filename_encoding(self, filename, ascii, utf8):\n        rv = flask.send_file(\n            \"static\/index.html\", as_attachment=True, attachment_filename=filename\n        )\n        rv.close()\n        content_disposition = rv.headers[\"Content-Disposition\"]\n        assert f\"filename={ascii}\" in content_disposition\n        if utf8:\n            assert f\"filename*=UTF-8''{utf8}\" in content_disposition\n        else:\n            assert \"filename*=UTF-8''\" not in content_disposition\n\n    def test_static_file(self, app, req_ctx):\n        # default cache timeout is 12 hours\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 12 * 60 * 60\n        rv.close()\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n        # Test again with direct use of send_file utility.\n        rv = flask.send_file(\"static\/index.html\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        # Test with static file handler.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n            # Test again with direct use of send_file utility.\n            rv = flask.send_file(\"static\/index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 10\n            rv.close()\n\n    def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_pathlike(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(FakePath(\"static\"), FakePath(\"hello.txt\"))\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n    def test_send_from_directory_null_character(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n\n        if sys.version_info >= (3, 8):\n            exception = NotFound\n        else:\n            exception = BadRequest\n\n        with pytest.raises(exception):\n            flask.send_from_directory(\"static\", \"bad\\x00\")\n\n\nclass TestUrlFor:\n    def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"\/#x%20y\"\n\n    def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n\n    def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        pytest.raises(ValueError, flask.url_for, \"index\", _scheme=\"https\")\n\n    def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"\/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https:\/\/localhost\/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http:\/\/localhost\/\"\n\n    def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return f\"Get {id:d}\"\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"\/myview\/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"\/myview\/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"\/myview\/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"\/myview\/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"\/myview\/create\"\n\n\nclass TestNoImports:\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self, modules_tmpdir):\n        modules_tmpdir.join(\"importerror.py\").write(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")\n\n\nclass TestStreaming:\n    def test_streaming_with_context(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"\/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"\/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]\n\n    def test_stream_keeps_session(self, app, client):\n        @app.route(\"\/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"\/\")\n        assert rv.data == b\"flask\"\n\n\nclass TestSafeJoin:\n    def test_safe_join(self):\n        # Valid combinations of *args and expected joined paths.\n        passing = (\n            ((\"a\/b\/c\",), \"a\/b\/c\"),\n            ((\"\/\", \"a\/\", \"b\/\", \"c\/\"), \"\/a\/b\/c\"),\n            ((\"a\", \"b\", \"c\"), \"a\/b\/c\"),\n            ((\"\/a\", \"b\/c\"), \"\/a\/b\/c\"),\n            ((\"a\/b\", \"X\/..\/c\"), \"a\/b\/c\"),\n            ((\"\/a\/b\", \"c\/X\/..\"), \"\/a\/b\/c\"),\n            # If last path is '' add a slash\n            ((\"\/a\/b\/c\", \"\"), \"\/a\/b\/c\/\"),\n            # Preserve dot slash\n            ((\"\/a\/b\/c\", \".\/\"), \"\/a\/b\/c\/.\"),\n            ((\"a\/b\/c\", \"X\/..\"), \"a\/b\/c\/.\"),\n            # Base directory is always considered safe\n            ((\"..\/\", \"a\/b\/c\"), \"..\/a\/b\/c\"),\n            ((\"\/..\",), \"\/..\"),\n        )\n\n        for args, expected in passing:\n            assert flask.safe_join(*args) == expected\n\n    def test_safe_join_exceptions(self):\n        # Should raise werkzeug.exceptions.NotFound on unsafe joins.\n        failing = (\n            # path.isabs and ``..'' checks\n            (\"\/a\", \"b\", \"\/c\"),\n            (\"\/a\", \"..\/b\/c\"),\n            (\"\/a\", \"..\", \"b\/c\"),\n            # Boundaries violations after path normalization\n            (\"\/a\", \"b\/..\/b\/..\/..\/c\"),\n            (\"\/a\", \"b\", \"c\/..\/..\"),\n            (\"\/a\", \"b\/..\/..\/c\"),\n        )\n\n        for args in failing:\n            with pytest.raises(NotFound):\n                print(flask.safe_join(*args))\n\n\nclass TestHelpers:\n    @pytest.mark.parametrize(\n        \"debug, expected_flag, expected_default_flag\",\n        [\n            (\"\", False, False),\n            (\"0\", False, False),\n            (\"False\", False, False),\n            (\"No\", False, False),\n            (\"True\", True, True),\n        ],\n    )\n    def test_get_debug_flag(\n        self, monkeypatch, debug, expected_flag, expected_default_flag\n    ):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        if expected_flag is None:\n            assert get_debug_flag() is None\n        else:\n            assert get_debug_flag() == expected_flag\n        assert get_debug_flag() == expected_default_flag\n\n    @pytest.mark.parametrize(\n        \"env, ref_env, debug\",\n        [\n            (\"\", \"production\", False),\n            (\"production\", \"production\", False),\n            (\"development\", \"development\", True),\n            (\"other\", \"other\", False),\n        ],\n    )\n    def test_get_env(self, monkeypatch, env, ref_env, debug):\n        monkeypatch.setenv(\"FLASK_ENV\", env)\n        assert get_debug_flag() == debug\n        assert get_env() == ref_env\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text\/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text\/html\"\n\n    @pytest.mark.parametrize(\"mode\", (\"r\", \"rb\", \"rt\"))\n    def test_open_resource(self, mode):\n        app = flask.Flask(__name__)\n\n        with app.open_resource(\"static\/index.html\", mode) as f:\n            assert \"<h1>Hello World!<\/h1>\" in str(f.read())\n\n    @pytest.mark.parametrize(\"mode\", (\"w\", \"x\", \"a\", \"r+\"))\n    def test_open_resource_exceptions(self, mode):\n        app = flask.Flask(__name__)\n\n        with pytest.raises(ValueError):\n            app.open_resource(\"static\/index.html\", mode)\n"}
{"prompt":"Python3\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: remove unused module docstrings\n\"\"\"\n","completion":" import logging\nimport sys\nfrom io import StringIO\n\nimport pytest\n\nfrom flask.logging import default_handler\nfrom flask.logging import has_level_handler\nfrom flask.logging import wsgi_errors_stream\n\n\n@pytest.fixture(autouse=True)\ndef reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger(\"flask_test\")\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")\n\n\ndef test_logger(app):\n    assert app.logger.name == \"flask_test\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n\n\ndef test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n\n\ndef test_wsgi_errors_stream(app, client):\n    @app.route(\"\/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"\/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n\n\ndef test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n\n\ndef test_log_view_exception(app, client):\n    @app.route(\"\/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"\/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on \/ [GET]\" in err\n    assert \"Exception: test\" in err\n"}
{"prompt":"Python3\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext:\/\/flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app):\n    \"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n\n\"\"\"\nGenerate tests which test: remove unused module docstrings\n\"\"\"\n","completion":" import logging\n\nimport pytest\nimport werkzeug.serving\nfrom jinja2 import TemplateNotFound\n\nimport flask\n\n\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"<p>23|42\"\n\n\ndef test_original_win(app, client):\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"42\"\n\n\ndef test_request_less_rendering(app, app_ctx):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\"\n\n\ndef test_standard_context(app, client):\n    @app.route(\"\/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"\/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]\n\n\ndef test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"\/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=flask.Markup(text)\n        )\n\n    lines = client.get(\"\/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"\n\n\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\"\n\n\ndef test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):\n    @app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_name(app):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"\/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"\/\")\n    assert rv.data == b\"Hello Custom World!\"\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"\/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"\/\")\n    assert rv.data == b\"<h1>Jameson<\/h1>\"\n\n\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True\n\n\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n\n    app.run()\n    assert not app.templates_auto_reload\n    assert not app.jinja_env.auto_reload\n\n    app.run(debug=True)\n    assert app.templates_auto_reload\n    assert app.jinja_env.auto_reload\n\n\ndef test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(self, record):\n            called.append(True)\n            text = str(record.msg)\n            assert \"1: trying loader of application 'blueprintapp'\" in text\n            assert (\n                \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to the blueprint 'frontend'\"\n            ) in text\n            assert \"See https:\/\/flask.palletsprojects.com\/blueprints\/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(\n            logging.getLogger(\"blueprintapp\"), \"handlers\", [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"\/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1\n\n\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n"}
{"prompt":"Python3\nimport typing as t\n\n\nif t.TYPE_CHECKING:\n    from werkzeug.datastructures import Headers  # noqa: F401\n    from wsgiref.types import WSGIApplication  # noqa: F401\n    from .wrappers import Response  # noqa: F401\n\n# The possible types that are directly convertible or are a Response object.\nResponseValue = t.Union[\n    \"Response\",\n    t.AnyStr,\n    t.Dict[str, t.Any],  # any jsonify-able dict\n    t.Generator[t.AnyStr, None, None],\n]\nStatusCode = int\n\n# the possible types for an individual HTTP header\nHeaderName = str\nHeaderValue = t.Union[str, t.List[str], t.Tuple[str, ...]]\n\n# the possible types for HTTP headers\nHeadersValue = t.Union[\n    \"Headers\", t.Dict[HeaderName, HeaderValue], t.List[t.Tuple[HeaderName, HeaderValue]]\n]\n\n# The possible types returned by a route function.\nResponseReturnValue = t.Union[\n    ResponseValue,\n    t.Tuple[ResponseValue, HeadersValue],\n    t.Tuple[ResponseValue, StatusCode],\n    t.Tuple[ResponseValue, StatusCode, HeadersValue],\n    \"WSGIApplication\",\n]\n\nAppOrBlueprintKey = t.Optional[str]  # The App key is None, whereas blueprints are named\nAfterRequestCallable = t.Callable[[\"Response\"], \"Response\"]\nBeforeRequestCallable = t.Callable[[], None]\nErrorHandlerCallable = t.Callable[[Exception], ResponseReturnValue]\nTeardownCallable = t.Callable[[t.Optional[BaseException]], \"Response\"]\nTemplateContextProcessorCallable = t.Callable[[], t.Dict[str, t.Any]]\nTemplateFilterCallable = t.Callable[[t.Any], str]\nTemplateGlobalCallable = t.Callable[[], t.Any]\nTemplateTestCallable = t.Callable[[t.Any], bool]\nURLDefaultCallable = t.Callable[[str, dict], None]\nURLValuePreprocessorCallable = t.Callable[[t.Optional[str], t.Optional[dict]], None]\n\n\"\"\"\nGenerate tests which test: Add initial type hints\n\nThis should make it easier for users to correctly use Flask. The hints\nare from Quart.\n\"\"\"\n","completion":" import typing as t\nfrom contextlib import contextmanager\nfrom copy import copy\nfrom types import TracebackType\n\nimport werkzeug.test\nfrom click.testing import CliRunner\nfrom werkzeug.test import Client\nfrom werkzeug.urls import url_parse\nfrom werkzeug.wrappers import Request as BaseRequest\n\nfrom . import _request_ctx_stack\nfrom .cli import ScriptInfo\nfrom .json import dumps as json_dumps\nfrom .sessions import SessionMixin\n\nif t.TYPE_CHECKING:\n    from .app import Flask\n    from .wrappers import Response\n\n\nclass EnvironBuilder(werkzeug.test.EnvironBuilder):\n    \"\"\"An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the\n    application.\n\n    :param app: The Flask application to configure the environment from.\n    :param path: URL path being requested.\n    :param base_url: Base URL where the app is being served, which\n        ``path`` is relative to. If not given, built from\n        :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n        :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n    :param subdomain: Subdomain name to append to :data:`SERVER_NAME`.\n    :param url_scheme: Scheme to use instead of\n        :data:`PREFERRED_URL_SCHEME`.\n    :param json: If given, this is serialized as JSON and passed as\n        ``data``. Also defaults ``content_type`` to\n        ``application\/json``.\n    :param args: other positional arguments passed to\n        :class:`~werkzeug.test.EnvironBuilder`.\n    :param kwargs: other keyword arguments passed to\n        :class:`~werkzeug.test.EnvironBuilder`.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: \"Flask\",\n        path: str = \"\/\",\n        base_url: t.Optional[str] = None,\n        subdomain: t.Optional[str] = None,\n        url_scheme: t.Optional[str] = None,\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -> None:\n        assert not (base_url or subdomain or url_scheme) or (\n            base_url is not None\n        ) != bool(\n            subdomain or url_scheme\n        ), 'Cannot pass \"subdomain\" or \"url_scheme\" with \"base_url\".'\n\n        if base_url is None:\n            http_host = app.config.get(\"SERVER_NAME\") or \"localhost\"\n            app_root = app.config[\"APPLICATION_ROOT\"]\n\n            if subdomain:\n                http_host = f\"{subdomain}.{http_host}\"\n\n            if url_scheme is None:\n                url_scheme = app.config[\"PREFERRED_URL_SCHEME\"]\n\n            url = url_parse(path)\n            base_url = (\n                f\"{url.scheme or url_scheme}:\/\/{url.netloc or http_host}\"\n                f\"\/{app_root.lstrip('\/')}\"\n            )\n            path = url.path\n\n            if url.query:\n                sep = b\"?\" if isinstance(url.query, bytes) else \"?\"\n                path += sep + url.query\n\n        self.app = app\n        super().__init__(path, base_url, *args, **kwargs)\n\n    def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:  # type: ignore\n        \"\"\"Serialize ``obj`` to a JSON-formatted string.\n\n        The serialization will be configured according to the config associated\n        with this EnvironBuilder's ``app``.\n        \"\"\"\n        kwargs.setdefault(\"app\", self.app)\n        return json_dumps(obj, **kwargs)\n\n\nclass FlaskClient(Client):\n    \"\"\"Works like a regular Werkzeug test client but has some knowledge about\n    how Flask works to defer the cleanup of the request context stack to the\n    end of a ``with`` body when used in a ``with`` statement.  For general\n    information about how to use this class refer to\n    :class:`werkzeug.test.Client`.\n\n    .. versionchanged:: 0.12\n       `app.test_client()` includes preset default environment, which can be\n       set after instantiation of the `app.test_client()` object in\n       `client.environ_base`.\n\n    Basic usage is outlined in the :doc:`\/testing` chapter.\n    \"\"\"\n\n    application: \"Flask\"\n    preserve_context = False\n\n    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n        super().__init__(*args, **kwargs)\n        self.environ_base = {\n            \"REMOTE_ADDR\": \"127.0.0.1\",\n            \"HTTP_USER_AGENT\": f\"werkzeug\/{werkzeug.__version__}\",\n        }\n\n    @contextmanager\n    def session_transaction(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Generator[SessionMixin, None, None]:\n        \"\"\"When used in combination with a ``with`` statement this opens a\n        session transaction.  This can be used to modify the session that\n        the test client uses.  Once the ``with`` block is left the session is\n        stored back.\n\n        ::\n\n            with client.session_transaction() as session:\n                session['value'] = 42\n\n        Internally this is implemented by going through a temporary test\n        request context and since session handling could depend on\n        request variables this function accepts the same arguments as\n        :meth:`~flask.Flask.test_request_context` which are directly\n        passed through.\n        \"\"\"\n        if self.cookie_jar is None:\n            raise RuntimeError(\n                \"Session transactions only make sense with cookies enabled.\"\n            )\n        app = self.application\n        environ_overrides = kwargs.setdefault(\"environ_overrides\", {})\n        self.cookie_jar.inject_wsgi(environ_overrides)\n        outer_reqctx = _request_ctx_stack.top\n        with app.test_request_context(*args, **kwargs) as c:\n            session_interface = app.session_interface\n            sess = session_interface.open_session(app, c.request)\n            if sess is None:\n                raise RuntimeError(\n                    \"Session backend did not open a session. Check the configuration\"\n                )\n\n            # Since we have to open a new request context for the session\n            # handling we want to make sure that we hide out own context\n            # from the caller.  By pushing the original request context\n            # (or None) on top of this and popping it we get exactly that\n            # behavior.  It's important to not use the push and pop\n            # methods of the actual request context object since that would\n            # mean that cleanup handlers are called\n            _request_ctx_stack.push(outer_reqctx)\n            try:\n                yield sess\n            finally:\n                _request_ctx_stack.pop()\n\n            resp = app.response_class()\n            if not session_interface.is_null_session(sess):\n                session_interface.save_session(app, sess, resp)\n            headers = resp.get_wsgi_headers(c.request.environ)\n            self.cookie_jar.extract_wsgi(c.request.environ, headers)\n\n    def open(  # type: ignore\n        self,\n        *args: t.Any,\n        as_tuple: bool = False,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> \"Response\":\n        # Same logic as super.open, but apply environ_base and preserve_context.\n        request = None\n\n        def copy_environ(other):\n            return {\n                **self.environ_base,\n                **other,\n                \"flask._preserve_context\": self.preserve_context,\n            }\n\n        if not kwargs and len(args) == 1:\n            arg = args[0]\n\n            if isinstance(arg, werkzeug.test.EnvironBuilder):\n                builder = copy(arg)\n                builder.environ_base = copy_environ(builder.environ_base or {})\n                request = builder.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(\n                    arg, app=self.application, environ_base=copy_environ({})\n                ).get_request()\n            elif isinstance(arg, BaseRequest):\n                request = copy(arg)\n                request.environ = copy_environ(request.environ)\n\n        if request is None:\n            kwargs[\"environ_base\"] = copy_environ(kwargs.get(\"environ_base\", {}))\n            builder = EnvironBuilder(self.application, *args, **kwargs)\n\n            try:\n                request = builder.get_request()\n            finally:\n                builder.close()\n\n        return super().open(  # type: ignore\n            request,\n            as_tuple=as_tuple,\n            buffered=buffered,\n            follow_redirects=follow_redirects,\n        )\n\n    def __enter__(self) -> \"FlaskClient\":\n        if self.preserve_context:\n            raise RuntimeError(\"Cannot nest client invocations\")\n        self.preserve_context = True\n        return self\n\n    def __exit__(\n        self, exc_type: type, exc_value: BaseException, tb: TracebackType\n    ) -> None:\n        self.preserve_context = False\n\n        # Normally the request context is preserved until the next\n        # request in the same thread comes. When the client exits we\n        # want to clean up earlier. Pop request contexts until the stack\n        # is empty or a non-preserved one is found.\n        while True:\n            top = _request_ctx_stack.top\n\n            if top is not None and top.preserved:\n                top.pop()\n            else:\n                break\n\n\nclass FlaskCliRunner(CliRunner):\n    \"\"\"A :class:`~click.testing.CliRunner` for testing a Flask app's\n    CLI commands. Typically created using\n    :meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.\n    \"\"\"\n\n    def __init__(self, app: \"Flask\", **kwargs: t.Any) -> None:\n        self.app = app\n        super().__init__(**kwargs)\n\n    def invoke(  # type: ignore\n        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any\n    ) -> t.Any:\n        \"\"\"Invokes a CLI command in an isolated environment. See\n        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for\n        full method documentation. See :ref:`testing-cli` for examples.\n\n        If the ``obj`` argument is not given, passes an instance of\n        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask\n        app being tested.\n\n        :param cli: Command object to invoke. Default is the app's\n            :attr:`~flask.app.Flask.cli` group.\n        :param args: List of strings to invoke the command with.\n\n        :return: a :class:`~click.testing.Result` object.\n        \"\"\"\n        if cli is None:\n            cli = self.app.cli\n\n        if \"obj\" not in kwargs:\n            kwargs[\"obj\"] = ScriptInfo(create_app=lambda: self.app)\n\n        return super().invoke(cli, args, **kwargs)\n"}
